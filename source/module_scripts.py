# -*- coding: cp1254 -*-
from header_common import *
from header_operations import *
from module_constants import *
from module_constants import *
from header_parties import *
from header_skills import *
from header_mission_templates import *
from header_items import *
from header_triggers import *
from header_terrain_types import *
from header_music import *
from header_map_icons import *
from ID_animations import *
##diplomacy start+
from module_factions import dplmc_factions_begin, dplmc_factions_end, dplmc_non_generic_factions_begin
##diplomacy end+

##diplomacy begin
##jrider reports
from header_presentations import tf_left_align
  #### Autoloot improved by rubik begin
from module_items import *

## deprecated due to 1.165 operations
# ibf_item_type_mask = 0x000000ff

# def set_item_difficulty():
  # item_difficulty = []
  # for i_item in xrange(len(items)):
    # item_difficulty.append((item_set_slot, i_item, dplmc_slot_item_difficulty, get_difficulty(items[i_item][6])))
  # return item_difficulty[:]

# def set_item_base_score():
  # item_base_score = []
  # for i_item in xrange(len(items)):
    # if items[i_item][3] & ibf_item_type_mask == itp_type_two_handed_wpn and items[i_item][3] & itp_two_handed == 0:
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_two_handed_one_handed, 1))
    # type = items[i_item][3] & ibf_item_type_mask
    # if type >= itp_type_head_armor and type <= itp_type_hand_armor:
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_item_head_armor, get_head_armor(items[i_item][6])))
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_item_body_armor, get_body_armor(items[i_item][6])))
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_item_leg_armor, get_leg_armor(items[i_item][6])))
    # elif type >= itp_type_one_handed_wpn and type <= itp_type_thrown and type != itp_type_shield:
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_item_thrust_damage, get_thrust_damage(items[i_item][6])))
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_item_swing_damage, get_swing_damage(items[i_item][6])))
    # elif type == itp_type_horse:
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_item_horse_speed, get_missile_speed(items[i_item][6])))
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_item_horse_armor, get_body_armor(items[i_item][6])))
    # elif type == itp_type_shield:
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_item_shield_size, get_weapon_length(items[i_item][6])))
      # item_base_score.append((item_set_slot, i_item, dplmc_slot_item_shield_armor, get_body_armor(items[i_item][6])))
  # return item_base_score[:]
  # #### Autoloot improved by rubik end

##diplomacy end

####################################################################################################################
# scripts is a list of script records.
# Each script record contns the following two fields:
# 1) Script id: The prefix "script_" will be inserted when referencing scripts.
# 2) Operation block: This must be a valid operation block. See header_operations.py for reference.
####################################################################################################################

#cross refs for alternate versions of weapons
def make_noswing_weapons(items):
  noswing_weapons = []
  for i_item in xrange(len(items)):
    noswing_name = 'noswing_' + items[i_item][0]
    i_noswing = find_object (items, noswing_name)
    if i_noswing > -1:
      noswing_weapons.append((item_set_slot, i_item, slot_item_alternate, i_noswing))
      noswing_weapons.append((item_set_slot, i_noswing, slot_item_alternate, i_item))
  return noswing_weapons[:]


def keys_array():
  keys_list = []
  for key_no in xrange(len(keys)):
    keys_list.append((troop_set_slot, "trp_temp_array_a", key_no, keys[key_no]))
    keys_list.append((troop_set_slot, "trp_temp_array_b", key_no, str_key_0+key_no))
  return keys_list[:]

scripts = [


  #script_game_start:
  # This script is called when a new game is started
  # INPUT: none
  ("game_start",
   [
      (faction_set_slot, "fac_player_supporters_faction", slot_faction_state, sfs_inactive),
#CC
      # hp bars
      (assign, "$g_hp_bar_dis_limit", 30),
      (assign, "$g_hp_bar_ally", 0),
      (assign, "$g_hp_bar_enemy", 0),
      # (assign, "$g_name_of_ally", 0),
      # (assign, "$g_name_of_enemy", 1),

      # minimap off = -1
      # new style = 0
      # old style 60% = 1
      # old style 80% = 2
      # old style 100% = 3
      (assign, "$g_minimap_style", -1),
      (assign, "$g_show_regain_hp_info", 1),
#CC
      (assign, "$first_time", 0),	#squelch compiler warnings
      (assign, "$fuck_stamina", 1),
      (assign, "$g_sexual_content", 0),
	  (assign, "$g_nohomo", 1),
	  (assign, "$g_keep_companions", 0),
      (assign, "$g_dark_hunters_enabled", 0),
      (assign, "$g_realistic_wounding", 0),
      (assign, "$g_polygamy", 0),
	  (assign, "$g_enable_shield_bash", 2),
	  (assign, "$f_con", 0),
	  (assign, "$f_player_prost", 0),

	  (assign, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_HIGH),
	  (assign, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_HIGH),
	  (call_script, "script_set_custom_armor_slots"), # Custom armor init

      (try_for_range, ":edible", "itm_raw_date_fruit", food_end),
        (neq, ":edible", "itm_furs"),
        (item_set_slot, ":edible", slot_item_edible, 1),
      (try_end),

      (assign, "$g_player_luck", 200),
      (troop_set_slot, "trp_player", slot_troop_occupation, slto_kingdom_hero),
      (store_random_in_range, ":starting_training_ground", training_grounds_begin, training_grounds_end),
      (party_relocate_near_party, "p_main_party", ":starting_training_ground", 3),
      (str_store_troop_name, s5, "trp_player"),
      (party_set_name, "p_main_party", s5),
      (call_script, "script_update_party_creation_random_limits"),
      (assign, "$g_player_party_icon", -1),

      #Warband changes begin -- set this early
      (try_for_range, ":npc", 0, kingdom_ladies_end),
        (this_or_next|eq, ":npc", "trp_player"),
        (is_between, ":npc", active_npcs_begin, kingdom_ladies_end),
        (troop_set_slot, ":npc", slot_troop_father, -1),
        (troop_set_slot, ":npc", slot_troop_mother, -1),
        (troop_set_slot, ":npc", slot_troop_guardian, -1),
        (troop_set_slot, ":npc", slot_troop_spouse, -1),
        (troop_set_slot, ":npc", slot_troop_betrothed, -1),
        (troop_set_slot, ":npc", slot_troop_prisoner_of_party, -1),
        (troop_set_slot, ":npc", slot_lady_last_suitor, -1),
        (troop_set_slot, ":npc", slot_troop_stance_on_faction_issue, -1),
        (troop_set_slot, ":npc", slot_troop_courtesan, -1),

        (store_random_in_range, ":decision_seed", 0, 10000),
        (troop_set_slot, ":npc", slot_troop_set_decision_seed, ":decision_seed"),	#currently not used
        (troop_set_slot, ":npc", slot_troop_temp_decision_seed, ":decision_seed"),	#currently not used, holds for at least 24 hours
      (try_end),

      (assign, "$g_lord_long_term_count", 0),
      ##diplomacy start+ Clear faction leader/marshall, since 0 is the player
      (try_for_range, ":faction_no", 0, dplmc_factions_end),
         (neq, ":faction_no", "fac_player_faction"),
         (neq, ":faction_no", "fac_player_supporters_faction"),
         (faction_set_slot, ":faction_no", slot_faction_leader, -1),
         (faction_set_slot, ":faction_no", slot_faction_marshall, -1),
      (try_end),
      ##diplomacy end+

      (call_script, "script_initialize_banner_info"),
      (call_script, "script_initialize_item_info"),
      (call_script, "script_initialize_aristocracy"),
      (call_script, "script_initialize_npcs"),
      (assign, "$disable_npc_complaints", 0),
      #NPC companion changes end

      # Setting random feast time
      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (store_random_in_range, ":last_feast_time", 0, 312), #240 + 72
        (val_mul, ":last_feast_time", -1),
        (faction_set_slot, ":faction_no", slot_faction_last_feast_start_time, ":last_feast_time"),
      (try_end),

      # Setting the random town sequence:
      (store_sub, ":num_towns", towns_end, towns_begin),
      (assign, ":num_iterations", ":num_towns"),
      (try_for_range, ":cur_town_no", 0, ":num_towns"),
        (troop_set_slot, "trp_random_town_sequence", ":cur_town_no", -1),
      (try_end),
      (assign, ":cur_town_no", 0),
      (try_for_range, ":unused", 0, ":num_iterations"),
        (store_random_in_range, ":random_no", 0, ":num_towns"),
        (assign, ":is_unique", 1),
        (try_for_range, ":cur_town_no_2", 0, ":num_towns"),
          (troop_slot_eq, "trp_random_town_sequence", ":cur_town_no_2", ":random_no"),
          (assign, ":is_unique", 0),
        (try_end),
        (try_begin),
          (eq, ":is_unique", 1),
          (troop_set_slot, "trp_random_town_sequence", ":cur_town_no", ":random_no"),
          (val_add, ":cur_town_no", 1),
        (else_try),
          (val_add, ":num_iterations", 1),
        (try_end),
      (try_end),

      # Cultures:
      (faction_set_slot, "fac_culture_1",  slot_faction_tier_1_troop, "trp_swadian_recruit"),
      (faction_set_slot, "fac_culture_1",  slot_faction_tier_2_troop, "trp_swadian_militia"),
      (faction_set_slot, "fac_culture_1",  slot_faction_tier_3_troop, "trp_swadian_footman"),
      (faction_set_slot, "fac_culture_1",  slot_faction_tier_4_troop, "trp_swadian_infantry"),
      (faction_set_slot, "fac_culture_1",  slot_faction_tier_5_troop, "trp_swadian_knight"),

      (faction_set_slot, "fac_culture_2", slot_faction_tier_1_troop, "trp_vaegir_recruit"),
      (faction_set_slot, "fac_culture_2", slot_faction_tier_2_troop, "trp_vaegir_footman"),
      (faction_set_slot, "fac_culture_2", slot_faction_tier_3_troop, "trp_vaegir_veteran"),
      (faction_set_slot, "fac_culture_2", slot_faction_tier_4_troop, "trp_vaegir_infantry"),
      (faction_set_slot, "fac_culture_2", slot_faction_tier_5_troop, "trp_vaegir_knight"),

      (faction_set_slot, "fac_culture_3", slot_faction_tier_1_troop, "trp_khergit_tribesman"),
      (faction_set_slot, "fac_culture_3", slot_faction_tier_2_troop, "trp_khergit_skirmisher"),
      (faction_set_slot, "fac_culture_3", slot_faction_tier_3_troop, "trp_khergit_horseman"),
      (faction_set_slot, "fac_culture_3", slot_faction_tier_4_troop, "trp_khergit_horse_archer"),
      (faction_set_slot, "fac_culture_3", slot_faction_tier_5_troop, "trp_khergit_veteran_horse_archer"),

      (faction_set_slot, "fac_culture_4", slot_faction_tier_1_troop, "trp_nord_recruit"),
      (faction_set_slot, "fac_culture_4", slot_faction_tier_2_troop, "trp_nord_footman"),
      (faction_set_slot, "fac_culture_4", slot_faction_tier_3_troop, "trp_nord_trained_footman"),
      (faction_set_slot, "fac_culture_4", slot_faction_tier_4_troop, "trp_nord_warrior"),
      (faction_set_slot, "fac_culture_4", slot_faction_tier_5_troop, "trp_nord_veteran"),

      (faction_set_slot, "fac_culture_5", slot_faction_tier_1_troop, "trp_rhodok_tribesman"),
      (faction_set_slot, "fac_culture_5", slot_faction_tier_2_troop, "trp_rhodok_spearman"),
      (faction_set_slot, "fac_culture_5", slot_faction_tier_3_troop, "trp_rhodok_trained_spearman"),
      (faction_set_slot, "fac_culture_5", slot_faction_tier_4_troop, "trp_rhodok_veteran_spearman"),
      (faction_set_slot, "fac_culture_5", slot_faction_tier_5_troop, "trp_rhodok_sergeant"),

      (faction_set_slot, "fac_culture_6", slot_faction_tier_1_troop, "trp_sarranid_recruit"),
      (faction_set_slot, "fac_culture_6", slot_faction_tier_2_troop, "trp_sarranid_footman"),
      (faction_set_slot, "fac_culture_6", slot_faction_tier_3_troop, "trp_sarranid_archer"),
      (faction_set_slot, "fac_culture_6", slot_faction_tier_4_troop, "trp_sarranid_horseman"),
      (faction_set_slot, "fac_culture_6", slot_faction_tier_5_troop, "trp_sarranid_mamluke"),

      (faction_set_slot, "fac_culture_1", slot_faction_town_walker_male_troop, "trp_town_walker_1"),
      (faction_set_slot, "fac_culture_1", slot_faction_town_walker_female_troop, "trp_town_walker_2"),
      (faction_set_slot, "fac_culture_1", slot_faction_village_walker_male_troop, "trp_village_walker_1"),
      (faction_set_slot, "fac_culture_1", slot_faction_village_walker_female_troop, "trp_village_walker_2"),
      (faction_set_slot, "fac_culture_1", slot_faction_town_spy_male_troop, "trp_spy_walker_1"),
      (faction_set_slot, "fac_culture_1", slot_faction_town_spy_female_troop, "trp_spy_walker_2"),

      (faction_set_slot, "fac_culture_2", slot_faction_town_walker_male_troop, "trp_town_walker_1"),
      (faction_set_slot, "fac_culture_2", slot_faction_town_walker_female_troop, "trp_town_walker_2"),
      (faction_set_slot, "fac_culture_2", slot_faction_village_walker_male_troop, "trp_village_walker_1"),
      (faction_set_slot, "fac_culture_2", slot_faction_village_walker_female_troop, "trp_village_walker_2"),
      (faction_set_slot, "fac_culture_2", slot_faction_town_spy_male_troop, "trp_spy_walker_1"),
      (faction_set_slot, "fac_culture_2", slot_faction_town_spy_female_troop, "trp_spy_walker_2"),

      (faction_set_slot, "fac_culture_3", slot_faction_town_walker_male_troop, "trp_khergit_townsman"),
      (faction_set_slot, "fac_culture_3", slot_faction_town_walker_female_troop, "trp_khergit_townswoman"),
      (faction_set_slot, "fac_culture_3", slot_faction_village_walker_male_troop, "trp_khergit_townsman"),
      (faction_set_slot, "fac_culture_3", slot_faction_village_walker_female_troop, "trp_khergit_townswoman"),
      (faction_set_slot, "fac_culture_3", slot_faction_town_spy_male_troop, "trp_spy_walker_1"),
      (faction_set_slot, "fac_culture_3", slot_faction_town_spy_female_troop, "trp_spy_walker_2"),

      (faction_set_slot, "fac_culture_4", slot_faction_town_walker_male_troop, "trp_town_walker_1"),
      (faction_set_slot, "fac_culture_4", slot_faction_town_walker_female_troop, "trp_town_walker_2"),
      (faction_set_slot, "fac_culture_4", slot_faction_village_walker_male_troop, "trp_village_walker_1"),
      (faction_set_slot, "fac_culture_4", slot_faction_village_walker_female_troop, "trp_village_walker_2"),
      (faction_set_slot, "fac_culture_4", slot_faction_town_spy_male_troop, "trp_spy_walker_1"),
      (faction_set_slot, "fac_culture_4", slot_faction_town_spy_female_troop, "trp_spy_walker_2"),

      (faction_set_slot, "fac_culture_5", slot_faction_town_walker_male_troop, "trp_town_walker_1"),
      (faction_set_slot, "fac_culture_5", slot_faction_town_walker_female_troop, "trp_town_walker_2"),
      (faction_set_slot, "fac_culture_5", slot_faction_village_walker_male_troop, "trp_village_walker_1"),
      (faction_set_slot, "fac_culture_5", slot_faction_village_walker_female_troop, "trp_village_walker_2"),
      (faction_set_slot, "fac_culture_5", slot_faction_town_spy_male_troop, "trp_spy_walker_1"),
      (faction_set_slot, "fac_culture_5", slot_faction_town_spy_female_troop, "trp_spy_walker_2"),

      (faction_set_slot, "fac_culture_6", slot_faction_town_walker_male_troop, "trp_sarranid_townsman"),
      (faction_set_slot, "fac_culture_6", slot_faction_town_walker_female_troop, "trp_sarranid_townswoman"),
      (faction_set_slot, "fac_culture_6", slot_faction_village_walker_male_troop, "trp_sarranid_townsman"),
      (faction_set_slot, "fac_culture_6", slot_faction_village_walker_female_troop, "trp_sarranid_townswoman"),
      (faction_set_slot, "fac_culture_6", slot_faction_town_spy_male_troop, "trp_spy_walker_1"),
      (faction_set_slot, "fac_culture_6", slot_faction_town_spy_female_troop, "trp_spy_walker_2"),

      (try_begin),
        (eq, "$cheat_mode", 1),
        (assign, reg3, "$cheat_mode"),
        (display_message, "@{!}DEBUG : Completed faction troop assignments, cheat mode: {reg3}"),
      (try_end),

# Factions:
      (faction_set_slot, "fac_kingdom_1",  slot_faction_culture, "fac_culture_1"),
      (faction_set_slot, "fac_kingdom_1",  slot_faction_leader, "trp_kingdom_1_lord"),
      (troop_set_slot, "trp_kingdom_1_lord", slot_troop_renown, 1200),

      (faction_set_slot, "fac_kingdom_2",  slot_faction_culture, "fac_culture_2"),
      (faction_set_slot, "fac_kingdom_2",  slot_faction_leader, "trp_kingdom_2_lord"),
      (troop_set_slot, "trp_kingdom_2_lord", slot_troop_renown, 1200),

      (faction_set_slot, "fac_kingdom_3",  slot_faction_culture, "fac_culture_3"),
      (faction_set_slot, "fac_kingdom_3",  slot_faction_leader, "trp_kingdom_3_lord"),
      (troop_set_slot, "trp_kingdom_3_lord", slot_troop_renown, 1200),

      (faction_set_slot, "fac_kingdom_4",  slot_faction_culture, "fac_culture_4"),
      (faction_set_slot, "fac_kingdom_4",  slot_faction_leader, "trp_kingdom_4_lord"),
      (troop_set_slot, "trp_kingdom_4_lord", slot_troop_renown, 1200),

      (faction_set_slot, "fac_kingdom_5",  slot_faction_culture, "fac_culture_5"),
      (faction_set_slot, "fac_kingdom_5",  slot_faction_leader, "trp_kingdom_5_lord"),
      (troop_set_slot, "trp_kingdom_5_lord", slot_troop_renown, 1200),

      (faction_set_slot, "fac_kingdom_6",  slot_faction_culture, "fac_culture_6"),
      (faction_set_slot, "fac_kingdom_6",  slot_faction_leader, "trp_kingdom_6_lord"),
      (troop_set_slot, "trp_kingdom_6_lord", slot_troop_renown, 1200),

      (assign, ":player_faction_culture", "fac_culture_1"),
      (faction_set_slot, "fac_player_supporters_faction",  slot_faction_culture, ":player_faction_culture"),
      (faction_set_slot, "fac_player_faction",  slot_faction_culture, ":player_faction_culture"),

      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (faction_set_slot, ":faction_no", slot_faction_marshall, -1),
      (try_end),
      (faction_set_slot, "fac_player_supporters_faction", slot_faction_marshall, "trp_player"),
      (call_script, "script_initialize_faction_troop_types"),
      ##diplomacy begin
      (call_script, "script_dplmc_init_domestic_policy"),
      ##diplomacy end


# Towns:
      (try_for_range, ":item_no", trade_goods_begin, trade_goods_end),
        (store_sub, ":offset", ":item_no", trade_goods_begin),
        (val_add, ":offset", slot_town_trade_good_prices_begin),
        (try_for_range, ":center_no", centers_begin, centers_end),
          (party_set_slot, ":center_no", ":offset", average_price_factor), #1000
        (try_end),
      (try_end),

      (call_script, "script_initialize_trade_routes"),
      (call_script, "script_initialize_town_arena_info"),
      #start some tournaments
      (try_for_range, ":town_no", towns_begin, towns_end),
        (store_random_in_range, ":rand", 0, 100),
        (lt, ":rand", 20),
        (store_random_in_range, ":random_days", 12, 15),
        (party_set_slot, ":town_no", slot_town_has_tournament, ":random_days"),
      (try_end),

      #village products -- at some point we might make it so that the villages supply raw materials to towns, and the towns produce manufactured goods
      #village products designate the raw materials produced in the vicinity
      #right now, just doing a test for grain produced in the swadian heartland


      # fill_village_bound_centers
    #pass 1: Give one village to each castle
      (try_for_range, ":cur_center", castles_begin, castles_end),
        (assign, ":min_dist", 999999),
        (assign, ":min_dist_village", -1),
        (try_for_range, ":cur_village", villages_begin, villages_end),
          (neg|party_slot_ge, ":cur_village", slot_village_bound_center, 1), #skip villages which are already bound.
          (store_distance_to_party_from_party, ":cur_dist", ":cur_village", ":cur_center"),
          (lt, ":cur_dist", ":min_dist"),
          (assign, ":min_dist", ":cur_dist"),
          (assign, ":min_dist_village", ":cur_village"),
        (try_end),
        (party_set_slot, ":min_dist_village", slot_village_bound_center, ":cur_center"),
        (store_faction_of_party, ":town_faction", ":cur_center"),
        (call_script, "script_give_center_to_faction_aux", ":min_dist_village", ":town_faction"),
      (try_end),


    #pass 2: Give other villages to closest town.
      (try_for_range, ":cur_village", villages_begin, villages_end),
        (neg|party_slot_ge, ":cur_village", slot_village_bound_center, 1), #skip villages which are already bound.
        (assign, ":min_dist", 999999),
        (assign, ":min_dist_town", -1),
        (try_for_range, ":cur_town", towns_begin, towns_end),
          (store_distance_to_party_from_party, ":cur_dist", ":cur_village", ":cur_town"),
          (lt, ":cur_dist", ":min_dist"),
          (assign, ":min_dist", ":cur_dist"),
          (assign, ":min_dist_town", ":cur_town"),
        (try_end),
        (party_set_slot, ":cur_village", slot_village_bound_center, ":min_dist_town"),
        (store_faction_of_party, ":town_faction", ":min_dist_town"),
        (call_script, "script_give_center_to_faction_aux", ":cur_village", ":town_faction"),
      (try_end),


    # Towns (loop)
      (try_for_range, ":town_no", towns_begin, towns_end),
        (store_sub, ":offset", ":town_no", towns_begin),
        (party_set_slot,":town_no", slot_party_type, spt_town),
        # (store_add, ":cur_object_no", "trp_town_1_seneschal", ":offset"),
        # (party_set_slot,":town_no", slot_town_seneschal, ":cur_object_no"),
        (store_add, ":cur_object_no", "scn_town_1_center", ":offset"),
        (party_set_slot,":town_no", slot_town_center, ":cur_object_no"),
        (store_add, ":cur_object_no", "scn_town_1_castle", ":offset"),
        (party_set_slot,":town_no", slot_town_castle, ":cur_object_no"),
        (store_add, ":cur_object_no", "scn_town_1_prison", ":offset"),
        (party_set_slot,":town_no", slot_town_prison, ":cur_object_no"),
        (store_add, ":cur_object_no", "scn_town_1_walls", ":offset"),
        (party_set_slot,":town_no", slot_town_walls, ":cur_object_no"),
        (store_add, ":cur_object_no", "scn_town_1_tavern", ":offset"),
        (party_set_slot,":town_no", slot_town_tavern, ":cur_object_no"),
        (store_add, ":cur_object_no", "scn_town_1_store", ":offset"),
        (party_set_slot,":town_no", slot_town_store, ":cur_object_no"),
        (store_add, ":cur_object_no", "scn_town_1_arena", ":offset"),
        (party_set_slot,":town_no", slot_town_arena, ":cur_object_no"),
        (store_add, ":cur_object_no", "scn_town_1_alley", ":offset"),
        (party_set_slot,":town_no", slot_town_alley, ":cur_object_no"),
        (store_add, ":cur_object_no", "trp_town_1_mayor", ":offset"),
        (party_set_slot,":town_no", slot_town_elder, ":cur_object_no"),
        (store_add, ":cur_object_no", "trp_town_1_tavernkeeper", ":offset"),
        (party_set_slot,":town_no", slot_town_tavernkeeper, ":cur_object_no"),
        (store_add, ":cur_object_no", "trp_town_1_weaponsmith", ":offset"),
        (party_set_slot,":town_no", slot_town_weaponsmith, ":cur_object_no"),
        (store_add, ":cur_object_no", "trp_town_1_armorer", ":offset"),
        (party_set_slot,":town_no", slot_town_armorer, ":cur_object_no"),
        (store_add, ":cur_object_no", "trp_town_1_merchant", ":offset"),
        (party_set_slot,":town_no", slot_town_merchant, ":cur_object_no"),
        (store_add, ":cur_object_no", "trp_town_1_horse_merchant", ":offset"),
        (party_set_slot,":town_no", slot_town_horse_merchant, ":cur_object_no"),
        (store_add, ":cur_object_no", "scn_town_1_center", ":offset"),
        (party_set_slot,":town_no", slot_town_center, ":cur_object_no"),
        # (party_set_slot,":town_no", slot_town_reinforcement_party_template, "pt_center_reinforcements"),
      (try_end),

      #ports
      (party_set_slot,"p_town_1", slot_town_port, "p_port_1"),
      (party_set_slot,"p_town_2", slot_town_port, "p_port_2"),
      (party_set_slot,"p_town_6", slot_town_port, "p_port_6"),
      (party_set_slot,"p_town_12", slot_town_port, "p_port_12"),
      (party_set_slot,"p_town_13", slot_town_port, "p_port_13"),
      (party_set_slot,"p_town_15", slot_town_port, "p_port_15"),
      (party_set_slot,"p_town_19", slot_town_port, "p_port_19"),

      (party_set_slot,"p_port_1", slot_port_town, "p_town_1"),
      (party_set_slot,"p_port_2", slot_port_town, "p_town_2"),
      (party_set_slot,"p_port_6", slot_port_town, "p_town_6"),
      (party_set_slot,"p_port_12", slot_port_town, "p_town_12"),
      (party_set_slot,"p_port_13", slot_port_town, "p_town_13"),
      (party_set_slot,"p_port_15", slot_port_town, "p_town_15"),
      (party_set_slot,"p_port_19", slot_port_town, "p_town_19"),

  #Duh Town Population for Land required // Linked to bank system

	  (try_for_range, ":town_no", towns_begin, towns_end),
		(this_or_next|eq,":town_no","p_town_1"),
		(this_or_next|eq,":town_no","p_town_5"),
		(this_or_next|eq,":town_no","p_town_6"),
		(this_or_next|eq,":town_no","p_town_8"),
		(this_or_next|eq,":town_no","p_town_10"),
		(eq,"$current_town","p_town_19"),
		(store_random_in_range, ":amount", 18000, 22000),
		(party_set_slot, ":town_no", slot_center_population, ":amount"),
		(val_div, ":amount", 200),
		(party_set_slot, ":town_no", slot_town_acres, ":amount"),
	  (else_try),
		(store_random_in_range, ":amount", 8000, 12000),
		(party_set_slot, ":town_no", slot_center_population, ":amount"),
		(val_div, ":amount", 200),
		(party_set_slot, ":town_no", slot_town_acres, ":amount"),
	  (try_end),

	  #Duh Over

# Castles
      (try_for_range, ":castle_no", castles_begin, castles_end),
        (store_sub, ":offset", ":castle_no", castles_begin),
        (val_mul, ":offset", 3),

        (store_add, ":exterior_scene_no", "scn_castle_1_exterior", ":offset"),
        (party_set_slot,":castle_no", slot_castle_exterior, ":exterior_scene_no"),
        (store_add, ":interior_scene_no", "scn_castle_1_interior", ":offset"),
        (party_set_slot,":castle_no", slot_town_castle, ":interior_scene_no"),
        (store_add, ":interior_scene_no", "scn_castle_1_prison", ":offset"),
        (party_set_slot,":castle_no", slot_town_prison, ":interior_scene_no"),

        # (party_set_slot,":castle_no", slot_town_reinforcement_party_template, "pt_center_reinforcements"),
        (party_set_slot,":castle_no", slot_party_type, spt_castle),
        (party_set_slot,":castle_no", slot_center_is_besieged_by, -1),
      (try_end),

      #seneschals - dckplmc
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (store_sub, ":offset", ":center_no", walled_centers_begin),
        (store_add, ":cur_object_no", "trp_town_1_seneschal", ":offset"),
        (troop_set_slot, ":cur_object_no", slot_troop_occupation, slto_kingdom_seneschal),
        (party_set_slot,":center_no", slot_town_seneschal, ":cur_object_no"),
      (try_end),

# Set which castles need to be attacked with siege towers.
      (party_set_slot,"p_town_13", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_town_16", slot_center_siege_with_belfry, 1),

      (party_set_slot,"p_castle_1", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_2", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_4", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_7", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_8", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_9", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_11", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_13", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_21", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_25", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_34", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_35", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_38", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_40", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_41", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_42", slot_center_siege_with_belfry, 1),
      (party_set_slot,"p_castle_43", slot_center_siege_with_belfry, 1),

	  # Villages characters
      (try_for_range, ":village_no", villages_begin, villages_end),
        (store_sub, ":offset", ":village_no", villages_begin),

        (store_add, ":exterior_scene_no", "scn_village_1", ":offset"),
        (party_set_slot,":village_no", slot_castle_exterior, ":exterior_scene_no"),

        (store_add, ":store_troop_no", "trp_village_1_elder", ":offset"),
        (party_set_slot,":village_no", slot_town_elder, ":store_troop_no"),

        (party_set_slot,":village_no", slot_party_type, spt_village),
        (party_set_slot,":village_no", slot_village_raided_by, -1),

        (call_script, "script_refresh_village_defenders", ":village_no"),
        (call_script, "script_refresh_village_defenders", ":village_no"),
        (call_script, "script_refresh_village_defenders", ":village_no"),
        (call_script, "script_refresh_village_defenders", ":village_no"),
      (try_end),

      (try_for_range, ":center_no", centers_begin, centers_end),
        (party_set_slot, ":center_no", slot_center_last_spotted_enemy, -1),
        (party_set_slot, ":center_no", slot_center_is_besieged_by, -1),
        (party_set_slot, ":center_no", slot_center_last_taken_by_troop, -1),
        ##diplomacy start+ Set the home slots for town merchants, elders, etc. for reverse-lookup
        (try_for_range, ":offset", dplmc_slot_town_merchants_begin, dplmc_slot_town_merchants_end),
           (party_get_slot, ":npc", ":center_no", ":offset"),
           (gt, ":npc", 0),
           (neg|troop_slot_ge, ":npc", slot_troop_home, 1),#If the startup script wasn't altered by another mod, we don't have to worry about this condition.
           (troop_set_slot, ":npc", slot_troop_home, ":center_no"),
        (try_end),
        ##diplomacy end+
      (try_end),

# Troops:

# Assign banners and renown.
# We assume there are enough banners for all kingdom heroes.

      #faction banners
      (faction_set_slot, "fac_kingdom_1", slot_faction_banner, "mesh_banner_kingdom_f"),
      (faction_set_slot, "fac_kingdom_2", slot_faction_banner, "mesh_banner_kingdom_b"),
      (faction_set_slot, "fac_kingdom_3", slot_faction_banner, "mesh_banner_kingdom_c"),
      (faction_set_slot, "fac_kingdom_4", slot_faction_banner, "mesh_banner_kingdom_a"),
      (faction_set_slot, "fac_kingdom_5", slot_faction_banner, "mesh_banner_kingdom_d"),
      (faction_set_slot, "fac_kingdom_6", slot_faction_banner, "mesh_banner_kingdom_e"),

      (try_for_range, ":cur_faction", npc_kingdoms_begin, npc_kingdoms_end),
        (faction_get_slot, ":cur_faction_king", ":cur_faction", slot_faction_leader),
        (faction_get_slot, ":cur_faction_banner", ":cur_faction", slot_faction_banner),
        (val_sub, ":cur_faction_banner", banner_meshes_begin),
        (val_add, ":cur_faction_banner", banner_scene_props_begin),
        (troop_set_slot, ":cur_faction_king", slot_troop_banner_scene_prop, ":cur_faction_banner"),
      (try_end),
      (assign, ":num_khergit_lords_assigned", 0),
      (assign, ":num_sarranid_lords_assigned", 0),
      (assign, ":num_other_lords_assigned", 0),

      (try_for_range, ":kingdom_hero", active_npcs_begin, active_npcs_end),
        (this_or_next|troop_slot_eq, ":kingdom_hero", slot_troop_occupation, slto_kingdom_hero),
        (troop_slot_eq, ":kingdom_hero", slot_troop_occupation, slto_inactive_pretender),

        (store_troop_faction, ":kingdom_hero_faction", ":kingdom_hero"),
        (neg|faction_slot_eq, ":kingdom_hero_faction", slot_faction_leader, ":kingdom_hero"),
        (try_begin),
          (eq, ":kingdom_hero_faction", "fac_kingdom_3"), #Khergit Khanate
          (store_add, ":kingdom_3_banners_begin", banner_scene_props_begin, khergit_banners_begin_offset),
          (store_add, ":banner_id", ":kingdom_3_banners_begin", ":num_khergit_lords_assigned"),
          (troop_set_slot, ":kingdom_hero", slot_troop_banner_scene_prop, ":banner_id"),
          (val_add, ":num_khergit_lords_assigned", 1),
        (else_try),
          (eq, ":kingdom_hero_faction", "fac_kingdom_6"), #Sarranid Sultanate
          (store_add, ":kingdom_6_banners_begin", banner_scene_props_begin, sarranid_banners_begin_offset),
          (store_add, ":banner_id", ":kingdom_6_banners_begin", ":num_sarranid_lords_assigned"),
          (troop_set_slot, ":kingdom_hero", slot_troop_banner_scene_prop, ":banner_id"),
          (val_add, ":num_sarranid_lords_assigned", 1),
        (else_try),
          (assign, ":hero_offset", ":num_other_lords_assigned"),
          (try_begin),
            (gt, ":hero_offset", khergit_banners_begin_offset),#Do not add khergit banners to other lords
            (val_add, ":hero_offset", khergit_banners_end_offset),
            (val_sub, ":hero_offset", khergit_banners_begin_offset),
          (try_end),
          (try_begin),
            (gt, ":hero_offset", sarranid_banners_begin_offset),#Do not add sarranid banners to other lords
            (val_add, ":hero_offset", sarranid_banners_end_offset),
            (val_sub, ":hero_offset", sarranid_banners_begin_offset),
          (try_end),
          (store_add, ":banner_id", banner_scene_props_begin, ":hero_offset"),
          (troop_set_slot, ":kingdom_hero", slot_troop_banner_scene_prop, ":banner_id"),
          (val_add, ":num_other_lords_assigned", 1),
        (try_end),
        (try_begin),
          (this_or_next|lt, ":banner_id", banner_scene_props_begin),
          (gt, ":banner_id", banner_scene_props_end_minus_one),
          (display_message, "@{!}ERROR: Not enough banners for heroes!"),
        (try_end),

        (store_character_level, ":level", ":kingdom_hero"),
        (store_mul, ":renown", ":level", ":level"),
        (val_div, ":renown", 4), #for top lord, is about 400

        (troop_get_slot, ":age", ":kingdom_hero", slot_troop_age),
        (store_mul, ":age_addition", ":age", ":age"),
        (val_div, ":age_addition", 8), #for top lord, is about 400
        (val_add, ":renown", ":age_addition"),

        (try_begin),
          (faction_slot_eq, ":kingdom_hero_faction", slot_faction_leader, ":kingdom_hero"),
          (store_random_in_range, ":random_renown", 250, 400),
        (else_try),
          (store_random_in_range, ":random_renown", 0, 100),
        (try_end),
        (val_add, ":renown", ":random_renown"),

        (troop_set_slot, ":kingdom_hero", slot_troop_renown, ":renown"),
      (try_end),

      (try_for_range, ":troop_no", "trp_player", "trp_merchants_end"),
        (add_troop_note_tableau_mesh, ":troop_no", "tableau_troop_note_mesh"),
      (try_end),

      (try_for_range, ":center_no", centers_begin, centers_end),
        (add_party_note_tableau_mesh, ":center_no", "tableau_center_note_mesh"),
      (try_end),

      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (is_between, ":faction_no", "fac_kingdom_1", kingdoms_end), #Excluding player kingdom
        (add_faction_note_tableau_mesh, ":faction_no", "tableau_faction_note_mesh"),
      (else_try),
        (add_faction_note_tableau_mesh, ":faction_no", "tableau_faction_note_mesh_banner"),
      (try_end),

	  #Give centers to factions first, to ensure more equal distributions
	  (call_script, "script_give_center_to_faction_aux", "p_town_1", "fac_kingdom_4"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_2", "fac_kingdom_4"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_3", "fac_kingdom_5"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_4", "fac_kingdom_1"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_5", "fac_kingdom_5"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_6", "fac_kingdom_1"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_7", "fac_kingdom_1"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_8", "fac_kingdom_2"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_9", "fac_kingdom_2"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_10", "fac_kingdom_3"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_11", "fac_kingdom_2"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_12", "fac_kingdom_4"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_13", "fac_kingdom_2"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_14", "fac_kingdom_3"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_15", "fac_kingdom_5"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_16", "fac_kingdom_1"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_17", "fac_kingdom_3"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_18", "fac_kingdom_3"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_19", "fac_kingdom_6"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_20", "fac_kingdom_6"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_21", "fac_kingdom_6"),
	  (call_script, "script_give_center_to_faction_aux", "p_town_22", "fac_kingdom_6"),

      (call_script, "script_give_center_to_faction_aux", "p_castle_1", "fac_kingdom_5"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_2", "fac_kingdom_3"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_3", "fac_kingdom_2"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_4", "fac_kingdom_2"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_5", "fac_kingdom_4"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_6", "fac_kingdom_1"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_7", "fac_kingdom_3"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_8", "fac_kingdom_2"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_9", "fac_kingdom_5"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_10", "fac_kingdom_4"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_11", "fac_kingdom_4"),

      (call_script, "script_give_center_to_faction_aux", "p_castle_12", "fac_kingdom_4"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_13", "fac_kingdom_1"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_14", "fac_kingdom_5"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_15", "fac_kingdom_5"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_16", "fac_kingdom_5"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_17", "fac_kingdom_3"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_18", "fac_kingdom_2"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_19", "fac_kingdom_2"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_20", "fac_kingdom_1"),

      (call_script, "script_give_center_to_faction_aux", "p_castle_21", "fac_kingdom_5"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_22", "fac_kingdom_3"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_23", "fac_kingdom_1"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_24", "fac_kingdom_1"),

      (call_script, "script_give_center_to_faction_aux", "p_castle_25", "fac_kingdom_1"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_26", "fac_kingdom_1"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_27", "fac_kingdom_1"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_28", "fac_kingdom_5"),

      (call_script, "script_give_center_to_faction_aux", "p_castle_29", "fac_kingdom_2"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_30", "fac_kingdom_3"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_31", "fac_kingdom_1"),

      (call_script, "script_give_center_to_faction_aux", "p_castle_32", "fac_kingdom_4"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_33", "fac_kingdom_5"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_34", "fac_kingdom_4"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_35", "fac_kingdom_1"),

      (call_script, "script_give_center_to_faction_aux", "p_castle_36", "fac_kingdom_4"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_37", "fac_kingdom_2"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_38", "fac_kingdom_3"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_39", "fac_kingdom_2"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_40", "fac_kingdom_3"),

      (call_script, "script_give_center_to_faction_aux", "p_castle_41", "fac_kingdom_6"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_42", "fac_kingdom_6"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_43", "fac_kingdom_6"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_44", "fac_kingdom_6"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_45", "fac_kingdom_6"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_46", "fac_kingdom_6"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_47", "fac_kingdom_6"),
      (call_script, "script_give_center_to_faction_aux", "p_castle_48", "fac_kingdom_6"),


	  #Now give towns to great lords
	  ##diplomacy+ notes added, otherwise unchanged
      (call_script, "script_give_center_to_lord", "p_town_1",  "trp_kingdom_4_lord", 0),# Sargoth - King Ragnar
      (call_script, "script_give_center_to_lord", "p_town_2",  "trp_knight_4_1", 0),#Tihr - Jarl Aedin
      (call_script, "script_give_center_to_lord", "p_town_3",  "trp_knight_5_1", 0),#Veluca - Count Matheas
      (call_script, "script_give_center_to_lord", "p_town_4",  "trp_knight_1_1", 0),#Suno - Count Klargus
      (call_script, "script_give_center_to_lord", "p_town_5",  "trp_kingdom_5_lord", 0),# Jelkala - King Graveth
      (call_script, "script_give_center_to_lord", "p_town_6",  "trp_kingdom_1_lord", 0),# Praven - King Harlaus
      (call_script, "script_give_center_to_lord", "p_town_7",  "trp_knight_1_2", 0),#Uxkhal - Count Delinard

      (call_script, "script_give_center_to_lord", "p_town_8",  "trp_kingdom_2_lord", 0),# Reyvadin - King Yaroglek
      (call_script, "script_give_center_to_lord", "p_town_9",  "trp_knight_2_1", 0),#Khudan -Boyar Vuldrat
      (call_script, "script_give_center_to_lord", "p_town_10", "trp_kingdom_3_lord", 0),# Tulga - Sanjar Khan
      (call_script, "script_give_center_to_lord", "p_town_11", "trp_knight_2_2", 0),#Curaw - Boyar Naldera
      (call_script, "script_give_center_to_lord", "p_town_12", "trp_knight_4_2", 0),#Wercheg - Jarl Irya
      (call_script, "script_give_center_to_lord", "p_town_13", "trp_knight_2_3", 0),#Rivacheg - Boyar Meriga
      (call_script, "script_give_center_to_lord", "p_town_14", "trp_knight_3_1", 0),#Halmar -Alagur Noyan

      (call_script, "script_give_center_to_lord", "p_town_15", "trp_knight_5_2", 0),#Yalen -Count Gutlans
      (call_script, "script_give_center_to_lord", "p_town_16", "trp_knight_1_4", 0),#Dhirim - Count Clais #changed from 1_3 (Count Harringoth)
      (call_script, "script_give_center_to_lord", "p_town_17", "trp_knight_3_2", 0),#Ichamur - Tonju Noyan
      (call_script, "script_give_center_to_lord", "p_town_18", "trp_knight_3_3", 0),#Narra - Belir Noyan

      (call_script, "script_give_center_to_lord", "p_town_19", "trp_kingdom_6_lord", 0),#Shariz - Sultan Hakim
      (call_script, "script_give_center_to_lord", "p_town_20", "trp_knight_6_1", 0),#Durquba - Emir Uqais
      (call_script, "script_give_center_to_lord", "p_town_21", "trp_knight_6_2", 0),#Ahmerrad - Emir Hamezan
      (call_script, "script_give_center_to_lord", "p_town_22", "trp_knight_6_3", 0),#Bariyye - Emir Atis
	  ##diplomacy end+

      # Give family castles to certain nobles.
      (call_script, "script_give_center_to_lord", "p_castle_29", "trp_knight_2_10", 0), #Nelag_Castle
      (call_script, "script_give_center_to_lord", "p_castle_30", "trp_knight_3_4", 0), #Asugan_Castle
      (call_script, "script_give_center_to_lord", "p_castle_35", "trp_knight_1_3", 0), #Haringoth_Castle
      ##diplomacy start+
      (call_script, "script_give_center_to_lord", "p_castle_33", "trp_knight_5_11", 0), #Etrosq Castle -- why wasn't this being done already?
	  #Add home centers for claimants
	  (troop_set_slot, "trp_kingdom_1_pretender", slot_troop_home, "p_town_4"),#Lady Isolle - Suno
	  (troop_set_slot, "trp_kingdom_2_pretender", slot_troop_home, "p_town_11"),#Prince Valdym - Curaw
      (troop_set_slot, "trp_kingdom_3_pretender", slot_troop_home, "p_town_18"),#Dustum Khan - Narra
      (troop_set_slot, "trp_kingdom_4_pretender", slot_troop_home, "p_town_12"),#Lethwin Far-Seeker - Wercheg
      (troop_set_slot, "trp_kingdom_5_pretender", slot_troop_home, "p_town_3"),#Lord Kastor - Veluca
	  (troop_set_slot, "trp_kingdom_6_pretender", slot_troop_home, "p_town_20"),#Arwa the Pearled One - Durquba
 	  #add ancestral fiefs to home slots (mods not using standard NPCs should remove this)
      (troop_set_slot, "trp_knight_2_10", slot_troop_home, "p_castle_29"), #Nelag_Castle
      (troop_set_slot, "trp_knight_3_4", slot_troop_home, "p_castle_30"), #Asugan_Castle
      (troop_set_slot, "trp_knight_1_3", slot_troop_home, "p_castle_35"), #Haringoth_Castle
      (troop_set_slot, "trp_knight_5_11", slot_troop_home, "p_castle_33"), #Etrosq_Castle
	  #Also the primary six towns:
	  (troop_set_slot, "trp_kingdom_1_lord", slot_troop_home, "p_town_6"),#King Harlaus to Praven
	  (troop_set_slot, "trp_kingdom_2_lord", slot_troop_home, "p_town_8"),#King Yaroglek to Reyvadin
	  (troop_set_slot, "trp_kingdom_3_lord", slot_troop_home, "p_town_10"),#Sanjar Khan to Tulga
	  (troop_set_slot, "trp_kingdom_4_lord", slot_troop_home, "p_town_1"),#King Ragnar to Sargoth
	  (troop_set_slot, "trp_kingdom_5_lord", slot_troop_home, "p_town_5"),#King Graveth to Jelkala
	  (troop_set_slot, "trp_kingdom_6_lord", slot_troop_home, "p_town_19"),#Sultan Hakim to Shariz
      ##Also set home slots for starting quest merchants (merchant of praven, merchant of reyvadin, etc.)
      (try_for_range, ":npc", kings_begin, kings_end),
         (troop_get_slot, ":center_no", ":npc", slot_troop_home),
         (val_sub, ":npc", kings_begin),
         (val_add, ":npc", startup_merchants_begin),
         (is_between, ":npc", startup_merchants_begin, startup_merchants_end),#Right now there's a startup merchant for each faction.  Verify this hasn't unexpectedly changed.
         (neg|troop_slot_ge, ":npc", slot_troop_home, 1),#Verify that the home slot is not already set
         (troop_set_slot, ":npc", slot_troop_home, ":center_no"),
      (try_end),
      ##diplomacy end+

      (call_script, "script_assign_lords_to_empty_centers"),

	  #set original factions
      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_faction_of_party, ":original_faction", ":center_no"),
        (faction_get_slot, ":culture", ":original_faction", slot_faction_culture),
        (party_set_slot, ":center_no", slot_center_culture,  ":culture"),
        (party_set_slot, ":center_no", slot_center_original_faction,  ":original_faction"),
        (party_set_slot, ":center_no", slot_center_ex_faction,  ":original_faction"),
		##diplomacy start+ set additional slots
		(party_get_slot, ":town_lord", ":center_no", slot_town_lord),

		(try_begin),
			(eq, ":town_lord", "trp_player"),
			#Use trp_kingdom_heroes_including_player_begin instead of trp_player as a workaround for
			#old saved games (since uninitialized memory is 0).
			(party_set_slot, ":center_no", dplmc_slot_center_ex_lord, "trp_kingdom_heroes_including_player_begin"),
			(troop_slot_eq, "trp_player", slot_troop_home, ":center_no"),
			(neg|party_slot_ge, ":center_no", dplmc_slot_center_original_lord, 1),
			(party_set_slot, ":center_no", dplmc_slot_center_original_lord, "trp_kingdom_heroes_including_player_begin"),
		(else_try),
			(party_set_slot, ":center_no", dplmc_slot_center_ex_lord, ":town_lord"),
			(ge, ":town_lord", 0),
			(troop_slot_eq, ":town_lord", slot_troop_home, ":center_no"),
			(neg|party_slot_ge, ":center_no", dplmc_slot_center_original_lord, 1),
			(party_set_slot, ":center_no", dplmc_slot_center_original_lord, ":town_lord"),
		(try_end),
		##diplomacy end+
      (try_end),

	  #set territorial disputes/outstanding border issues
	  (party_set_slot, "p_castle_10", slot_center_ex_faction, "fac_kingdom_2"), #vaegirs claim nord-held alburq
	  (party_set_slot, "p_castle_13", slot_center_ex_faction, "fac_kingdom_4"), #nords claim swadian-held kelredan
	  (party_set_slot, "p_castle_15", slot_center_ex_faction, "fac_kingdom_1"), #swadians claim rhodok-held ergelon
	  (party_set_slot, "p_castle_46", slot_center_ex_faction, "fac_kingdom_5"), #rhodoks claim sarranid-held weyyah
	  (party_set_slot, "p_castle_40", slot_center_ex_faction, "fac_kingdom_6"), #sarranids claim khergit-held uhhun
	  (party_set_slot, "p_town_11",   slot_center_ex_faction, "fac_kingdom_3"), #Khergits claim vaegir-held curaw

	  #Swadians, being in the middle, will have additional claims on two of their neighhbors
	  (party_set_slot, "p_castle_15", slot_center_ex_faction, "fac_kingdom_1"), #swadians claim vaegir-held tilbault
	  (party_set_slot, "p_castle_22", slot_center_ex_faction, "fac_kingdom_1"), #swadians claim khergit-held unuzdaq

      (call_script, "script_update_village_market_towns"),

	  ##diplomacy start+
	  #(1) Assign plausible ancestral homes to some of the lords (not all of them) who didn't have
      #one set before.  Among other things, this is used for a sense of possessiveness.
      #(2) Assign last-transfer-times to the contested centers.
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
		 (try_begin),
			#Assign last-transfer-times to the contested centers.
			(party_get_slot, ":original_faction", ":center_no", slot_center_original_faction),
			(neg|party_slot_eq, ":center_no", slot_center_ex_faction, ":original_faction"),
			(store_random_in_range, ":transfer_time", 1, 181),#some time in the last 180 days (the length of a short game)
			(val_mul, ":transfer_time", -24),
			(party_set_slot, ":center_no", dplmc_slot_center_last_transfer_time, ":transfer_time"),
		 (else_try),
			#For non-contested centers, possibly set the lord's home slot.  Note that because
			#we're iterating in order, lords will get set to towns they own before they get
			#set to cities.
			(party_get_slot, ":town_lord", ":center_no", slot_town_lord),
			(ge, ":town_lord", 1),#only NPCs
			(neg|party_slot_ge, ":center_no", dplmc_slot_center_original_lord, 1),#If there is an original owner who is dispossessed, such as a claimant
			(neg|troop_slot_ge, ":town_lord", slot_troop_home, 1),
			(troop_set_slot, ":town_lord", slot_troop_home, ":center_no"),
		 (try_end),
      (try_end),

	  # (try_for_range, ":troop_id", heroes_begin, heroes_end),
	  # (try_end),
      #
      #etc.
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
		 #If the original owner of the lord is set, don't apply this
		 (neg|party_slot_ge, ":center_no", dplmc_slot_center_original_lord, 1),
		 #Don't apply this to contested centers.
		 (party_get_slot, ":original_faction", ":center_no", slot_center_original_faction),
		 (party_slot_eq, ":center_no", slot_center_ex_faction, ":original_faction"),
		 #If the owner already has his "home" slot set, don't overwrite it
         (party_get_slot, ":town_lord", ":center_no", slot_town_lord),
		 (neg|troop_slot_ge, ":town_lord", slot_troop_home, 1),
		 #No objections, so go ahead
		 (troop_set_slot, ":town_lord", slot_troop_home, ":center_no"),
      (try_end),
      ##diplomacy end+

	  #this should come after assignment of territorial grievances
      (try_for_range, ":unused", 0, 70),
        (try_begin),
          (eq, "$cheat_mode", 1),
          (display_message, "@{!}DEBUG -- initial war/peace check begins"),
        (try_end),
        (call_script, "script_randomly_start_war_peace_new", 0),
      (try_end),


      #Initialize walkers
      (try_for_range, ":center_no", centers_begin, centers_end),
        (this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_town),
                     (party_slot_eq, ":center_no", slot_party_type, spt_village),
        (try_for_range, ":walker_no", 0, num_town_walkers),
          (call_script, "script_center_set_walker_to_type", ":center_no", ":walker_no", walkert_default),
        (try_end),
      (try_end),


	  #This needs to be after market towns
	  (call_script, "script_initialize_economic_information"),

	  (try_for_range, ":village_no", villages_begin, villages_end),
        (call_script, "script_refresh_village_merchant_inventory", ":village_no"),
      (try_end),

      (try_for_range, ":troop_id", original_kingdom_heroes_begin, active_npcs_end),
        (try_begin),
          (store_troop_faction, ":faction_id", ":troop_id"),
          (is_between, ":faction_id", kingdoms_begin, kingdoms_end),
          (troop_set_slot, ":troop_id", slot_troop_original_faction, ":faction_id"),
          (try_begin),
            (is_between, ":troop_id", pretenders_begin, pretenders_end),
            (faction_set_slot, ":faction_id", slot_faction_has_rebellion_chance, 1),
          (try_end),
        (try_end),
        (assign, ":initial_wealth", 6000),
        (try_begin),
          (store_troop_faction, ":faction", ":troop_id"),
          (faction_slot_eq, ":faction", slot_faction_leader, ":troop_id"),
          (assign, ":initial_wealth", 20000),
        (try_end),
        (troop_set_slot, ":troop_id", slot_troop_wealth, ":initial_wealth"),
      (try_end),

      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),#add town garrisons
        #Add initial center wealth
        (assign, ":initial_wealth", 2000),
        (try_begin),
          (is_between, ":center_no", towns_begin, towns_end),
          (val_mul, ":initial_wealth", 2),
        (try_end),
        (party_set_slot, ":center_no", slot_town_wealth, ":initial_wealth"),

        (assign, ":garrison_strength", 15),
        (try_begin),
          (party_slot_eq, ":center_no", slot_party_type, spt_town),
          (assign, ":garrison_strength", 40),
        (try_end),
        (try_for_range, ":unused", 0, ":garrison_strength"),
          (call_script, "script_cf_reinforce_party", ":center_no"),
        (try_end),
        ## ADD some XP initially
        (store_div, ":xp_rounds", ":garrison_strength", 5),
        (val_add, ":xp_rounds", 2),

        (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),

        (try_begin), #hard
          (eq, ":reduce_campaign_ai", 0),
          (assign, ":xp_addition_for_centers", 7500),
        (else_try), #moderate
          (eq, ":reduce_campaign_ai", 1),
          (assign, ":xp_addition_for_centers", 5000),
        (else_try), #easy
          (eq, ":reduce_campaign_ai", 2),
          (assign, ":xp_addition_for_centers", 2500),
        (try_end),

        (try_for_range, ":unused", 0, ":xp_rounds"),
          (party_upgrade_with_xp, ":center_no", ":xp_addition_for_centers", 0),
        (try_end),

        #Fill town food stores upto half the limit
        (call_script, "script_center_get_food_store_limit", ":center_no"),
        (assign, ":food_store_limit", reg0),
        (val_div, ":food_store_limit", 2),
        (party_set_slot, ":center_no", slot_party_food_store, ":food_store_limit"),

        #create lord parties
        (party_get_slot, ":center_lord", ":center_no", slot_town_lord),
        (ge, ":center_lord", 1),
        (troop_slot_eq, ":center_lord", slot_troop_leaded_party, 0),
        (assign, "$g_there_is_no_avaliable_centers", 0),
        (call_script, "script_create_kingdom_hero_party", ":center_lord", ":center_no"),
        (assign, ":lords_party", "$pout_party"),
        (party_attach_to_party, ":lords_party", ":center_no"),
        (party_set_slot, ":center_no", slot_town_player_odds, 1000),
      (try_end),

	#More pre-Warband family structures removed here

	  #Warband changes begin - set companions relations
	  (try_for_range, ":companion", companions_begin, companions_end),
		(try_for_range, ":other_companion", companions_begin, companions_end),
			(neq, ":other_companion", ":companion"),
			(neg|troop_slot_eq, ":companion", slot_troop_personalityclash_object, ":other_companion"),
			(neg|troop_slot_eq, ":companion", slot_troop_personalityclash2_object, ":other_companion"),
			(call_script, "script_troop_change_relation_with_troop", ":companion", ":other_companion", 7), #companions have a starting relation of 14, unless they are rivals
		(try_end),
	  (try_end),

	  #Warband changes continue -  sets relations in the same faction
      (try_for_range, ":lord", original_kingdom_heroes_begin, active_npcs_end),
		(troop_slot_eq, ":lord", slot_troop_occupation, slto_kingdom_hero),
		(troop_get_slot, ":lord_faction", ":lord", slot_troop_original_faction),

		(try_for_range, ":other_hero", original_kingdom_heroes_begin, active_npcs_end),
			(this_or_next|troop_slot_eq, ":other_hero", slot_troop_occupation, slto_kingdom_hero),
				(troop_slot_eq, ":other_hero", slot_troop_occupation, slto_inactive_pretender),
			(troop_get_slot, ":other_hero_faction", ":other_hero", slot_troop_original_faction),
			(eq, ":other_hero_faction", ":lord_faction"),
			(call_script, "script_troop_get_family_relation_to_troop", ":lord", ":other_hero"),
			(call_script, "script_troop_change_relation_with_troop", ":lord", ":other_hero", reg0),

			(store_random_in_range, ":random", 0, 11), #this will be scored twice between two kingdom heroes, so starting relation will average 10. Between lords and pretenders it will average 7.5
			(call_script, "script_troop_change_relation_with_troop", ":lord", ":other_hero", ":random"),
		(try_end),
	  (try_end),

	  ##diplomacy start+
     ##Initialize town "last caravan arrived" times randomly
	  (try_for_range, ":cur_town", towns_begin, towns_end),
	     (try_for_range, ":cur_slot", dplmc_slot_town_trade_route_last_arrivals_begin, dplmc_slot_town_trade_route_last_arrivals_end),
		    (party_slot_eq, ":cur_town", ":cur_slot", 0),
		    (store_random_in_range, ":last_arrived", 1, (24 * 7 * 5) + 1),#some time in the last five weeks
			(val_mul, ":last_arrived", -1),
			(party_get_slot, ":prosperity_factor", ":cur_town", slot_town_prosperity),#modify plus or minus 40% based on prosperity
			(val_clamp, ":prosperity_factor", 0, 101),
			(val_add, ":prosperity_factor", 75),
			(val_mul, ":last_arrived", 125),
			(val_div, ":last_arrived", ":prosperity_factor"),#last arrival some time in the last five weeks, plus or minus 40%
			(party_set_slot, ":cur_town", ":cur_slot", ":last_arrived"),
		 (try_end),
	  (try_end),
      (try_for_range, ":cur_village", villages_begin, villages_end),
          (party_get_slot, ":prosperity_factor", ":cur_town", slot_town_prosperity),#modify plus or minus 40% based on prosperity
          (val_clamp, ":prosperity_factor", 0, 101),
          (val_add, ":prosperity_factor", 75),#average 125, min 75, max 175
          (store_random_in_range, ":last_arrived", 1, (24 * 7) + 1),
          (val_mul, ":last_arrived", -1),#some time in the last 7 days, plus or minus 40%
          (val_mul, ":last_arrived", 125),
          (val_div, ":last_arrived", ":prosperity_factor"),
          (party_set_slot, ":cur_village", dplmc_slot_village_trade_last_returned_from_market, ":last_arrived"),
          (store_random_in_range, ":last_arrived", 1, (24 * 7) + 1),
          (val_mul, ":last_arrived", -1),#some time in the last 7 days
          (val_mul, ":last_arrived", 125),
          (val_div, ":last_arrived", ":prosperity_factor"),
          (party_set_slot, ":cur_village", dplmc_slot_village_trade_last_arrived_to_market, ":last_arrived"),
      (try_end),
      ##diplomacy end+

	  #do about 5 years' worth of political history (assuming 3 random checks a day)
	  (try_for_range, ":unused", 0, 5000),
		(call_script, "script_cf_random_political_event"),
	  (try_end),
	  (assign, "$total_random_quarrel_changes", 0),
	  (assign, "$total_relation_adds", 0),
	  (assign, "$total_relation_subs", 0),

	  (try_for_range, ":kingdom", kingdoms_begin, kingdoms_end),
		(call_script, "script_evaluate_realm_stability", ":kingdom"),
	  (try_end),
	  #Warband changes end

	  (try_begin),
	    (eq, "$cheat_mode", 1),
	    (assign, reg3, "$cheat_mode"),
	    (display_message, "@{!}DEBUG : Completed political events, cheat mode: {reg3}"),
	  (try_end),

	  #assign love interests to unmarried male lords
	  (try_for_range, ":cur_troop", lords_begin, lords_end),
	    (troop_slot_eq, ":cur_troop", slot_troop_spouse, -1),
##diplomacy start+ Also bypass this for characters that start with manually-assigned fiancees
       (troop_slot_eq, ":cur_troop", slot_troop_betrothed, -1),
##diplomacy end+
		(neg|is_between, ":cur_troop", kings_begin, kings_end),
		(neg|is_between, ":cur_troop", pretenders_begin, pretenders_end),

		(call_script, "script_assign_troop_love_interests", ":cur_troop"),
	  (try_end),

	  (store_random_in_range, "$romantic_attraction_seed", 0, 5),

	  (try_begin),
	    (eq, "$cheat_mode", 1),
	    (assign, reg3, "$romantic_attraction_seed"),
	    (display_message, "@{!}DEBUG : Assigned love interests. Attraction seed: {reg3}"),
	  (try_end),

	  #we need to spawn more bandits in warband, because map is bigger.
      #(try_for_range, ":unused", 0, 7),
      #  (call_script, "script_spawn_bandits"),
      #(try_end),

      #(set_spawn_radius, 50),
      #(try_for_range, ":unused", 0, 25),
      #  (spawn_around_party, "p_main_party", "pt_looters"),
      #(try_end),

      (try_for_range, ":unused", 0, 10),
        (call_script, "script_spawn_bandits"),
      (try_end),

      #we are adding looter parties around each village with 1/5 probability.
      (set_spawn_radius, 5),
      (try_for_range, ":cur_village", villages_begin, villages_end),
        (store_random_in_range, ":random_value", 0, 5),
        (eq, ":random_value", 0),
        (spawn_around_party, ":cur_village", "pt_looters"),
      (try_end),

      (call_script, "script_update_mercenary_units_of_towns"),
      (call_script, "script_update_companion_candidates_in_taverns"),
      (call_script, "script_update_ransom_brokers"),
      (call_script, "script_update_tavern_travellers"),
      (call_script, "script_update_tavern_minstrels"),
      (call_script, "script_update_booksellers"),

      (try_for_range, ":village_no", villages_begin, villages_end),
        (call_script, "script_update_volunteer_troops_in_village", ":village_no"),
      (try_end),

      (try_for_range, ":cur_kingdom", kingdoms_begin, kingdoms_end),
        (call_script, "script_update_faction_notes", ":cur_kingdom"),
        (store_random_in_range, ":random_no", -60, 0),
        ##diplomacy start+
        #The above is a random time in the last 60 hours, but that's probably a mistake.
        #Change to a time within the last 60 days.
        (val_mul, ":random_no", 24),
        ##diplomacy end+
        (faction_set_slot, ":faction_no", slot_faction_last_offensive_concluded, ":random_no"),
      (try_end),

      (try_for_range, ":cur_troop", original_kingdom_heroes_begin, active_npcs_end),
        (troop_set_slot, ":cur_troop", slot_lord_granted_courtship_permission, 0), #initialize
        (call_script, "script_update_troop_notes", ":cur_troop"),
      (try_end),

      (try_for_range, ":cur_center", centers_begin, centers_end),
        ##diplomacy start+
        (party_get_slot, ":original_faction", ":center_no", slot_center_original_faction),
        (try_begin),
           #Assign plausible last-transfer-times to the contested centers based
           #on the "last offensive concluded" slot of the controlling faction.
           (is_between, ":original_faction", kingdoms_begin, kingdoms_end),
           (neg|party_slot_eq, ":center_no", slot_center_ex_faction, ":original_faction"),
           (faction_get_slot, reg0, ":original_faction", slot_faction_last_offensive_concluded),
           (party_set_slot, ":center_no", dplmc_slot_center_last_transfer_time, reg0),
        (try_end),
        ##diplomacy end+
        (call_script, "script_update_center_notes", ":cur_center"),
      (try_end),

      (call_script, "script_update_troop_notes", "trp_player"),

	  #Place kingdom ladies
      (try_for_range, ":troop_id", kingdom_ladies_begin, kingdom_ladies_end),
		(call_script, "script_get_kingdom_lady_social_determinants", ":troop_id"),
		(troop_set_slot, ":troop_id", slot_troop_cur_center, reg1),
		##diplomacy start+
		#Set their original faction.
		(ge, reg0, 0),
		(troop_get_slot, ":original_faction", reg0, slot_troop_original_faction),
		(troop_set_slot, ":troop_id", slot_troop_original_faction, ":original_faction"),
		##diplomacy end+
	  (try_end),

	  ##diplomacy start+
	  ##Set initial relations between kingdom ladies and their relatives.
	  ##Do *not* initialize their relations with anyone they aren't related to:
	  ##that is used for courtship.
	  ##  The purpose of this initialization is so if a kingdom lady gets promoted,
	  ##her relations aren't a featureless slate.  Also, it would be interesting to
	  ##further develop the idea of ladies as pursuing agendas even if they aren't
	  ##leading warbands, which would benefit from giving them relations with other
	  ##people.
     (try_for_range, ":lady", kingdom_ladies_begin, kingdom_ladies_end),
		(troop_slot_eq, ":lady", slot_troop_occupation, slto_kingdom_lady),
		(troop_get_slot, ":lady_faction", ":lady", slot_troop_original_faction),

		(try_for_range, ":other_hero", heroes_begin, heroes_end),
		   (this_or_next|troop_slot_eq, ":other_hero", slot_troop_occupation, slto_kingdom_lady),
			(this_or_next|troop_slot_eq, ":other_hero", slot_troop_occupation, slto_kingdom_hero),
				(troop_slot_eq, ":other_hero", slot_troop_occupation, slto_inactive_pretender),
			(troop_slot_eq, ":other_hero", slot_troop_original_faction, ":lady_faction"),

			(neq, ":other_hero", ":lady"),
			(try_begin),
			   (this_or_next|troop_slot_eq, ":lady", slot_troop_spouse, ":other_hero"),
				   (troop_slot_eq, ":other_hero", slot_troop_spouse, ":lady"),
				(store_random_in_range, reg0, 0, 11),
			(else_try),
			   (call_script, "script_troop_get_family_relation_to_troop", ":lady", ":other_hero"),
			(try_end),
			(call_script, "script_troop_change_relation_with_troop", ":lady", ":other_hero", reg0),

			#This relation change only applies between kingdom ladies.
			(troop_slot_eq, ":other_hero", slot_troop_occupation, slto_kingdom_lady),
			(is_between, ":other_hero", kingdom_ladies_begin, kingdom_ladies_end),

			(store_random_in_range, ":random", 0, 11),
			(call_script, "script_troop_change_relation_with_troop", ":lady", ":other_hero", ":random"),
		(try_end),
	  (try_end),
	  ##diplomacy end+


	  (try_begin),
	    (eq, "$cheat_mode", 1),
	    (assign, reg3, "$cheat_mode"),
	    (display_message, "@{!}DEBUG : Located kingdom ladies, cheat mode: {reg3}"),
	  (try_end),

      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (call_script, "script_faction_recalculate_strength", ":faction_no"),
      (try_end),

	  (faction_set_slot, "fac_kingdom_1", slot_faction_adjective, "str_kingdom_1_adjective"),
	  (faction_set_slot, "fac_kingdom_2", slot_faction_adjective, "str_kingdom_2_adjective"),
	  (faction_set_slot, "fac_kingdom_3", slot_faction_adjective, "str_kingdom_3_adjective"),
	  (faction_set_slot, "fac_kingdom_4", slot_faction_adjective, "str_kingdom_4_adjective"),
	  (faction_set_slot, "fac_kingdom_5", slot_faction_adjective, "str_kingdom_5_adjective"),
	  (faction_set_slot, "fac_kingdom_6", slot_faction_adjective, "str_kingdom_6_adjective"),

##      (assign, "$players_kingdom", "fac_kingdom_1"),
##      (call_script, "script_give_center_to_lord", "p_town_7", "trp_player", 0),
##      (call_script, "script_give_center_to_lord", "p_town_16", "trp_player", 0),
####      (call_script, "script_give_center_to_lord", "p_castle_10", "trp_player", 0),
##      (assign, "$g_castle_requested_by_player", "p_castle_10"),
      (call_script, "script_get_player_party_morale_values"),
      (party_set_morale, "p_main_party", reg0),

      (troop_set_note_available, "trp_player", 1),

      (try_for_range, ":troop_no", kings_begin, kings_end),
        (troop_set_note_available, ":troop_no", 1),
      (try_end),

      (try_for_range, ":troop_no", lords_begin, lords_end),
        (troop_set_note_available, ":troop_no", 1),
      (try_end),

	  (try_for_range, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
        (troop_set_note_available, ":troop_no", 1),
      (try_end),
	  (troop_set_note_available, "trp_knight_1_1_wife", 0),

      (try_for_range, ":troop_no", pretenders_begin, pretenders_end),
        (troop_set_note_available, ":troop_no", 1),
      (try_end),

	  #Lady and companion notes become available as you meet/recruit them

      (try_for_range, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
        (faction_set_note_available, ":faction_no", 1),
      (try_end),
      (faction_set_note_available, "fac_neutral", 0),

      (try_for_range, ":party_no", centers_begin, centers_end),
        (party_set_note_available, ":party_no", 1),
      (try_end),

	##diplomacy start+
    #Perform initialization for autoloot / autosell.
	(call_script, "script_dplmc_initialize_autoloot", 1),#argument "1" forces this to make changes
	#Set the version number (this slot on this troop should never be used for anything else)
	#The lowest 7 bits of the slot are a verification code.  They should always be equal to 68,
	#  unless there is no version number set.  The rest of the slot is the version number.
    (troop_set_slot, "trp_dplmc_chamberlain", dplmc_slot_troop_affiliated, (DPLMC_CURRENT_VERSION_CODE * 128) + DPLMC_VERSION_LOW_7_BITS),#Version number 1
	##diplomacy end+

    #SB : default parameters for post-battle continuation
    (call_script, "script_setup_camera_keys"),
    (assign, "$g_dplmc_cam_default", camera_mouse),
    (assign, "$g_dplmc_player_disguise", disguise_pilgrim),
    (assign, "$g_dplmc_charge_when_dead", 1),

    #SB : training ground slots
    (try_for_range, ":npc", training_ground_trainers_begin, training_ground_trainers_end),
        #init trainer vars
        (troop_set_slot, ":npc", slot_troop_trainer_met, 0),
        (troop_set_slot, ":npc", slot_troop_trainer_waiting_for_result, 0),
        (troop_set_slot, ":npc", slot_troop_trainer_training_fight_won, 0),
        (troop_set_slot, ":npc", slot_troop_trainer_num_opponents_to_beat, 3),
        (troop_set_slot, ":npc", slot_troop_trainer_training_system_explained, 0),
        (troop_set_slot, ":npc", slot_troop_trainer_opponent_troop, fighters_begin),
        (troop_set_slot, ":npc", slot_troop_trainer_training_difficulty, 0),

        (store_sub, ":offset", ":npc", training_ground_trainers_begin),
        #init grounds vars
        (store_add, ":grounds", ":offset", training_grounds_begin),
        (store_add, ":scene", ":offset", "scn_training_ground_ranged_melee_1"),
        (party_set_slot, ":grounds", slot_grounds_melee, ":scene"),
        (store_add, ":scene", ":offset", "scn_training_ground_horse_track_1"),
        (party_set_slot, ":grounds", slot_grounds_track, ":scene"),
        (party_set_slot, ":grounds", slot_grounds_trainer, ":npc"),
        (party_set_slot, ":grounds", slot_grounds_count, 0),
        (troop_set_slot, ":npc", slot_troop_cur_center, ":grounds"),
    (try_end),
    ]),

  #script_game_get_use_string
  # This script is called from the game engine for getting using information text
  # INPUT: used_scene_prop_id
  # OUTPUT: s0
  ("game_get_use_string",
   [
     (store_script_param, ":instance_id", 1),

     (prop_instance_get_scene_prop_kind, ":scene_prop_id", ":instance_id"),

     (try_begin),
       (this_or_next|eq, ":scene_prop_id", "spr_winch_b"),
       (eq, ":scene_prop_id", "spr_winch"),
       (assign, ":effected_object", "spr_portcullis"),
     (else_try),
       (this_or_next|eq, ":scene_prop_id", "spr_door_destructible"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_b"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_e_sally_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_sally_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),
       (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_right"),
       (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),
       (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_right"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_6m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_8m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_10m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_12m"),
       (eq, ":scene_prop_id", "spr_siege_ladder_move_14m"),
       (assign, ":effected_object", ":scene_prop_id"),
     (try_end),

     (scene_prop_get_slot, ":item_situation", ":instance_id", scene_prop_open_or_close_slot),

     (try_begin), #opening/closing portcullis
       (eq, ":effected_object", "spr_portcullis"),

       (try_begin),
         (eq, ":item_situation", 0),
         (str_store_string, s0, "str_open_gate"),
       (else_try),
         (str_store_string, s0, "str_close_gate"),
       (try_end),
     (else_try), #opening/closing door
       (this_or_next|eq, ":effected_object", "spr_door_destructible"),
       (this_or_next|eq, ":effected_object", "spr_castle_f_door_b"),
       (this_or_next|eq, ":effected_object", "spr_castle_e_sally_door_a"),
       (this_or_next|eq, ":effected_object", "spr_castle_f_sally_door_a"),
       (this_or_next|eq, ":effected_object", "spr_earth_sally_gate_left"),
       (this_or_next|eq, ":effected_object", "spr_earth_sally_gate_right"),
       (this_or_next|eq, ":effected_object", "spr_viking_keep_destroy_sally_door_left"),
       (this_or_next|eq, ":effected_object", "spr_viking_keep_destroy_sally_door_right"),
       (eq, ":effected_object", "spr_castle_f_door_a"),

       (try_begin),
         (eq, ":item_situation", 0),
         (str_store_string, s0, "str_open_door"),
       (else_try),
         (str_store_string, s0, "str_close_door"),
       (try_end),
     (else_try), #raising/dropping ladder
       (try_begin),
         (eq, ":item_situation", 0),
         (str_store_string, s0, "str_raise_ladder"),
       (else_try),
         (str_store_string, s0, "str_drop_ladder"),
       (try_end),
     (try_end),
   ]),

  #script_game_quick_start
  # This script is called from the game engine for initializing the global variables for tutorial, multiplayer and custom battle modes.
  # INPUT:
  # none
  # OUTPUT:
  # none
  ("game_quick_start",
    [
      #for quick battle mode
      (assign, "$g_is_quick_battle", 0),
      (assign, "$g_quick_battle_game_type", 0),
      (assign, "$g_quick_battle_troop", quick_battle_troops_begin),
      (assign, "$g_quick_battle_map", quick_battle_scenes_begin),
      (assign, "$g_quick_battle_team_1_faction", "fac_kingdom_1"),
      (assign, "$g_quick_battle_team_2_faction", "fac_kingdom_2"),
      (assign, "$g_quick_battle_army_1_size", 25),
      (assign, "$g_quick_battle_army_2_size", 25),

      (faction_set_slot, "fac_outlaws", slot_faction_quick_battle_tier_1_infantry, "trp_mountain_bandit"),
      (faction_set_slot, "fac_outlaws", slot_faction_quick_battle_tier_2_infantry, "trp_sea_raider"),
      (faction_set_slot, "fac_outlaws", slot_faction_quick_battle_tier_1_archer, "trp_forest_bandit"),
      (faction_set_slot, "fac_outlaws", slot_faction_quick_battle_tier_2_archer, "trp_taiga_bandit"),
      (faction_set_slot, "fac_outlaws", slot_faction_quick_battle_tier_1_cavalry, "trp_steppe_bandit"),
      (faction_set_slot, "fac_outlaws", slot_faction_quick_battle_tier_2_cavalry, "trp_desert_bandit"),
      (faction_set_slot, "fac_kingdom_1", slot_faction_quick_battle_tier_1_infantry, "trp_swadian_footman"),
      (faction_set_slot, "fac_kingdom_1", slot_faction_quick_battle_tier_2_infantry, "trp_swadian_infantry"),
      (faction_set_slot, "fac_kingdom_1", slot_faction_quick_battle_tier_1_archer, "trp_swadian_skirmisher"),
      (faction_set_slot, "fac_kingdom_1", slot_faction_quick_battle_tier_2_archer, "trp_swadian_crossbowman"),
      (faction_set_slot, "fac_kingdom_1", slot_faction_quick_battle_tier_1_cavalry, "trp_swadian_man_at_arms"),
      (faction_set_slot, "fac_kingdom_1", slot_faction_quick_battle_tier_2_cavalry, "trp_swadian_knight"),
      (faction_set_slot, "fac_kingdom_2", slot_faction_quick_battle_tier_1_infantry, "trp_vaegir_footman"),
      (faction_set_slot, "fac_kingdom_2", slot_faction_quick_battle_tier_2_infantry, "trp_vaegir_infantry"),
      (faction_set_slot, "fac_kingdom_2", slot_faction_quick_battle_tier_1_archer, "trp_vaegir_skirmisher"),
      (faction_set_slot, "fac_kingdom_2", slot_faction_quick_battle_tier_2_archer, "trp_vaegir_archer"),
      (faction_set_slot, "fac_kingdom_2", slot_faction_quick_battle_tier_1_cavalry, "trp_vaegir_horseman"),
      (faction_set_slot, "fac_kingdom_2", slot_faction_quick_battle_tier_2_cavalry, "trp_vaegir_knight"),
      (faction_set_slot, "fac_kingdom_3", slot_faction_quick_battle_tier_1_infantry, "trp_khergit_dismounted_lancer_multiplayer_ai"),
      (faction_set_slot, "fac_kingdom_3", slot_faction_quick_battle_tier_2_infantry, "trp_khergit_dismounted_lancer_multiplayer_ai"),
      (faction_set_slot, "fac_kingdom_3", slot_faction_quick_battle_tier_1_archer, "trp_khergit_horse_archer"),
      (faction_set_slot, "fac_kingdom_3", slot_faction_quick_battle_tier_2_archer, "trp_khergit_veteran_horse_archer"),
      (faction_set_slot, "fac_kingdom_3", slot_faction_quick_battle_tier_1_cavalry, "trp_khergit_lancer"),
      (faction_set_slot, "fac_kingdom_3", slot_faction_quick_battle_tier_2_cavalry, "trp_khergit_lancer"),
      (faction_set_slot, "fac_kingdom_4", slot_faction_quick_battle_tier_1_infantry, "trp_nord_warrior"),
      (faction_set_slot, "fac_kingdom_4", slot_faction_quick_battle_tier_2_infantry, "trp_nord_champion"),
      (faction_set_slot, "fac_kingdom_4", slot_faction_quick_battle_tier_1_archer, "trp_nord_archer"),
      (faction_set_slot, "fac_kingdom_4", slot_faction_quick_battle_tier_2_archer, "trp_nord_veteran_archer"),
      (faction_set_slot, "fac_kingdom_4", slot_faction_quick_battle_tier_1_cavalry, "trp_nord_scout_multiplayer_ai"),
      (faction_set_slot, "fac_kingdom_4", slot_faction_quick_battle_tier_2_cavalry, "trp_nord_scout_multiplayer_ai"),
      (faction_set_slot, "fac_kingdom_5", slot_faction_quick_battle_tier_1_infantry, "trp_rhodok_veteran_spearman"),
      (faction_set_slot, "fac_kingdom_5", slot_faction_quick_battle_tier_2_infantry, "trp_rhodok_sergeant"),
      (faction_set_slot, "fac_kingdom_5", slot_faction_quick_battle_tier_1_archer, "trp_rhodok_crossbowman"),
      (faction_set_slot, "fac_kingdom_5", slot_faction_quick_battle_tier_2_archer, "trp_rhodok_veteran_crossbowman"),
      (faction_set_slot, "fac_kingdom_5", slot_faction_quick_battle_tier_1_cavalry, "trp_rhodok_scout_multiplayer_ai"),
      (faction_set_slot, "fac_kingdom_5", slot_faction_quick_battle_tier_2_cavalry, "trp_rhodok_scout_multiplayer_ai"),
      (faction_set_slot, "fac_kingdom_6", slot_faction_quick_battle_tier_1_infantry, "trp_sarranid_veteran_footman"),
      (faction_set_slot, "fac_kingdom_6", slot_faction_quick_battle_tier_2_infantry, "trp_sarranid_infantry"),
      (faction_set_slot, "fac_kingdom_6", slot_faction_quick_battle_tier_1_archer, "trp_sarranid_skirmisher"),
      (faction_set_slot, "fac_kingdom_6", slot_faction_quick_battle_tier_2_archer, "trp_sarranid_archer"),
      (faction_set_slot, "fac_kingdom_6", slot_faction_quick_battle_tier_1_cavalry, "trp_sarranid_horseman"),
      (faction_set_slot, "fac_kingdom_6", slot_faction_quick_battle_tier_2_cavalry, "trp_sarranid_mamluke"),

      #for multiplayer mode
      (assign, "$g_multiplayer_selected_map", multiplayer_scenes_begin),
      (assign, "$g_multiplayer_respawn_period", 5),
      (assign, "$g_multiplayer_round_max_seconds", 300),
      (assign, "$g_multiplayer_game_max_minutes", 30),
      (assign, "$g_multiplayer_game_max_points", 300),

      (server_get_renaming_server_allowed, "$g_multiplayer_renaming_server_allowed"),
      (server_get_changing_game_type_allowed, "$g_multiplayer_changing_game_type_allowed"),
      (assign, "$g_multiplayer_point_gained_from_flags", 100),
      (assign, "$g_multiplayer_point_gained_from_capturing_flag", 5),
      (assign, "$g_multiplayer_game_type", 0),
      (assign, "$g_multiplayer_team_1_faction", "fac_kingdom_1"),
      (assign, "$g_multiplayer_team_2_faction", "fac_kingdom_2"),
      (assign, "$g_multiplayer_next_team_1_faction", "$g_multiplayer_team_1_faction"),
      (assign, "$g_multiplayer_next_team_2_faction", "$g_multiplayer_team_2_faction"),
      (assign, "$g_multiplayer_num_bots_team_1", 0),
      (assign, "$g_multiplayer_num_bots_team_2", 0),
      (assign, "$g_multiplayer_number_of_respawn_count", 0),
      (assign, "$g_multiplayer_num_bots_voteable", 50),
      (assign, "$g_multiplayer_max_num_bots", 101),
      (assign, "$g_multiplayer_factions_voteable", 1),
      (assign, "$g_multiplayer_maps_voteable", 1),
      (assign, "$g_multiplayer_kick_voteable", 1),
      (assign, "$g_multiplayer_ban_voteable", 1),
      (assign, "$g_multiplayer_valid_vote_ratio", 51), #more than 50 percent
      (assign, "$g_multiplayer_auto_team_balance_limit", 3), #auto balance when difference is more than 2
      (assign, "$g_multiplayer_player_respawn_as_bot", 1),
      (assign, "$g_multiplayer_stats_chart_opened_manually", 0),
      (assign, "$g_multiplayer_mission_end_screen", 0),
      (assign, "$g_multiplayer_ready_for_spawning_agent", 1),
      (assign, "$g_multiplayer_welcome_message_shown", 0),
      (assign, "$g_multiplayer_allow_player_banners", 1),
      (assign, "$g_multiplayer_force_default_armor", 1),
      (assign, "$g_multiplayer_disallow_ranged_weapons", 0),

      (assign, "$g_multiplayer_initial_gold_multiplier", 100),
      (assign, "$g_multiplayer_battle_earnings_multiplier", 100),
      (assign, "$g_multiplayer_round_earnings_multiplier", 100),

      #faction banners
      (faction_set_slot, "fac_kingdom_1", slot_faction_banner, "mesh_banner_kingdom_f"),
      (faction_set_slot, "fac_kingdom_2", slot_faction_banner, "mesh_banner_kingdom_b"),
      (faction_set_slot, "fac_kingdom_3", slot_faction_banner, "mesh_banner_kingdom_c"),
      (faction_set_slot, "fac_kingdom_4", slot_faction_banner, "mesh_banner_kingdom_a"),
      (faction_set_slot, "fac_kingdom_5", slot_faction_banner, "mesh_banner_kingdom_d"),
      (faction_set_slot, "fac_kingdom_6", slot_faction_banner, "mesh_banner_kingdom_e"),

      (call_script, "script_initialize_banner_info"),

      (try_for_range, ":cur_item", all_items_begin, all_items_end),
        (try_for_range, ":cur_faction", npc_kingdoms_begin, npc_kingdoms_end),
          (store_sub, ":faction_index", ":cur_faction", npc_kingdoms_begin),
          (val_add, ":faction_index", slot_item_multiplayer_faction_price_multipliers_begin),
          (item_set_slot, ":cur_item", ":faction_index", 100), #100 is the default price multiplier
        (try_end),
      (try_end),
      (store_sub, ":swadian_price_slot", "fac_kingdom_1", npc_kingdoms_begin),
      (val_add, ":swadian_price_slot", slot_item_multiplayer_faction_price_multipliers_begin),
      (store_sub, ":vaegir_price_slot", "fac_kingdom_2", npc_kingdoms_begin),
      (val_add, ":vaegir_price_slot", slot_item_multiplayer_faction_price_multipliers_begin),
      (store_sub, ":khergit_price_slot", "fac_kingdom_3", npc_kingdoms_begin),
      (val_add, ":khergit_price_slot", slot_item_multiplayer_faction_price_multipliers_begin),
      (store_sub, ":nord_price_slot", "fac_kingdom_4", npc_kingdoms_begin),
      (val_add, ":nord_price_slot", slot_item_multiplayer_faction_price_multipliers_begin),
      (store_sub, ":rhodok_price_slot", "fac_kingdom_5", npc_kingdoms_begin),
      (val_add, ":rhodok_price_slot", slot_item_multiplayer_faction_price_multipliers_begin),
      (store_sub, ":sarranid_price_slot", "fac_kingdom_6", npc_kingdoms_begin),
      (val_add, ":sarranid_price_slot", slot_item_multiplayer_faction_price_multipliers_begin),

      (item_set_slot, "itm_awlpike", ":swadian_price_slot", 80),
      (item_set_slot, "itm_awlpike_long", ":swadian_price_slot", 90),
      (item_set_slot, "itm_sword_medieval_a", ":swadian_price_slot", 80),
      (item_set_slot, "itm_sword_medieval_b", ":swadian_price_slot", 80),
      (item_set_slot, "itm_sword_medieval_b_small", ":swadian_price_slot", 80),
      (item_set_slot, "itm_sword_medieval_c", ":swadian_price_slot", 80),
      (item_set_slot, "itm_sword_medieval_c_small", ":swadian_price_slot", 80),
      (item_set_slot, "itm_leather_boots", ":swadian_price_slot", 90),
      (item_set_slot, "itm_mail_chausses", ":swadian_price_slot", 80),
      (item_set_slot, "itm_splinted_greaves", ":swadian_price_slot", 80),
      (item_set_slot, "itm_plate_boots", ":swadian_price_slot", 80),
      (item_set_slot, "itm_courser", ":swadian_price_slot", 90),
      (item_set_slot, "itm_hunter", ":swadian_price_slot", 75),
      (item_set_slot, "itm_norman_helmet", ":swadian_price_slot", 75),
      (item_set_slot, "itm_helmet_with_neckguard", ":swadian_price_slot", 75),
      (item_set_slot, "itm_red_gambeson", ":swadian_price_slot", 75),
      (item_set_slot, "itm_darts", ":swadian_price_slot", 50),
      (item_set_slot, "itm_war_darts", ":swadian_price_slot", 50),
      (item_set_slot, "itm_tab_shield_heater_d", ":swadian_price_slot", 80),
      (item_set_slot, "itm_brigandine_red", ":swadian_price_slot", 75),
      (item_set_slot, "itm_bastard_sword_b", ":swadian_price_slot", 65),
      (item_set_slot, "itm_bastard_sword_a", ":swadian_price_slot", 85),

      (item_set_slot, "itm_steppe_horse", ":khergit_price_slot", 120),
      (item_set_slot, "itm_courser", ":khergit_price_slot", 80),
      (item_set_slot, "itm_hunter", ":khergit_price_slot", 80),
      (item_set_slot, "itm_warhorse_steppe", ":khergit_price_slot", 120),
      (item_set_slot, "itm_one_handed_war_axe_a", ":khergit_price_slot", 300),
      (item_set_slot, "itm_tribal_warrior_outfit", ":khergit_price_slot", 140),

      (item_set_slot, "itm_leather_gloves", ":sarranid_price_slot", 50),
      (item_set_slot, "itm_short_bow", ":sarranid_price_slot", 50),
      (item_set_slot, "itm_barbed_arrows", ":sarranid_price_slot", 80),
      (item_set_slot, "itm_jarid", ":sarranid_price_slot", 85),
      (item_set_slot, "itm_javelin", ":sarranid_price_slot", 85),

      (item_set_slot, "itm_lamellar_vest", ":vaegir_price_slot", 130),
      (item_set_slot, "itm_awlpike", ":vaegir_price_slot", 150),
      (item_set_slot, "itm_scimitar", ":vaegir_price_slot", 130),
      (item_set_slot, "itm_scimitar_b", ":vaegir_price_slot", 150),
      (item_set_slot, "itm_tab_shield_kite_a", ":vaegir_price_slot", 120),
      (item_set_slot, "itm_tab_shield_kite_b", ":vaegir_price_slot", 120),
      (item_set_slot, "itm_tab_shield_kite_c", ":vaegir_price_slot", 120),
      (item_set_slot, "itm_tab_shield_kite_d", ":vaegir_price_slot", 120),
      (item_set_slot, "itm_javelin", ":vaegir_price_slot", 120),

      #arrows
      (item_set_slot, "itm_arrows", slot_item_multiplayer_item_class, multi_item_class_type_arrow),
      (item_set_slot, "itm_barbed_arrows", slot_item_multiplayer_item_class, multi_item_class_type_arrow),
      (item_set_slot, "itm_bodkin_arrows", slot_item_multiplayer_item_class, multi_item_class_type_arrow),
      (item_set_slot, "itm_khergit_arrows", slot_item_multiplayer_item_class, multi_item_class_type_arrow),
      #bolts
      (item_set_slot, "itm_bolts", slot_item_multiplayer_item_class, multi_item_class_type_bolt),
      (item_set_slot, "itm_steel_bolts", slot_item_multiplayer_item_class, multi_item_class_type_bolt),
      #bows
      (item_set_slot, "itm_crossbow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      (item_set_slot, "itm_heavy_crossbow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      (item_set_slot, "itm_sniper_crossbow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      (item_set_slot, "itm_nomad_bow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      (item_set_slot, "itm_khergit_bow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      (item_set_slot, "itm_strong_bow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      (item_set_slot, "itm_war_bow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      (item_set_slot, "itm_short_bow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      (item_set_slot, "itm_long_bow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      (item_set_slot, "itm_light_crossbow", slot_item_multiplayer_item_class, multi_item_class_type_bow),
      #swords
      (item_set_slot, "itm_sword_medieval_a", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_medieval_b", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_medieval_b_small", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_medieval_c", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_medieval_c_small", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_scimitar", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_scimitar_b", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_dagger", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_khergit_1", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_khergit_2", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_khergit_3", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_khergit_4", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_viking_1", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_viking_2", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_viking_2_small", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_viking_3", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_sword_viking_3_small", slot_item_multiplayer_item_class, multi_item_class_type_sword),
      (item_set_slot, "itm_bastard_sword_a", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_sword),
      (item_set_slot, "itm_bastard_sword_b", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_sword),
      (item_set_slot, "itm_sword_two_handed_a", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_sword),
      (item_set_slot, "itm_sword_two_handed_b", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_sword),
      (item_set_slot, "itm_arabian_sword_a", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_sword),
      (item_set_slot, "itm_arabian_sword_b", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_sword),
      (item_set_slot, "itm_sarranid_cavalry_sword", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_sword),
      (item_set_slot, "itm_arabian_sword_d", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_sword),

      #axe
      (item_set_slot, "itm_axe", slot_item_multiplayer_item_class, multi_item_class_type_axe),
      (item_set_slot, "itm_battle_axe", slot_item_multiplayer_item_class, multi_item_class_type_axe),
      (item_set_slot, "itm_one_handed_war_axe_a", slot_item_multiplayer_item_class, multi_item_class_type_axe),
      (item_set_slot, "itm_one_handed_war_axe_b", slot_item_multiplayer_item_class, multi_item_class_type_axe),
      (item_set_slot, "itm_one_handed_battle_axe_a", slot_item_multiplayer_item_class, multi_item_class_type_axe),
      (item_set_slot, "itm_one_handed_battle_axe_b", slot_item_multiplayer_item_class, multi_item_class_type_axe),
      (item_set_slot, "itm_one_handed_battle_axe_c", slot_item_multiplayer_item_class, multi_item_class_type_axe),

      (item_set_slot, "itm_two_handed_axe", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_two_handed_battle_axe_2", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_shortened_voulge", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_bardiche", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_great_axe", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_great_bardiche", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_long_axe", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_long_axe_b", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_long_axe_c", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_voulge", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_long_bardiche", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_great_long_bardiche", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),

      #blunt
      (item_set_slot, "itm_mace_1", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_mace_2", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_mace_3", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_mace_4", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_long_spiked_club", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_long_hafted_spiked_mace", slot_item_multiplayer_item_class, multi_item_class_type_blunt),

      (item_set_slot, "itm_maul", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_sledgehammer", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_warhammer", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_morningstar", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      #picks
      (item_set_slot, "itm_military_sickle_a", slot_item_multiplayer_item_class, multi_item_class_type_war_picks),
      (item_set_slot, "itm_fighting_pick", slot_item_multiplayer_item_class, multi_item_class_type_war_picks),
      (item_set_slot, "itm_military_pick", slot_item_multiplayer_item_class, multi_item_class_type_war_picks),
      (item_set_slot, "itm_club_with_spike_head", slot_item_multiplayer_item_class, multi_item_class_type_war_picks),

	  #Cleavers
	  (item_set_slot, "itm_falchion", slot_item_multiplayer_item_class, multi_item_class_type_cleavers),
      (item_set_slot, "itm_military_cleaver_b", slot_item_multiplayer_item_class, multi_item_class_type_cleavers),
      (item_set_slot, "itm_military_cleaver_c", slot_item_multiplayer_item_class, multi_item_class_type_cleavers),
      (item_set_slot, "itm_two_handed_cleaver", slot_item_multiplayer_item_class, multi_item_class_type_cleavers),
      (item_set_slot, "itm_hafted_blade_a", slot_item_multiplayer_item_class, multi_item_class_type_cleavers),
      (item_set_slot, "itm_hafted_blade_b", slot_item_multiplayer_item_class, multi_item_class_type_cleavers),
      (item_set_slot, "itm_shortened_military_scythe", slot_item_multiplayer_item_class, multi_item_class_type_cleavers),

      (item_set_slot, "itm_sarranid_mace_1", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_sarranid_axe_a", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_sarranid_axe_b", slot_item_multiplayer_item_class, multi_item_class_type_blunt),
      (item_set_slot, "itm_sarranid_two_handed_axe_a", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_sarranid_two_handed_axe_b", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_sarranid_two_handed_mace_1", slot_item_multiplayer_item_class, multi_item_class_type_two_handed_axe),
      (item_set_slot, "itm_bamboo_spear", slot_item_multiplayer_item_class, multi_item_class_type_spear),



      #spears
      (item_set_slot, "itm_double_sided_lance", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_glaive", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_poleaxe", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_polehammer", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_staff", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_quarter_staff", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_iron_staff", slot_item_multiplayer_item_class, multi_item_class_type_spear),

      (item_set_slot, "itm_shortened_spear", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_spear", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_war_spear", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_military_scythe", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_pike", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_ashwood_pike", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_awlpike", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      (item_set_slot, "itm_awlpike_long", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      #lance
      (item_set_slot, "itm_light_lance", slot_item_multiplayer_item_class, multi_item_class_type_lance),
      (item_set_slot, "itm_lance", slot_item_multiplayer_item_class, multi_item_class_type_lance),
      (item_set_slot, "itm_heavy_lance", slot_item_multiplayer_item_class, multi_item_class_type_lance),
      (item_set_slot, "itm_great_lance", slot_item_multiplayer_item_class, multi_item_class_type_lance),
      #shields

      (item_set_slot, "itm_tab_shield_round_a", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_round_b", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_round_c", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_round_d", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_round_e", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_kite_a", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_kite_b", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_kite_c", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_kite_d", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_kite_cav_a", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_kite_cav_b", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_heater_a", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_heater_b", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_heater_c", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_heater_d", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_heater_cav_a", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_heater_cav_b", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_pavise_a", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_pavise_b", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_pavise_c", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_pavise_d", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_small_round_a", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_small_round_b", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_tab_shield_small_round_c", slot_item_multiplayer_item_class, multi_item_class_type_small_shield),
      (item_set_slot, "itm_spear", slot_item_multiplayer_item_class, multi_item_class_type_spear),
      #throwing
      (item_set_slot, "itm_darts", slot_item_multiplayer_item_class, multi_item_class_type_throwing),
      (item_set_slot, "itm_war_darts", slot_item_multiplayer_item_class, multi_item_class_type_throwing),
      (item_set_slot, "itm_javelin", slot_item_multiplayer_item_class, multi_item_class_type_throwing),
      (item_set_slot, "itm_jarid", slot_item_multiplayer_item_class, multi_item_class_type_throwing),
      (item_set_slot, "itm_throwing_spears", slot_item_multiplayer_item_class, multi_item_class_type_throwing),

      (item_set_slot, "itm_throwing_axes", slot_item_multiplayer_item_class, multi_item_class_type_throwing_axe),
      (item_set_slot, "itm_light_throwing_axes", slot_item_multiplayer_item_class, multi_item_class_type_throwing_axe),
      (item_set_slot, "itm_heavy_throwing_axes", slot_item_multiplayer_item_class, multi_item_class_type_throwing_axe),
       #armors
      (item_set_slot, "itm_red_shirt", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_red_tunic", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_aketon_green", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_padded_cloth", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_red_gambeson", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_leather_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_haubergeon", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_coat_of_plates_red", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_brigandine_red", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_mail_with_surcoat", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_linen_tunic", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_leather_vest", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_leather_jerkin", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_studded_leather_coat", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_lamellar_vest", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_lamellar_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_coarse_tunic", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_tribal_warrior_outfit", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_khergit_guard_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_blue_tunic", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_mail_hauberk", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_mail_shirt", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_byrnie", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
	  (item_set_slot, "itm_lamellar_vest_khergit", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
	  (item_set_slot, "itm_steppe_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),


      (item_set_slot, "itm_banded_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_cuir_bouilli", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_scale_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),

      (item_set_slot, "itm_padded_leather", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_green_tunic", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_tunic_with_green_cape", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_aketon_green", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_ragged_outfit", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_surcoat_over_mail", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),

      (item_set_slot, "itm_sarranid_elite_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_skirmisher_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_archers_vest", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_sarranid_leather_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_sarranid_cloth_robe", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_sarranid_mail_shirt", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_sarranid_cavalry_robe", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_arabian_armor_b", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_mamluke_mail", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_khergit_elite_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
      (item_set_slot, "itm_vaegir_elite_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
	  (item_set_slot, "itm_khergit_armor", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),





      #boots
      (item_set_slot, "itm_hide_boots", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_ankle_boots", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_nomad_boots", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_leather_boots", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_splinted_leather_greaves", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_mail_chausses", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_splinted_leather_greaves", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_splinted_greaves", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_mail_boots", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_iron_greaves", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_sarranid_boots_b", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_sarranid_boots_c", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
      (item_set_slot, "itm_sarranid_boots_d", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
	  (item_set_slot, "itm_plate_boots", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
	  (item_set_slot, "itm_khergit_leather_boots", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),
	  (item_set_slot, "itm_khergit_guard_boots", slot_item_multiplayer_item_class, multi_item_class_type_light_foot),








      #helmets


      (item_set_slot, "itm_leather_steppe_cap_a", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_leather_steppe_cap_b", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_steppe_cap", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_khergit_war_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_khergit_guard_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),



      (item_set_slot, "itm_arming_cap", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_padded_coif", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_mail_coif", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_footman_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_norman_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_kettle_hat", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_helmet_with_neckguard", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),

	  (item_set_slot, "itm_bascinet_2", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
	  (item_set_slot, "itm_bascinet_3", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),



      (item_set_slot, "itm_flat_topped_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_guard_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_full_helm", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_great_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_nomad_cap_b", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_skullcap", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_leather_cap", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),

      (item_set_slot, "itm_spiked_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
#      (item_set_slot, "itm_nasal_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_nordic_archer_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_nordic_veteran_archer_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_nordic_footman_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_nordic_fighter_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_nordic_huscarl_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_nordic_warlord_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),

      (item_set_slot, "itm_sarranid_helmet1", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_sarranid_horseman_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_sarranid_felt_hat", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_sarranid_veiled_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_turban", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_desert_turban", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_sarranid_warrior_cap", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_sarranid_mail_coif", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),

      (item_set_slot, "itm_vaegir_fur_cap", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_vaegir_fur_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_vaegir_spiked_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_vaegir_lamellar_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_vaegir_noble_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_vaegir_war_helmet", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),
      (item_set_slot, "itm_vaegir_mask", slot_item_multiplayer_item_class, multi_item_class_type_light_helm),


	  #gloves
      (item_set_slot, "itm_leather_gloves", slot_item_multiplayer_item_class, multi_item_class_type_glove),
      (item_set_slot, "itm_mail_mittens", slot_item_multiplayer_item_class, multi_item_class_type_glove),
      (item_set_slot, "itm_scale_gauntlets", slot_item_multiplayer_item_class, multi_item_class_type_glove),
	  (item_set_slot, "itm_lamellar_gauntlets", slot_item_multiplayer_item_class, multi_item_class_type_glove),
	  (item_set_slot, "itm_gauntlets", slot_item_multiplayer_item_class, multi_item_class_type_glove),

      #horses
      (item_set_slot, "itm_saddle_horse", slot_item_multiplayer_item_class, multi_item_class_type_horse),
      (item_set_slot, "itm_hunter", slot_item_multiplayer_item_class, multi_item_class_type_horse),
      (item_set_slot, "itm_courser", slot_item_multiplayer_item_class, multi_item_class_type_horse),
      (item_set_slot, "itm_hunter", slot_item_multiplayer_item_class, multi_item_class_type_horse),
      (item_set_slot, "itm_warhorse", slot_item_multiplayer_item_class, multi_item_class_type_horse),
      (item_set_slot, "itm_charger", slot_item_multiplayer_item_class, multi_item_class_type_horse),
      (item_set_slot, "itm_steppe_horse", slot_item_multiplayer_item_class, multi_item_class_type_horse),
      (item_set_slot, "itm_arabian_horse_a", slot_item_multiplayer_item_class, multi_item_class_type_horse),
      (item_set_slot, "itm_arabian_horse_b", slot_item_multiplayer_item_class, multi_item_class_type_horse),
	  (item_set_slot, "itm_warhorse_steppe", slot_item_multiplayer_item_class, multi_item_class_type_horse),
	  (item_set_slot, "itm_warhorse_sarranid", slot_item_multiplayer_item_class, multi_item_class_type_horse),


      #1-Swadian Warriors
      #1a-Swadian Crossbowman
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bolts", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steel_bolts", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_crossbow", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_heavy_crossbow", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sniper_crossbow", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_a", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_b", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_b_small", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_a", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_b", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_c", "trp_swadian_crossbowman_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_red_shirt", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_padded_cloth", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_armor", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_haubergeon", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_ankle_boots", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_boots", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_chausses", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_swadian_crossbowman_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arming_cap", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_norman_helmet", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_helmet_with_neckguard", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_flat_topped_helmet", "trp_swadian_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_guard_helmet", "trp_swadian_crossbowman_multiplayer"),

      #1b-Swadian Infantry
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_awlpike", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_awlpike_long", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_a", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_b", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_b_small", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_c", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_c_small", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bastard_sword_a", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bastard_sword_b", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_two_handed_a", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_two_handed_b", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_darts", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_darts", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_a", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_b", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_c", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_d", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_red_tunic", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_red_gambeson", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_armor", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_haubergeon", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_brigandine_red", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_ankle_boots", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_boots", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_chausses", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arming_cap", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_norman_helmet", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_helmet_with_neckguard", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_flat_topped_helmet", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_guard_helmet", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_great_helmet", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_swadian_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_gauntlets", "trp_swadian_infantry_multiplayer"),

      #1c-Swadian Man At Arms
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_darts", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_darts", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lance", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_heavy_lance", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_great_lance", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_a", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_b", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_b_small", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_c", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_c_small", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bastard_sword_a", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bastard_sword_b", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_a", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_b", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_c", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_d", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_red_tunic", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_padded_cloth", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_armor", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_with_surcoat", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_coat_of_plates_red", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_ankle_boots", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_boots", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_chausses", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_plate_boots", "trp_swadian_man_at_arms_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arming_cap", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_norman_helmet", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_helmet_with_neckguard", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_flat_topped_helmet", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_guard_helmet", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_great_helmet", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_gauntlets", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_saddle_horse", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_courser", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hunter", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_warhorse", "trp_swadian_man_at_arms_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_charger", "trp_swadian_man_at_arms_multiplayer"),

      # #1d-Swadian Mounted Crossbowman
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bolts", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_light_crossbow", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_crossbow", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_heavy_crossbow", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_cav_a", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_cav_b", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bastard_sword_a", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_red_shirt", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_padded_cloth", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_armor", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_with_surcoat", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_coat_of_plates_red", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hide_boots", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arming_cap", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_norman_helmet", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_helmet_with_neckguard", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_flat_topped_helmet", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_guard_helmet", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_saddle_horse", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_courser", "trp_swadian_mounted_crossbowman_multiplayer"),
      # (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hunter", "trp_swadian_mounted_crossbowman_multiplayer"),

      #2-Vaegir Warriors
      #2a-Vaegir Archer
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arrows", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_barbed_arrows", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_1", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_2", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_falchion", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_bow", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_bow", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_strong_bow", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_bow", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_linen_tunic", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_jerkin", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_vest", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_vest", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hide_boots", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_boots", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_leather_greaves", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_cap", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_fur_cap", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_fur_helmet", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_spiked_helmet", "trp_vaegir_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_lamellar_helmet", "trp_vaegir_archer_multiplayer"),

      #2b-Vaegir Spearman
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_spear", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_spear", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_awlpike", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_a", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_b", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_c", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_d", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_1", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_2", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_3", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_4", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_long_hafted_spiked_mace", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_long_spiked_club", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scimitar", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scimitar_b", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bardiche", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_great_bardiche", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_long_bardiche", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_great_long_bardiche", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_javelin", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_linen_tunic", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_jerkin", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_vest", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_vest", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_armor", "trp_vaegir_spearman_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_elite_armor", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hide_boots", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_boots", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_leather_greaves", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_vaegir_spearman_multiplayer"),
#      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_spiked_helmet", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_fur_cap", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_fur_helmet", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_spiked_helmet", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_lamellar_helmet", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_noble_helmet", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_war_helmet", "trp_vaegir_spearman_multiplayer"),
	  #      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nasal_helmet", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_vaegir_spearman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_vaegir_spearman_multiplayer"),

      #2c-Vaegir Horseman
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_darts", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_darts", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bardiche", "trp_vaegir_horseman_multiplayer"),
#      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_great_bardiche", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scimitar", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scimitar_b", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lance", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_heavy_lance", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_cav_a", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_cav_b", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_c", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_d", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_linen_tunic", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_vest", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_vest", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_studded_leather_coat", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_armor", "trp_vaegir_horseman_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_elite_armor", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hide_boots", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_boots", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_leather_greaves", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_plate_boots", "trp_vaegir_horseman_multiplayer"),
#      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_spiked_helmet", "trp_vaegir_horseman_multiplayer"),
#      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nasal_helmet", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_fur_cap", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_fur_helmet", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_spiked_helmet", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_lamellar_helmet", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_noble_helmet", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_war_helmet", "trp_vaegir_horseman_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_vaegir_mask", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_saddle_horse", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_courser", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hunter", "trp_vaegir_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_warhorse_steppe", "trp_vaegir_horseman_multiplayer"),

      #3-Khergit Warriors
      #3a-Khergit Veteran Horse Archer
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_1", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_2", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_3", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_4", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_bow", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_bow", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_strong_bow", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arrows", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_arrows", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_steppe_cap_a", "trp_khergit_veteran_horse_archer_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_cap_b", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_steppe_cap_b", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steppe_cap", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_armor", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steppe_armor", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tribal_warrior_outfit", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_vest_khergit", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hide_boots", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_boots", "trp_khergit_veteran_horse_archer_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_leather_boots", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_leather_greaves", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_khergit_veteran_horse_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steppe_horse", "trp_khergit_veteran_horse_archer_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_khergit_veteran_horse_archer_multiplayer"),
      #3a-Khergit Dismounted Lancer
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_javelin", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_jarid", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_1", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_2", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_3", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_4", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_a", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_b", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_c", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_round_b", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_round_c", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_spear", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hafted_blade_a", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hafted_blade_b", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_1", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_2", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_3", "trp_khergit_infantry_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_cap_b", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_steppe_cap_b", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steppe_cap", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_war_helmet", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_guard_helmet", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steppe_armor", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tribal_warrior_outfit", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_armor", "trp_khergit_infantry_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_elite_armor", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hide_boots", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_boots", "trp_khergit_infantry_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_leather_boots", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_leather_greaves", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_khergit_infantry_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_khergit_infantry_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_gauntlets", "trp_khergit_infantry_multiplayer"),
      #3a-Khergit Lancer
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_javelin", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_1", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_2", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_3", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_khergit_4", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_a", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_b", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_c", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lance", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_heavy_lance", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hafted_blade_a", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hafted_blade_b", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_one_handed_war_axe_a", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_steppe_cap_a", "trp_khergit_lancer_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_cap_b", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_steppe_cap_b", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steppe_cap", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_war_helmet", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_armor", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steppe_armor", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tribal_warrior_outfit", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_armor", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hide_boots", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_boots", "trp_khergit_lancer_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_khergit_leather_boots", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_leather_greaves", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_khergit_lancer_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lamellar_gauntlets", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steppe_horse", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_courser", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hunter", "trp_khergit_lancer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_warhorse_steppe", "trp_khergit_lancer_multiplayer"),

      #Nord Warriors

      #4c-Nord Archer
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arrows", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_barbed_arrows", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bodkin_arrows", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_1", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_2", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_2_small", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_3", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_3_small", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_one_handed_war_axe_a", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_one_handed_war_axe_b", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_two_handed_axe", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_short_bow", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_long_bow", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_blue_tunic", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_jerkin", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_byrnie", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_boots", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_leather_greaves", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_chausses", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_boots", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_archer_helmet", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_veteran_archer_helmet", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_footman_helmet", "trp_nord_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_fighter_helmet", "trp_nord_archer_multiplayer"),

      #4a-Nord Veteran
#      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_darts", "trp_nord_veteran_multiplayer"),
#      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_darts", "trp_nord_veteran_multiplayer"),
#      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_javelin", "trp_nord_veteran_multiplayer"),
#      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_throwing_spears", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_1", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_2", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_2_small", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_3", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_3_small", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_one_handed_war_axe_a", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_one_handed_war_axe_b", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_one_handed_battle_axe_a", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_one_handed_battle_axe_b", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_one_handed_battle_axe_c", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_two_handed_axe", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_two_handed_battle_axe_2", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_great_axe", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_long_axe", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_long_axe_b", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_long_axe_c", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_spear", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_spear", "trp_nord_veteran_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_round_a", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_round_b", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_round_c", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_round_d", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_round_e", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_light_throwing_axes", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_throwing_axes", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_heavy_throwing_axes", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_veteran_archer_helmet", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_footman_helmet", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_fighter_helmet", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_huscarl_helmet", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_warlord_helmet", "trp_nord_veteran_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_blue_tunic", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_jerkin", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_shirt", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_hauberk", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_banded_armor", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_boots", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_leather_greaves", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_chausses", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_boots", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_nord_veteran_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_nord_veteran_multiplayer"),

      #4b-Nord Scout
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_darts", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_darts", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_javelin", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_throwing_spears", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_light_throwing_axes", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_throwing_axes", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_1", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_2", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_viking_3", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_two_handed_axe", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_two_handed_battle_axe_2", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_shortened_voulge", "trp_nord_scout_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_spear", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_spear", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_light_lance", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lance", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_a", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_b", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_c", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_archer_helmet", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_veteran_archer_helmet", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_footman_helmet", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_fighter_helmet", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nordic_huscarl_helmet", "trp_nord_scout_multiplayer"),


      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_blue_tunic", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_jerkin", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_shirt", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_hauberk", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_boots", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_leather_greaves", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_chausses", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_boots", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_saddle_horse", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_courser", "trp_nord_scout_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hunter", "trp_nord_scout_multiplayer"),


      #5-Rhodok Warriors
      #5a-Rhodok Veteran Crossbowman
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_crossbow", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_heavy_crossbow", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sniper_crossbow", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bolts", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_steel_bolts", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_fighting_pick", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_military_pick", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_club_with_spike_head", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_maul", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sledgehammer", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_a", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_b", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_b_small", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_pavise_a", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_pavise_b", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_pavise_c", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_pavise_d", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_cap", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_padded_coif", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_footman_helmet", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_kettle_hat", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tunic_with_green_cape", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_aketon_green", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_armor", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_ankle_boots", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_boots", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_rhodok_veteran_crossbowman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_rhodok_veteran_crossbowman_multiplayer"),

	  #5b-Rhodok Sergeant
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_darts", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_darts", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_javelin", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_fighting_pick", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_military_pick", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_morningstar", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_club_with_spike_head", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_military_cleaver_b", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_military_cleaver_c", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_two_handed_cleaver", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_military_sickle_a", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_maul", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sledgehammer", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_warhammer", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_spear", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_pike", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_ashwood_pike", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_spear", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_glaive", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_pavise_a", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_pavise_b", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_pavise_c", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_pavise_d", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_cap", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_padded_coif", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_footman_helmet", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_kettle_hat", "trp_rhodok_sergeant_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bascinet_2", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_full_helm", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_green_tunic", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_aketon_green", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_ragged_outfit", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_armor", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_surcoat_over_mail", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_ankle_boots", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_boots", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_iron_greaves", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_rhodok_sergeant_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_gauntlets", "trp_rhodok_sergeant_multiplayer"),

	  #5c-Rhodok Horseman
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_darts", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_war_darts", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_javelin", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_a", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_b", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sword_medieval_c", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_fighting_pick", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_military_pick", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_morningstar", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_military_cleaver_b", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_military_cleaver_c", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_two_handed_cleaver", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_shortened_military_scythe", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_light_lance", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lance", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_heavy_lance", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_cav_a", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_heater_cav_b", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_padded_coif", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_footman_helmet", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_kettle_hat", "trp_rhodok_horseman_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bascinet_3", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_green_tunic", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_aketon_green", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_ragged_outfit", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_armor", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_surcoat_over_mail", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_ankle_boots", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_boots", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_splinted_greaves", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_plate_boots", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_gauntlets", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_saddle_horse", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_courser", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_hunter", "trp_rhodok_horseman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_warhorse", "trp_rhodok_horseman_multiplayer"),



      #6-Sarranid Warriors
      #5a-Sarranid archer
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_cloth_robe", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_skirmisher_armor", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_archers_vest", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_armor_b", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_felt_hat", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_turban", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_desert_turban", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_mail_coif", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_horseman_helmet", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_warrior_cap", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_boots_b", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_boots_c", "trp_sarranid_archer_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_short_bow", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_nomad_bow", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arrows", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_barbed_arrows", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scimitar", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mace_1", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_sword_a", "trp_sarranid_archer_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_sword_b", "trp_sarranid_archer_multiplayer"),

	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_sarranid_archer_multiplayer"),



	  #Sarranid footman
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_cloth_robe", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_skirmisher_armor", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_archers_vest", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_leather_armor", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_armor_b", "trp_sarranid_footman_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_elite_armor", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_felt_hat", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_turban", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_desert_turban", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_mail_coif", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_warrior_cap", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_veiled_helmet", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_boots_b", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_boots_c", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_boots_d", "trp_sarranid_footman_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_sword_a", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_sword_b", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_sword_d", "trp_sarranid_footman_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_mace_1", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_axe_a", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_axe_b", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_two_handed_axe_a", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_two_handed_axe_b", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_two_handed_mace_1", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_bamboo_spear", "trp_sarranid_footman_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_spear", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_jarid", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_javelin", "trp_sarranid_footman_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_a", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_b", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_c", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_kite_d", "trp_sarranid_footman_multiplayer"),

	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_sarranid_footman_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_sarranid_footman_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_sarranid_footman_multiplayer"),




	  #Sarranid mamluke
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_cloth_robe", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_skirmisher_armor", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_archers_vest", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_mail_shirt", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_cavalry_robe", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mamluke_mail", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_elite_armor", "trp_sarranid_mamluke_multiplayer"),


      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_turban", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_desert_turban", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_horseman_helmet", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_mail_coif", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_veiled_helmet", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_boots_b", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_boots_c", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_boots_d", "trp_sarranid_mamluke_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_sword_a", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_sword_b", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_cavalry_sword", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_sword_d", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_mace_1", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_axe_a", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_axe_b", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_sarranid_two_handed_axe_a", "trp_sarranid_mamluke_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_lance", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_heavy_lance", "trp_sarranid_mamluke_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_jarid", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_javelin", "trp_sarranid_mamluke_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_a", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_b", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_tab_shield_small_round_c", "trp_sarranid_mamluke_multiplayer"),

      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_saddle_horse", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_horse_a", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_arabian_horse_b", "trp_sarranid_mamluke_multiplayer"),
      (call_script, "script_multiplayer_set_item_available_for_troop", "itm_warhorse_sarranid", "trp_sarranid_mamluke_multiplayer"),

	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_leather_gloves", "trp_sarranid_mamluke_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_mail_mittens", "trp_sarranid_mamluke_multiplayer"),
	  (call_script, "script_multiplayer_set_item_available_for_troop", "itm_scale_gauntlets", "trp_sarranid_mamluke_multiplayer"),


      ]),

  #script_get_army_size_from_slider_value
  # INPUT: arg1 = slider_value
  # OUTPUT: reg0 = army_size
  ("get_army_size_from_slider_value",
    [
     (store_script_param, ":slider_value", 1),
     (assign, ":army_size", ":slider_value"),
     (try_begin),
       (gt, ":slider_value", 25),
       (store_sub, ":adder_value", ":slider_value", 25),
       (val_add, ":army_size", ":adder_value"),
       (try_begin),
         (gt, ":slider_value", 50),
         (store_sub, ":adder_value", ":slider_value", 50),
         (val_mul, ":adder_value", 3),
         (val_add, ":army_size", ":adder_value"),
       (try_end),
     (try_end),
     (assign, reg0, ":army_size"),
  ]),

  #script_spawn_quick_battle_army
  # INPUT: arg1 = initial_entry_point, arg2 = faction_no, arg3 = infantry_ratio, arg4 = archers_ratio, arg5 = cavalry_ratio, arg6 = divide_archer_entry_points, arg7 = player_team
  # OUTPUT: none
  ("spawn_quick_battle_army",
   [
     (store_script_param, ":cur_entry_point", 1),
     (store_script_param, ":faction_no", 2),
     (store_script_param, ":infantry_ratio", 3),
     (store_script_param, ":archers_ratio", 4),
     (store_script_param, ":cavalry_ratio", 5),
     (store_script_param, ":divide_archer_entry_points", 6),
     (store_script_param, ":player_team", 7),

     (try_begin),
       (eq, ":player_team", 1),
       (call_script, "script_get_army_size_from_slider_value", "$g_quick_battle_army_1_size"),
       (assign, ":army_size", reg0),
       (set_player_troop, "$g_quick_battle_troop"),
       (set_visitor, ":cur_entry_point", "$g_quick_battle_troop"),
       (try_begin),
         (eq, ":cur_entry_point", 0),
         (try_begin),
           (is_between, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
           (faction_get_slot, "$g_quick_battle_team_0_banner", ":faction_no", slot_faction_banner),
         (else_try),
           (assign, "$g_quick_battle_team_0_banner", "mesh_banners_default_b"),
         (try_end),
       (else_try),
         (try_begin),
           (is_between, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
           (faction_get_slot, "$g_quick_battle_team_1_banner", ":faction_no", slot_faction_banner),
         (else_try),
           (assign, "$g_quick_battle_team_1_banner", "mesh_banners_default_b"),
         (try_end),
       (try_end),
       (val_add, ":cur_entry_point", 1),

     (else_try),
       (call_script, "script_get_army_size_from_slider_value", "$g_quick_battle_army_2_size"),
       (assign, ":army_size", reg0),
       (try_begin),
         (eq, ":cur_entry_point", 0),
         (try_begin),
           (is_between, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
           (faction_get_slot, "$g_quick_battle_team_0_banner", ":faction_no", slot_faction_banner),
         (else_try),
           (assign, "$g_quick_battle_team_0_banner", "mesh_banners_default_a"),
         (try_end),
       (else_try),
         (try_begin),
           (is_between, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
           (faction_get_slot, "$g_quick_battle_team_1_banner", ":faction_no", slot_faction_banner),
         (else_try),
           (assign, "$g_quick_battle_team_1_banner", "mesh_banners_default_a"),
         (try_end),
       (try_end),
       (val_add, ":cur_entry_point", 1),
     (try_end),

     (store_mul, ":num_infantry", ":infantry_ratio", ":army_size"),
     (val_div, ":num_infantry", 100),
     (store_mul, ":num_archers", ":archers_ratio", ":army_size"),
     (val_div, ":num_archers", 100),
     (store_mul, ":num_cavalry", ":cavalry_ratio", ":army_size"),
     (val_div, ":num_cavalry", 100),

     (try_begin),
       (store_add, ":num_total", ":num_infantry", ":num_archers"),
       (val_add, ":num_total", ":num_cavalry"),
       (neq, ":num_total", ":army_size"),
       (store_sub, ":leftover", ":army_size", ":num_total"),
       (try_begin),
         (gt, ":infantry_ratio", ":archers_ratio"),
         (gt, ":infantry_ratio", ":cavalry_ratio"),
         (val_add, ":num_infantry", ":leftover"),
       (else_try),
         (gt, ":archers_ratio", ":cavalry_ratio"),
         (val_add, ":num_archers", ":leftover"),
       (else_try),
         (val_add, ":num_cavalry", ":leftover"),
       (try_end),
     (try_end),

     (store_mul, ":rand_min", ":num_infantry", 15),
     (val_div, ":rand_min", 100),
     (store_mul, ":rand_max", ":num_infantry", 45),
     (val_div, ":rand_max", 100),
     (store_random_in_range, ":num_tier_2_infantry", ":rand_min", ":rand_max"),
     (store_sub, ":num_tier_1_infantry", ":num_infantry", ":num_tier_2_infantry"),
     (store_mul, ":rand_min", ":num_archers", 15),
     (val_div, ":rand_min", 100),
     (store_mul, ":rand_max", ":num_archers", 45),
     (val_div, ":rand_max", 100),
     (store_random_in_range, ":num_tier_2_archers", ":rand_min", ":rand_max"),
     (store_sub, ":num_tier_1_archers", ":num_archers", ":num_tier_2_archers"),
     (store_mul, ":rand_min", ":num_cavalry", 15),
     (val_div, ":rand_min", 100),
     (store_mul, ":rand_max", ":num_cavalry", 45),
     (val_div, ":rand_max", 100),
     (store_random_in_range, ":num_tier_2_cavalry", ":rand_min", ":rand_max"),
     (store_sub, ":num_tier_1_cavalry", ":num_cavalry", ":num_tier_2_cavalry"),

     (faction_get_slot, ":cur_troop", ":faction_no", slot_faction_quick_battle_tier_2_infantry),
     (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_2_infantry"),
     (val_add, ":cur_entry_point", 1),
     (faction_get_slot, ":cur_troop", ":faction_no", slot_faction_quick_battle_tier_1_infantry),
     (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_1_infantry"),
     (val_add, ":cur_entry_point", 1),
     (faction_get_slot, ":cur_troop", ":faction_no", slot_faction_quick_battle_tier_2_cavalry),
     (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_2_cavalry"),
     (val_add, ":cur_entry_point", 1),
     (faction_get_slot, ":cur_troop", ":faction_no", slot_faction_quick_battle_tier_1_cavalry),
     (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_1_cavalry"),
     (val_add, ":cur_entry_point", 1),

     (try_begin),
       (eq, ":divide_archer_entry_points", 0),
       (faction_get_slot, ":cur_troop", ":faction_no", slot_faction_quick_battle_tier_2_archer),
       (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_2_archers"),
       (val_add, ":cur_entry_point", 1),
       (faction_get_slot, ":cur_troop", ":faction_no", slot_faction_quick_battle_tier_1_archer),
       (set_visitors, ":cur_entry_point", ":cur_troop", ":num_tier_1_archers"),
       (val_add, ":cur_entry_point", 1),
     (else_try),
       (assign, ":cur_entry_point", 40), #archer positions begin point
       (store_div, ":num_tier_1_archers_ceil_8", ":num_tier_1_archers", 8),
       (val_mul, ":num_tier_1_archers_ceil_8", 8),
       (try_begin),
         (neq, ":num_tier_1_archers_ceil_8", ":num_tier_1_archers"),
         (val_div, ":num_tier_1_archers_ceil_8", 8),
         (val_add, ":num_tier_1_archers_ceil_8", 1),
         (val_mul, ":num_tier_1_archers_ceil_8", 8),
       (try_end),
       (store_div, ":num_tier_2_archers_ceil_8", ":num_tier_2_archers", 8),
       (val_mul, ":num_tier_2_archers_ceil_8", 8),
       (try_begin),
         (neq, ":num_tier_2_archers_ceil_8", ":num_tier_2_archers"),
         (val_div, ":num_tier_2_archers_ceil_8", 8),
         (val_add, ":num_tier_2_archers_ceil_8", 1),
         (val_mul, ":num_tier_2_archers_ceil_8", 8),
       (try_end),
       (store_add, ":num_archers_ceil_8", ":num_tier_1_archers_ceil_8", ":num_tier_2_archers_ceil_8"),
       (store_div, ":num_archers_per_entry_point", ":num_archers_ceil_8", 8),
       (assign, ":left_tier_1_archers", ":num_tier_1_archers"),
       (assign, ":left_tier_2_archers", ":num_tier_2_archers"),
       (assign, ":end_cond", 1000),
       (try_for_range, ":unused", 0, ":end_cond"),
         (try_begin),
           (gt, ":left_tier_2_archers", 0),
           (assign, ":used_tier_2_archers", ":num_archers_per_entry_point"),
           (val_min, ":used_tier_2_archers", ":left_tier_2_archers"),
           (faction_get_slot, ":cur_troop", ":faction_no", slot_faction_quick_battle_tier_2_archer),
           (set_visitors, ":cur_entry_point", ":cur_troop", ":used_tier_2_archers"),
           (val_add, ":cur_entry_point", 1),
           (val_sub, ":left_tier_2_archers", ":used_tier_2_archers"),
         (else_try),
           (gt, ":left_tier_1_archers", 0),
           (assign, ":used_tier_1_archers", ":num_archers_per_entry_point"),
           (val_min, ":used_tier_1_archers", ":left_tier_1_archers"),
           (faction_get_slot, ":cur_troop", ":faction_no", slot_faction_quick_battle_tier_1_archer),
           (set_visitors, ":cur_entry_point", ":cur_troop", ":used_tier_1_archers"),
           (val_add, ":cur_entry_point", 1),
           (val_sub, ":left_tier_1_archers", ":used_tier_1_archers"),
         (else_try),
           (assign, ":end_cond", 0),
         (try_end),
       (try_end),
     (try_end),
     ]),

  ("player_arrived",
   [
      # (assign, ":player_faction_culture", "fac_culture_1"),
      #SB : align start faction culture
      (party_relocate_near_party, "p_main_party", "$g_starting_town", 2),
      (party_get_slot, ":player_faction_culture", "$g_starting_town", slot_center_culture),
      (faction_set_slot, "fac_player_supporters_faction",  slot_faction_culture, ":player_faction_culture"),
      (faction_set_slot, "fac_player_faction",  slot_faction_culture, ":player_faction_culture"),
      (party_set_morale, "p_main_party", 100),
    ]),


  #script_game_set_multiplayer_mission_end
  # This script is called from the game engine when a multiplayer map is ended in clients (not in server).
  # INPUT:
  # none
  # OUTPUT:
  # none
  ("game_set_multiplayer_mission_end",
    [
      (assign, "$g_multiplayer_mission_end_screen", 1),
  ]),
  #script_game_enable_cheat_menu
  # This script is called from the game engine when user enters "cheatmenu from command console (ctrl+~).
  # INPUT:
  # none
  # OUTPUT:
  # none
  ("game_enable_cheat_menu",
    [
      (store_script_param, ":input", 1),
      (try_begin),
        (eq, ":input", 0),
        (assign, "$cheat_mode", 0),
      (else_try),
        (eq, ":input", 1),
        (assign, "$cheat_mode", 1),
        #SB : flavour text
        (call_script, "script_objectionable_action", tmt_honest, "str_stop_cheating"),
      (try_end),
      (try_begin),
        (neg|is_presentation_active, "prsnt_modify_slots"),
        # (assign, "$g_talk_troop", ":input"),
        (assign, "$g_presentation_state", 0),
        (assign, "$g_presentation_input", rename_companion),
        (start_presentation, "prsnt_modify_slots"),
      (try_end),
      ]),

  #script_game_get_console_command
  # This script is called from the game engine when a console command is entered from the dedicated server.
  # INPUT: anything
  # OUTPUT: s0 = result text
  ("game_get_console_command",
   [
     (store_script_param, ":input", 1),
     (store_script_param, ":val1", 2),
     (try_begin),
       #getting val2 for some commands
       (eq, ":input", 2),
       (store_script_param, ":val2", 3),
     (end_try),
     (try_begin),
       (eq, ":input", 1),
       (assign, reg0, ":val1"),
       (try_begin),
         (eq, ":val1", 1),
         (assign, reg1, "$g_multiplayer_num_bots_team_1"),
         (str_store_string, s0, "str_team_reg0_bot_count_is_reg1"),
       (else_try),
         (eq, ":val1", 2),
         (assign, reg1, "$g_multiplayer_num_bots_team_2"),
         (str_store_string, s0, "str_team_reg0_bot_count_is_reg1"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 2),
       (assign, reg0, ":val1"),
       (assign, reg1, ":val2"),
       (try_begin),
         (eq, ":val1", 1),
         (ge, ":val2", 0),
         (assign, "$g_multiplayer_num_bots_team_1", ":val2"),
         (str_store_string, s0, "str_team_reg0_bot_count_is_reg1"),
       (else_try),
         (eq, ":val1", 2),
         (ge, ":val2", 0),
         (assign, "$g_multiplayer_num_bots_team_2", ":val2"),
         (str_store_string, s0, "str_team_reg0_bot_count_is_reg1"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 3),
       (assign, reg0, "$g_multiplayer_round_max_seconds"),
       (str_store_string, s0, "str_maximum_seconds_for_round_is_reg0"),
     (else_try),
       (eq, ":input", 4),
       (assign, reg0, ":val1"),
       (try_begin),
         (is_between, ":val1", multiplayer_round_max_seconds_min, multiplayer_round_max_seconds_max),
         (assign, "$g_multiplayer_round_max_seconds", ":val1"),
         (str_store_string, s0, "str_maximum_seconds_for_round_is_reg0"),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_round_max_seconds, ":val1"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 5),
       (assign, reg0, "$g_multiplayer_respawn_period"),
       (str_store_string, s0, "str_respawn_period_is_reg0_seconds"),
     (else_try),
       (eq, ":input", 6),
       (assign, reg0, ":val1"),
       (try_begin),
         (is_between, ":val1", multiplayer_respawn_period_min, multiplayer_respawn_period_max),
         (assign, "$g_multiplayer_respawn_period", ":val1"),
         (str_store_string, s0, "str_respawn_period_is_reg0_seconds"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 7),
       (assign, reg0, "$g_multiplayer_num_bots_voteable"),
       (str_store_string, s0, "str_bots_upper_limit_for_votes_is_reg0"),
     (else_try),
       (eq, ":input", 8),
       (try_begin),
         (is_between, ":val1", 0, 51),
         (assign, "$g_multiplayer_num_bots_voteable", ":val1"),
         (store_add, "$g_multiplayer_max_num_bots", ":val1", 1),
         (assign, reg0, "$g_multiplayer_num_bots_voteable"),
         (str_store_string, s0, "str_bots_upper_limit_for_votes_is_reg0"),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_num_bots_voteable, ":val1"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 9),
       (try_begin),
         (eq, "$g_multiplayer_maps_voteable", 1),
         (str_store_string, s0, "str_map_is_voteable"),
       (else_try),
         (str_store_string, s0, "str_map_is_not_voteable"),
       (try_end),
     (else_try),
       (eq, ":input", 10),
       (try_begin),
         (is_between, ":val1", 0, 2),
         (assign, "$g_multiplayer_maps_voteable", ":val1"),
         (try_begin),
           (eq, ":val1", 1),
           (str_store_string, s0, "str_map_is_voteable"),
         (else_try),
           (str_store_string, s0, "str_map_is_not_voteable"),
         (try_end),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_maps_voteable, ":val1"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 11),
       (try_begin),
         (eq, "$g_multiplayer_factions_voteable", 1),
         (str_store_string, s0, "str_factions_are_voteable"),
       (else_try),
         (str_store_string, s0, "str_factions_are_not_voteable"),
       (try_end),
     (else_try),
       (eq, ":input", 12),
       (try_begin),
         (is_between, ":val1", 0, 2),
         (assign, "$g_multiplayer_factions_voteable", ":val1"),
         (try_begin),
           (eq, ":val1", 1),
           (str_store_string, s0, "str_factions_are_voteable"),
         (else_try),
           (str_store_string, s0, "str_factions_are_not_voteable"),
         (try_end),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_factions_voteable, ":val1"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 13),
       (try_begin),
         (eq, "$g_multiplayer_player_respawn_as_bot", 1),
         (str_store_string, s0, "str_players_respawn_as_bot"),
       (else_try),
         (str_store_string, s0, "str_players_do_not_respawn_as_bot"),
       (try_end),
     (else_try),
       (eq, ":input", 14),
       (try_begin),
         (is_between, ":val1", 0, 2),
         (assign, "$g_multiplayer_player_respawn_as_bot", ":val1"),
         (try_begin),
           (eq, ":val1", 1),
           (str_store_string, s0, "str_players_respawn_as_bot"),
         (else_try),
           (str_store_string, s0, "str_players_do_not_respawn_as_bot"),
         (try_end),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_player_respawn_as_bot, ":val1"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 15),
       (try_begin),
         (eq, "$g_multiplayer_kick_voteable", 1),
         (str_store_string, s0, "str_kicking_a_player_is_voteable"),
       (else_try),
         (str_store_string, s0, "str_kicking_a_player_is_not_voteable"),
       (try_end),
     (else_try),
       (eq, ":input", 16),
       (try_begin),
         (is_between, ":val1", 0, 2),
         (assign, "$g_multiplayer_kick_voteable", ":val1"),
         (try_begin),
           (eq, ":val1", 1),
           (str_store_string, s0, "str_kicking_a_player_is_voteable"),
         (else_try),
           (str_store_string, s0, "str_kicking_a_player_is_not_voteable"),
         (try_end),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_kick_voteable, ":val1"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 17),
       (try_begin),
         (eq, "$g_multiplayer_ban_voteable", 1),
         (str_store_string, s0, "str_banning_a_player_is_voteable"),
       (else_try),
         (str_store_string, s0, "str_banning_a_player_is_not_voteable"),
       (try_end),
     (else_try),
       (eq, ":input", 18),
       (try_begin),
         (is_between, ":val1", 0, 2),
         (assign, "$g_multiplayer_ban_voteable", ":val1"),
         (try_begin),
           (eq, ":val1", 1),
           (str_store_string, s0, "str_banning_a_player_is_voteable"),
         (else_try),
           (str_store_string, s0, "str_banning_a_player_is_not_voteable"),
         (try_end),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_ban_voteable, ":val1"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 19),
       (assign, reg0, "$g_multiplayer_valid_vote_ratio"),
       (str_store_string, s0, "str_percentage_of_yes_votes_required_for_a_poll_to_get_accepted_is_reg0"),
     (else_try),
       (eq, ":input", 20),
       (try_begin),
         (is_between, ":val1", 50, 101),
         (assign, "$g_multiplayer_valid_vote_ratio", ":val1"),
         (assign, reg0, ":val1"),
         (str_store_string, s0, "str_percentage_of_yes_votes_required_for_a_poll_to_get_accepted_is_reg0"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 21),
       (assign, reg0, "$g_multiplayer_auto_team_balance_limit"),
       (str_store_string, s0, "str_auto_team_balance_threshold_is_reg0"),
     (else_try),
       (eq, ":input", 22),
       (try_begin),
         (is_between, ":val1", 2, 7),
         (assign, "$g_multiplayer_auto_team_balance_limit", ":val1"),
         (assign, reg0, "$g_multiplayer_auto_team_balance_limit"),
         (str_store_string, s0, "str_auto_team_balance_threshold_is_reg0"),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_auto_team_balance_limit, ":val1"),
         (try_end),
       (else_try),
         (ge, ":val1", 7),
         (assign, "$g_multiplayer_auto_team_balance_limit", 1000),
         (assign, reg0, "$g_multiplayer_auto_team_balance_limit"),
         (str_store_string, s0, "str_auto_team_balance_threshold_is_reg0"),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_auto_team_balance_limit, ":val1"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 23),
       (assign, reg0, "$g_multiplayer_initial_gold_multiplier"),
       (str_store_string, s0, "str_starting_gold_ratio_is_reg0"),
     (else_try),
       (eq, ":input", 24),
       (try_begin),
         (is_between, ":val1", 0, 1001),
         (assign, "$g_multiplayer_initial_gold_multiplier", ":val1"),
         (assign, reg0, "$g_multiplayer_initial_gold_multiplier"),
         (str_store_string, s0, "str_starting_gold_ratio_is_reg0"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 25),
       (assign, reg0, "$g_multiplayer_battle_earnings_multiplier"),
       (str_store_string, s0, "str_combat_gold_bonus_ratio_is_reg0"),
     (else_try),
       (eq, ":input", 26),
       (try_begin),
         (is_between, ":val1", 0, 1001),
         (assign, "$g_multiplayer_battle_earnings_multiplier", ":val1"),
         (assign, reg0, "$g_multiplayer_battle_earnings_multiplier"),
         (str_store_string, s0, "str_combat_gold_bonus_ratio_is_reg0"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 27),
       (assign, reg0, "$g_multiplayer_round_earnings_multiplier"),
       (str_store_string, s0, "str_round_gold_bonus_ratio_is_reg0"),
     (else_try),
       (eq, ":input", 28),
       (try_begin),
         (is_between, ":val1", 0, 1001),
         (assign, "$g_multiplayer_round_earnings_multiplier", ":val1"),
         (assign, reg0, "$g_multiplayer_round_earnings_multiplier"),
         (str_store_string, s0, "str_round_gold_bonus_ratio_is_reg0"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 29),
       (try_begin),
         (eq, "$g_multiplayer_allow_player_banners", 1),
         (str_store_string, s0, "str_player_banners_are_allowed"),
       (else_try),
         (str_store_string, s0, "str_player_banners_are_not_allowed"),
       (try_end),
     (else_try),
       (eq, ":input", 30),
       (try_begin),
         (is_between, ":val1", 0, 2),
         (assign, "$g_multiplayer_allow_player_banners", ":val1"),
         (try_begin),
           (eq, ":val1", 1),
           (str_store_string, s0, "str_player_banners_are_allowed"),
         (else_try),
           (str_store_string, s0, "str_player_banners_are_not_allowed"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 31),
       (try_begin),
         (eq, "$g_multiplayer_force_default_armor", 1),
         (str_store_string, s0, "str_default_armor_is_forced"),
       (else_try),
         (str_store_string, s0, "str_default_armor_is_not_forced"),
       (try_end),
     (else_try),
       (eq, ":input", 32),
       (try_begin),
         (is_between, ":val1", 0, 2),
         (assign, "$g_multiplayer_force_default_armor", ":val1"),
         (try_begin),
           (eq, ":val1", 1),
           (str_store_string, s0, "str_default_armor_is_forced"),
         (else_try),
           (str_store_string, s0, "str_default_armor_is_not_forced"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 33),
       (assign, reg0, "$g_multiplayer_point_gained_from_flags"),
       (str_store_string, s0, "str_point_gained_from_flags_is_reg0"),
     (else_try),
       (eq, ":input", 34),
       (try_begin),
         (is_between, ":val1", 25, 401),
         (assign, "$g_multiplayer_point_gained_from_flags", ":val1"),
         (assign, reg0, "$g_multiplayer_point_gained_from_flags"),
         (str_store_string, s0, "str_point_gained_from_flags_is_reg0"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 35),
       (assign, reg0, "$g_multiplayer_point_gained_from_capturing_flag"),
       (str_store_string, s0, "str_point_gained_from_capturing_flag_is_reg0"),
     (else_try),
       (eq, ":input", 36),
       (try_begin),
         (is_between, ":val1", 0, 11),
         (assign, "$g_multiplayer_point_gained_from_capturing_flag", ":val1"),
         (assign, reg0, "$g_multiplayer_point_gained_from_capturing_flag"),
         (str_store_string, s0, "str_point_gained_from_capturing_flag_is_reg0"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 37),
       (assign, reg0, "$g_multiplayer_game_max_minutes"),
       (str_store_string, s0, "str_map_time_limit_is_reg0"),
     (else_try),
       (eq, ":input", 38),
       (try_begin),
         (is_between, ":val1", 5, 121),
         (assign, "$g_multiplayer_game_max_minutes", ":val1"),
         (assign, reg0, "$g_multiplayer_game_max_minutes"),
         (str_store_string, s0, "str_map_time_limit_is_reg0"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 39),
       (assign, reg0, "$g_multiplayer_game_max_points"),
       (str_store_string, s0, "str_team_points_limit_is_reg0"),
     (else_try),
       (eq, ":input", 40),
       (try_begin),
         (is_between, ":val1", 3, 1001),
         (assign, "$g_multiplayer_game_max_points", ":val1"),
         (assign, reg0, "$g_multiplayer_game_max_points"),
         (str_store_string, s0, "str_team_points_limit_is_reg0"),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 41),
       (assign, reg0, "$g_multiplayer_number_of_respawn_count"),
       (try_begin),
         (eq, reg0, 0),
         (str_store_string, s1, "str_unlimited"),
       (else_try),
         (str_store_string, s1, "str_reg0"),
       (try_end),
       (str_store_string, s0, "str_defender_spawn_count_limit_is_s1"),
     (else_try),
       (eq, ":input", 42),
       (try_begin),
         (is_between, ":val1", 0, 6),
         (assign, "$g_multiplayer_number_of_respawn_count", ":val1"),
         (assign, reg0, "$g_multiplayer_number_of_respawn_count"),
         (try_begin),
           (eq, reg0, 0),
           (str_store_string, s1, "str_unlimited"),
         (else_try),
           (str_store_string, s1, "str_reg0"),
         (try_end),
         (str_store_string, s0, "str_defender_spawn_count_limit_is_s1"),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_respawn_count, ":val1"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (eq, ":input", 43),
       (try_begin),
         (eq, "$g_multiplayer_disallow_ranged_weapons", 1),
         (str_store_string, s0, "str_ranged_weapons_are_disallowed"),
       (else_try),
         (str_store_string, s0, "str_ranged_weapons_are_allowed"),
       (try_end),
     (else_try),
       (eq, ":input", 44),
       (try_begin),
         (is_between, ":val1", 0, 2),
         (assign, "$g_multiplayer_disallow_ranged_weapons", ":val1"),
         (try_begin),
           (eq, ":val1", 1),
           (str_store_string, s0, "str_ranged_weapons_are_disallowed"),
         (else_try),
           (str_store_string, s0, "str_ranged_weapons_are_allowed"),
         (try_end),
       (else_try),
         (str_store_string, s0, "str_input_is_not_correct_for_the_command_type_help_for_more_information"),
       (try_end),
     (else_try),
       (str_store_string, s0, "@{!}DEBUG : SYSTEM ERROR!"),
     (try_end),
  ]),


  # script_game_event_party_encounter:
  # This script is called from the game engine whenever player party encounters another party or a battle on the world map
  # INPUT:
  # param1: encountered_party
  # param2: second encountered_party (if this was a battle
  ("game_event_party_encounter",
   [
       (store_script_param_1, "$g_encountered_party"),
       (store_script_param_2, "$g_encountered_party_2"),# encountered_party2 is set when we come across a battle or siege, otherwise it's a negative value
#       (store_encountered_party, "$g_encountered_party"),
#       (store_encountered_party2,"$g_encountered_party_2"), # encountered_party2 is set when we come across a battle or siege, otherwise it's a minus value
       (store_faction_of_party, "$g_encountered_party_faction","$g_encountered_party"),
       (store_relation, "$g_encountered_party_relation", "$g_encountered_party_faction", "fac_player_faction"),

       (party_get_slot, "$g_encountered_party_type", "$g_encountered_party", slot_party_type),
       (party_get_template_id,"$g_encountered_party_template","$g_encountered_party"),
#       (try_begin),
#         (gt, "$g_encountered_party_2", 0),
#         (store_faction_of_party, "$g_encountered_party_2_faction","$g_encountered_party_2"),
#         (store_relation, "$g_encountered_party_2_relation", "$g_encountered_party_2_faction", "fac_player_faction"),
#         (party_get_template_id,"$g_encountered_party_2_template","$g_encountered_party_2"),
#       (else_try),
#         (assign, "$g_encountered_party_2_faction",-1),
#         (assign, "$g_encountered_party_2_relation", 0),
#         (assign,"$g_encountered_party_2_template", -1),
#       (try_end),


#NPC companion changes begin
       (call_script, "script_party_count_fit_regulars", "p_main_party"),
       (assign, "$playerparty_prebattle_regulars", reg0),

#        (try_begin),
#            (assign, "$player_party__regulars", 0),
#            (call_script, "script_party_count_fit_regulars", "p_main_party"),
#            (gt, reg0, 0),
#            (assign, "$player_party_contains_regulars", 1),
#        (try_end),
#NPC companion changes end


        (assign, "$g_last_rest_center", -1),
        (assign, "$talk_context", 0),
        (assign, "$g_player_surrenders",0),
        (assign, "$g_enemy_surrenders",0),
        (assign, "$g_leave_encounter",0),
        (assign, "$g_engaged_enemy", 0),
#       (assign,"$waiting_for_arena_fight_result", 0),
#       (assign,"$arena_bet_amount",0),
#       (assign,"$g_player_raiding_village",0),
        (try_begin),
          (neg|is_between, "$g_encountered_party", centers_begin, centers_end),
          (rest_for_hours, 0), #stop waiting
          (assign, "$g_infinite_camping", 0),
        (try_end),
        #       (assign, "$g_permitted_to_center",0),
        #SB : do cheat here before other menus are accessed
      (try_begin),
        (eq, "$new_encounter", 2),
        (jump_to_menu, "mnu_party_cheat"),
      (else_try),
        (assign, "$new_encounter", 1), #check this in the menu.
        (try_begin),
         (lt, "$g_encountered_party_2",0), #Normal encounter. Not battle or siege.
         (try_begin),
           (party_slot_eq, "$g_encountered_party", slot_party_type, spt_town),
           (jump_to_menu, "mnu_castle_outside"),
         (else_try),
           (party_slot_eq, "$g_encountered_party", slot_party_type, spt_castle),
           (jump_to_menu, "mnu_castle_outside"),
         (else_try),
           (party_slot_eq, "$g_encountered_party", slot_party_type, spt_ship),
           (jump_to_menu, "mnu_ship_reembark"),
         (else_try),
           (party_slot_eq, "$g_encountered_party", slot_party_type, spt_village),
           (jump_to_menu, "mnu_village"),
         (else_try),
           (party_slot_eq, "$g_encountered_party", slot_party_type, spt_cattle_herd),
           (jump_to_menu, "mnu_cattle_herd"),
         (else_try),
           (is_between, "$g_encountered_party", training_grounds_begin, training_grounds_end),
           (jump_to_menu, "mnu_training_ground"),
         (else_try),
           (party_get_template_id, ":template", "$g_encountered_party"), #SB : is_between range
           (is_between, ":template", "pt_steppe_bandit_lair", "pt_bandit_lair_templates_end"),
           (assign, "$loot_screen_shown", 0),
           (jump_to_menu, "mnu_bandit_lair"),
         (else_try),
           (is_between, "$g_encountered_party", "p_port_1", "p_ports_end"),
           (party_get_slot, ":port_town", "$g_encountered_party", slot_port_town),
           (party_get_position, pos0, ":port_town"),
           (assign, "$g_player_icon_state", pis_normal),
           (party_set_flags, "p_main_party", pf_is_ship, 0),
           (assign, "$g_main_ship_party", -1),
           (party_set_slot, "p_main_party", slot_party_ship_type, 0),
           (party_set_position, "p_main_party", pos0),
           (jump_to_menu, "mnu_auto_return"),
         (else_try),
           (eq, "$g_encountered_party", "p_zendar"),
           (jump_to_menu, "mnu_zendar"),
         (else_try),
           (eq, "$g_encountered_party", "p_salt_mine"),
           (jump_to_menu, "mnu_salt_mine"),
         (else_try),
           (eq, "$g_encountered_party", "p_four_ways_inn"),
           (jump_to_menu, "mnu_four_ways_inn"),
         (else_try),
           (eq, "$g_encountered_party", "p_test_scene"),
           (jump_to_menu, "mnu_test_scene"),
         (else_try),
           (eq, "$g_encountered_party", "p_battlefields"),
           (jump_to_menu, "mnu_battlefields"),
         (else_try),
           (eq, "$g_encountered_party", "p_training_ground"),
           (jump_to_menu, "mnu_tutorial"),
         (else_try),
           (eq, "$g_encountered_party", "p_camp_bandits"),
           (jump_to_menu, "mnu_camp"),
         (else_try),
           (jump_to_menu, "mnu_simple_encounter"),
         (try_end),
        (else_try), #Battle or siege
          (try_begin),
            (this_or_next|party_slot_eq, "$g_encountered_party", slot_party_type, spt_town),
            (party_slot_eq, "$g_encountered_party", slot_party_type, spt_castle),
            (try_begin),
              (eq, "$auto_enter_town", "$g_encountered_party"),
              (jump_to_menu, "mnu_town"),
            (else_try),
              (eq, "$auto_besiege_town", "$g_encountered_party"),
              (jump_to_menu, "mnu_besiegers_camp_with_allies"),
            (else_try),
              (jump_to_menu, "mnu_join_siege_outside"),
            (try_end),
          (else_try),
            (jump_to_menu, "mnu_pre_join"),
          (try_end),
        (try_end),
      (try_end),
       (assign,"$auto_enter_town",0),
       (assign,"$auto_besiege_town",0),
      ]),

  #script_game_event_simulate_battle:
  # This script is called whenever the game simulates the battle between two parties on the map.
  # INPUT:
  # param1: Defender Party
  # param2: Attacker Party
  ("game_event_simulate_battle",
    [
      (store_script_param_1, ":root_defender_party"),
      (store_script_param_2, ":root_attacker_party"),

      (assign, "$marshall_defeated_in_battle", -1),

      (store_current_hours, ":hours"),

      ##diplomacy start+ Get campaign AI, used below
      (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
      ##diplomacy end+

      (try_for_parties, ":party"),
        (party_get_battle_opponent, ":opponent", ":party"),
        (gt, ":opponent", 0),
        (party_set_slot, ":party", slot_party_last_in_combat, ":hours"),
      (try_end),

      (assign, ":trigger_result", 1),
      (try_begin),
        (ge, ":root_defender_party", 0),
        (ge, ":root_attacker_party", 0),
        (party_is_active, ":root_defender_party"),
        (party_is_active, ":root_attacker_party"),
        (store_faction_of_party, ":defender_faction", ":root_defender_party"),
        (store_faction_of_party, ":attacker_faction", ":root_attacker_party"),
        #(neq, ":defender_faction", "fac_player_faction"),
        #(neq, ":attacker_faction", "fac_player_faction"),
        (store_relation, ":reln", ":defender_faction", ":attacker_faction"),
        (lt, ":reln", 0),
        (assign, ":trigger_result", 0),

        (try_begin),
          (this_or_next|eq, "$g_battle_simulation_cancel_for_party", ":root_defender_party"),
          (eq, "$g_battle_simulation_cancel_for_party", ":root_attacker_party"),
          (assign, "$g_battle_simulation_cancel_for_party", -1),
          (assign, "$auto_enter_town", "$g_battle_simulation_auto_enter_town_after_battle"),
          (assign, ":trigger_result", 1),
        (else_try),
          (try_begin),
            (this_or_next|party_slot_eq, ":root_defender_party", slot_party_retreat_flag, 1),
            (party_slot_eq, ":root_attacker_party", slot_party_retreat_flag, 1),
            (assign, ":trigger_result", 1), #End battle!
          (try_end),
          (party_set_slot, ":root_attacker_party", slot_party_retreat_flag, 0),

          #(assign, ":cancel_attack", 0),

          (party_collect_attachments_to_party, ":root_defender_party", "p_collective_ally"),
          (party_collect_attachments_to_party, ":root_attacker_party", "p_collective_enemy"),

	      ##diplomacy start+
 		  (assign, ":terrain_code", dplmc_terrain_code_none),#defined in header_terrain.py
          (try_begin),
              (eq, "$g_dplmc_terrain_advantage", DPLMC_TERRAIN_ADVANTAGE_ENABLE),
			  (call_script, "script_dplmc_get_terrain_code_for_battle", ":root_attacker_party", ":root_defender_party"),
			  (assign, ":terrain_code", reg0),
			  #
              (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_ally", ":terrain_code", 0, 1),
              (assign, ":defender_strength", reg0),
              (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_enemy", ":terrain_code", 0, 1),
              (assign, ":attacker_strength", reg0),
          (else_try),
              (call_script, "script_party_calculate_strength", "p_collective_ally", 0),
              (assign, ":defender_strength", reg0),
          #(call_script, "script_party_count_fit_for_battle", "p_collective_enemy"),
              (call_script, "script_party_calculate_strength", "p_collective_enemy", 0),
              (assign, ":attacker_strength", reg0),
          (try_end),
          ##diplomacy end+

          (store_div, ":defender_strength", ":defender_strength", 20),
          (val_min, ":defender_strength", 50),
          (val_max, ":defender_strength", 1),
          (store_div, ":attacker_strength", ":attacker_strength", 20),
          (val_min, ":attacker_strength", 50),
          (val_add, ":attacker_strength", 1),
          (try_begin),
            #For sieges increase attacker casualties and reduce defender casualties.
            (this_or_next|party_slot_eq, ":root_defender_party", slot_party_type, spt_castle),
            (party_slot_eq, ":root_defender_party", slot_party_type, spt_town),
            (val_mul, ":defender_strength", 123), #it was 1.5 in old version, now it is only 1.23
            (val_div, ":defender_strength", 100),

            (val_mul, ":attacker_strength", 100), #it was 0.5 in old version, now it is only 1 / 1.23
            (val_div, ":attacker_strength", 123),
          (try_end),

          ##diplomacy begin
          (assign, ":defender_percent", 100),
          (try_begin),
            (faction_get_slot, ":serfdom", ":defender_faction", dplmc_slot_faction_serfdom),
            (neq, ":serfdom", 0),
            (val_mul, ":serfdom", -2),
            (val_add, ":defender_percent", ":serfdom"),
          (try_end),
          (try_begin),
            (faction_get_slot, ":quality", ":defender_faction", dplmc_slot_faction_quality),
            (neq, ":quality", 0),
            (val_mul, ":quality", 4),
            (val_add, ":defender_percent", ":quality"),
          (try_end),
          (val_mul, ":defender_strength", ":defender_percent"),
          (val_div, ":defender_strength", 100),

          (assign, ":attacker_percent", 100),
          (try_begin),
            (faction_get_slot, ":serfdom", ":attacker_faction", dplmc_slot_faction_serfdom),
            (neq, ":serfdom", 0),
            (val_mul, ":serfdom", -2),
            (val_add, ":attacker_percent", ":serfdom"),
          (try_end),
          (try_begin),
            (faction_get_slot, ":quality", ":attacker_faction", dplmc_slot_faction_quality),
            (neq, ":quality", 0),
            (val_mul, ":quality", 4),
            (val_add, ":attacker_percent", ":quality"),
          (try_end),
          (val_mul, ":attacker_strength", ":attacker_percent"),
          (val_div, ":attacker_strength", 100),
          ##diplomacy end

          (call_script, "script_party_count_fit_for_battle", "p_collective_ally", 0),
          (assign, ":old_defender_strength", reg0),

          (try_begin),
            (neg|is_currently_night), #Don't fight at night
            (inflict_casualties_to_party_group, ":root_attacker_party", ":defender_strength", "p_temp_casualties"),
            (party_collect_attachments_to_party, ":root_attacker_party", "p_collective_enemy"),
          (try_end),
          (call_script, "script_party_count_fit_for_battle", "p_collective_enemy", 0),
          (assign, ":new_attacker_strength", reg0),

          (try_begin),
            (gt, ":new_attacker_strength", 0),
            (neg|is_currently_night), #Don't fight at night
            (inflict_casualties_to_party_group, ":root_defender_party", ":attacker_strength", "p_temp_casualties"),
            (party_collect_attachments_to_party, ":root_defender_party", "p_collective_ally"),
          (try_end),
          (call_script, "script_party_count_fit_for_battle", "p_collective_ally", 0),
          (assign, ":new_defender_strength", reg0),

          (try_begin),
            (this_or_next|eq, ":new_attacker_strength", 0),
            (eq, ":new_defender_strength", 0),
            # Battle concluded! determine winner

            (assign, ":do_not_end_battle", 0),
            (try_begin),
              (neg|troop_is_wounded, "trp_player"),
              (eq, ":new_defender_strength", 0),
              (eq, "$auto_enter_town", "$g_encountered_party"),
              (eq, ":old_defender_strength", ":new_defender_strength"),
              (assign, ":do_not_end_battle", 1),
            (try_end),
            (eq, ":do_not_end_battle", 0),

            (try_begin),
              (eq, ":new_attacker_strength", 0),
              (eq, ":new_defender_strength", 0),
              (assign, ":root_winner_party", -1),
              (assign, ":root_defeated_party", -1),
              (assign, ":collective_casualties", -1),
            (else_try),
              (eq, ":new_attacker_strength", 0),
              (assign, ":root_winner_party", ":root_defender_party"),
              (assign, ":root_defeated_party", ":root_attacker_party"),
              (assign, ":collective_casualties", "p_collective_enemy"),
            (else_try),
              (assign, ":root_winner_party", ":root_attacker_party"),
              (assign, ":root_defeated_party", ":root_defender_party"),
              (assign, ":collective_casualties", "p_collective_ally"),
            (try_end),
##diplomacy begin
        (try_begin),
          (gt, ":root_defeated_party", -1),
# Recruiter kit begin
 # This little fella just shows a message when a recruiter is defeated.

         (assign, ":minimum_distance", 1000000),
         (try_for_range, ":center", centers_begin, centers_end),
           (store_distance_to_party_from_party, ":dist", ":root_defeated_party", ":center"),
           (try_begin),
             (lt, ":dist", ":minimum_distance"),
             (assign, ":minimum_distance", ":dist"),
             (assign, ":nearest_center", ":center"),
           (try_end),
         (try_end),

        (str_clear, s10),
        (try_begin),
          (gt, ":nearest_center", 0),
          (str_store_party_name, s10, ":nearest_center"),
          (str_store_string, s10, "@ near {s10}"),
        (try_end),

        #SB : reformat loop
        (party_get_slot, ":type", ":root_defeated_party", slot_party_type),
        (try_begin),
          (eq, ":type", dplmc_spt_recruiter),
          (party_get_slot, reg10, ":root_defeated_party", dplmc_slot_party_recruiter_needed_recruits),
          (party_get_slot, ":party_origin", ":root_defeated_party", dplmc_slot_party_recruiter_origin),
          (str_store_party_name_link, s13, ":party_origin"),
          (display_log_message, "@Your recruiter who was commissioned to recruit {reg10} recruits to {s13} has been defeated{s10}!", message_defeated),
        (else_try),
          (eq,":type", dplmc_spt_gift_caravan),
          (party_get_slot, ":target_troop", ":root_defeated_party", slot_party_orders_object),
          (party_get_slot, ":target_party", ":root_defeated_party", slot_party_ai_object),
          (try_begin),
            (gt, ":target_troop", 0),
            (str_store_troop_name, s13, ":target_troop"),
          (else_try),
            (str_store_party_name, s13, ":target_party"),
          (end_try),
          (party_get_slot, ":gift", ":root_defeated_party", dplmc_slot_party_mission_diplomacy),
          (str_store_item_name, s12, ":gift"),
          #SB : defeated -> looted
          (display_log_message, "@Your caravan sending {s12} to {s13} has been looted{s10}!", message_defeated),
        (else_try),
          (eq, ":type", spt_messenger),
          (party_get_slot, ":target_party", ":root_defeated_party", slot_party_orders_object),
          (party_stack_get_troop_id, ":party_leader", ":target_party", 0),
          (str_store_troop_name, s13, ":party_leader"),
          #SB : defeated -> intercepted
          (display_log_message, "@Your messenger on the way to {s13} has been ambushed{s10}!", message_defeated),
        (else_try),
          (eq, ":type", spt_patrol),
          (party_slot_eq, ":root_defeated_party", dplmc_slot_party_mission_diplomacy, "trp_player"),
          (party_get_slot, ":target_party", ":root_defeated_party", slot_party_ai_object),
          (str_store_party_name, s13, ":target_party"),
          (display_log_message, "@Your soldiers patrolling {s13} have been defeated{s10}!", message_defeated),
        (else_try),
          (eq, ":type", spt_scout),
          (store_faction_of_party, ":party_faction", ":root_defeated_party"),
          (eq, ":party_faction", "$players_kingdom"),
          (party_get_slot, ":target_party", ":root_defeated_party", slot_party_orders_object),
          (str_store_party_name, s13, ":target_party"),
          (display_log_message, "@A scout trying to gather information about {s13} has been slain{s10}!", message_defeated),
        (else_try), #SB : reinforcements
          (eq, ":type", spt_reinforcement),
          (store_faction_of_party, ":party_faction", ":root_defeated_party"),
          (eq, ":party_faction", "$players_kingdom"), #show only if relevant
          (party_get_slot, ":home_village", ":root_defeated_party", slot_party_home_center),
          (party_get_slot, ":target_party", ":home_village", slot_village_bound_center),
          (str_store_party_name_link, s12, ":home_village"),
          (str_store_party_name_link, s13, ":target_party"),
          (display_log_message, "@Reinforcements from {s12} intended for {s13} have been intercepted{s10}!", message_defeated),
        (try_end),
      (try_end),
##diplomacy end

            (try_begin),
              (ge, ":root_winner_party", 0),
              (call_script, "script_get_nonempty_party_in_group", ":root_winner_party"),
              (assign, ":nonempty_winner_party", reg0),
              (store_faction_of_party, ":faction_receiving_prisoners", ":nonempty_winner_party"),
              (store_faction_of_party, ":defeated_faction", ":root_defeated_party"),
            (else_try),
              (assign, ":nonempty_winner_party", -1),
            (try_end),

            (try_begin),
              (ge, ":collective_casualties", 0),
              (party_get_num_companion_stacks, ":num_stacks", ":collective_casualties"),
            (else_try),
              (assign, ":num_stacks", 0),
            (try_end),

            #SB : set up primary color here
            (faction_get_color, ":faction_color", ":faction_receiving_prisoners"),
            #depending on war status we can enforce either message_positive or message_negative
            (try_for_range, ":troop_iterator", 0, ":num_stacks"),
              (party_stack_get_troop_id, ":cur_troop_id", ":collective_casualties", ":troop_iterator"),
              (troop_is_hero, ":cur_troop_id"),

              (try_begin),
                #abort quest if troop loses a battle during rest time
                (check_quest_active, "qst_lend_surgeon"),
                (quest_slot_eq, "qst_lend_surgeon", slot_quest_giver_troop, ":cur_troop_id"),
                (call_script, "script_abort_quest", "qst_lend_surgeon", 0),
              (try_end),

              (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),

              (troop_set_slot, ":cur_troop_id", slot_troop_leaded_party, -1),

              (store_random_in_range, ":rand", 0, 100),
              (str_store_troop_name_link, s1, ":cur_troop_id"),
              (str_store_faction_name_link, s2, ":faction_receiving_prisoners"),
              (store_troop_faction, ":defeated_troop_faction", ":cur_troop_id"),
              (str_store_faction_name_link, s3, ":defeated_troop_faction"),
              #SB : colorize
              (faction_get_color, ":color", ":defeated_troop_faction"),
              (try_begin),
                (ge, ":rand", hero_escape_after_defeat_chance),

                #dckplmc
                (party_get_template_id, ":party_template", ":root_defeated_party"),
                (try_begin),
                    (eq, ":party_template", "pt_hero_party"),
                    (is_between, ":cur_troop_id", companions_begin, companions_end),
                    (troop_set_slot, ":cur_troop_id", slot_troop_playerparty_history, pp_history_scattered),
                    (troop_set_slot, ":cur_troop_id", slot_troop_turned_down_twice, 0),
                    (troop_set_slot, ":cur_troop_id", slot_troop_occupation, 0),
                    # (assign, ":continue", 1),
                    # (assign, ":minimum_distance", 99999),
                    # (assign, ":prison_center", -1),
                     # (try_for_range, ":center", walled_centers_begin, walled_centers_end),
                        # (store_distance_to_party_from_party, ":dist", ":center", ":root_defeated_party"),
                        # (lt, ":dist", ":minimum_distance"),
                        # (assign, ":minimum_distance", ":dist"),
                        # (assign, ":prison_center", ":center"),
                     # (try_end),
                      # (assign, reg1, ":prison_center"),
                      # #(display_message, "@{!}DEBUG : prison center is {reg1}"),
                      # (try_begin),
                        # (ge, ":prison_center", 0),
                        # (party_add_prisoners, ":prison_center", ":cur_troop_id", 1),
                        # (troop_set_slot, ":cur_troop_id", slot_troop_prisoner_of_party, ":prison_center"),
                      # (else_try),
                        # (store_random_in_range, ":town_no", towns_begin, towns_end),
                        # (troop_set_slot, ":cur_troop_id", slot_troop_cur_center, ":town_no"),
                      # (try_end),
                (try_end),
                #(neq, ":party_template", "pt_hero_party"), #end




                (party_stack_get_troop_id, ":leader_troop_id", ":nonempty_winner_party", 0),
                ##diplomacy start+ kingdom ladies might lead kingdom parties
                (this_or_next|is_between,":leader_troop_id", kingdom_ladies_begin, kingdom_ladies_end),
                   (is_between, ":leader_troop_id", active_npcs_begin, active_npcs_end),

                (this_or_next|troop_slot_eq, ":leader_troop_id", slot_troop_occupation, slto_kingdom_hero),
                ##diplomacy end+
                (is_between, ":leader_troop_id", active_npcs_begin, active_npcs_end), #disable non-kingdom parties capturing enemy lords
                (party_add_prisoners, ":nonempty_winner_party", ":cur_troop_id", 1),
                (gt, reg0, 0),
                #(troop_set_slot, ":cur_troop_id", slot_troop_is_prisoner, 1),
                (troop_set_slot, ":cur_troop_id", slot_troop_prisoner_of_party, ":nonempty_winner_party"),

                (display_log_message, "str_hero_taken_prisoner", ":color"),

                (try_begin),
                  (call_script, "script_cf_prisoner_offered_parole", ":cur_troop_id"),

                  (try_begin),
                    (eq, "$cheat_mode", 1),
                    (display_message, "@{!}DEBUG : Prisoner granted parole"),
                  (try_end),

                  (call_script, "script_troop_change_relation_with_troop", ":leader_troop_id", ":cur_troop_id", 3),
				  (val_add, "$total_battle_enemy_changes", 3),
                (else_try),
                  (try_begin),
                    (eq, "$cheat_mode", 1),
                    (display_message, "@{!}DEBUG : Prisoner not offered parole"),
		          (try_end),

		          (call_script, "script_troop_change_relation_with_troop", ":leader_troop_id", ":cur_troop_id", -5),
				  (val_add, "$total_battle_enemy_changes", -5),
		        (try_end),

				(store_faction_of_party, ":capturer_faction", ":nonempty_winner_party"),
                (call_script, "script_update_troop_location_notes_prisoned", ":cur_troop_id", ":capturer_faction"),
              (else_try),

                #dckplmc
                (try_begin),
                    (party_get_template_id, ":party_template", ":root_defeated_party"),
                    (eq, ":party_template", "pt_hero_party"),
                    (is_between, ":cur_troop_id", companions_begin, companions_end),
                    (store_random_in_range, ":town_no", towns_begin, towns_end),
                    (troop_set_slot, ":cur_troop_id", slot_troop_cur_center, ":town_no"),
                    (troop_set_slot, ":cur_troop_id", slot_troop_playerparty_history, pp_history_scattered),
                    (troop_set_slot, ":cur_troop_id", slot_troop_turned_down_twice, 0),
                    (troop_set_slot, ":cur_troop_id", slot_troop_occupation, 0),
                (try_end),

                (display_message,"@{s1} of {s3} was defeated in battle but managed to escape.", ":color"),
              (try_end),

              (try_begin),
                (store_troop_faction, ":cur_troop_faction", ":cur_troop_id"),
                (is_between, ":cur_troop_faction", kingdoms_begin, kingdoms_end),
                (faction_slot_eq, ":cur_troop_faction", slot_faction_marshall, ":cur_troop_id"),
                (is_between, ":cur_troop_faction", kingdoms_begin, kingdoms_end),
                (assign, "$marshall_defeated_in_battle", ":cur_troop_id"),
                #Marshall is defeated, refresh ai.
                (assign, "$g_recalculate_ais", 1),
              (try_end),

              ##diplomacy begin
              (try_begin),
                (call_script, "script_dplmc_is_affiliated_family_member", ":cur_troop_id"),
                (eq, reg0, 1),
                ##diplomacy start+ skip relationship decay for defeat when the player himself is imprisoned or wounded
					 (eq, "$g_player_is_captive", 0),
                (neg|troop_slot_ge, "trp_player", slot_troop_prisoner_of_party, 1),
                (neg|troop_is_wounded, "trp_player"),
                ##diplomacy end+
					 (assign, ":mitigating_factors", 0),
					 (try_begin),
					    #Being at war with the troop's faction is a mitigating factor, unless the player leads his faction.
						 (store_relation, reg0, "$players_kingdom", ":cur_troop_faction"),
						 (lt, reg0, 0),
						 (neq, "$players_kingdom", "fac_player_supporters_faction"),
						 (neg|faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
						 (assign, ":mitigating_factors", 1),
					 (try_end),

                (try_for_range, ":family_member", lords_begin, kingdom_ladies_end),
					   ##diplomacy start+
						#The dead, exiled, and retired don't participate in this
						(neg|troop_slot_ge, ":family_member", slot_troop_occupation, slto_retirement),
						#Members of factions at war with the defeated affiliate's faction don't have
						#any relation loss either: it would be nonsensical for them to be willing to
						#battle him themselves, but become enraged at his defeat.
						(store_troop_faction, ":family_member_faction", ":family_member"),
						(store_relation, reg0, ":family_member_faction", ":cur_troop_faction"),
						(this_or_next|eq, ":family_member_faction", ":cur_troop_faction"),
							(ge, reg0, 0),
                  ##(call_script, "script_troop_get_family_relation_to_troop", ":family_member", "$g_player_affiliated_troop"),
                  (call_script, "script_dplmc_is_affiliated_family_member", ":family_member"),
                  (gt, reg0, 0),
                  (assign, reg0, -2),
                  (try_begin),
                    (eq, ":reduce_campaign_ai", 0),#hard: -1
                    (assign, reg0, -1),
                  (else_try),
                    (eq, ":reduce_campaign_ai", 1),#medium: -1 or 0
                    (store_random_in_range, reg0, -1, 1),
                  (else_try),
                    (eq, ":reduce_campaign_ai", 2),#easy: 0
                    (assign, reg0, 0),
                  (try_end),
                  (val_add, reg0, ":mitigating_factors"),
                  (lt, reg0, 0),
                  (call_script, "script_change_player_relation_with_troop", ":family_member", reg0),
                  ##diplomacy end+
                (try_end),
              (try_end),
              ##diplomacy end
            (try_end),

             (try_begin),
               (ge, ":collective_casualties", 0),
               (party_get_num_prisoner_stacks, ":num_stacks", ":collective_casualties"),
             (else_try),
               (assign, ":num_stacks", 0),
             (try_end),
             (try_for_range, ":troop_iterator", 0, ":num_stacks"),
               (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":collective_casualties", ":troop_iterator"),
               (troop_is_hero, ":cur_troop_id"),
               (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),
               (store_troop_faction, ":cur_troop_faction", ":cur_troop_id"),
               (str_store_troop_name_link, s1, ":cur_troop_id"),
               (str_store_faction_name_link, s2, ":faction_receiving_prisoners"),
               (str_store_faction_name_link, s3, ":cur_troop_faction"),
               #SB : colorize, use previously set up primary color
               (display_log_message, "str_hero_freed", ":faction_color"),

                (try_begin), #dckplmc
                    (is_between, ":cur_troop_id", companions_begin, companions_end),
                    (neg|troop_slot_eq, ":cur_troop_id", slot_troop_playerparty_history, dplmc_pp_history_granted_fief),
                    (neg|troop_slot_eq, ":cur_troop_id", slot_troop_playerparty_history, dplmc_pp_history_lord_rejoined),
                    (neg|troop_slot_eq, ":cur_troop_id", slot_troop_occupation, slto_kingdom_hero),
                    (store_random_in_range, ":town_no", towns_begin, towns_end),
                    (troop_set_slot, ":cur_troop_id", slot_troop_cur_center, ":town_no"),
                    (troop_set_slot, ":cur_troop_id", slot_troop_playerparty_history, pp_history_scattered),
                    (troop_set_slot, ":cur_troop_id", slot_troop_turned_down_twice, 0),
                    (troop_set_slot, ":cur_troop_id", slot_troop_occupation, 0),
                (try_end),
             (try_end),

             (try_begin),
               (ge, ":collective_casualties", 0),
               (party_clear, "p_temp_party"),
               (assign, "$g_move_heroes", 0), #heroes are already processed above. Skip them here.
               (call_script, "script_party_add_party_prisoners", "p_temp_party", ":collective_casualties"),
               (call_script, "script_party_prisoners_add_party_companions", "p_temp_party", ":collective_casualties"),
               (distribute_party_among_party_group, "p_temp_party", ":root_winner_party"),

               (call_script, "script_battle_political_consequences", ":root_defeated_party", ":root_winner_party"),

               (call_script, "script_clear_party_group", ":root_defeated_party"),
             (try_end),
             (assign, ":trigger_result", 1), #End battle!

             #Center captured
             (try_begin),
               (ge, ":collective_casualties", 0),
               (party_get_slot, ":cur_party_type", ":root_defeated_party", slot_party_type),
               (this_or_next|eq, ":cur_party_type", spt_town),
               (eq, ":cur_party_type", spt_castle),

               #free all captive ladies
               (try_for_range, ":lady", kingdom_ladies_begin, kingdom_ladies_end),
                   (troop_get_slot, ":center", ":lady", slot_troop_prisoner_of_party),
                   (neg|troop_slot_eq, ":lady", slot_troop_occupation, slto_kingdom_hero),
                   (eq, ":root_defeated_party", ":center"),
                   (call_script, "script_remove_troop_from_prison", ":lady"),
                   (store_faction_of_troop, ":lady_faction", ":lady"),
                   (store_faction_of_party, ":rescue_faction", ":root_winner_party"),
                   (faction_get_color, ":lady_faction_color", ":lady_faction"),
                   (str_store_troop_name_link, s1, ":lady"),
                   (str_store_faction_name_link, s2, ":rescue_faction"),
                   (str_store_faction_name_link, s3, ":lady_faction"),
                   (display_log_message, "str_hero_freed", ":lady_faction_color"),
               (try_end),

               (assign, "$g_recalculate_ais", 1),

               (store_faction_of_party, ":winner_faction", ":root_winner_party"),
               (store_faction_of_party, ":defeated_faction", ":root_defeated_party"),

               (str_store_party_name, s1, ":root_defeated_party"),
               (str_store_faction_name, s2, ":winner_faction"),
               (str_store_faction_name, s3, ":defeated_faction"),
               ## CC
               (faction_get_color, ":faction_color", ":winner_faction"),
               (display_log_message, "str_center_captured", ":faction_color"),
               ## CC

			   (store_current_hours, ":hours"),
			   (faction_set_slot, ":winner_faction", slot_faction_ai_last_decisive_event, ":hours"),

               (try_begin),
                 (eq, "$g_encountered_party", ":root_defeated_party"),
                 (call_script, "script_add_log_entry", logent_player_participated_in_siege, "trp_player",  "$g_encountered_party", 0, "$g_encountered_party_faction"),
               (try_end),

               (try_begin),
                 (party_get_num_companion_stacks, ":num_stacks", ":root_winner_party"),
                 (gt, ":num_stacks", 0),
                 (party_stack_get_troop_id, ":leader_troop_no", ":root_winner_party", 0),
		##diplomacy start+ support for promoted kingdom ladies
                 (is_between, ":leader_troop_no", heroes_begin, heroes_end),#<- dplmc+ added
                 (this_or_next|troop_slot_eq, ":leader_troop_no", slot_troop_occupation, slto_kingdom_hero),#<- dplmc+ addded
                     (is_between, ":leader_troop_no", active_npcs_begin, active_npcs_end),
		##diplomacy end+
                 (party_set_slot, ":root_defeated_party", slot_center_last_taken_by_troop, ":leader_troop_no"),
               (else_try),
                 (party_set_slot, ":root_defeated_party", slot_center_last_taken_by_troop, -1),
               (try_end),

               (call_script, "script_lift_siege", ":root_defeated_party", 0),
               (call_script, "script_spawn_looters", ":root_defeated_party", 5), #SB : spawn some looters
               (store_faction_of_party, ":fortress_faction", ":root_defeated_party"),
			   (try_begin),
			     (is_between, ":root_defeated_party", towns_begin, towns_end),
			     (assign, ":damage", 40),
			   (else_try),
			     (assign, ":damage", 20),
			   (try_end),
			   (call_script, "script_faction_inflict_war_damage_on_faction", ":winner_faction", ":fortress_faction", ":damage"),

               (call_script, "script_give_center_to_faction", ":root_defeated_party", ":winner_faction"),
               (try_begin),
			     ##diplomacy start+ Handle player is co-ruler of faction
			     (assign, ":is_defeated_faction_coruler", 0),
            	 (try_begin),
            		##zerilius changes begin
            		(eq, ":defeated_faction", "$players_kingdom"),
            		# (eq, ":is_defeated_faction_coruler", "$players_kingdom"),
            		##zerilius changes end
            		(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
            		(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
            		(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
            		(assign, ":is_defeated_faction_coruler", 1),
            	 (try_end),
				 (this_or_next|eq, ":is_defeated_faction_coruler", 1),
	  		     ##diplomacy end+
                 (eq, ":defeated_faction", "fac_player_supporters_faction"),
                 (call_script, "script_add_notification_menu", "mnu_notification_center_lost", ":root_defeated_party", ":winner_faction"),
               (try_end),

               (party_get_num_attached_parties, ":num_attached_parties",  ":root_attacker_party"),
                 (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
                 (party_get_attached_party_with_rank, ":attached_party", ":root_attacker_party", ":attached_party_rank"),

                 (party_get_num_companion_stacks, ":num_stacks", ":attached_party"),
                 (assign, ":total_size", 0),
                 (try_for_range, ":i_stack", 0, ":num_stacks"),
                   (party_stack_get_size, ":stack_size", ":attached_party", ":i_stack"),
                   (val_add, ":total_size", ":stack_size"),
                 (try_end),

                 (try_begin),
                   (ge, ":total_size", 10),

                   (assign, ":stacks_added", 0),
                   (assign, ":last_random_stack", -1),

                   (assign, ":end_condition", 10),
                   (try_for_range, ":unused", 0, ":end_condition"),
                     (store_random_in_range, ":random_stack", 1, ":num_stacks"),
                     (party_stack_get_troop_id, ":random_stack_troop", ":attached_party", ":random_stack"),
                     (party_stack_get_size, ":stack_size", ":attached_party", ":random_stack"),
                     (ge, ":stack_size", 4),
                     (neq, ":random_stack", ":last_random_stack"),

                     (store_mul, ":total_size_mul_2", ":total_size", 2),
                     (assign, ":percentage", ":total_size_mul_2"),
                     (val_min, ":percentage", 100),

                     (val_mul, ":stack_size", ":percentage"),
                     (val_div, ":stack_size", 100),

                     (party_stack_get_troop_id, ":party_leader", ":attached_party", 0),

                     (try_begin),
                       ##diplomacy start+ add lady personality
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_conventional),
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_otherworldly),
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_adventurous),
                       ##diplomacy end+
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_goodnatured),
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_upstanding),
                       (troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_martial),
                       (assign, reg2, 0),
                       (store_random_in_range, ":random_percentage", 40, 50), #average 45%
                     (else_try),
                       ##diplomacy start+ add lady personality
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_ambitious),
                       ##diplmoacy end+
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_quarrelsome),
                       (troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_cunning),
                       (assign, reg2, 1),
                       (store_random_in_range, ":random_percentage", 30, 40), #average 35%
                     (else_try),
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_selfrighteous),
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_roguish),
                       (troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_debauched),
                       (assign, reg2, 2),
                       (store_random_in_range, ":random_percentage", 20, 30), #average 25%
                     (else_try),
                       ##diplomacy start+ add lady personality
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_moralist),
                       ##diplomacy end+
                       (this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_benefactor),
                       (troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_custodian),
                       (assign, reg2, 3),
                       (store_random_in_range, ":random_percentage", 50, 60), #average 55%
                     (try_end),

                     (val_min, ":random_percentage", 100),
                     (val_mul, ":stack_size", ":random_percentage"),
                     (val_div, ":stack_size", 100),

                     (party_add_members, ":root_defender_party", ":random_stack_troop", ":stack_size"),
                     (party_remove_members, ":attached_party", ":random_stack_troop", ":stack_size"),

                     (val_add, ":stacks_added", 1),
                     (assign, ":last_random_stack", ":random_stack"),

                     (try_begin),
                       #if troops from three different stack is already added then break
                       (eq, ":stacks_added", 3),
                       (assign, ":end_condition", 0),
                     (try_end),
                   (try_end),
                 (try_end),
               (try_end),

               #Reduce prosperity of the center by 5
			   (try_begin),
			     (neg|is_between, ":root_defeated_party", castles_begin, castles_end),
			     (call_script, "script_change_center_prosperity", ":root_defeated_party", -5),
			     (val_add, "$newglob_total_prosperity_from_townloot", -5),
			   (try_end),
               (call_script, "script_order_best_besieger_party_to_guard_center", ":root_defeated_party", ":winner_faction"),
               (call_script, "script_cf_reinforce_party", ":root_defeated_party"),
               (call_script, "script_cf_reinforce_party", ":root_defeated_party"),
             (try_end),
           (try_end),

           #ADD XP
           (try_begin),
             (party_slot_eq, ":root_attacker_party", slot_party_type, spt_kingdom_hero_party),

             (assign, ":xp_gained_attacker", 200),
             (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
             (store_faction_of_party, ":root_attacker_party_faction", ":root_attacker_party"),
             (try_begin),
               (this_or_next|eq, ":root_attacker_party", "p_main_party"),
               (this_or_next|eq, ":root_attacker_party_faction", "fac_player_supporters_faction"),
               (eq, ":root_attacker_party_faction", "$players_kingdom"),
               #same
             (else_try),
               (eq, ":reduce_campaign_ai", 0), #hard (1.5x)
               (val_mul, ":xp_gained_attacker", 3),
               (val_div, ":xp_gained_attacker", 2),
             (else_try),
               (eq, ":reduce_campaign_ai", 1), #moderate (1.0x)
               #same
             (else_try),
               (eq, ":reduce_campaign_ai", 2), #easy (0.5x)
               (val_div, ":xp_gained_attacker", 2),
             (try_end),

             (gt, ":new_attacker_strength", 0),
             (call_script, "script_upgrade_hero_party", ":root_attacker_party", ":xp_gained_attacker"),
           (try_end),
           (try_begin),
             (party_slot_eq, ":root_defender_party", slot_party_type, spt_kingdom_hero_party),

             (assign, ":xp_gained_defender", 200),
             (store_faction_of_party, ":root_defender_party_faction", ":root_defender_party"),
             (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
             (try_begin),
               (this_or_next|eq, ":root_defender_party", "p_main_party"),
               (this_or_next|eq, ":root_defender_party_faction", "fac_player_supporters_faction"),
               (eq, ":root_defender_party_faction", "$players_kingdom"),
               #same
             (else_try),
               (eq, ":reduce_campaign_ai", 0), #hard (1.5x)
               (val_mul, ":xp_gained_defender", 3),
               (val_div, ":xp_gained_defender", 2),
             (else_try),
               (eq, ":reduce_campaign_ai", 1), #moderate (1.0x)
               #same
             (else_try),
               (eq, ":reduce_campaign_ai", 2), #easy (0.5x)
               (val_div, ":xp_gained_defender", 2),
             (try_end),

             (gt, ":new_defender_strength", 0),
             (call_script, "script_upgrade_hero_party", ":root_defender_party", ":xp_gained_defender"),
           (try_end),

           (try_begin),
             #ozan - do not randomly end battles aganist towns or castles.
             (neg|party_slot_eq, ":root_defender_party", slot_party_type, spt_castle), #added by ozan
             (neg|party_slot_eq, ":root_defender_party", slot_party_type, spt_town),   #added by ozan
             #end ozan

             (party_get_slot, ":attacker_root_strength", ":root_attacker_party", slot_party_cached_strength),
             (party_get_slot, ":attacker_nearby_friend_strength", ":root_attacker_party", slot_party_nearby_friend_strength),
             (party_get_slot, ":strength_of_attacker_followers", ":root_attacker_party", slot_party_follower_strength),
             (store_add, ":total_attacker_strength", ":attacker_root_strength", ":attacker_nearby_friend_strength"),
             (val_add, ":total_attacker_strength", ":strength_of_attacker_followers"),

             (party_get_slot, ":defender_root_strength", ":root_defender_party", slot_party_cached_strength),
             (party_get_slot, ":defender_nearby_friend_strength", ":root_defender_party", slot_party_nearby_friend_strength),
             (party_get_slot, ":strength_of_defender_followers", ":root_defender_party", slot_party_follower_strength),
             (store_add, ":total_defender_strength", ":defender_root_strength", ":defender_nearby_friend_strength"),
             (val_add, ":total_attacker_strength", ":strength_of_defender_followers"),

             #Players can make save loads and change history because these random values are not determined from random_slots of troops
             (store_random_in_range, ":random_num", 0, 100),

             (try_begin),
               (lt, ":random_num", 10),
               (assign, ":trigger_result", 1), #End battle!
             (try_end),
           (else_try),
             (party_get_slot, ":attacker_root_strength", ":root_attacker_party", slot_party_cached_strength),
             (party_get_slot, ":attacker_nearby_friend_strength", ":root_attacker_party", slot_party_nearby_friend_strength),
             (party_get_slot, ":strength_of_followers", ":root_attacker_party", slot_party_follower_strength),
             (store_add, ":total_attacker_strength", ":attacker_root_strength", ":attacker_nearby_friend_strength"),
             (val_add, ":total_attacker_strength", ":strength_of_followers"),

             (party_get_slot, ":defender_root_strength", ":root_defender_party", slot_party_cached_strength),
             (party_get_slot, ":defender_nearby_friend_strength", ":root_defender_party", slot_party_nearby_friend_strength),
             (store_add, ":total_defender_strength", ":defender_root_strength", ":defender_nearby_friend_strength"),

             (val_mul, ":total_defender_strength", 13), #multiply defender strength with 1.3
             (val_div, ":total_defender_strength", 10),

             (gt, ":total_defender_strength", ":total_attacker_strength"),
             (gt, ":total_defender_strength", 3),

             #Players can make save loads and change history because these random values are not determined from random_slots of troops
             (store_random_in_range, ":random_num", 0, 100),

             (try_begin),
               (lt, ":random_num", 15), #15% is a bit higher than 10% (which is open area escape probability)
               (assign, ":trigger_result", 1), #End battle!

               (assign, "$g_recalculate_ais", 1), #added new

               (try_begin),
                 (eq, "$cheat_mode", 1),
                 (display_message, "@{!}DEBUG : Siege attackers are running away"),
               (try_end),
             (try_end),
           (try_end),
         (try_end),
       (try_end),
       (set_trigger_result, ":trigger_result"),
  ]),

  #script_game_event_battle_end:
  # This script is called whenever the game ends the battle between two parties on the map.
  # INPUT:
  # param1: Defender Party
  # param2: Attacker Party
  ("game_event_battle_end",
    [
##       (store_script_param_1, ":root_defender_party"),
##       (store_script_param_2, ":root_attacker_party"),

      #Fixing deleted heroes
      ##diplomacy start+ kingdom ladies may also potentially lead parties
      (try_for_range, ":cur_troop", heroes_begin, heroes_end),#<- changed active_npcs to heroes
      #diplomacy end+
		(this_or_next|troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
        (is_between, ":cur_troop", companions_begin, companions_end),
        (troop_get_slot, ":cur_party", ":cur_troop", slot_troop_leaded_party),
        (troop_get_slot, ":cur_prisoner_of_party", ":cur_troop", slot_troop_prisoner_of_party),
        (try_begin),
          (ge, ":cur_party", 0),
          (assign, ":continue", 0),
          (try_begin),
            (neg|party_is_active, ":cur_party"),
            (assign, ":continue", 1),
          (else_try),
            (party_count_companions_of_type, ":amount", ":cur_party", ":cur_troop"),
            (le, ":amount", 0),
            (assign, ":continue", 1),
          (try_end),
          (eq, ":continue", 1),
          (try_begin),
            (eq, "$cheat_mode", 1),
            (str_store_troop_name, s1, ":cur_troop"),
            (display_message, "@{!}DEBUG: {s1} no longer leads a party."),
          (try_end),

          (troop_set_slot, ":cur_troop", slot_troop_leaded_party, -1),
          #(str_store_troop_name, s5, ":cur_troop"),
          #(display_message, "@{!}DEBUG : {s5}'s troop_leaded_party set to -1"),
        (try_end),
        (try_begin),
          (ge, ":cur_prisoner_of_party", 0),
          (assign, ":continue", 0),
          (try_begin),
            (neg|party_is_active, ":cur_prisoner_of_party"),
            (assign, ":continue", 1),
          (else_try),
            (party_count_prisoners_of_type, ":amount", ":cur_prisoner_of_party", ":cur_troop"),
            (le, ":amount", 0),
            (assign, ":continue", 1),
          (try_end),
          (eq, ":continue", 1),
          (try_begin),
            (eq, "$cheat_mode", 1),
            (str_store_troop_name, s1, ":cur_troop"),
            (display_message, "@{!}DEBUG: {s1} is no longer a prisoner."),
          (try_end),
          (call_script, "script_remove_troop_from_prison", ":cur_troop"),
          #searching player
          (try_begin),
            (party_count_prisoners_of_type, ":amount", "p_main_party", ":cur_troop"),
            (gt, ":amount", 0),
            (troop_set_slot, ":cur_troop", slot_troop_prisoner_of_party, "p_main_party"),
            (troop_set_slot, ":cur_troop", slot_troop_courtesan, -1),
            (assign, ":continue", 0),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (str_store_troop_name, s1, ":cur_troop"),
              (display_message, "@{!}DEBUG: {s1} is now a prisoner of player."),
            (try_end),
          (try_end),
          (eq, ":continue", 1),
		  ##diplomacy start+
		  #Add increased information for affiliates.
		  (call_script, "script_dplmc_store_troop_is_eligible_for_affiliate_messages", ":cur_troop"),
		  (assign, ":is_affiliated", reg0),
		  ##diplomacy end+
          #searching kingdom heroes
	  ##diplomacy start+ support for promoted kingdom ladies
          (try_for_range, ":cur_troop_2", heroes_begin, heroes_end),#<-- changed active_npcs to heroes
          ##diplomacy end+
			(this_or_next|troop_slot_eq, ":cur_troop_2", slot_troop_occupation, slto_kingdom_hero),
            (is_between, ":cur_troop_2", companions_begin, companions_end),
			(eq, ":continue", 1),
            (troop_get_slot, ":cur_prisoner_of_party_2", ":cur_troop_2", slot_troop_leaded_party),
            (party_is_active, ":cur_prisoner_of_party_2"),
            (party_count_prisoners_of_type, ":amount", ":cur_prisoner_of_party_2", ":cur_troop"),
            (gt, ":amount", 0),
            (troop_set_slot, ":cur_troop", slot_troop_prisoner_of_party, ":cur_prisoner_of_party_2"),
            (assign, ":continue", 0),
            (try_begin),
			##diplomacy start+ Show for affiliates
			  (ge, ":is_affiliated", 1),
			  (str_store_troop_name, s1, ":cur_troop"),
			  (str_store_party_name, s2, ":cur_prisoner_of_party_2"),
			  (display_message, "@{s1} is now a prisoner of {s2}."),
			(else_try),
			##diplomacy end+
              (eq, "$cheat_mode", 1),
              (str_store_troop_name, s1, ":cur_troop"),
              (str_store_party_name, s2, ":cur_prisoner_of_party_2"),
              (display_message, "@{!}DEBUG: {s1} is now a prisoner of {s2}."),
            (try_end),
          (try_end),
          #searching walled centers
          (try_for_range, ":cur_prisoner_of_party_2", walled_centers_begin, walled_centers_end),
            (eq, ":continue", 1),
            (party_count_prisoners_of_type, ":amount", ":cur_prisoner_of_party_2", ":cur_troop"),
            (gt, ":amount", 0),
            (troop_set_slot, ":cur_troop", slot_troop_prisoner_of_party, ":cur_prisoner_of_party_2"),
            (assign, ":continue", 0),
            (try_begin),
			##diplomacy start+ Show for affiliates
			  (ge, ":is_affiliated", 1),
			  (str_store_troop_name, s1, ":cur_troop"),
			  (str_store_party_name, s2, ":cur_prisoner_of_party_2"),
			  (display_message, "@{s1} is now a prisoner of {s2}."),
			(else_try),
			##diplomacy end+
              (eq, "$cheat_mode", 1),
              (str_store_troop_name, s1, ":cur_troop"),
              (str_store_party_name, s2, ":cur_prisoner_of_party_2"),
              (display_message, "@{!}DEBUG: {s1} is now a prisoner of {s2}."),
            (try_end),
          (try_end),
        (try_end),
      (try_end),
  ]),

  #script_order_best_besieger_party_to_guard_center:
  # INPUT:
  # param1: defeated_center, param2: winner_faction
  # OUTPUT:
  # none
  ("order_best_besieger_party_to_guard_center",
    [
      (store_script_param, ":defeated_center", 1),
      (store_script_param, ":winner_faction", 2),
      (assign, ":best_party", -1),
      (assign, ":best_party_strength", 0),
      ##diplomacy start+ support for promoted kingdom ladies
      (try_for_range, ":kingdom_hero", heroes_begin, heroes_end),#<- changed to heroes
        (this_or_next|troop_slot_eq, ":kingdom_hero", slot_troop_occupation, slto_kingdom_hero),
           (is_between, ":kingdom_hero", active_npcs_begin, active_npcs_end),
      ##diplomacy end+
        (troop_get_slot, ":kingdom_hero_party", ":kingdom_hero", slot_troop_leaded_party),
        (gt, ":kingdom_hero_party", 0),
        (party_is_active, ":kingdom_hero_party"),
        (store_faction_of_party, ":kingdom_hero_party_faction", ":kingdom_hero_party"),
        (eq, ":winner_faction", ":kingdom_hero_party_faction"),
        (store_distance_to_party_from_party, ":dist", ":kingdom_hero_party", ":defeated_center"),
        (lt, ":dist", 5),
        #If marshall has captured the castle, then do not leave him behind.
        (neg|faction_slot_eq, ":winner_faction", slot_faction_marshall, ":kingdom_hero"),
        (assign, ":has_besiege_ai", 0),
        (try_begin),
          (party_slot_eq, ":kingdom_hero_party", slot_party_ai_state, spai_besieging_center),
          (party_slot_eq, ":kingdom_hero_party", slot_party_ai_object, ":defeated_center"),
          (assign, ":has_besiege_ai", 1),
        (else_try),
          (party_slot_eq, ":kingdom_hero_party", slot_party_ai_state, spai_accompanying_army),
          (party_get_slot, ":kingdom_hero_party_commander_party", ":kingdom_hero_party", slot_party_ai_object),
          (party_slot_eq, ":kingdom_hero_party_commander_party", slot_party_ai_state, spai_besieging_center),
          (party_slot_eq, ":kingdom_hero_party_commander_party", slot_party_ai_object, ":defeated_center"),
          (assign, ":has_besiege_ai", 1),
        (try_end),
        (eq, ":has_besiege_ai", 1),
        (party_get_slot, ":kingdom_hero_party_strength", ":kingdom_hero_party", slot_party_cached_strength),#recently calculated
        (gt, ":kingdom_hero_party_strength", ":best_party_strength"),
        (assign, ":best_party_strength", ":kingdom_hero_party_strength"),
        (assign, ":best_party", ":kingdom_hero_party"),
      (try_end),
      (try_begin),
        (gt, ":best_party", 0),
        (call_script, "script_party_set_ai_state", ":best_party", spai_holding_center, ":defeated_center"),
        #(party_set_slot, ":best_party", slot_party_commander_party, -1),
        (party_set_flags, ":best_party", pf_default_behavior, 1),
      (try_end),
      ]),

  #script_game_get_item_buy_price_factor:
  # This script is called from the game engine for calculating the buying price of any item.
  # INPUT:
  # param1: item_kind_id
  # OUTPUT:
  # trigger_result and reg0 = price_factor
  ("game_get_item_buy_price_factor",
    [
      (store_script_param_1, ":item_kind_id"),
      (assign, ":price_factor", 100),

      (call_script, "script_get_trade_penalty", ":item_kind_id"),
      (assign, ":trade_penalty", reg0),

      (try_begin),
        (is_between, "$g_encountered_party", centers_begin, centers_end),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
        (val_add, ":item_slot_no", slot_town_trade_good_prices_begin),
        (party_get_slot, ":price_factor", "$g_encountered_party", ":item_slot_no"),

		#new
		#(try_begin),
		#	(is_between, "$g_encountered_party", villages_begin, villages_end),
		#	(party_get_slot, ":market_town", "$g_encountered_party", slot_village_market_town),
		#	(party_get_slot, ":price_in_market_town", ":market_town", ":item_slot_no"),
		#	(val_max, ":price_factor", ":price_in_market_town"),
		#(try_end),

		#For villages, the good will be sold no cheaper than in the market town
		#This represents the absence of a permanent market -- ie, the peasants retain goods to sell on their journeys to town, and are not about to do giveaway deals with passing adventurers


        (val_mul, ":price_factor", 100), #normalize price factor to range 0..100
        (val_div, ":price_factor", average_price_factor),
      (try_end),

      (store_add, ":penalty_factor", 100, ":trade_penalty"),

      (val_mul, ":price_factor", ":penalty_factor"),
      (val_div, ":price_factor", 100),

      (assign, reg0, ":price_factor"),
      (set_trigger_result, reg0),
  ]),

  #script_game_get_item_sell_price_factor:
  # This script is called from the game engine for calculating the selling price of any item.
  # INPUT:
  # param1: item_kind_id
  # OUTPUT:
  # trigger_result and reg0 = price_factor
  ("game_get_item_sell_price_factor",
    [
      (store_script_param_1, ":item_kind_id"),
      (assign, ":price_factor", 100),

      (call_script, "script_get_trade_penalty", ":item_kind_id"),
      (assign, ":trade_penalty", reg0),

      (try_begin),
        (is_between, "$g_encountered_party", centers_begin, centers_end),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
        (val_add, ":item_slot_no", slot_town_trade_good_prices_begin),
        (party_get_slot, ":price_factor", "$g_encountered_party", ":item_slot_no"),
        (val_mul, ":price_factor", 100),#normalize price factor to range 0..100
        (val_div, ":price_factor", average_price_factor),
      (else_try),
        #increase trade penalty while selling weapons, armor, and horses
        (val_mul, ":trade_penalty", 4),
      (try_end),

	  ##diplomacy start+
	  #If economic changes are enabled, use a lesser trade penalty when selling
 	  #to the correct merchant in town.
	  (try_begin),
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		(is_between, "$g_encountered_party", towns_begin, towns_end),
		(gt, "$g_talk_troop", "trp_player"),
		(try_begin),
			#Selling weapons to the weaponsmith
			(party_slot_eq, "$g_encountered_party", slot_town_weaponsmith, "$g_talk_troop"),
			(this_or_next|is_between, ":item_kind_id", weapons_begin, weapons_end),
			(this_or_next|is_between, ":item_kind_id", shields_begin, shields_end),
				(is_between, ":item_kind_id", ranged_weapons_begin, ranged_weapons_end),
			(val_mul, ":trade_penalty", 9),
			(val_div, ":trade_penalty", 10),
		(else_try),
			#Selling armor to the armorer
			(party_slot_eq, "$g_encountered_party", slot_town_armorer, "$g_talk_troop"),
			(is_between, ":item_kind_id", armors_begin, armors_end),
			(val_mul, ":trade_penalty", 9),
			(val_div, ":trade_penalty", 10),
		(else_try),
			#Selling horses to the horse merchant
			(party_slot_eq, "$g_encountered_party", slot_town_horse_merchant, "$g_talk_troop"),
			(is_between, ":item_kind_id", horses_begin, horses_end),
			(val_mul, ":trade_penalty", 9),
			(val_div, ":trade_penalty", 10),
		(try_end),
	  (try_end),

	  #If economic changes are enabled, increase food prices in a town under siege.
	  (try_begin),
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		(is_between, "$g_encountered_party", centers_begin, centers_end),
		#Check selling food
		(is_between, ":item_kind_id", food_begin, food_end),
		#Check at a town or castle under siege for at least 48 hours
		(this_or_next|party_slot_eq, "$g_encountered_party", slot_party_type, spt_town),
			(party_slot_eq, "$g_encountered_party", slot_party_type, spt_castle),
		(party_slot_eq, "$g_encountered_party", slot_village_state, svs_under_siege),

		(party_slot_ge, "$g_encountered_party", slot_center_is_besieged_by, 1),
		(party_get_slot, ":siege_start", "$g_encountered_party", slot_center_siege_begin_hours),
		(store_current_hours, ":cur_hours"),
		(store_sub, reg0, ":cur_hours", ":siege_start"),
		(ge, reg0, 48),
		#Check last caravan or village trading party arrival (default to eight weeks ago)
		(store_sub, ":last_arrival", ":cur_hours", 8 * 7 * 24),
		(val_min, ":last_arrival", ":siege_start"),
		(try_for_range, ":village_no", villages_begin, villages_end),
			(party_slot_eq, ":village_no", slot_village_market_town, "$g_encountered_party"),
			(party_get_slot, reg0, ":village_no", dplmc_slot_village_trade_last_arrived_to_market),
			(val_min, reg0, ":cur_hours"),
			(val_max, ":last_arrival", reg0),
		(try_end),
		(try_for_range, ":slot_no", dplmc_slot_town_trade_route_last_arrivals_begin, dplmc_slot_town_trade_route_last_arrivals_end),
			#Not all of these slots correspond to towns, but that doesn't
			#matter since their arrival times won't update after the start
			#of the game.
			(party_get_slot, reg0, "$g_encountered_party", ":slot_no"),
			(val_min, reg0, ":cur_hours"),
			(val_max, ":last_arrival", reg0),
		(try_end),
		##Increase food prices by 10% for every 3 days the siege has been going on,
		#or a minimum of 5%.
		#TODO: Make use of the last caravan arrival time.
		(store_sub, ":hours_since", ":cur_hours", ":siege_start"),
		(store_mul, ":siege_percent", ":hours_since", 10),
		(val_add, ":siege_percent", (3 * 24) // 2),
		(val_div, ":siege_percent", 3 * 24),
		(val_max, ":siege_percent", 5),
		(val_add, ":siege_percent", 100),
		(val_mul, ":price_factor", ":siege_percent"),
		(val_add, ":price_factor", 50),
		(val_div, ":price_factor", 100),
	  (try_end),
	  ##diplomacy end+

      (store_add, ":penalty_divisor", 100, ":trade_penalty"),

      (val_mul, ":price_factor", 100),
	  ##diplomacy start+
	  (try_begin),
		(gt, ":penalty_divisor", 0),
		(store_div, reg0, ":penalty_divisor", 2),
		(val_add, ":price_factor", reg0),#round correctly
	  (try_end),
	  ##diplomacy end+
      (val_div, ":price_factor", ":penalty_divisor"),

      (assign, reg0, ":price_factor"),
      (set_trigger_result, reg0),
  ]),

  # script_get_trade_penalty
  #
  # Input:
  # param1: troop_id,
  # Output: reg0

  ("get_trade_penalty",
    [
	##diplomacy start+
	##Changed to fall back to parameterized version
	##NEW:
      (store_script_param_1, ":item_kind_id"),
	  (call_script, "script_dplmc_get_trade_penalty", ":item_kind_id", "$g_encountered_party", "trp_player", "$g_talk_troop"),

	##OLD:
#	  (store_script_param_1, ":item_kind_id"),
#
#      (assign, ":penalty",0),
#
#      (party_get_skill_level, ":trade_skill", "p_main_party", skl_trade),
#      (try_begin),
#        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
#        (assign, ":penalty",15), #reduced slightly
#        (store_mul, ":skill_bonus", ":trade_skill", 1),
#        (val_sub, ":penalty", ":skill_bonus"),
#      (else_try),
#        (assign, ":penalty",100),
#        (store_mul, ":skill_bonus", ":trade_skill", 5),
#        (val_sub, ":penalty", ":skill_bonus"),
#      (try_end),
#
#	  ##diplomacy start+
#      (assign, ":penalty_multiplier", average_price_factor),#<-- replaced 1000 with average_price_factor
#	  ##diplomacy end+
###       # Apply penalty if player is hostile to merchants faction
###      (store_relation, ":merchants_reln", "fac_merchants", "fac_player_supporters_faction"),
###      (try_begin),
###        (lt, ":merchants_reln", 0),
###        (store_sub, ":merchants_reln_dif", 10, ":merchants_reln"),
###        (store_mul, ":merchants_relation_penalty", ":merchants_reln_dif", 20),
###        (val_add, ":penalty_multiplier", ":merchants_relation_penalty"),
###      (try_end),
#
#       # Apply penalty if player is on bad terms with the town
#      (try_begin),
#        (is_between, "$g_encountered_party", centers_begin, centers_end),
#        (party_get_slot, ":center_relation", "$g_encountered_party", slot_center_player_relation),
#        (store_mul, ":center_relation_penalty", ":center_relation", -3),
#        (val_add, ":penalty_multiplier", ":center_relation_penalty"),
#        (try_begin),
#          (lt, ":center_relation", 0),
#          (store_sub, ":center_penalty_multiplier", 100, ":center_relation"),
#          (val_mul, ":penalty_multiplier", ":center_penalty_multiplier"),
#          (val_div, ":penalty_multiplier", 100),
#        (try_end),
#      (try_end),
#
#       # Apply penalty if player is on bad terms with the merchant (not currently used)
#      (call_script, "script_troop_get_player_relation", "$g_talk_troop"),
#      (assign, ":troop_reln", reg0),
#      #(troop_get_slot, ":troop_reln", "$g_talk_troop", slot_troop_player_relation),
#      (try_begin),
#        (lt, ":troop_reln", 0),
#        (store_sub, ":troop_reln_dif", 0, ":troop_reln"),
#        (store_mul, ":troop_relation_penalty", ":troop_reln_dif", 20),
#        (val_add, ":penalty_multiplier", ":troop_relation_penalty"),
#      (try_end),
#
#
#	  (try_begin),
#		(is_between, "$g_encountered_party", villages_begin, villages_end),
#	    (val_mul, ":penalty", 2),
#	  (try_end),
#
#	  (try_begin),
#            (is_between, "$g_encountered_party", centers_begin, centers_end),
#	    #Double trade penalty if no local production or consumption
#	    (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
#		##diplomacy start+
#		#OPTIONAL CHANGE: Do not apply this to food
#       (this_or_next|lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
#		   (neg|is_between, ":item_kind_id", food_begin, food_end),
#		##diplomacy end+
#	    (call_script, "script_center_get_production", "$g_encountered_party", ":item_kind_id"),
#	    (eq, reg0, 0),
#	    (call_script, "script_center_get_consumption", "$g_encountered_party", ":item_kind_id"),
#	    (eq, reg0, 0),
#	    (val_mul, ":penalty", 2),
#	  (try_end),
#
#      (val_mul, ":penalty",  ":penalty_multiplier"),
#	  ##diplomacy start+
#	  (val_add, ":penalty", average_price_factor // 2),#round in the correct direction (we don't need to worry about penalty < 0)
#      (val_div, ":penalty", average_price_factor),#replace the hardcoded constant 1000 with average_price_factor
#	  ##diplomacy end+
#      (val_max, ":penalty", 1),
#      (assign, reg0, ":penalty"),
  ]),

  #script_game_event_buy_item:
  # This script is called from the game engine when player buys an item.
  # INPUT:
  # param1: item_kind_id
  ("game_event_buy_item",
    [
      (store_script_param_1, ":item_kind_id"),
      (store_script_param_2, ":reclaim_mode"),
      (try_begin),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
        (val_add, ":item_slot_no", slot_town_trade_good_prices_begin),
        (party_get_slot, ":multiplier", "$g_encountered_party", ":item_slot_no"),
        (try_begin),
          (eq, ":reclaim_mode", 0),
          (val_add, ":multiplier", 20),
        (else_try),
          (val_add, ":multiplier", 30),
        (try_end),

        (store_item_value, ":item_value", ":item_kind_id"),
        (try_begin),
          (ge, ":item_value", 100),
          (store_sub, ":item_value_sub_100", ":item_value", 100),
          (store_div, ":item_value_sub_100_div_8", ":item_value_sub_100", 8),
          (val_add, ":multiplier", ":item_value_sub_100_div_8"),
        (try_end),
        (val_min, ":multiplier", maximum_price_factor),

        (party_set_slot, "$g_encountered_party", ":item_slot_no", ":multiplier"),
      (try_end),
  ]),

  #script_game_event_sell_item:
  # This script is called from the game engine when player sells an item.
  # INPUT:
  # param1: item_kind_id
  ("game_event_sell_item",
    [
      (store_script_param_1, ":item_kind_id"),
      (store_script_param_2, ":return_mode"),
      (try_begin),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
        (val_add, ":item_slot_no", slot_town_trade_good_prices_begin),
        (party_get_slot, ":multiplier", "$g_encountered_party", ":item_slot_no"),
        (try_begin),
          (eq, ":return_mode", 0),
          (val_sub, ":multiplier", 30),
        (else_try),
          (val_sub, ":multiplier", 20),
        (try_end),

        (store_item_value, ":item_value", ":item_kind_id"),
        (try_begin),
          (ge, ":item_value", 100),
          (store_sub, ":item_value_sub_100", ":item_value", 100),
          (store_div, ":item_value_sub_100_div_8", ":item_value_sub_100", 8),
          (val_sub, ":multiplier", ":item_value_sub_100_div_8"),
        (try_end),
        (val_max, ":multiplier", minimum_price_factor),

        (party_set_slot, "$g_encountered_party", ":item_slot_no", ":multiplier"),
      (try_end),
  ]),

  #script_start_wedding_cutscene
  # INPUT: arg1 = groom_troop, arg2 = bride_troop
  # OUTPUT: none
  ("start_wedding_cutscene",
   [
     (store_script_param, "$g_wedding_groom_troop", 1),
     (store_script_param, "$g_wedding_bride_troop", 2),
     ##diplomacy start+
	 (assign, ":save_reg0", reg0),
	 (assign, ":save_reg1", reg1),


     #To prevent a ridiculous cutscene, reverse genders if the bride is male.
	 (call_script, "script_dplmc_store_is_female_troop_1_troop_2", "$g_wedding_groom_troop", "$g_wedding_bride_troop"),
	 (assign, ":groom_is_woman", reg0),
	 (assign, ":bride_is_woman", reg1),

     (try_begin),
       (eq, ":bride_is_woman", 0),
       (neq, ":groom_is_woman", 0),#Don't bother reversing if both are male
       (assign, reg0, "$g_wedding_bride_troop"),
       (assign, "$g_wedding_bride_troop", "$g_wedding_groom_troop"),
       (assign, "$g_wedding_groom_troop", reg0),
	 (else_try),
	   #If it's a same-sex wedding, put the player in the role of the groom.
	   (eq, ":bride_is_woman", ":groom_is_woman"),
	   (eq, "$g_wedding_bride_troop", "trp_player"),
	   (assign, "$g_wedding_bride_troop", "$g_wedding_groom_troop"),
	   (assign, "$g_wedding_groom_troop", "trp_player"),
     (try_end),
     #diplomacy end+
     (assign, "$g_wedding_bishop_troop", "trp_temporary_minister"),
     (try_begin),
       (is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
       (neg|faction_slot_eq, "$players_kingdom", slot_faction_leader, "$g_wedding_groom_troop"),
       (neg|faction_slot_eq, "$players_kingdom", slot_faction_leader, "$g_wedding_bride_troop"),
       (faction_get_slot, ":players_king", "$players_kingdom", slot_faction_leader),
	   ##diplomacy start+
	   (neq, ":players_king", "$g_wedding_bride_troop"),#necessary now that marrying monarchs can occur
	   (neq, ":players_king", "$g_wedding_groom_troop"),
	   #Changed the gender requirement (used to be required male)
       #(troop_get_type, ":troop_type", ":players_king"),
       #(eq, ":troop_type", 0), #male
	   (call_script, "script_dplmc_store_troop_is_female", ":players_king"),
	   (this_or_next|eq, reg0, 0),
	   (this_or_next|eq, ":groom_is_woman", ":bride_is_woman"),
	      (ge, "$g_disable_condescending_comments", 2),
       (neq, ":players_king", "$g_wedding_bride_troop"),
       (neg|troop_slot_eq, "$g_wedding_bride_troop", slot_troop_father, ":players_king"),
	   (neg|troop_slot_eq, "$g_wedding_bride_troop", slot_troop_mother, ":players_king"),
       ##diplomacy end+
       (neq, ":players_king", "$g_wedding_groom_troop"),
       (assign, "$g_wedding_bishop_troop", ":players_king"),
     (else_try),
       (eq, "$players_kingdom", "fac_player_supporters_faction"),
       (faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
       (gt, "$g_player_minister", 0),
	   ##diplomacy start+
       #(troop_get_type, ":troop_type", "$g_player_minister"),
	   #(eq, ":troop_type", 0), #male
	   (call_script, "script_dplmc_store_troop_is_female", "$g_player_minister"),
	   (this_or_next|eq, reg0, 0),
	   (this_or_next|eq, ":groom_is_woman", ":bride_is_woman"),
	      (ge, "$g_disable_condescending_comments", 2),
	   ##diplomacy end+
       (neq, "$g_player_minister", "$g_wedding_groom_troop"),
       (assign, "$g_wedding_bishop_troop", "$g_player_minister"),
     (try_end),

     (assign, "$g_wedding_brides_dad_troop", "trp_temporary_minister"),
     (try_begin),
       (neq, "$g_wedding_bride_troop", "trp_player"),
       (try_begin),
         (troop_get_slot, ":father", "$g_wedding_bride_troop", slot_troop_father),
         (gt, ":father", 0),
         ##diplomacy start+
         (neg|troop_slot_ge, ":father", slot_troop_occupation, slto_retirement),
         #(troop_get_type, ":troop_type", ":father"), #just to make sure #<- dplmc+ replaced
		 (call_script, "script_dplmc_store_troop_is_female", ":father"),
		 (this_or_next|eq, ":bride_is_woman", 0),
			(eq, reg0, 0), #male
		 ##diplomacy end+
         (neq, ":father", "$g_wedding_groom_troop"), #this might be 0 due to an error
         (neq, ":father", "$g_wedding_bishop_troop"),
         (assign, "$g_wedding_brides_dad_troop", ":father"),
       (else_try),
         (troop_get_slot, ":guardian", "$g_wedding_bride_troop", slot_troop_guardian),
         (gt, ":guardian", 0),
         ##diplomacy start+
         (neg|troop_slot_ge, ":guardian", slot_troop_occupation, slto_retirement),
         #(troop_get_type, ":troop_type", ":guardian"), #just to make sure #<- dplmc+ replaced
		 (call_script, "script_dplmc_store_troop_is_female", ":guardian"),
		 (this_or_next|eq, ":bride_is_woman", 0),
			(eq, reg0, 0), #male
		 (call_script, "script_dplmc_store_troop_is_female", ":guardian"),
		 ##diplomacy end+
         (neq, ":guardian", "$g_wedding_groom_troop"), #this might be 0 due to an error
         (neq, ":guardian", "$g_wedding_bishop_troop"),
         (assign, "$g_wedding_brides_dad_troop", ":guardian"),
       ##diplomacy start+
	   #mother might be appropriate
	   (else_try),
		  (troop_get_slot, ":mother", "$g_wedding_bride_troop", slot_troop_mother),
	      (gt, ":mother", 0),
	      (neg|troop_slot_ge, ":mother", slot_troop_occupation, slto_retirement),

		  (neq, ":mother", "$g_wedding_groom_troop"),
		  (neq, ":mother", "$g_wedding_bride_troop"),
		  (neq, ":mother", "$g_wedding_bishop_troop"),

	      (assign, "$g_wedding_brides_dad_troop", ":mother"),
	   #we can get here, since male players can marry female lords
       (else_try),
          (is_between, "$g_wedding_bride_troop", companions_begin, companions_end),
          (troop_get_slot, ":cur_npc", "$g_wedding_bride_troop", slot_troop_personalitymatch_object),
          (ge, ":cur_npc", heroes_begin),
          (troop_slot_ge, ":cur_npc", slot_troop_met, 1),
		  (neg|troop_slot_ge, ":cur_npc", slot_troop_occupation, slto_retirement),
		  (this_or_next|troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_kingdom_hero),
		  (this_or_next|troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_player_companion),
		  (this_or_next|troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_kingdom_seneschal),
		     (troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_kingdom_lady),

		  (neg|troop_slot_ge, ":cur_npc", slot_troop_occupation, slto_retirement),
		  (neq, ":cur_npc", "$g_wedding_groom_troop"),
	      (neq, ":cur_npc", "$g_wedding_bride_troop"),
	      (neq, ":cur_npc", "$g_wedding_bishop_troop"),

		  (this_or_next|neg|troop_slot_ge, ":cur_npc", slot_lord_reputation_type, lrep_roguish),
		  (this_or_next|troop_slot_ge, ":cur_npc", slot_lord_reputation_type, lrep_conventional),

          (assign, "$g_wedding_brides_dad_troop", ":cur_npc"),
	   (else_try),
	      #any other companion or lord that is favorable
		  (assign, ":best_score", 0),#must be at least positive
		  (try_for_range, ":cur_npc", heroes_begin, heroes_end),
			(neq, ":cur_npc", "$g_wedding_groom_troop"),
	        (neq, ":cur_npc", "$g_wedding_bride_troop"),
	        (neq, ":cur_npc", "$g_wedding_bishop_troop"),
			(neq, ":cur_npc", "trp_knight_1_1_wife"),
			(neq, ":cur_npc", "trp_kingdom_heroes_including_player_begin"),

			(neg|troop_slot_ge, ":cur_npc", slot_troop_occupation, slto_retirement),

			(call_script, "script_troop_get_relation_with_troop", ":cur_npc", "$g_wedding_bride_troop"),
			(assign, ":relation", reg0),
			#(call_script, "script_troop_get_family_relation_to_troop", ":cur_npc", "$g_wedding_bride_troop"),
			(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":cur_npc",  "$g_wedding_bride_troop"),
			(assign, ":family_relation", reg0),

			(store_add, ":score", ":relation", ":family_relation"),

			(gt, ":score", ":best_score"),#score better than current best
			(assign, ":best_score", ":score"),
			(assign, "$g_wedding_brides_dad_troop", ":cur_npc"),
		  (try_end),
       ##diplomacy end+
       (try_end),
     (else_try),
       (try_for_range, ":cur_companion", companions_begin, companions_end),
         (this_or_next|troop_slot_eq, ":cur_companion", slot_troop_occupation, slto_player_companion),
         (troop_slot_eq, ":cur_companion", slot_troop_occupation, slto_kingdom_hero),
		 ##diplomacy start+
         #(troop_get_type, ":troop_type", ":cur_companion"), #just to make sure
         #(eq, ":troop_type", 0), #male
		 (call_script, "script_dplmc_store_troop_is_female", ":cur_companion"),
		 (this_or_next|eq, reg0, 0),
			(eq, ":bride_is_woman", 0),
		 ##diplomacy end+
         (neq, ":cur_companion", "$g_wedding_groom_troop"),
         (neq, ":cur_companion", "$g_wedding_bishop_troop"),
         (assign, "$g_wedding_brides_dad_troop", ":cur_companion"),
       (try_end),
       ##diplomacy start+ try again with female companions if no male companions available
       (eq, "$g_wedding_brides_dad_troop", "trp_temporary_minister"),
       (try_for_range, ":cur_companion", companions_begin, companions_end),
         (this_or_next|troop_slot_eq, ":cur_companion", slot_troop_occupation, slto_player_companion),
			(troop_slot_eq, ":cur_companion", slot_troop_occupation, slto_kingdom_hero),
         (neq, ":cur_companion", "$g_wedding_groom_troop"),
         (neq, ":cur_companion", "$g_wedding_bishop_troop"),
         (assign, "$g_wedding_brides_dad_troop", ":cur_companion"),
       (try_end),
	   #try again with all lords if no female companions available
	   (eq, "$g_wedding_brides_dad_troop", "trp_temporary_minister"),
	   (assign, ":best_score", -100),#best score
       (try_for_range, ":cur_npc", heroes_begin, heroes_end),
	     (neg|troop_slot_eq, ":cur_npc", slot_troop_met, 0),

 	     (this_or_next|troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_kingdom_seneschal),
         (this_or_next|troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_player_companion),
		 (this_or_next|troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_kingdom_lady),
			(troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_kingdom_hero),

         (neq, ":cur_npc", "$g_wedding_groom_troop"),
         (neq, ":cur_npc", "$g_wedding_bishop_troop"),
		 (neq, ":cur_npc", "trp_knight_1_1_wife"),
	 	 (neq, ":cur_npc", "trp_kingdom_heroes_including_player_begin"),

		 (call_script, "script_troop_get_player_relation", ":cur_npc"),
		 (assign, ":score", reg0),
		 (ge, ":score", 0),
		 (call_script, "script_dplmc_is_affiliated_family_member", ":cur_npc"),
		 (this_or_next|ge, ":score", 20),
			(ge, reg0, 1),
		 (gt, ":score", ":best_score"),
		 (assign, ":best_score", ":score"),
         (assign, "$g_wedding_brides_dad_troop", ":cur_npc"),
       (try_end),
       ##diplomacy end+
     (try_end),

     (modify_visitors_at_site,"scn_wedding"),
     (reset_visitors,0),
     (set_visitor, 0, "$g_wedding_groom_troop"),
     (set_visitor, 1, "$g_wedding_bride_troop"),
     (set_visitor, 2, "$g_wedding_brides_dad_troop"),
     (set_visitor, 3, "$g_wedding_bishop_troop"),
     (assign, ":num_visitors", 4),
     (assign, ":num_male_visitors", 0),
	 ##diplomacy start+
	 (store_troop_faction, ":groom_faction", "$g_wedding_groom_troop"),
	 (store_troop_faction, ":bride_faction", "$g_wedding_bride_troop"),
	 ##diplomacy end+
     (try_for_range, ":cur_npc", active_npcs_begin, kingdom_ladies_end),
       (lt, ":num_visitors", 32),
       (neq, ":cur_npc", "$g_wedding_groom_troop"),
       (neq, ":cur_npc", "$g_wedding_bride_troop"),
       (neq, ":cur_npc", "$g_wedding_brides_dad_troop"),
       (neq, ":cur_npc", "$g_wedding_bishop_troop"),
       (store_troop_faction, ":npc_faction", ":cur_npc"),
	   ##diplomacy start+
       #(is_between, ":npc_faction", kingdoms_begin, kingdoms_end),
       #(eq, ":npc_faction", "$players_kingdom"),
	   (this_or_next|eq, ":groom_faction", ":npc_faction"),
	      (eq, ":bride_faction", ":npc_faction"),
       ##diplomacy end+
       (this_or_next|troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_player_companion),
       (this_or_next|troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_kingdom_hero),
       (troop_slot_eq, ":cur_npc", slot_troop_occupation, slto_kingdom_lady),
	   ##diplomacy start+
       #(troop_get_type, ":troop_type", ":cur_npc"),
	   (call_script, "script_dplmc_store_troop_is_female", ":cur_npc"),
	   (assign, ":troop_type", reg0),
	   ##diplomacy end+
       (assign, ":continue_adding", 1),
       (try_begin),
         (eq, ":troop_type", 0),
         (assign, ":continue_adding", 0),
         (lt, ":num_male_visitors", 16), #limit number of male visitors
         (assign, ":continue_adding", 1),
         (val_add, ":num_male_visitors", 1),
       (try_end),
       (eq, ":continue_adding", 1),
       (set_visitor, ":num_visitors", ":cur_npc"),
       (val_add, ":num_visitors", 1),
     (try_end),
	 ##diplomacy start+
	 (assign, reg0, ":save_reg0"),
	 (assign, reg1, ":save_reg1"),
	 ##diplomacy end+
     (set_jump_mission,"mt_wedding"),
     (jump_to_scene,"scn_wedding"),
     (change_screen_mission),
    ]),


  # script_game_get_troop_wage
  # This script is called from the game engine for calculating troop wages.
  # Input:
  # param1: troop_id, param2: party-id
  # Output: reg0: weekly wage

  ("game_get_troop_wage",
    [
      (store_script_param_1, ":troop_id"),
      (store_script_param_2, ":unused"), #party id

      (assign,":wage", 0),
      (try_begin),
        (this_or_next|eq, ":troop_id", "trp_player"),
        (eq, ":troop_id", "trp_kidnapped_girl"),
      (else_try),
        (is_between, ":troop_id", pretenders_begin, pretenders_end),
      ##diplomacy start+
      (else_try),
      #Temporarily joined lords and ladies don't require wages.
        (is_between, ":troop_id", heroes_begin, heroes_end),
        (this_or_next|troop_slot_eq, ":troop_id", slot_troop_playerparty_history,dplmc_pp_history_lord_rejoined),
        (this_or_next|troop_slot_eq, ":troop_id", slot_troop_occupation, slto_kingdom_hero),
           (troop_slot_eq, ":troop_id",slot_troop_occupation, slto_kingdom_lady),
      ##diplomacy end+
      (else_try),
        (store_character_level, ":troop_level", ":troop_id"),
        (assign, ":wage", ":troop_level"),
        (val_add, ":wage", 3),
        (val_mul, ":wage", ":wage"),
        (val_div, ":wage", 25),
      (try_end),

      (try_begin), #mounted troops cost 65% more than the normal cost
        (neg|is_between, ":troop_id", companions_begin, companions_end),
        (troop_is_mounted, ":troop_id"),
        (val_mul, ":wage", 5),
        (val_div, ":wage", 3),
      (try_end),

      (try_begin), #mercenaries cost %50 more than the normal cost
        (is_between, ":troop_id", mercenary_troops_begin, mercenary_troops_end),
        (val_mul, ":wage", 3),
        (val_div, ":wage", 2),
      (try_end),

      (try_begin),
        (is_between, ":troop_id", companions_begin, companions_end),
        (val_mul, ":wage", 2),
      (try_end),

      (store_skill_level, ":leadership_level", "skl_leadership", "trp_player"),
      (store_mul, ":leadership_bonus", 5, ":leadership_level"),
      (store_sub, ":leadership_factor", 100, ":leadership_bonus"),
      (val_mul, ":wage", ":leadership_factor"),  #wage = wage * (100 - 5*leadership)/100
	  (val_div, ":wage", 100),

      (try_begin),
        (neq, ":troop_id", "trp_player"),
        (neq, ":troop_id", "trp_kidnapped_girl"),
        (neg|is_between, ":troop_id", pretenders_begin, pretenders_end),
          ##diplomacy start+ For temporarily rejoined lords, and temporarily joined ladies
        (neg|troop_slot_eq, ":troop_id", slot_troop_playerparty_history,dplmc_pp_history_lord_rejoined),
        (neg|troop_slot_eq, ":troop_id", slot_troop_occupation, slto_kingdom_hero),
        (neg|is_between, ":troop_id", kingdom_ladies_begin, kingdom_ladies_end),
          ##diplomacy end+
        (val_max, ":wage", 1),
      (try_end),

      (assign, reg0, ":wage"),
      (set_trigger_result, reg0),
  ]),

  # script_game_get_total_wage
  # This script is called from the game engine for calculating total wage of the player party which is shown at the party window.
  # Input: none
  # Output: reg0: weekly wage

  ("game_get_total_wage",
    [
      (assign, ":total_wage", 0),
      (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", "p_main_party", ":i_stack"),
        (party_stack_get_size, ":stack_size", "p_main_party", ":i_stack"),
        (call_script, "script_game_get_troop_wage", ":stack_troop", 0),
        (val_mul, reg0, ":stack_size"),
        (val_add, ":total_wage", reg0),
      (try_end),
	  ##diplomacy start+
	  #If the player leads a kingdom, take into account centralization.
	  (faction_get_slot, ":centralization", "$players_kingdom", dplmc_slot_faction_centralization),
	  (try_begin),
		  (neq, ":centralization", 0),

		  (assign, reg0, 0),
	     (try_begin),
		     (is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
		     (faction_get_slot, ":faction_leader", "$players_kingdom", slot_faction_leader),
		     (ge, ":faction_leader", 0),
		     (this_or_next|eq, ":faction_leader", "trp_player"),
		     (this_or_next|troop_slot_eq, ":faction_leader", slot_troop_spouse, "trp_player"),
              (troop_slot_eq, "trp_player", slot_troop_spouse, reg0),
           (assign, reg0, 1),
        (try_end),

		  (this_or_next|eq, reg0, 1),
		     (eq, "$players_kingdom", "fac_player_supporters_faction"),
		  (faction_slot_eq, "$players_kingdom", slot_faction_state, sfs_active),

		  #Apply centralization, but limit it for nascent kingdoms
        (val_clamp, ":centralization", -3, 4),
	     (faction_get_slot, ":policy_limit", "$players_kingdom", slot_faction_num_towns),
	     (faction_get_slot, reg0, "$players_kingdom", slot_faction_num_castles),
	     (val_add, ":policy_limit", reg0),

	     (val_max, ":policy_limit", 0),
	     (val_min, ":centralization", ":policy_limit"),
	     (val_mul, ":policy_limit", -1),
	     (val_max, ":centralization", ":policy_limit"),

		  #Now reg0 is going to be the result again
		  (store_mul, reg0, ":centralization", -5),
		  (val_add, reg0, 100),
		  (val_mul, reg0, ":total_wage"),
		  (val_add, reg0, 50),#rounding
		  (val_div, reg0, 100),
	  (try_end),
    ##diplomacy end+
      (assign, reg0, ":total_wage"),
      (set_trigger_result, reg0),
  ]),

  # script_game_get_join_cost
  # This script is called from the game engine for calculating troop join cost.
  # Input:
  # param1: troop_id,
  # Output: reg0: weekly wage

  ("game_get_join_cost",
    [
      (store_script_param_1, ":troop_id"),

      (assign,":join_cost", 0),
      (try_begin),
        (troop_is_hero, ":troop_id"),
      (else_try),
        (store_character_level, ":troop_level", ":troop_id"),
        (store_add, ":join_cost", ":troop_level", 5),
        (val_mul, ":join_cost", ":join_cost"),
        (val_add, ":join_cost", 40),
        (val_div, ":join_cost", 5),
        (try_begin), #mounted troops cost %100 more than the normal cost
          (troop_is_mounted, ":troop_id"),
          (val_mul, ":join_cost", 2),
        (try_end),
      (try_end),
      (assign, reg0, ":join_cost"),
      (set_trigger_result, reg0),
  ]),

  # script_game_get_upgrade_xp
  # This script is called from game engine for calculating needed troop upgrade exp
  # Input:
  # param1: troop_id,
  # Output: reg0 = needed exp for upgrade
  ("game_get_upgrade_xp",
    [
      (store_script_param_1, ":troop_id"),

      (assign, ":needed_upgrade_xp", 0),
      #formula : int needed_upgrade_xp = 2 * (30 + 0.006f * level_boundaries[troops[troop_id].level + 3]);
      (store_character_level, ":troop_level", ":troop_id"),
      (store_add, ":needed_upgrade_xp", ":troop_level", 3),
      (get_level_boundary, reg0, ":needed_upgrade_xp"),
      (val_mul, reg0, 6),
      (val_div, reg0, 1000),
      (val_add, reg0, 30),

      (try_begin), #SB : merge range
        (is_between, ":troop_id", bandits_begin, bandits_end),
        (val_mul, reg0, 2),
      (try_end),

      (set_trigger_result, reg0),
  ]),

  # script_game_get_upgrade_cost
  # This script is called from game engine for calculating needed troop upgrade exp
  # Input:
  # param1: troop_id,
  # Output: reg0 = needed cost for upgrade
  ("game_get_upgrade_cost",
    [
      (store_script_param_1, ":troop_id"),

      (store_character_level, ":troop_level", ":troop_id"),

      (try_begin),
        (is_between, ":troop_level", 0, 6),
        (assign, reg0, 10),
      (else_try),
        (is_between, ":troop_level", 6, 11),
        (assign, reg0, 20),
      (else_try),
        (is_between, ":troop_level", 11, 16),
        (assign, reg0, 40),
      (else_try),
        (is_between, ":troop_level", 16, 21),
        (assign, reg0, 80),
      (else_try),
        (is_between, ":troop_level", 21, 26),
        (assign, reg0, 120),
      (else_try),
        (is_between, ":troop_level", 26, 31),
        (assign, reg0, 160),
      (else_try),
        (assign, reg0, 200),
      (try_end),

      (set_trigger_result, reg0),
  ]),

  # script_game_get_prisoner_price
  # This script is called from the game engine for calculating prisoner price
  # Input:
  # param1: troop_id,
  # Output: reg0
  ("game_get_prisoner_price",
    [
      (store_script_param_1, ":troop_id"),

      (try_begin), #SB : regular prices for constable selling
        (this_or_next|eq, "$g_talk_troop", "$g_player_constable"),
        (is_between, "$g_talk_troop", ransom_brokers_begin, ransom_brokers_end),
        (store_character_level, ":troop_level", ":troop_id"),
        (store_add, ":ransom_amount", ":troop_level", 10),
        # (val_add, ":ransom_amount", 10),
        (val_mul, ":ransom_amount", ":ransom_amount"),
        (val_div, ":ransom_amount", 6),
      (else_try),
        # (eq, "$g_talk_troop", "trp_brothel_madam"),
        # (assign, ":ransom_amount", 0),
      # (else_try),
        (assign, ":ransom_amount", 100),
      (try_end),

      (assign, reg0, ":ransom_amount"),

      (set_trigger_result, reg0),
  ]),


  # script_game_check_prisoner_can_be_sold
  # This script is called from the game engine for checking if a given troop can be sold.
  # Input:
  # param1: troop_id,
  # Output: reg0: 1= can be sold; 0= cannot be sold.

  ("game_check_prisoner_can_be_sold",
    [
      (store_script_param_1, ":troop_id"),
      (assign, reg0, 0),
      (try_begin),
        (neg|troop_is_hero, ":troop_id"),
        (try_begin),
          (check_quest_active, "qst_hunt_down_fugitive"),
          (eq, ":troop_id", "trp_fugitive"), #SB : can't sell quest troops
          (assign, reg0, 0),
        (else_try),
          (check_quest_active, "qst_hunt_down_fugitive"),
          (this_or_next|eq, ":troop_id", "trp_spy"),
          (eq, ":troop_id", "trp_spy_partner"),
          (assign, reg0, 0),
        (else_try),
          (assign, reg0, 1),
        (try_end),
      (try_end),

      #sell women only
      # (try_begin),
          # (eq, "$g_talk_troop", "trp_brothel_madam"),
          # (call_script, "script_dplmc_store_troop_is_female_reg", ":troop_id", 65),
          # (assign, ":is_female", reg65),
          # (neq, ":is_female", 1),
          # (assign, reg0, 0),
      # (try_end),

      (set_trigger_result, reg0),
  ]),

  # script_game_get_morale_of_troops_from_faction
  # This script is called from the game engine
  # Input:
  # param1: faction_no,
  # Output: reg0: extra morale x 100

  ("game_get_morale_of_troops_from_faction",
    [
      (store_script_param_1, ":troop_no"),

      (store_troop_faction, ":faction_no", ":troop_no"),

      (try_begin),
        (is_between, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),

        (faction_get_slot, reg0, ":faction_no",  slot_faction_morale_of_player_troops),

        #(assign, reg1, ":faction_no"),
        #(assign, reg2, ":troop_no"),
        #(assign, reg3, reg0),
        #(display_message, "@extra morale for troop {reg2} of faction {reg1} is {reg3}"),
      (else_try),
        (assign, reg0, 0),
      (try_end),
      ##diplomacy start+
      #If there is no current morale penalty, then there will be a minor morale bonus
		#if the player has his own faction and his culture matches the source kingdom.
		(try_begin),
		   (eq, reg0, 0),
			(is_between,"$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
			(eq, "$g_player_culture", ":faction_no"),
			#xxx TODO: pick a number less arbitrarily
			(assign, reg0, 100),
		(try_end),
      ##diplomacy end+
      (val_div, reg0, 100),

      (party_get_morale, reg1, "p_main_party"),

      (val_add, reg0, reg1),

      (set_trigger_result, reg0),
  ]),

  #script_game_event_detect_party:
  # This script is called from the game engine when player party inspects another party.
  # INPUT:
  # param1: Party-id
  ("game_event_detect_party",
    [
        (store_script_param_1, ":party_id"),
        (try_begin),
          (party_slot_eq, ":party_id", slot_party_type, spt_kingdom_hero_party),
          (party_stack_get_troop_id, ":leader", ":party_id", 0),
          ##diplomacy start+ support for promoted kingdom ladies
          (is_between, ":leader", heroes_begin, heroes_end),
          (this_or_next|troop_slot_eq, ":leader", slot_troop_occupation, slto_kingdom_hero),
          ##diplomacy end+
          (is_between, ":leader", active_npcs_begin, active_npcs_end),
          (call_script, "script_update_troop_location_notes", ":leader", 0),
        (else_try),
          (is_between, ":party_id", walled_centers_begin, walled_centers_end),
          (party_get_num_attached_parties, ":num_attached_parties",  ":party_id"),
          (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
            (party_get_attached_party_with_rank, ":attached_party", ":party_id", ":attached_party_rank"),
            (party_stack_get_troop_id, ":leader", ":attached_party", 0),
			##diplomacy start+ support for promoted kingdom ladies
			(is_between, ":leader", heroes_begin, heroes_end),
			(this_or_next|troop_slot_eq, ":leader", slot_troop_occupation, slto_kingdom_hero),
			##diplomacy end+
            (is_between, ":leader", active_npcs_begin, active_npcs_end),
            (call_script, "script_update_troop_location_notes", ":leader", 0),
          (try_end),
        (try_end),
  ]),

  #script_game_event_undetect_party:
  # This script is called from the game engine when player party inspects another party.
  # INPUT:
  # param1: Party-id
  ("game_event_undetect_party",
    [
        (store_script_param_1, ":party_id"),
        (try_begin),
          (party_slot_eq, ":party_id", slot_party_type, spt_kingdom_hero_party),
          (party_stack_get_troop_id, ":leader", ":party_id", 0),
          ##diplomacy start+ support for promoted kingdom ladies
          (is_between, ":leader", heroes_begin, heroes_end),
          (this_or_next|troop_slot_eq, ":leader", slot_troop_occupation, slto_kingdom_hero),
          ##diplomacy end+
          (is_between, ":leader", active_npcs_begin, active_npcs_end),
          (call_script, "script_update_troop_location_notes", ":leader", 0),
        (try_end),
  ]),

  #script_game_get_statistics_line:
  # This script is called from the game engine when statistics page is opened.
  # INPUT:
  # param1: line_no
  ("game_get_statistics_line",
    [
      (store_script_param_1, ":line_no"),
      (try_begin),
        (eq, ":line_no", 0),
        (get_player_agent_kill_count, reg1),
        (str_store_string, s1, "str_number_of_troops_killed_reg1"),
        (set_result_string, s1),
      (else_try),
        (eq, ":line_no", 1),
        (get_player_agent_kill_count, reg1, 1),
        (str_store_string, s1, "str_number_of_troops_wounded_reg1"),
        (set_result_string, s1),
      (else_try),
        (eq, ":line_no", 2),
        (get_player_agent_own_troop_kill_count, reg1),
        (str_store_string, s1, "str_number_of_own_troops_killed_reg1"),
        (set_result_string, s1),
      (else_try),
        (eq, ":line_no", 3),
        (get_player_agent_own_troop_kill_count, reg1, 1),
        (str_store_string, s1, "str_number_of_own_troops_wounded_reg1"),
        (set_result_string, s1),
      (try_end),
  ]),

 #script_game_get_date_text:
  # This script is called from the game engine when the date needs to be displayed.
  # INPUT: arg1 = number of days passed since the beginning of the game
  # OUTPUT: result string = date
  ("game_get_date_text",
    [
		(store_script_param_1, ":version"),
      (store_script_param_2, ":num_hours"),
      (store_div, ":num_days", ":num_hours", 24),
      (store_add, ":cur_day", ":num_days", 23),
      (assign, ":cur_month", 3),
      (assign, ":cur_year", 1257),
      (assign, ":try_range", 99999),
      (try_for_range, ":unused", 0, ":try_range"),
        (try_begin),
          (this_or_next|eq, ":cur_month", 1),
          (this_or_next|eq, ":cur_month", 3),
          (this_or_next|eq, ":cur_month", 5),
          (this_or_next|eq, ":cur_month", 7),
          (this_or_next|eq, ":cur_month", 8),
          (this_or_next|eq, ":cur_month", 10),
          (eq, ":cur_month", 12),
          (assign, ":month_day_limit", 31),
        (else_try),
          (this_or_next|eq, ":cur_month", 4),
          (this_or_next|eq, ":cur_month", 6),
          (this_or_next|eq, ":cur_month", 9),
          (eq, ":cur_month", 11),
          (assign, ":month_day_limit", 30),
        (else_try),
          (try_begin),
            (store_div, ":cur_year_div_4", ":cur_year", 4),
            (val_mul, ":cur_year_div_4", 4),
            (eq, ":cur_year_div_4", ":cur_year"),
            (assign, ":month_day_limit", 29),
          (else_try),
            (assign, ":month_day_limit", 28),
          (try_end),
        (try_end),
        (try_begin),
          (gt, ":cur_day", ":month_day_limit"),
          (val_sub, ":cur_day", ":month_day_limit"),
          (val_add, ":cur_month", 1),
          (try_begin),
            (gt, ":cur_month", 12),
            (val_sub, ":cur_month", 12),
            (val_add, ":cur_year", 1),
          (try_end),
        (else_try),
          (assign, ":try_range", 0),
        (try_end),
      (try_end),
      (assign, reg1, ":cur_day"),
      (assign, reg2, ":cur_year"),
      (store_time_of_day, reg3), ## CC
	  (try_begin),
		(this_or_next|eq, ":version", 1),
		(try_begin),
			(eq, ":cur_month", 1),
			(str_store_string, s1, "str_january_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 2),
			(str_store_string, s1, "str_february_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 3),
			(str_store_string, s1, "str_march_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 4),
			(str_store_string, s1, "str_april_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 5),
			(str_store_string, s1, "str_may_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 6),
			(str_store_string, s1, "str_june_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 7),
			(str_store_string, s1, "str_july_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 8),
			(str_store_string, s1, "str_august_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 9),
			(str_store_string, s1, "str_september_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 10),
			(str_store_string, s1, "str_october_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 11),
			(str_store_string, s1, "str_november_reg1_reg2_v2"),
		  (else_try),
			(eq, ":cur_month", 12),
			(str_store_string, s1, "str_december_reg1_reg2_v2"),
		  (try_end),
		(else_try),
		  (try_begin),
			(eq, ":cur_month", 1),
			(str_store_string, s1, "str_january_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 2),
			(str_store_string, s1, "str_february_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 3),
			(str_store_string, s1, "str_march_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 4),
			(str_store_string, s1, "str_april_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 5),
			(str_store_string, s1, "str_may_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 6),
			(str_store_string, s1, "str_june_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 7),
			(str_store_string, s1, "str_july_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 8),
			(str_store_string, s1, "str_august_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 9),
			(str_store_string, s1, "str_september_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 10),
			(str_store_string, s1, "str_october_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 11),
			(str_store_string, s1, "str_november_reg1_reg2"),
		  (else_try),
			(eq, ":cur_month", 12),
			(str_store_string, s1, "str_december_reg1_reg2"),
		  (try_end),
		(try_end),
      (set_result_string, s1),
  ]),

  #script_game_get_money_text:
  # This script is called from the game engine when an amount of money needs to be displayed.
  # INPUT: arg1 = amount in units
  # OUTPUT: result string = money in text
  ("game_get_money_text",
    [
      (store_script_param_1, ":amount"),
      (try_begin),
        (eq, ":amount", 1),
        (str_store_string, s1, "str_1_denar"),
      (else_try),
        (assign, reg1, ":amount"),
        (str_store_string, s1, "str_reg1_denars"),
      (try_end),
      (set_result_string, s1),
  ]),

  #script_game_get_party_companion_limit:
  # This script is called from the game engine when the companion limit is needed for a party.
  # INPUT: arg1 = none
  # OUTPUT: reg0 = companion_limit
  ("game_get_party_companion_limit",
    [
      (assign, ":troop_no", "trp_player"),

      (assign, ":limit", 30),
      (store_skill_level, ":skill", "skl_leadership", ":troop_no"),
      (store_attribute_level, ":charisma", ":troop_no", ca_charisma),
      (val_mul, ":skill", 5),
      (val_add, ":limit", ":skill"),
      (val_add, ":limit", ":charisma"),

      #SB : possibly inherit half of spouse's renown
      (troop_get_slot, ":troop_renown", ":troop_no", slot_troop_renown),
      (store_div, ":renown_bonus", ":troop_renown", 25),
      (val_add, ":limit", ":renown_bonus"),

      #SB : add non-standard size modifiers here
      (try_begin),
        (eq, ":troop_no", "trp_player"),
        (is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
        (try_begin),
          (faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
          (store_mul, ":king_bonus", "$player_right_to_rule", 5),
          (val_clamp, ":king_bonus", dplmc_marshal_party_bonus, dplmc_monarch_party_bonus + 1), #to match marshal amount
          (val_add, ":limit", ":king_bonus"),
        (try_end),
        (try_begin),
          (faction_slot_eq, "$players_kingdom", slot_faction_marshall, "trp_player"),
          (val_add, ":limit", dplmc_marshal_party_bonus),
        (try_end),
        #party takes additional 20 limit per each castle its party leader owns
        (try_for_range, ":cur_center", castles_begin, castles_end),
          (party_slot_eq, ":cur_center", slot_town_lord, "trp_player"),
          (val_add, ":limit", dplmc_castle_party_bonus),
        (try_end),

        ##diplomacy begin
        (assign, ":percent", 100),
        (assign, ":policy_min", -3),
        (assign, ":policy_max", 4),

        (try_begin),
            (this_or_next|eq, "$players_kingdom", "fac_player_supporters_faction"),
                (faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
            (faction_get_slot, ":policy_max", "$players_kingdom", slot_faction_num_towns),
            (faction_get_slot, reg0, "$players_kingdom", slot_faction_num_castles),
            (val_add, ":policy_max", reg0),
            (val_clamp, ":policy_max", 0, 4),#0, 1, 2, 3
            (store_mul, ":policy_min", ":policy_max", -1),
            (val_add, ":policy_max", 1),#one greater than the maximum
        (try_end),
        ##diplomacy end+

        (try_begin),
          (faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
          # (val_add, ":limit", "$player_right_to_rule"),
          (try_begin),
            (faction_get_slot, ":centralization", "$players_kingdom", dplmc_slot_faction_centralization),
            (neq, ":centralization", 0),
            (val_clamp, ":centralization", ":policy_min", ":policy_max"),
            (val_mul, ":centralization", 10),
            (val_add, ":percent", ":centralization"),
          (try_end),

        (else_try),
          (try_begin),
            (faction_get_slot, ":centralization", "$players_kingdom", dplmc_slot_faction_centralization),
            (neq, ":centralization", 0),
            (val_clamp, ":centralization", ":policy_min", ":policy_max"),
            (val_mul, ":centralization", -3),
            (val_add, ":percent", ":centralization"),
          (try_end),
          (try_begin),
            (faction_get_slot, ":aristocracy", "$players_kingdom", dplmc_slot_faction_aristocracy),
            (neq, ":aristocracy", 0),
            (val_clamp, ":aristocracy", ":policy_min", ":policy_max"),
            (val_mul, ":aristocracy", 3),
            (val_add, ":percent", ":aristocracy"),
          (try_end),
          (try_begin),
            (faction_get_slot, ":quality", "$players_kingdom", dplmc_slot_faction_quality),
            (neq, ":quality", 0),
            (val_clamp, ":quality", ":policy_min", ":policy_max"),
            (val_mul, ":quality", -4),
            (val_add, ":percent", ":quality"),
          (try_end),
        (try_end),

        (try_begin),
          (faction_get_slot, ":serfdom", "$players_kingdom", dplmc_slot_faction_serfdom),
          (neq, ":serfdom", 0),
          (val_clamp, ":serfdom", ":policy_min", ":policy_max"),
          (val_mul, ":serfdom", 2),
          (val_add, ":percent", ":serfdom"),
        (try_end),

        (val_mul, ":limit", ":percent"),
        ##nested diplomacy start+ Round correctly
        (val_add, ":limit", 50),
        ##nested diplomacy end+
        (val_div, ":limit", 100),
        ##diplomacy end
      (try_end),

      (assign, reg0, ":limit"),
      (set_trigger_result, reg0),
  ]),


  #script_game_reset_player_party_name:
  # This script is called from the game engine when the player name is changed.
  # INPUT: none
  # OUTPUT: none
  ("game_reset_player_party_name",
    [(str_store_troop_name, s5, "trp_player"),
     (party_set_name, "p_main_party", s5),
     ]),

  #script_game_get_troop_note
  # This script is called from the game engine when the notes of a troop is needed.
  # INPUT: arg1 = troop_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_troop_note",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":note_index"),
      (set_trigger_result, 0),

      (str_store_troop_name, s54, ":troop_no"),
      (try_begin),
        (eq, ":troop_no", "trp_player"),
        (this_or_next|eq, "$player_has_homage", 1),
        (eq, "$players_kingdom", "fac_player_supporters_faction"),
        (assign, ":troop_faction", "$players_kingdom"),
      (else_try),
        (store_troop_faction, ":troop_faction", ":troop_no"),
      (try_end),
      (str_clear, s49),

	  #Family notes
      (try_begin),
	    ##diplomacy start+ add support for displaying relations with kings and claimants
		#(this_or_next|is_between, ":troop_no", lords_begin, kingdom_ladies_end),
        #(eq, ":troop_no", "trp_player"),
        #(neg|is_between, ":troop_no", pretenders_begin, pretenders_end),

		(this_or_next|eq, ":troop_no", "trp_player"),
		(this_or_next|is_between, ":troop_no", lords_begin, kingdom_ladies_end),#includes pretenders
			(is_between, ":troop_no", kings_begin, kings_end),

		##The following would only show relations for kings and claimants if they are married.
        #(this_or_next|troop_slot_ge, ":troop_no", slot_troop_spouse, 0),
		#	(neg|is_between, ":troop_no", pretenders_begin, pretenders_end),
		#(this_or_next|troop_slot_ge, ":troop_no", slot_troop_spouse, 0),
		#	(neg|is_between, ":troop_no", kings_begin, kings_end),

		##diplomacy end+
        (assign, ":num_relations", 0),

        (try_begin),
          (call_script, "script_troop_get_family_relation_to_troop", "trp_player", ":troop_no"),
          (gt, reg0, 0),
          (val_add, ":num_relations", 1),
        (try_end),
		##diplomacy start+
        #(try_for_range, ":aristocrat", lords_begin, kingdom_ladies_end),
		#Display relations with kings and claimants
		(try_for_range, ":aristocrat", heroes_begin, heroes_end),
		  (this_or_next|is_between, ":aristocrat", lords_begin, kingdom_ladies_end),#includes pretenders
			  (is_between, ":aristocrat", kings_begin, kings_end),
		##diplomacy end+
          (call_script, "script_troop_get_family_relation_to_troop", ":aristocrat", ":troop_no"),
          (gt, reg0, 0),
          (val_add, ":num_relations", 1),
        (try_end),
        (try_begin),
          (gt, ":num_relations", 0),
          (try_begin),
            (eq, ":troop_no", "trp_player"),
            (str_store_string, s49, "str__family_"),
          (else_try),
            (troop_get_slot, reg1, ":troop_no", slot_troop_age),
            (str_store_string, s49, "str__age_reg1_family_"),
          (try_end),
          (try_begin),
            (call_script, "script_troop_get_family_relation_to_troop", "trp_player", ":troop_no"),
            (gt, reg0, 0),
            (str_store_troop_name_link, s12, "trp_player"),
            (val_sub, ":num_relations", 1),
            (try_begin),
              (eq, ":num_relations", 0),
              (str_store_string, s49, "str_s49_s12_s11_end"),
            (else_try),
              (str_store_string, s49, "str_s49_s12_s11"),
            (try_end),
          (try_end),
		  ##diplomacy start+
          #(try_for_range, ":aristocrat", lords_begin, kingdom_ladies_end),
		  #Display relations with kings and claimants
		  (try_for_range, ":aristocrat", heroes_begin, heroes_end),
		    (this_or_next|is_between, ":aristocrat", lords_begin, kingdom_ladies_end),#includes pretenders
			   (is_between, ":aristocrat", kings_begin, kings_end),
		  ##diplomacy end+
            (call_script, "script_troop_get_family_relation_to_troop", ":aristocrat", ":troop_no"),
            (gt, reg0, 0),
            (try_begin),
              (neg|is_between, ":aristocrat", kingdom_ladies_begin, kingdom_ladies_end),
              (eq, "$cheat_mode", 1),
              (str_store_troop_name_link, s12, ":aristocrat"),
              (call_script, "script_troop_get_relation_with_troop", ":aristocrat", ":troop_no"),
              (str_store_string, s49, "str_s49_s12_s11_rel_reg0"),
            (else_try),
              (str_store_troop_name_link, s12, ":aristocrat"),
              (val_sub, ":num_relations", 1),
              (try_begin),
                (eq, ":num_relations", 0),
                (str_store_string, s49, "str_s49_s12_s11_end"),
              (else_try),
                (str_store_string, s49, "str_s49_s12_s11"),
              (try_end),
            (try_end),
          (try_end),
        (try_end),
      (try_end),

      (try_begin),
        (neq, ":troop_no", "trp_player"),
        (neg|is_between, ":troop_faction", kingdoms_begin, kingdoms_end),
        (neg|is_between, ":troop_no", companions_begin, companions_end),
        (neg|is_between, ":troop_no", pretenders_begin, pretenders_end),

        (try_begin),
          (eq, ":note_index", 0),
          (str_store_string, s0, "str_s54_has_left_the_realm"),
          ##diplomacy start+
          #Check for "deceased" instead
          (try_begin),
             (troop_slot_eq, ":troop_no", slot_troop_occupation, dplmc_slto_dead),
             (str_store_string, s0, "str_s54_is_deceased"),
          (try_end),
          ##diplomacy end+
          (set_trigger_result, 1),
        (else_try),
          (str_clear, s0),
          (this_or_next|eq, ":note_index", 1),
          (eq, ":note_index", 2),
          (set_trigger_result, 1),
        (try_end),

      (else_try),
        (is_between, ":troop_no", companions_begin, companions_end),
        (neg|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
        (eq, ":note_index", 0),
        (set_trigger_result, 1),
        (str_clear, s0),
        (assign, ":companion", ":troop_no"),
        (str_store_troop_name, s4, ":companion"),
        (try_begin),
			# (troop_get_slot, ":days_left", ":companion", slot_troop_days_on_mission),

			(this_or_next|main_party_has_troop, ":companion"),
			(this_or_next|troop_slot_ge, ":companion", slot_troop_current_mission, 1),
				(eq, "$g_player_minister", ":companion"),
            #SB : replace the call
            (call_script, "script_companion_get_mission_string", ":companion"),

			# (try_begin),
				# (troop_slot_eq, ":companion", slot_troop_current_mission, npc_mission_kingsupport),
				# (str_store_string, s8, "str_gathering_support"),
				# (try_begin),
					# (eq, ":days_left", 1),
					# (str_store_string, s5, "str_expected_back_imminently"),
				# (else_try),
					# (assign, reg3, ":days_left"),
					# (str_store_string, s5, "str_expected_back_in_approximately_reg3_days"),
				# (try_end),
			# (else_try),
				# (troop_slot_eq, ":companion", slot_troop_current_mission, npc_mission_gather_intel),
				# (troop_get_slot, ":town_with_contacts", ":companion", slot_troop_town_with_contacts),
				# (str_store_party_name, s11, ":town_with_contacts"),

				# (str_store_string, s8, "str_gathering_intelligence"),
				# (try_begin),
					# (eq, ":days_left", 1),
					# (str_store_string, s5, "str_expected_back_imminently"),
				# (else_try),
					# (assign, reg3, ":days_left"),
					# (str_store_string, s5, "str_expected_back_in_approximately_reg3_days"),
				# (try_end),
			# (else_try),

				# (troop_slot_ge, ":companion", slot_troop_current_mission, npc_mission_peace_request),
				# (neg|troop_slot_ge, ":companion", slot_troop_current_mission, npc_mission_rejoin_when_possible), #SB : replace hard constant 8

				# (troop_get_slot, ":faction", ":companion", slot_troop_mission_object),
				# (str_store_faction_name, s9, ":faction"),
				# (str_store_string, s8, "str_diplomatic_embassy_to_s9"),
				# (try_begin),
					# (eq, ":days_left", 1),
					# (str_store_string, s5, "str_expected_back_imminently"),
				# (else_try),
					# (assign, reg3, ":days_left"),
					# (str_store_string, s5, "str_expected_back_in_approximately_reg3_days"),
				# (try_end),
			# (else_try),
				# (eq, ":companion", "$g_player_minister"),
				# (str_store_string, s8, "str_serving_as_minister"),
				# (str_store_party_name, s9, "$g_player_court"),
				# (is_between, "$g_player_court", centers_begin, centers_end),
				# (str_store_string, s5, "str_in_your_court_at_s9"),
			# (else_try),
				# (eq, ":companion", "$g_player_minister"),
				# (str_store_string, s8, "str_serving_as_minister"),
				# (str_store_string, s5, "str_awaiting_the_capture_of_a_fortress_which_can_serve_as_your_court"),
			# (else_try),
				# (main_party_has_troop, ":companion"),
				# (str_store_string, s8, "str_under_arms"),
				# (str_store_string, s5, "str_in_your_party"),
			# (try_end),

			# (str_store_string, s0, "str_s4_s8_s5"),
		##diplomacy start+
		#Check for explicit "exiled" and "dead" settings
		(else_try),
			(troop_slot_eq, ":troop_no", slot_troop_occupation, dplmc_slto_dead),
			(str_store_string, s0, "str_s54_is_deceased"),
		(else_try),
			(troop_slot_eq, ":troop_no", slot_troop_occupation, dplmc_slto_exile),
			(str_store_string, s0, "str_s54_has_left_the_realm"),
		##diplomacy end+
		(else_try),
			(str_store_string, s0, "str_whereabouts_unknown"),
		(try_end),


      (else_try),
        (is_between, ":troop_no", pretenders_begin, pretenders_end),
        (neg|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
        (neq, ":troop_no", "$supported_pretender"),


        (troop_get_slot, ":orig_faction", ":troop_no", slot_troop_original_faction),
        (try_begin),
          (faction_slot_eq, ":orig_faction", slot_faction_state, sfs_active),
          (faction_slot_eq, ":orig_faction", slot_faction_has_rebellion_chance, 1),
          (try_begin),
            (eq, ":note_index", 0),
            (str_store_faction_name_link, s56, ":orig_faction"),
            ##diplomacy start+ xxx Removed third argument (was it doing anything?)
            #(str_store_string, s0, "@{s54} is a claimant to the throne of {s56}.", 0),
            (str_store_string, s0, "@{s54} is a claimant to the throne of {s56}."),
            ##diplomacy end+
            (set_trigger_result, 1),
          (try_end),
        (else_try),
          (try_begin),
            (str_clear, s0),
            (this_or_next|eq, ":note_index", 0),
            (this_or_next|eq, ":note_index", 1),
            (eq, ":note_index", 2),
            (set_trigger_result, 1),
          (try_end),
        (try_end),

      (else_try),
        (try_begin),
          (eq, ":note_index", 0),
          (faction_get_slot, ":faction_leader", ":troop_faction", slot_faction_leader),
          (str_store_troop_name_link, s55, ":faction_leader"),
          (str_store_faction_name_link, s56, ":troop_faction"),
          (assign, ":troop_is_player_faction", 0),
          (assign, ":troop_is_faction_leader", 0),
          (try_begin),
            (eq, ":troop_faction", "fac_player_faction"),
            (assign, ":troop_is_player_faction", 1),
          (else_try),
            (eq, ":faction_leader", ":troop_no"),
            (assign, ":troop_is_faction_leader", 1),
          (try_end),
          #SB: add marshal check
          (try_begin),
            (faction_slot_eq, ":troop_faction", slot_faction_marshall, ":troop_no"),
            (assign, ":troop_is_marshal", 1),
          (else_try),
            (assign, ":troop_is_marshal", 0),
          (try_end),
          (assign, ":num_centers", 0),
          (str_store_string, s58, "@nowhere"),
          (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
            (party_slot_eq, ":cur_center", slot_town_lord, ":troop_no"),
            (try_begin),
              (eq, ":num_centers", 0),
              (str_store_party_name_link, s58, ":cur_center"),
            (else_try),
              (eq, ":num_centers", 1),
              (str_store_party_name_link, s57, ":cur_center"),
              (str_store_string, s58, "@{s57} and {s58}"),
            (else_try),
              (str_store_party_name_link, s57, ":cur_center"),
              (str_store_string, s58, "@{!}{s57}, {s58}"),
            (try_end),
            (val_add, ":num_centers", 1),
          (try_end),
          ##diplomacy start+ use script for gender
          #(troop_get_type, reg3, ":troop_no"),
          (call_script, "script_dplmc_store_troop_is_female_reg", ":troop_no", 3),
          #(assign, reg3, reg0),
          ##diplomacy end+


          (str_clear, s59),
          (try_begin),
            (call_script, "script_troop_get_player_relation", ":troop_no"),
            (assign, ":relation", reg0),
            (store_add, ":normalized_relation", ":relation", 100),
            (val_add, ":normalized_relation", 5),
            (store_div, ":str_offset", ":normalized_relation", 10),
            (val_clamp, ":str_offset", 0, 20),
            (store_add, ":str_id", "str_relation_mnus_100_ns",  ":str_offset"),
            (neq, ":str_id", "str_relation_plus_0_ns"),
            (str_store_string, s60, "@{reg3?She:He}"),
            (str_store_string, s59, ":str_id"),
            (str_store_string, s59, "@{!}^{s59}"),
          (try_end),
          #lord recruitment changes begin
          #This sends a bunch of political information to s47.

          #refresh registers
          (assign, reg9, ":num_centers"),
          ##diplomacy start+ use script for gender
          #(troop_get_type, reg3, ":troop_no"),
          (call_script, "script_dplmc_store_troop_is_female_reg", ":troop_no", 3),
          ##diplomacy end+

          #SB : rearrange registers a bit
          (assign, reg4, ":troop_is_faction_leader"),
          (assign, reg5, ":troop_is_marshal"),
          (assign, reg6, ":troop_is_player_faction"),

          #SB : TODO, add rounding based on personal relation/time last met?
          (troop_get_slot, reg15, ":troop_no", slot_troop_renown),
          (troop_get_slot, reg16, ":troop_no", slot_troop_controversy),
          #SB : actually use this wealth in string
          (troop_get_slot, reg17, ":troop_no", slot_troop_wealth), #DEBUGS
          ##diplomacy start+ xxx remove third argument (was it doing anything?)
          #(str_store_string, s0, "str_lord_info_string", 0),
          (str_store_string, s0, "str_lord_info_string"),
          ##diplomacy end+
          #lord recruitment changes end
          (add_troop_note_tableau_mesh, ":troop_no", "tableau_troop_note_mesh"),
          (set_trigger_result, 1),
        (try_end),
      (try_end),
     ]),

  #script_game_get_center_note
  # This script is called from the game engine when the notes of a center is needed.
  # INPUT: arg1 = center_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_center_note",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":note_index"),

      (set_trigger_result, 0),
      (try_begin),
        (eq, ":note_index", 0),
        (party_get_slot, ":lord_troop", ":center_no", slot_town_lord),
        (try_begin),
          (ge, ":lord_troop", 0),
          (store_troop_faction, ":lord_faction", ":lord_troop"),
          (str_store_troop_name_link, s1, ":lord_troop"),
          (try_begin),
            (eq, ":lord_troop", "trp_player"),
            (gt, "$players_kingdom", 0),
            (str_store_faction_name_link, s2, "$players_kingdom"),
          (else_try),
            (str_store_faction_name_link, s2, ":lord_faction"),
          (try_end),
          (str_store_party_name, s50, ":center_no"),
          (try_begin),
            (party_slot_eq, ":center_no", slot_party_type, spt_town),
            (str_store_string, s51, "@The town of {s50}"),
          (else_try),
            (party_slot_eq, ":center_no", slot_party_type, spt_village),
            (party_get_slot, ":bound_center", ":center_no", slot_village_bound_center),
            (str_store_party_name_link, s52, ":bound_center"),
            (str_store_string, s51, "@The village of {s50} near {s52}"),
          (else_try),
            (str_store_string, s51, "@{!}{s50}"),
          (try_end),
          ##diplomacy start+ Show when the city is the home of a lord or is a court
          (assign, ":bound_center", reg0),#Save reg0 to avoid having it randomly change
          (try_begin),
             (eq, "$g_player_court", ":center_no"),

             (store_and, reg1, "$players_kingdom_name_set", rename_center), #SB : specify capitals
             (str_store_string, s2, "@{s51} belongs to {s1} of {s2}, and is {reg1?your capital:where you make your court}.^"),
          (else_try),
             (neq, ":lord_troop", "trp_player"),
             (neg|is_between, ":center_no", villages_begin, villages_end),
             (call_script, "script_lord_get_home_center", ":lord_troop"),
             (eq, reg0, ":center_no"),
             (call_script, "script_dplmc_get_troop_standing_in_faction", ":lord_troop", ":lord_faction"),
             (try_begin),
                (ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
                (call_script, "script_dplmc_store_troop_is_female", ":lord_troop"),
                (str_store_string, s2, "@{s51} belongs to {s1} of {s2}, and is where {reg0?she:he} makes {reg0?her:his} court.^"),
             (else_try),
                (call_script, "script_dplmc_store_troop_is_female", ":lord_troop"),
                (str_store_string, s2, "@{s51} belongs to {s1} of {s2}, and is where {reg0?she:he} makes {reg0?her:his} home.^"),
             (try_end),
          (else_try),#Fall through to normal behavior
          ##diplomacy end+
          (str_store_string, s2, "@{s51} belongs to {s1} of {s2}.^"),
          ##diplomacy start+
          (try_end),
          (assign, reg0, ":bound_center"),#Revert reg0 to avoid having it randomly change
          ##diplomacy end+
        (else_try),
          (str_clear, s2),
          ##diplomacy start+ Don't hide notes for centers with no lords.
          (store_faction_of_party, ":lord_faction", ":center_no"),
          (str_store_string, s1, "str_noone"),
          (try_begin),
             (ge, ":lord_faction", 1),
             (str_store_faction_name_link, s2, ":lord_faction"),
          (else_try),
             (str_store_string, s2, "str_noone"),
          (try_end),
          (str_store_party_name, s50, ":center_no"),
          (try_begin),
            (party_slot_eq, ":center_no", slot_party_type, spt_town),
            (str_store_string, s51, "@The town of {s50}"),
          (else_try),
            (party_slot_eq, ":center_no", slot_party_type, spt_village),
            (party_get_slot, ":bound_center", ":center_no", slot_village_bound_center),
            (str_store_party_name_link, s52, ":bound_center"),
            (str_store_string, s51, "@The village of {s50} near {s52}"),
          (else_try),
            (str_store_string, s51, "@{!}{s50}"),
          (try_end),
          (try_begin),
             (is_between, ":lord_faction", kingdoms_begin, kingdoms_end),
             (faction_slot_eq, ":lord_faction", slot_faction_state, sfs_active),
             (str_store_string, s2, "@{s51} belongs to {s2} but has not yet been granted to a lord.^"),
          (else_try),
             (str_store_string, s2, "@{s51} belongs to {s2}.^"),
          (try_end),
          ##diplomacy end+
        (try_end),
        (try_begin),
          (is_between, ":center_no", villages_begin, villages_end),
          ##diplomacy start+ Show market town if it differs from the bound center
          (party_get_slot, ":market_center", ":center_no", slot_village_market_town),
          (try_begin),
             (is_between, ":market_center", centers_begin, centers_end),
             (neq, ":market_center", ":center_no"),
             (neg|party_slot_eq, ":center_no", slot_village_bound_center, ":market_center"),
             (str_store_party_name_link, s8, ":market_center"),
             (str_store_string, s2, "@{s2}Its market town is {s8}.^"),
          (try_end),
          ##diplomacy end+
        (else_try),
          (assign, ":num_villages", 0),
          (try_for_range_backwards, ":village_no", villages_begin, villages_end),
            (party_slot_eq, ":village_no", slot_village_bound_center, ":center_no"),
            (try_begin),
              (eq, ":num_villages", 0),
              (str_store_party_name_link, s8, ":village_no"),
            (else_try),
              (eq, ":num_villages", 1),
              (str_store_party_name_link, s7, ":village_no"),
              (str_store_string, s8, "@{s7} and {s8}"),
            (else_try),
              (str_store_party_name_link, s7, ":village_no"),
              (str_store_string, s8, "@{!}{s7}, {s8}"),
            (try_end),
            (val_add, ":num_villages", 1),
          (try_end),
          (try_begin),
            (eq, ":num_villages", 0),
            (str_store_string, s2, "@{s2}It has no villages.^"),
          (else_try),
            (store_sub, reg0, ":num_villages", 1),
            (str_store_string, s2, "@{s2}{reg0?Its villages are:Its village is} {s8}.^"),
          (try_end),
        (try_end),
        (call_script, "script_get_prosperity_text_to_s50", ":center_no"),
        #(party_get_slot, reg7, ":center_no", slot_town_prosperity),
        (str_store_string, s0, "@{s2}Its prosperity is: {s50}", 0),

        (set_trigger_result, 1),
      (try_end),
     ]),

  #script_game_get_faction_note
  # This script is called from the game engine when the notes of a faction is needed.
  # INPUT: arg1 = faction_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_faction_note",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":note_index"),
      (set_trigger_result, 0),

##      (try_begin),
##        (eq, 2, 1),
##        (str_store_faction_name, s14, ":faction_no"),
##        (assign, reg4, "$temp"),
##        (display_message, "str_updating_faction_notes_for_s14_temp_=_reg4"),
##      (try_end),

      (try_begin),
        (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
        #conditions end
        (try_begin),
            (eq, ":note_index", 0),
          (faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),
          (str_store_faction_name, s5, ":faction_no"),
          ##diplomacy start+
          ##OLD:
          #(str_store_troop_name_link, s6, ":faction_leader"),
          ##NEW:
          (try_begin),
             (lt, ":faction_leader", 0),
             #(le, ":faction_leader", 0),
             #(this_or_next|lt, ":faction_leader", 0),
             #   (neg|is_between, ":faction_no", kingdoms_begin, kingdoms_end),
             (str_store_string, s6, "str_noone"),
          (else_try),
             (eq, ":faction_leader", "trp_kingdom_heroes_including_player_begin"),
             (assign, ":faction_leader", "trp_player"),
          (str_store_troop_name_link, s6, ":faction_leader"),
          (else_try),
             (str_store_troop_name_link, s6, ":faction_leader"),
          (try_end),
			 ##diplomacy end+
          (assign, ":num_centers", 0),
          (str_store_string, s8, "@nowhere"),
          (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
            (store_faction_of_party, ":center_faction", ":cur_center"),
            (eq, ":center_faction", ":faction_no"),
            (try_begin),
              (eq, ":num_centers", 0),
              (str_store_party_name_link, s8, ":cur_center"),
            (else_try),
              (eq, ":num_centers", 1),
              (str_store_party_name_link, s7, ":cur_center"),
              (str_store_string, s8, "@{s7} and {s8}"),
            (else_try),
              (str_store_party_name_link, s7, ":cur_center"),
              (str_store_string, s8, "@{!}{s7}, {s8}"),
            (try_end),
            (val_add, ":num_centers", 1),
          (try_end),
          (assign, ":num_members", 0),
          (str_store_string, s10, "@noone"),
          ##diplomacy start+ support for promoted kingdom ladies
          (try_for_range_backwards, ":loop_var", "trp_kingdom_heroes_including_player_begin", heroes_end),#<- changed active_npcs_end to heroes_end
          ##diplomacy end+
            (assign, ":cur_troop", ":loop_var"),
            (try_begin),
              (eq, ":loop_var", "trp_kingdom_heroes_including_player_begin"),
              (assign, ":cur_troop", "trp_player"),
              (assign, ":troop_faction", "$players_kingdom"),
            (else_try),
              (store_troop_faction, ":troop_faction", ":cur_troop"),
            (try_end),
            (eq, ":troop_faction", ":faction_no"),
            (neq, ":cur_troop", ":faction_leader"),
            (troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
            (try_begin),
              (eq, ":num_members", 0),
              (str_store_troop_name_link, s10, ":cur_troop"),
            (else_try),
              (eq, ":num_members", 1),
              (str_store_troop_name_link, s9, ":cur_troop"),
              (str_store_string, s10, "@{s9} and {s10}"),
            (else_try),
              (str_store_troop_name_link, s9, ":cur_troop"),
              (str_store_string, s10, "@{!}{s9}, {s10}"),
            (try_end),
            (val_add, ":num_members", 1),
          (try_end),

              #wars
          (str_store_string, s12, "@noone"),
   #       (assign, ":num_enemies", 0),
   #       (try_for_range_backwards, ":cur_faction", kingdoms_begin, kingdoms_end),
   #         (faction_slot_eq, ":cur_faction", slot_faction_state, sfs_active),
   #         (store_relation, ":cur_relation", ":cur_faction", ":faction_no"),
   #         (lt, ":cur_relation", 0),
   #         (try_begin),
   #           (eq, ":num_enemies", 0),
   #           (str_store_faction_name_link, s12, ":cur_faction"),
   #         (else_try),
   #           (eq, ":num_enemies", 1),
   #           (str_store_faction_name_link, s11, ":cur_faction"),
   #           (str_store_string, s12, "@the {s11} and the {s12}"),
   #         (else_try),
   #           (str_store_faction_name_link, s11, ":cur_faction"),
   #           (str_store_string, s12, "@the {s11}, the {s12}"),
   #         (try_end),
   #         (val_add, ":num_enemies", 1),
        #       (try_end),


        ##SB : add domestic policy as overview
        (str_clear, s21),
        (str_clear, s20),
        (try_begin),
            (eq, ":faction_no", "$players_kingdom"),
            (str_store_string, s20, "@Domestic policy: ^^"),
            (call_script, "script_display_policy_string_to_reg", ":faction_no", 0, 1),
        (try_end),
        (str_store_string, s21, "str_foreign_relations__"),

              #other foreign relations
          (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
            (faction_slot_eq, ":cur_faction", slot_faction_state, sfs_active),
            (neq, ":faction_no", ":cur_faction"),
            (str_store_faction_name_link, s14, ":cur_faction"),
            (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":faction_no", ":cur_faction"),
            (assign, ":diplomatic_status", reg0),
            (assign, ":duration_of_status", reg1),

            (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":cur_faction", ":faction_no"),
            (assign, ":reverse_diplomatic_status", reg0),
            (try_begin),
              (eq, ":diplomatic_status", -2),
              (str_store_string, s21, "str_s21__the_s5_is_at_war_with_the_s14"),
              (store_add, ":slot_war_damage_inflicted", ":cur_faction", slot_faction_war_damage_inflicted_on_factions_begin),
              (val_sub, ":slot_war_damage_inflicted", kingdoms_begin),
              (faction_get_slot, ":war_damage_inflicted", ":faction_no", ":slot_war_damage_inflicted"),
              (store_mul, ":war_damage_inflicted_x_2", ":war_damage_inflicted", 2),

              (store_add, ":slot_war_damage_suffered", ":faction_no", slot_faction_war_damage_inflicted_on_factions_begin),
              (val_sub, ":slot_war_damage_suffered", kingdoms_begin),
              (faction_get_slot, ":war_damage_suffered", ":cur_faction", ":slot_war_damage_suffered"),
              (store_mul, ":war_damage_suffered_x_2", ":war_damage_suffered", 2),


			  (assign, ":war_cause", 0),
			  (assign, ":attacker", 0),
			  (try_for_range, ":log_entry", 0, "$num_log_entries"),
				(troop_get_slot, ":type", "trp_log_array_entry_type", ":log_entry"),
				(is_between, ":type", logent_faction_declares_war_out_of_personal_enmity, logent_war_declaration_types_end),
				(troop_get_slot, ":actor", "trp_log_array_actor", ":log_entry"),
				(troop_get_slot, ":object", "trp_log_array_faction_object", ":log_entry"),

				(try_begin),
					(eq, ":actor", ":cur_faction"),
					(eq, ":object", ":faction_no"),
					(assign, ":war_cause", ":type"),
					(assign, ":attacker", ":actor"),
				(else_try),
					(eq, ":actor", ":faction_no"),
					(eq, ":object", ":cur_faction"),
					(assign, ":war_cause", ":type"),
					(assign, ":attacker", ":actor"),
				(try_end),
			  (try_end),

			  #bug fix! backing up s8 to somewhere else
                          (str_store_string, s25, s8),
			  (try_begin),
			    (gt, ":war_cause", 0),
				(str_store_faction_name, s8, ":attacker"),
				(try_begin),
					(eq, ":war_cause", logent_faction_declares_war_out_of_personal_enmity),
					(str_store_string, s21, "str_s21_the_s8_declared_war_out_of_personal_enmity"),
				(else_try),
					(eq, ":war_cause", logent_faction_declares_war_to_respond_to_provocation),
					(str_store_string, s21, "str_s21_the_s8_declared_war_in_response_to_border_provocations"),
				(else_try),
					(eq, ":war_cause", logent_faction_declares_war_to_curb_power),
					(str_store_string, s21, "str_s21_the_s8_declared_war_to_curb_the_other_realms_power"),
				(else_try),
					(eq, ":war_cause", logent_faction_declares_war_to_regain_territory),
					(str_store_string, s21, "str_s21_the_s8_declared_war_to_regain_lost_territory"),
				##diplomacy begin
				(else_try),
					(eq, ":war_cause", logent_faction_declares_war_to_fulfil_pact),
					(str_store_string, s21, "str_dplmc_s21_the_s8_declared_war_to_fulfil_pact"),
				##diplomacy end
				(else_try),
					(eq, ":war_cause", logent_player_faction_declares_war),
					(neq, ":attacker", "fac_player_supporters_faction"),
					(str_store_string, s21, "str_s21_the_s8_declared_war_as_part_of_a_bid_to_conquer_all_calradia"),
				(try_end),
			  (try_end),
			  #bug fix! restoring the back up to s8
              (str_store_string, s8, s25),

              (try_begin),
                (gt, ":war_damage_inflicted", ":war_damage_suffered_x_2"),
                (str_store_string, s21, "str_s21_the_s5_has_had_the_upper_hand_in_the_fighting"),
              (else_try),
                (gt, ":war_damage_suffered", ":war_damage_inflicted_x_2"),
                (str_store_string, s21, "str_s21_the_s5_has_gotten_the_worst_of_the_fighting"),
              (else_try),
                (gt, ":war_damage_inflicted", 100),
                (gt, ":war_damage_inflicted", 100),
                (str_store_string, s21, "str_s21_the_fighting_has_gone_on_for_some_time_and_the_war_may_end_soon_with_a_truce"),
              (else_try),
                (str_store_string, s21, "str_s21_the_fighting_has_begun_relatively_recently_and_the_war_may_continue_for_some_time"),
              (try_end),
              (try_begin),
                (eq, "$cheat_mode", 1),
                (assign, reg4, ":war_damage_inflicted"),
                (assign, reg5, ":war_damage_suffered"),
                (str_store_string, s21, "str_s21_reg4reg5"),
              (try_end),
            (else_try),
              (eq, ":diplomatic_status", 1),
              (str_clear, s18),
              (try_begin),
                (neq, ":reverse_diplomatic_status", 1),
                (str_store_string, s18, "str__however_the_truce_is_no_longer_binding_on_the_s14"),
              (try_end),
			  (assign, reg1, ":duration_of_status"),
			  ##diplomacy begin
              (try_begin),
			    ##nested diplomacy start+ Use named variables for truce lengths
                #(is_between, ":duration_of_status", 1, 21),
				(is_between, ":duration_of_status", dplmc_treaty_truce_days_expire + 1, dplmc_treaty_truce_days_initial + 1),
				##nested diplomacy end+
              ##diplomacy end
              (str_store_string, s21, "str_s21__the_s5_is_bound_by_truce_not_to_attack_the_s14s18_the_truce_will_expire_in_reg1_days"),
              ##diplomacy begin
			  ##nested diplomacy start+ Use named variables for truce lengths
              (else_try),
                #(is_between, ":duration_of_status", 21, 41),
                #(val_sub, reg1, 20),
                (is_between, ":duration_of_status", dplmc_treaty_trade_days_expire + 1, dplmc_treaty_trade_days_initial + 1),
                (val_sub, reg1, dplmc_treaty_trade_days_expire),
                (str_store_string, s21, "str_dplmc_s21__the_s5_is_bound_by_trade_not_to_attack_the_s14s18_it_will_expire_in_reg1_days"),
              (else_try),
                #(is_between, ":duration_of_status", 41, 61),
                #(val_sub, reg1, 40),
                (is_between, ":duration_of_status", dplmc_treaty_defense_days_expire + 1, dplmc_treaty_defense_days_initial + 1),
                (val_sub, reg1, dplmc_treaty_defense_days_expire),
                (str_store_string, s21, "str_dplmc_s21__the_s5_is_bound_by_defensive_not_to_attack_the_s14s18_it_will_expire_in_reg1_days"),
              (else_try),
                #(is_between, ":duration_of_status", 61, 81),
                #(val_sub, reg1, 60),
                (is_between, ":duration_of_status", dplmc_treaty_alliance_days_expire + 1, dplmc_treaty_alliance_days_initial + 1),
                (val_sub, reg1, dplmc_treaty_alliance_days_expire),
                (str_store_string, s21, "str_dplmc_s21__the_s5_is_bound_by_alliance_not_to_attack_the_s14s18_it_will_expire_in_reg1_days"),
              (try_end),
			  ##nested diplomacy end+ (Use named variables for truce lengths)
               ##diplomacy end
            (else_try),
              (eq, ":diplomatic_status", -1),
              (str_store_string, s21, "str_s21__the_s5_has_recently_suffered_provocation_by_subjects_of_the_s14_and_there_is_a_risk_of_war"),
            (else_try),
              (eq, ":diplomatic_status", 0),
              (str_store_string, s21, "str_s21__the_s5_has_no_outstanding_issues_with_the_s14"),
            (try_end),
            (try_begin),
              (eq, ":reverse_diplomatic_status", -1),
              (str_store_string, s21, "str_s21_the_s14_was_recently_provoked_by_subjects_of_the_s5_and_there_is_a_risk_of_war_"),
            (try_end),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (call_script, "script_npc_decision_checklist_peace_or_war", ":faction_no", ":cur_faction", -1),
			  (str_store_string, s21, "@{!}DEBUG : {s21}.^CHEAT MODE ASSESSMENT: {s14}^"),
            (try_end),
          (try_end),
          (str_store_string, s0, "str_the_s5_is_ruled_by_s6_it_occupies_s8_its_vassals_are_s10__s21", 0),
          (set_trigger_result, 1),
        (try_end),
      (else_try),
        (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":faction_no", slot_faction_state, sfs_defeated),
        (try_begin),
          (eq, ":note_index", 0),
          (str_store_faction_name, s5, ":faction_no"),
          (str_store_string, s0, "@{s5} has been defeated!", 0),
          (set_trigger_result, 1),
        (else_try),
          (eq, ":note_index", 1),
          (str_clear, s0),
          (set_trigger_result, 1),
        (try_end),
      (else_try),
        (try_begin),
          (this_or_next|eq, ":note_index", 0),
          (eq, ":note_index", 1),
          (str_clear, s0),
          (set_trigger_result, 1),
        (try_end),
      (try_end),
     ]),

  #script_game_get_quest_note
  # This script is called from the game engine when the notes of a quest is needed.
  # INPUT: arg1 = quest_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_quest_note",
    [
##      (store_script_param_1, ":quest_no"),
##      (store_script_param_2, ":note_index"),
      (set_trigger_result, 0), # set it to 1 if this script is wanted to be used rather than static notes
      #SB: TODO set up progress for pretender quests and other long-winding series
     ]),

  #script_game_get_info_page_note
  # This script is called from the game engine when the notes of a info_page is needed.
  # INPUT: arg1 = info_page_no, arg2 = note_index
  # OUTPUT: s0 = note
  ("game_get_info_page_note",
    [
##      (store_script_param_1, ":info_page_no"),
##      (store_script_param_2, ":note_index"),
      (set_trigger_result, 0), # set it to 1 if this script is wanted to be used rather than static notes
      #SB: TODO use actual settings for camera, ai_changes etc
     ]),

  #script_game_get_scene_name
  # This script is called from the game engine when a name for the scene is needed.
  # INPUT: arg1 = scene_no
  # OUTPUT: s0 = name
  ("game_get_scene_name",
    [
      (store_script_param, ":scene_no", 1),
      (try_begin),
        (is_between, ":scene_no", multiplayer_scenes_begin, multiplayer_scenes_end),
        (store_sub, ":string_id", ":scene_no", multiplayer_scenes_begin),
        (val_add, ":string_id", multiplayer_scene_names_begin),
        (str_store_string, s0, ":string_id"),
      (try_end),
     ]),

  #script_game_get_mission_template_name
  # This script is called from the game engine when a name for the mission template is needed.
  # INPUT: arg1 = mission_template_no
  # OUTPUT: s0 = name
  ("game_get_mission_template_name",
    [
      (store_script_param, ":mission_template_no", 1),
      (call_script, "script_multiplayer_get_mission_template_game_type", ":mission_template_no"),
      (assign, ":game_type", reg0),
      (try_begin),
        (is_between, ":game_type", 0, multiplayer_num_game_types),
        (store_add, ":string_id", ":game_type", multiplayer_game_type_names_begin),
        (str_store_string, s0, ":string_id"),
      (try_end),
     ]),

  #script_add_kill_death_counts
  # INPUT: arg1 = killer_agent_no, arg2 = dead_agent_no
  # OUTPUT: none
  ("add_kill_death_counts",
   [
      (store_script_param, ":killer_agent_no", 1),
      (store_script_param, ":dead_agent_no", 2),

      (try_begin),
        (ge, ":killer_agent_no", 0),
        (agent_get_team, ":killer_agent_team", ":killer_agent_no"),
      (else_try),
        (assign, ":killer_agent_team", -1),
      (try_end),

      (try_begin),
        (ge, ":dead_agent_no", 0),
        (agent_get_team, ":dead_agent_team", ":dead_agent_no"),
      (else_try),
        (assign, ":dead_agent_team", -1),
      (try_end),

      #adjusting kill counts of players/bots
      (try_begin),
        (try_begin),
          (ge, ":killer_agent_no", 0),
          (ge, ":dead_agent_no", 0),
          (agent_is_human, ":killer_agent_no"),
          (agent_is_human, ":dead_agent_no"),
          (neq, ":killer_agent_no", ":dead_agent_no"),

          (this_or_next|neq, ":killer_agent_team", ":dead_agent_team"),
          (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch),
          (eq, "$g_multiplayer_game_type", multiplayer_game_type_duel),

          (agent_get_player_id, ":killer_agent_player", ":killer_agent_no"),
          (try_begin),
            (agent_is_non_player, ":killer_agent_no"), #if killer agent is bot then increase bot kill counts of killer agent's team by one.
            (agent_get_team, ":killer_agent_team", ":killer_agent_no"),
            (team_get_bot_kill_count, ":killer_agent_team_bot_kill_count", ":killer_agent_team"),
            (val_add, ":killer_agent_team_bot_kill_count", 1),
            (team_set_bot_kill_count, ":killer_agent_team", ":killer_agent_team_bot_kill_count"),
          (else_try), #if killer agent is not bot then increase kill counts of killer agent's player by one.
            (player_is_active, ":killer_agent_player"),
            (player_get_kill_count, ":killer_agent_player_kill_count", ":killer_agent_player"),
            (val_add, ":killer_agent_player_kill_count", 1),
            (player_set_kill_count, ":killer_agent_player", ":killer_agent_player_kill_count"),
          (try_end),
        (try_end),

        (try_begin),
          (ge, ":dead_agent_no", 0),
          (agent_is_human, ":dead_agent_no"),
          (try_begin),
            (agent_is_non_player, ":dead_agent_no"), #if dead agent is bot then increase bot kill counts of dead agent's team by one.
            (agent_get_team, ":dead_agent_team", ":dead_agent_no"),
            (team_get_bot_death_count, ":dead_agent_team_bot_death_count", ":dead_agent_team"),
            (val_add, ":dead_agent_team_bot_death_count", 1),
            (team_set_bot_death_count, ":dead_agent_team", ":dead_agent_team_bot_death_count"),
          (else_try), #if dead agent is not bot then increase death counts of dead agent's player by one.
            (agent_get_player_id, ":dead_agent_player", ":dead_agent_no"),
            (player_is_active, ":dead_agent_player"),
            (player_get_death_count, ":dead_agent_player_death_count", ":dead_agent_player"),
            (val_add, ":dead_agent_player_death_count", 1),
            (player_set_death_count, ":dead_agent_player", ":dead_agent_player_death_count"),
          (try_end),

          (try_begin),
            (assign, ":continue", 0),

            (try_begin),
              (this_or_next|lt, ":killer_agent_no", 0), #if he killed himself (1a(team change) or 1b(self kill)) then decrease kill counts of killer player by one.
              (eq, ":killer_agent_no", ":dead_agent_no"),
              (assign, ":continue", 1),
            (try_end),

            (try_begin),
              (eq, ":killer_agent_team", ":dead_agent_team"), #if he killed a teammate and game mod is not deathmatch then decrease kill counts of killer player by one.
              (neq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch),
              (neq, "$g_multiplayer_game_type", multiplayer_game_type_duel),
              (assign, ":continue", 1),
            (try_end),

            (eq, ":continue", 1),

            (try_begin),
              (ge, ":killer_agent_no", 0),
              (assign, ":responsible_agent", ":killer_agent_no"),
            (else_try),
              (assign, ":responsible_agent", ":dead_agent_no"),
            (try_end),

            (try_begin),
              (ge, ":responsible_agent", 0),
              (neg|agent_is_non_player, ":responsible_agent"),
              (agent_get_player_id, ":responsible_player", ":responsible_agent"),
              (ge, ":responsible_player", 0),
              (player_get_kill_count, ":dead_agent_player_kill_count", ":responsible_player"),
              (val_add, ":dead_agent_player_kill_count", -1),
              (player_set_kill_count, ":responsible_player", ":dead_agent_player_kill_count"),
            (try_end),
          (try_end),
        (try_end),
      (try_end),
    ]),

  #script_warn_player_about_auto_team_balance
  # INPUT: none
  # OUTPUT: none
  ("warn_player_about_auto_team_balance",
   [
     (assign, "$g_multiplayer_message_type", multiplayer_message_type_auto_team_balance_next),
     (start_presentation, "prsnt_multiplayer_message_2"),
     ]),

  #script_check_team_balance
  # INPUT: none
  # OUTPUT: none
  ("check_team_balance",
   [
     (try_begin),
       (multiplayer_is_server),

       (assign, ":number_of_players_at_team_1", 0),
       (assign, ":number_of_players_at_team_2", 0),
       (get_max_players, ":num_players"),
       (try_for_range, ":cur_player", 0, ":num_players"),
         (player_is_active, ":cur_player"),
         (player_get_team_no, ":player_team", ":cur_player"),
         (try_begin),
           (eq, ":player_team", 0),
           (val_add, ":number_of_players_at_team_1", 1),
         (else_try),
           (eq, ":player_team", 1),
           (val_add, ":number_of_players_at_team_2", 1),
         (try_end),
       (try_end),

       (store_sub, ":difference_of_number_of_players", ":number_of_players_at_team_1", ":number_of_players_at_team_2"),
       (assign, ":number_of_players_will_be_moved", 0),
       (try_begin),
         (try_begin),
           (store_mul, ":checked_value", "$g_multiplayer_auto_team_balance_limit", -1),
           (le, ":difference_of_number_of_players", ":checked_value"),
           (store_div, ":number_of_players_will_be_moved", ":difference_of_number_of_players", -2),
           (assign, ":team_with_more_players", 1),
           (assign, ":team_with_less_players", 0),
         (else_try),
           (ge, ":difference_of_number_of_players", "$g_multiplayer_auto_team_balance_limit"),
           (store_div, ":number_of_players_will_be_moved", ":difference_of_number_of_players", 2),
           (assign, ":team_with_more_players", 0),
           (assign, ":team_with_less_players", 1),
         (try_end),
       (try_end),
       #team balance checks are done
       (try_begin),
         (gt, ":number_of_players_will_be_moved", 0),
         (try_begin),
           (eq, "$g_team_balance_next_round", 1), #if warning is given

           #auto team balance starts
           (try_for_range, ":unused", 0, ":number_of_players_will_be_moved"),
             (assign, ":max_player_join_time", 0),
             (assign, ":latest_joined_player_no", -1),
             (get_max_players, ":num_players"),
             (try_for_range, ":player_no", 0, ":num_players"),
               (player_is_active, ":player_no"),
               (player_get_team_no, ":player_team", ":player_no"),
               (eq, ":player_team", ":team_with_more_players"),
               (player_get_slot, ":player_join_time", ":player_no", slot_player_join_time),
               (try_begin),
                 (gt, ":player_join_time", ":max_player_join_time"),
                 (assign, ":max_player_join_time", ":player_join_time"),
                 (assign, ":latest_joined_player_no", ":player_no"),
               (try_end),
             (try_end),
             (try_begin),
               (ge, ":latest_joined_player_no", 0),
               (try_begin),
                 #if player is living add +1 to his kill count because he will get -1 because of team change while living.
                 (player_get_agent_id, ":latest_joined_agent_id", ":latest_joined_player_no"),
                 (ge, ":latest_joined_agent_id", 0),
                 (agent_is_alive, ":latest_joined_agent_id"),

                 (player_get_kill_count, ":player_kill_count", ":latest_joined_player_no"), #adding 1 to his kill count, because he will lose 1 undeserved kill count for dying during team change
                 (val_add, ":player_kill_count", 1),
                 (player_set_kill_count, ":latest_joined_player_no", ":player_kill_count"),

                 (player_get_death_count, ":player_death_count", ":latest_joined_player_no"), #subtracting 1 to his death count, because he will gain 1 undeserved death count for dying during team change
                 (val_sub, ":player_death_count", 1),
                 (player_set_death_count, ":latest_joined_player_no", ":player_death_count"),

                 (player_get_score, ":player_score", ":latest_joined_player_no"), #adding 1 to his score count, because he will lose 1 undeserved score for dying during team change
                 (val_add, ":player_score", 1),
                 (player_set_score, ":latest_joined_player_no", ":player_score"),

                 (try_for_range, ":player_no", 1, ":num_players"), #0 is server so starting from 1
                   (player_is_active, ":player_no"),
                   (multiplayer_send_4_int_to_player, ":player_no", multiplayer_event_set_player_score_kill_death, ":latest_joined_player_no", ":player_score", ":player_kill_count", ":player_death_count"),
                 (try_end),

                 (player_get_value_of_original_items, ":old_items_value", ":latest_joined_player_no"),
                 (player_get_gold, ":player_gold", ":latest_joined_player_no"),
                 (val_add, ":player_gold", ":old_items_value"),
                 (player_set_gold, ":latest_joined_player_no", ":player_gold", multi_max_gold_that_can_be_stored),
               (end_try),

               (player_set_troop_id, ":latest_joined_player_no", -1),
               (player_set_team_no, ":latest_joined_player_no", ":team_with_less_players"),
               (multiplayer_send_message_to_player, ":latest_joined_player_no", multiplayer_event_force_start_team_selection),
             (try_end),
           (try_end),

           #for only server itself-----------------------------------------------------------------------------------------------
           (call_script, "script_show_multiplayer_message", multiplayer_message_type_auto_team_balance_done, 0), #0 is useless here
           #for only server itself-----------------------------------------------------------------------------------------------
           (get_max_players, ":num_players"),
           (try_for_range, ":player_no", 1, ":num_players"),
             (player_is_active, ":player_no"),
             (multiplayer_send_int_to_player, ":player_no", multiplayer_event_show_multiplayer_message, multiplayer_message_type_auto_team_balance_done),
           (try_end),
           (assign, "$g_team_balance_next_round", 0),
           #auto team balance done
         (else_try),
           #tutorial message (next round there will be auto team balance)
           (assign, "$g_team_balance_next_round", 1),

           #for only server itself-----------------------------------------------------------------------------------------------
           (call_script, "script_show_multiplayer_message", multiplayer_message_type_auto_team_balance_next, 0), #0 is useless here
           #for only server itself-----------------------------------------------------------------------------------------------
           (get_max_players, ":num_players"),
           (try_for_range, ":player_no", 1, ":num_players"),
             (player_is_active, ":player_no"),
             (multiplayer_send_int_to_player, ":player_no", multiplayer_event_show_multiplayer_message, multiplayer_message_type_auto_team_balance_next),
           (try_end),
         (try_end),
       (else_try),
         (assign, "$g_team_balance_next_round", 0),
       (try_end),
     (try_end),
   ]),

  #script_check_creating_ladder_dust_effect
  # INPUT: arg1 = instance_id, arg2 = remaining_time
  # OUTPUT: none
  ("check_creating_ladder_dust_effect",
   [
      (store_trigger_param_1, ":instance_id"),
      (store_trigger_param_2, ":remaining_time"),

      (try_begin),
        (lt, ":remaining_time", 15), #less then 0.15 seconds
        (gt, ":remaining_time", 3), #more than 0.03 seconds

        (scene_prop_get_slot, ":smoke_effect_done", ":instance_id", scene_prop_smoke_effect_done),
        (scene_prop_get_slot, ":opened_or_closed", ":instance_id", scene_prop_open_or_close_slot),

        (try_begin),
          (eq, ":smoke_effect_done", 0),
          (eq, ":opened_or_closed", 0),

          (prop_instance_get_position, pos0, ":instance_id"),

          (assign, ":smallest_dist", -1),
          (try_for_range, ":entry_point_no", multi_entry_points_for_usable_items_start, multi_entry_points_for_usable_items_end),
            (entry_point_get_position, pos1, ":entry_point_no"),
            (get_sq_distance_between_positions, ":dist", pos0, pos1),
            (this_or_next|eq, ":smallest_dist", -1),
            (lt, ":dist", ":smallest_dist"),
            (assign, ":smallest_dist", ":dist"),
            (assign, ":nearest_entry_point", ":entry_point_no"),
          (try_end),

          (try_begin),
            (set_fixed_point_multiplier, 100),

            (ge, ":smallest_dist", 0),
            (lt, ":smallest_dist", 22500), #max 15m distance

            (entry_point_get_position, pos1, ":nearest_entry_point"),
            (position_rotate_x, pos1, -90),

            (prop_instance_get_scene_prop_kind, ":scene_prop_kind", ":instance_id"),
            (try_begin),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_6m"),
              (init_position, pos2),
              (position_set_z, pos2, 300),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_6m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_6m", pos3, 100),
            (else_try),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_8m"),
              (init_position, pos2),
              (position_set_z, pos2, 400),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_8m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_8m", pos3, 100),
            (else_try),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_10m"),
              (init_position, pos2),
              (position_set_z, pos2, 500),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_10m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_10m", pos3, 100),
            (else_try),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_12m"),
              (init_position, pos2),
              (position_set_z, pos2, 600),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_12m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_12m", pos3, 100),
            (else_try),
              (eq, ":scene_prop_kind", "spr_siege_ladder_move_14m"),
              (init_position, pos2),
              (position_set_z, pos2, 700),
              (position_transform_position_to_parent, pos3, pos1, pos2),
              (particle_system_burst, "psys_ladder_dust_14m", pos3, 100),
              (particle_system_burst, "psys_ladder_straw_14m", pos3, 100),
            (try_end),

            (scene_prop_set_slot, ":instance_id", scene_prop_smoke_effect_done, 1),
          (try_end),
        (try_end),
      (try_end),
      ]),

  #script_money_management_after_agent_death
  # INPUT: arg1 = killer_agent_no, arg2 = dead_agent_no
  # OUTPUT: none
  ("money_management_after_agent_death",
   [
     (store_script_param, ":killer_agent_no", 1),
     (store_script_param, ":dead_agent_no", 2),

     (assign, ":dead_agent_player_id", -1),

     (try_begin),
       (multiplayer_is_server),
       (ge, ":killer_agent_no", 0),
       (ge, ":dead_agent_no", 0),
       (agent_is_human, ":dead_agent_no"), #if dead agent is not horse
       (agent_is_human, ":killer_agent_no"), #if killer agent is not horse
       (agent_get_team, ":killer_agent_team", ":killer_agent_no"),
       (agent_get_team, ":dead_agent_team", ":dead_agent_no"),

       (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch),
       (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_duel),
       (neq, ":killer_agent_team", ":dead_agent_team"), #if these agents are enemies

       (neq, ":dead_agent_no", ":killer_agent_no"), #if agents are different, do not remove it is needed because in deathmatch mod, self killing passes here because of this or next.

       (try_begin),
         (neg|agent_is_non_player, ":dead_agent_no"),
         (agent_get_player_id, ":dead_player_no", ":dead_agent_no"),
         (player_get_slot, ":dead_agent_equipment_value", ":dead_player_no", slot_player_total_equipment_value),
       (else_try),
         (assign, ":dead_agent_equipment_value", 0),
       (try_end),

       (assign, ":dead_agent_team_human_players_count", 0),
       (get_max_players, ":num_players"),
       (try_for_range, ":player_no", 0, ":num_players"),
         (player_is_active, ":player_no"),
         (player_get_team_no, ":player_team", ":player_no"),
         (eq, ":player_team", ":dead_agent_team"),
         (val_add, ":dead_agent_team_human_players_count", 1),
       (try_end),

       (try_for_range, ":player_no", 0, ":num_players"),
         (player_is_active, ":player_no"),

         (try_begin),
           (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
           (eq, "$g_multiplayer_game_type", multiplayer_game_type_destroy),
           (assign, ":one_spawn_per_round_game_type", 1),
         (else_try),
           (assign, ":one_spawn_per_round_game_type", 0),
         (try_end),

         (this_or_next|eq, ":one_spawn_per_round_game_type", 0),
         (this_or_next|player_slot_eq, ":player_no", slot_player_spawned_this_round, 0),
         (player_slot_eq, ":player_no", slot_player_spawned_this_round, 1),

         (player_get_agent_id, ":agent_no", ":player_no"),
         (try_begin),
           (eq, ":agent_no", ":dead_agent_no"), #if this agent is dead agent then get share from total loot. (20% of total equipment value)
           (player_get_gold, ":player_gold", ":player_no"),

           (assign, ":dead_agent_player_id", ":player_no"),

           #dead agent loot share (32%-48%-64%, norm : 48%)
           (store_mul, ":share_of_dead_agent", ":dead_agent_equipment_value", multi_dead_agent_loot_percentage_share),
           (val_div, ":share_of_dead_agent", 100),
           (val_mul, ":share_of_dead_agent", "$g_multiplayer_battle_earnings_multiplier"),
           (val_div, ":share_of_dead_agent", 100),
           (try_begin),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch), #(4/3x) share if current mod is deathmatch
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_duel), #(4/3x) share if current mod is duel
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_team_deathmatch), #(4/3x) share if current mod is team_deathmatch
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag), #(4/3x) share if current mod is capture the flag
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters), #(4/3x) share if current mod is headquarters
             (val_mul, ":share_of_dead_agent", 4),
             (val_div, ":share_of_dead_agent", 3),
             (val_add, ":player_gold", ":share_of_dead_agent"),
           (else_try),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_battle), #(2/3x) share if current mod is battle
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_destroy), #(2/3x) share if current mod is fight and destroy
             (val_mul, ":share_of_dead_agent", 2),
             (val_div, ":share_of_dead_agent", 3),
             (val_add, ":player_gold", ":share_of_dead_agent"),
           (else_try),
             (val_add, ":player_gold", ":share_of_dead_agent"), #(3/3x) share if current mod is siege
           (try_end),
           (player_set_gold, ":player_no", ":player_gold", multi_max_gold_that_can_be_stored),
         (else_try),
           (eq, ":agent_no", ":killer_agent_no"), #if this agent is killer agent then get share from total loot. (10% of total equipment value)
           (player_get_gold, ":player_gold", ":player_no"),

           #killer agent standart money (100-150-200, norm : 150)
           (assign, ":killer_agent_standard_money_addition", multi_killer_agent_standard_money_add),
           (val_mul, ":killer_agent_standard_money_addition", "$g_multiplayer_battle_earnings_multiplier"),
           (val_div, ":killer_agent_standard_money_addition", 100),
           (try_begin),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch), #(4/3x) share if current mod is deathmatch
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_duel), #(4/3x) share if current mod is duel
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_team_deathmatch), #(4/3x) share if current mod is team_deathmatch
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag), #(4/3x) share if current mod is capture the flag
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters), #(4/3x) share if current mod is headquarters
             (val_mul, ":killer_agent_standard_money_addition", 4),
             (val_div, ":killer_agent_standard_money_addition", 3),
             (val_add, ":player_gold", ":killer_agent_standard_money_addition"),
           (else_try),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_battle), #(2/3x) share if current mod is battle
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_destroy), #(2/3x) share if current mod is fight and destroy
             (val_mul, ":killer_agent_standard_money_addition", 2),
             (val_div, ":killer_agent_standard_money_addition", 3),
             (val_add, ":player_gold", ":killer_agent_standard_money_addition"),
           (else_try),
             (val_add, ":player_gold", ":killer_agent_standard_money_addition"), #(3/3x) share if current mod is siege
           (try_end),

           #killer agent loot share (8%-12%-16%, norm : 12%)
           (store_mul, ":share_of_killer_agent", ":dead_agent_equipment_value", multi_killer_agent_loot_percentage_share),
           (val_div, ":share_of_killer_agent", 100),
           (val_mul, ":share_of_killer_agent", "$g_multiplayer_battle_earnings_multiplier"),
           (val_div, ":share_of_killer_agent", 100),
           (try_begin),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch), #(4/3x) share if current mod is deathmatch
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_duel), #(4/3x) share if current mod is duel
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_team_deathmatch), #(4/3x) share if current mod is team_deathmatch
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag), #(4/3x) share if current mod is capture the flag
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters), #(4/3x) share if current mod is headquarters
             (val_mul, ":share_of_killer_agent", 4),
             (val_div, ":share_of_killer_agent", 3),
             (val_add, ":player_gold", ":share_of_killer_agent"),
           (else_try),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_battle), #(2/3x) share if current mod is battle
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_destroy), #(2/3x) share if current mod is fight and destroy
             (val_mul, ":share_of_killer_agent", 2),
             (val_div, ":share_of_killer_agent", 3),
             (val_add, ":player_gold", ":share_of_killer_agent"),
           (else_try),
             (val_add, ":player_gold", ":share_of_killer_agent"), #(3/3x) share if current mod is siege
           (try_end),
           (player_set_gold, ":player_no", ":player_gold", multi_max_gold_that_can_be_stored),
         (try_end),
       (try_end),
     (try_end),

     #(below lines added new at 25.11.09 after Armagan decided new money system)
     (try_begin),
       (multiplayer_is_server),
       (neq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
       (neq, "$g_multiplayer_game_type", multiplayer_game_type_destroy),

       (ge, ":dead_agent_no", 0),
       (agent_is_human, ":dead_agent_no"), #if dead agent is not horse
       (agent_get_player_id, ":dead_agent_player_id", ":dead_agent_no"),
       (ge, ":dead_agent_player_id", 0),

       (player_get_gold, ":player_gold", ":dead_agent_player_id"),
       (try_begin),
         (store_mul, ":minimum_gold", "$g_multiplayer_initial_gold_multiplier", 10),
         (lt, ":player_gold", ":minimum_gold"),
         (assign, ":player_gold", ":minimum_gold"),
       (try_end),
       (player_set_gold, ":dead_agent_player_id", ":player_gold"),
     (try_end),
     #new money system addition end
     ]),

	("initialize_aristocracy",
	[
	  #LORD OCCUPATIONS, BLOOD RELATIONSHIPS, RENOWN AND REPUTATIONS

	  #King ages
	  (try_for_range, ":cur_troop", kings_begin, kings_end),
		(troop_set_slot, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
		(store_random_in_range, ":age", 50, 60),
		(troop_set_slot, ":cur_troop", slot_troop_age, ":age"),
		##diplomacy start+
		#(eq, ":cur_troop", "trp_kingdom_5_lord"),#<-- There was no reason for this to be in the loop, so moved it out.
		#(troop_set_slot, ":cur_troop", slot_troop_age, 47),
	  (try_end),
	  (troop_set_slot, "trp_kingdom_5_lord", slot_troop_age, 47),#<-- Moved from above
	  ##diplomacy end+

	  #The first thing - family structure
	  #lords 1 to 8 are patriarchs with one live-at-home son and one daughter. They come from one of six possible ancestors, thus making it likely that there will be two sets of siblings
	  #lords 9 to 12 are unmarried landowners with sisters
	  #lords 13 to 20 are sons who still live in their fathers' houses
	  #For the sake of simplicity, we can assume that all male aristocrats in prior generations either married commoners or procured their brides from the Old Country, thus discounting intermarriage

	  (try_for_range, ":cur_troop", kingdom_ladies_begin, kingdom_ladies_end),
		(troop_set_slot, ":cur_troop", slot_troop_occupation, slto_kingdom_lady),
	  (try_end),

	  (assign, ":cur_lady", "trp_kingdom_1_lady_1"),

	  (try_for_range, ":cur_troop", lords_begin, lords_end),
		(troop_set_slot, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),

		(store_random_in_range, ":father_age_at_birth", 23, 26),
#		(store_random_in_range, ":mother_age_at_birth", 19, 22),

		(try_begin),
			(is_between, ":cur_troop", "trp_knight_1_1", "trp_knight_2_1"),
			(store_sub, ":npc_seed", ":cur_troop", "trp_knight_1_1"),
			(assign, ":ancestor_seed", 1),

		(else_try),
			(is_between, ":cur_troop", "trp_knight_2_1", "trp_knight_3_1"),
			(store_sub, ":npc_seed", ":cur_troop", "trp_knight_2_1"),
			(assign, ":ancestor_seed", 7),

		(else_try),
			(is_between, ":cur_troop", "trp_knight_3_1", "trp_knight_4_1"),
			(store_sub, ":npc_seed", ":cur_troop", "trp_knight_3_1"),
			(assign, ":ancestor_seed", 13),

		(else_try),
			(is_between, ":cur_troop", "trp_knight_4_1", "trp_knight_5_1"),
			(store_sub, ":npc_seed", ":cur_troop", "trp_knight_4_1"),
			(assign, ":ancestor_seed", 19),

		(else_try),
			(is_between, ":cur_troop", "trp_knight_5_1", "trp_knight_6_1"),
			(store_sub, ":npc_seed", ":cur_troop", "trp_knight_5_1"),
			(assign, ":ancestor_seed", 25),

		(else_try),
			(is_between, ":cur_troop", "trp_knight_6_1", "trp_kingdom_1_pretender"),
			(store_sub, ":npc_seed", ":cur_troop", "trp_knight_6_1"),
			(assign, ":ancestor_seed", 31),

		(try_end),


		(try_begin),
			(lt, ":npc_seed", 8), #NPC seed is the order in the faction
			##diplomacy start+ do not overwrite reputation if it was already set explicitly
			(troop_get_slot, ":reputation", ":cur_troop", slot_lord_reputation_type),
			(try_begin),
				(lt, ":reputation", 1),
				#Original behavior:
				(assign, ":reputation", ":npc_seed"),
			(try_end),
			##diplomacy end+
			(store_random_in_range, ":age", 45, 64),

			##diplomacy start+ only set father if not already set
			(try_begin),#<- dplmc+ added
				(troop_slot_eq, ":cur_troop", slot_troop_father, -1),#<- dplmc+ added
				(store_random_in_range, ":father", 0, 6), #six possible fathers
				(val_add, ":father", ":ancestor_seed"),
				(troop_set_slot, ":cur_troop", slot_troop_father, ":father"),
			(try_end),#<- dplmc+ added
			##diplomacy end+

			#wife
			##diplomacy start+ do not rebind an already-set wife
			(try_begin),
				(troop_slot_eq, ":cur_troop", slot_troop_spouse, -1),
				#There may be a better solution, but to avoid oddities disable automatic spouses if there is a gender mismatch.
				#Mods that add additional races may want to tweak this (for example if some races shouldn't intermarry).
				(call_script, "script_dplmc_store_is_female_troop_1_troop_2", ":cur_troop", ":cur_lady"),
				#Types are stored to reg0 and reg1.
				(neq, reg0, reg1),#lord and lady aren't both female or both non-female
				(val_mul, reg0, reg1),
				(eq, reg0, 0),#at least one of lord or lady is non-female
			##diplomacy end+
				(troop_set_slot, ":cur_troop", slot_troop_spouse, ":cur_lady"),
				(troop_set_slot, ":cur_lady", slot_troop_spouse, ":cur_troop"),
                (store_faction_of_troop, ":cur_troop_faction", ":cur_troop"),
                (call_script, "script_troop_set_title_according_to_faction", ":cur_lady", ":cur_troop_faction"),
				(store_random_in_range, ":wife_reputation", 20, 26),
				(try_begin),
					(eq, ":wife_reputation", 20),
					(assign, ":wife_reputation", lrep_conventional),
				(try_end),
				(troop_set_slot, ":cur_lady", slot_lord_reputation_type, ":wife_reputation"),


				(call_script, "script_init_troop_age", ":cur_lady", 49),
				(call_script, "script_add_lady_items", ":cur_lady"),

				(val_add, ":cur_lady", 1),
			##diplomacy start+
			(try_end),
			##diplomacy end+

			#daughter
			##diplomacy start+
			(try_begin),
			##diplomacy end+
				(troop_set_slot, ":cur_lady", slot_troop_father, ":cur_troop"),
				(store_sub, ":mother", ":cur_lady", 1),
				(call_script, "script_init_troop_age", ":cur_lady", 19),
			##diplomacy start+
				#fix native bug (daughters are their own mothers)
        # Note: this bug was fixed in native version 1.158
				#(troop_set_slot, ":cur_lady", slot_troop_mother, ":cur_lady"),
				(troop_set_slot, ":cur_lady", slot_troop_mother, ":mother"),
				(try_begin),
					#swap father and mother slots if the lord was female (do nothing if both were female)
					(call_script, "script_dplmc_store_is_female_troop_1_troop_2", ":cur_troop", ":mother"),
					(neq, reg0, 0),#:cur_troop is female
					(eq, reg1, 0),#:mother is not female
					(troop_set_slot, ":cur_lady", slot_troop_mother, ":cur_troop"),
					(troop_set_slot, ":cur_lady", slot_troop_father, ":mother"),
				(try_end),
			##diplomacy end+
				(store_random_in_range, ":lady_reputation", lrep_conventional, 34), #33% chance of father-derived
				(try_begin),
					(le, ":lady_reputation", 25),
					(troop_set_slot, ":cur_lady", slot_lord_reputation_type, ":lady_reputation"),
				(else_try),
					(eq, ":lady_reputation", 26),
					(troop_set_slot, ":cur_lady", slot_lord_reputation_type, lrep_conventional),
				(else_try),
					(eq, ":lady_reputation", 27),
					(troop_set_slot, ":cur_lady", slot_lord_reputation_type, lrep_moralist),
				(else_try),
					(assign, ":guardian_reputation", ":reputation"),
					(try_begin),
						(this_or_next|eq, ":guardian_reputation", lrep_martial),
							(eq, ":guardian_reputation", 0),
						(troop_set_slot, ":cur_lady", slot_lord_reputation_type, lrep_conventional),
					(else_try),
						(eq, ":guardian_reputation", lrep_quarrelsome),
						(troop_set_slot, ":cur_lady", slot_lord_reputation_type, lrep_otherworldly),
					(else_try),
						(eq, ":guardian_reputation", lrep_selfrighteous),
						(troop_set_slot, ":cur_lady", slot_lord_reputation_type, lrep_ambitious),
					(else_try),
						(eq, ":guardian_reputation", lrep_cunning),
						(troop_set_slot, ":cur_lady", slot_lord_reputation_type, lrep_adventurous),
					(else_try),
						(eq, ":guardian_reputation", lrep_goodnatured),
						(troop_set_slot, ":cur_lady", slot_lord_reputation_type, lrep_adventurous),
					(else_try),
						(eq, ":guardian_reputation", lrep_debauched),
						(troop_set_slot, ":cur_lady", slot_lord_reputation_type, lrep_ambitious),
					(else_try),
						(eq, ":guardian_reputation", lrep_upstanding),
						(troop_set_slot, ":cur_lady", slot_lord_reputation_type, lrep_moralist),
					(try_end),
				(try_end),

				(call_script, "script_add_lady_items", ":cur_lady"),
				(val_add, ":cur_lady", 1),
			##diplomacy start+
			(try_end),
			##diplomacy end+
			#high renown

		(else_try),	#Older unmarried lords
			(is_between, ":npc_seed", 8, 12),

			(store_random_in_range, ":age", 25, 36),
			##diplomacy start+ do not overwrite reputation if it was already set explicitly
			(troop_get_slot, ":reputation", ":cur_troop", slot_lord_reputation_type),
			(try_begin),
				(lt, ":reputation", 1),
				#Original behavior:
				(store_random_in_range, ":reputation", 0, 8),
			(try_end),
			##diplomacy end+

			(store_random_in_range, ":sister_reputation", 20, 26),
			(try_begin),
				(eq, ":sister_reputation", 20),
				(assign, ":sister_reputation", lrep_conventional),
			(try_end),
			(troop_set_slot, ":cur_lady", slot_lord_reputation_type, ":sister_reputation"),

			(troop_set_slot, ":cur_lady", slot_troop_guardian, ":cur_troop"),
			##diplomacy start+
			#Initialize parents
			(try_begin),
				(troop_slot_eq, ":cur_troop", slot_troop_father, -1),
				(store_mul, ":new_index", ":cur_troop", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),#defined in module_constants.py
				(val_add, ":new_index", DPLMC_VIRTUAL_RELATIVE_FATHER_OFFSET),#defined in module_constants.py
				(troop_set_slot, ":cur_troop", slot_troop_father, ":new_index"),
				(troop_slot_eq, ":cur_lady", slot_troop_father, -1),
				(troop_set_slot, ":cur_lady", slot_troop_father, ":new_index"),
			(try_end),
			(try_begin),
				(troop_slot_eq, ":cur_troop", slot_troop_mother, -1),
				(store_mul, ":new_index", ":cur_troop", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),#defined in module_constants.py
				(val_add, ":new_index", DPLMC_VIRTUAL_RELATIVE_MOTHER_OFFSET),#defined in module_constants.py
				(troop_set_slot, ":cur_troop", slot_troop_mother, ":new_index"),
				(troop_slot_eq, ":cur_lady", slot_troop_mother, -1),
				(troop_set_slot, ":cur_lady", slot_troop_mother, ":new_index"),
			(try_end),
			##diplomacy end+

			(call_script, "script_init_troop_age", ":cur_lady", 21),
			(call_script, "script_add_lady_items", ":cur_lady"),

			(val_add, ":cur_lady", 1),

		(else_try),	#Younger unmarried lords
			#age is father's minus 20 to 25
			(store_sub, ":father", ":cur_troop", 12),
			##diplomacy start+
			#Some submods don't pay attention to this aspect of the troop list, and
			#so initialization produces absurd or impossible results.  Prevent such
			#things from appearing in the game.
			(try_begin),
				#"father" can be father or mother
				#(troop_get_type, ":parent_type", ":father"),
				(try_begin),
					#(eq, ":parent_type", tf_female),
					(call_script, "script_cf_dplmc_troop_is_female", ":father"),
					(assign, ":parent_slot", slot_troop_mother),
					(assign, ":other_parent_slot", slot_troop_father),
				(else_try),
					(assign, ":parent_slot", slot_troop_father),
					(assign, ":other_parent_slot", slot_troop_mother),
				(try_end),

				(troop_slot_eq, ":cur_troop", ":parent_slot", -1),
				(store_add, ":logical_minimum_age", ":father_age_at_birth", 16),
				(troop_slot_ge, ":father", slot_troop_age, ":logical_minimum_age"),
				#Passed test
				(troop_set_slot, ":cur_troop", ":parent_slot", ":father"),
				#Set mother if not already specified
				(try_begin),
					(troop_slot_eq, ":cur_troop", ":other_parent_slot", -1),
					(troop_get_slot, ":mother", ":father", slot_troop_spouse),
					(troop_set_slot, ":cur_troop", ":other_parent_slot", ":mother"),
				(try_end),

				(troop_get_slot, ":father_age", ":father", slot_troop_age),
				(store_sub, ":age", ":father_age", ":father_age_at_birth"),

				(troop_get_slot, ":reputation", ":cur_troop", slot_lord_reputation_type),
				(try_begin),
					#Don't change reputation if it already has been set
					(lt, ":reputation", 1),
					#50% chance of having father's rep
					(store_random_in_range, ":reputation", 0, 16),

					(gt, ":reputation", 7),
					(troop_get_slot, ":reputation", ":father", slot_lord_reputation_type),
				(try_end),
			(else_try),
				#Average age is [45,63] minus [23,25], so [22, 38]
				(store_random_in_range, ":age", 22, 39),
				(troop_get_slot, ":reputation", ":cur_troop", slot_lord_reputation_type),
				#Don't change reputation if it already has been set
				(lt, ":reputation", 1),
				(store_random_in_range, ":reputation", 0, 8),
			(try_end),
			#diplomacy end+
		(try_end),

		(try_begin),
			(eq, ":reputation", 0),
			(assign, ":reputation", 1),
		(try_end),

        (troop_set_slot, ":cur_troop", slot_lord_reputation_type, ":reputation"),

		(call_script, "script_init_troop_age", ":cur_troop", ":age"),
	  (try_end),

	  (try_begin),
	    (eq, "$cheat_mode", 1),
	    (assign, reg3, "$cheat_mode"),
	    (display_message, "@{!}DEBUG -- Assigned lord reputation and relations"),

#	    (display_message, "str_assigned_lord_reputation_and_relations_cheat_mode_reg3"), #This string can be removed
	  (try_end),

	  (try_for_range, ":cur_troop", pretenders_begin, pretenders_end),
		(troop_set_slot, ":cur_troop", slot_troop_occupation, slto_inactive_pretender),
		(store_random_in_range, ":age", 25, 30),
		(troop_set_slot, ":cur_troop", slot_troop_age, ":age"),
		(eq, ":cur_troop", "trp_kingdom_5_pretender"),
		(troop_set_slot, ":cur_troop", slot_troop_age, 45),
	  (try_end),
	]),





	("initialize_trade_routes",
	[
	  #SARGOTH - 10 routes
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_2"), #Sargoth - Tihr
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_4"), #Sargoth - Suno
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_12"), #Sargoth - Wercheg
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_11"), #Sargoth - Curaw
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_8"), #Sargoth - Reyvadin
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_13"), #Sargoth - Rivacheg
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_7"), #Sargoth - Uxkhal
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_9"), #Sargoth - Khudan
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_6"), #Sargoth - Praven
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_15"), #Sargoth - Yalen
      (call_script, "script_set_trade_route_between_centers", "p_town_1", "p_town_16"), #Sargoth - Dhirim

	  #TIHR- 8 Routes
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_4"), #Tihr- Suno
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_6"), #Tihr - Praven
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_7"), #Tihr - Uxkhal
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_15"), #Tihr - Yalen
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_12"), #Tihr - Wercheg
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_8"), #Tihr - Reyvadin
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_11"), #Tihr - Curaw
      (call_script, "script_set_trade_route_between_centers", "p_town_2", "p_town_16"), #Thir - Dhirim

	  #VELUCA - 8 Routes
      (call_script, "script_set_trade_route_between_centers", "p_town_3", "p_town_7"), #Veluca- Uxkhal
      (call_script, "script_set_trade_route_between_centers", "p_town_3", "p_town_5"), #Veluca - Jelkala
      (call_script, "script_set_trade_route_between_centers", "p_town_3", "p_town_15"), #Veluca - Yalen
      (call_script, "script_set_trade_route_between_centers", "p_town_3", "p_town_16"), #Veluca - Dhirim
      (call_script, "script_set_trade_route_between_centers", "p_town_3", "p_town_14"), #Veluca - Halmar
      (call_script, "script_set_trade_route_between_centers", "p_town_3", "p_town_4"), #Veluca - Suno
      (call_script, "script_set_trade_route_between_centers", "p_town_3", "p_town_19"), #Veluca - Shariz
      (call_script, "script_set_trade_route_between_centers", "p_town_3", "p_town_6"), #Veluca - Praven

	  #SUNO - 11 routes
	  #Sargoth, Tihr, Veluca
      (call_script, "script_set_trade_route_between_centers", "p_town_4", "p_town_12"), #Suno - Wercheg
      (call_script, "script_set_trade_route_between_centers", "p_town_4", "p_town_8"), #Suno - Reyvadin
      (call_script, "script_set_trade_route_between_centers", "p_town_4", "p_town_11"), #Suno - Curaw
      (call_script, "script_set_trade_route_between_centers", "p_town_4", "p_town_6"), #Suno - Praven
      (call_script, "script_set_trade_route_between_centers", "p_town_4", "p_town_7"), #Suno - Uxkhal
      (call_script, "script_set_trade_route_between_centers", "p_town_4", "p_town_16"), #Suno - Dhirim
      (call_script, "script_set_trade_route_between_centers", "p_town_4", "p_town_5"), #Suno - Jelkala
      (call_script, "script_set_trade_route_between_centers", "p_town_4", "p_town_15"), #Suno - Yalen

	  #JELKALA - 6 ROUTES
      #Veluca, Suno
      (call_script, "script_set_trade_route_between_centers", "p_town_5", "p_town_15"), #Jelkala - Yalen
      (call_script, "script_set_trade_route_between_centers", "p_town_5", "p_town_6"), #Jelkala - Praven
      (call_script, "script_set_trade_route_between_centers", "p_town_5", "p_town_7"), #Jelkala - Uxkhal
      (call_script, "script_set_trade_route_between_centers", "p_town_5", "p_town_19"), #Jelkala - Shariz

	  #PRAVEN - 7 ROUTES
	  #Tihr, Veluca, Suno, Jelkala
      (call_script, "script_set_trade_route_between_centers", "p_town_6", "p_town_7"), #Praven - Uxkhal
      (call_script, "script_set_trade_route_between_centers", "p_town_6", "p_town_15"), #Praven - Yalen
      (call_script, "script_set_trade_route_between_centers", "p_town_6", "p_town_16"), #Praven - Dhirim

	  #UXKHAL - 9 Routes
	  #Sargoth, Tihr, Suno, Jelkala, Praven
      (call_script, "script_set_trade_route_between_centers", "p_town_7", "p_town_15"), #Yalen
      (call_script, "script_set_trade_route_between_centers", "p_town_7", "p_town_16"), #Dhirim
      (call_script, "script_set_trade_route_between_centers", "p_town_7", "p_town_19"), #Shariz
      (call_script, "script_set_trade_route_between_centers", "p_town_7", "p_town_14"), #Halmar

	  #REYVADIN - 9 Routes
	  #Suno, Sargoth
      (call_script, "script_set_trade_route_between_centers", "p_town_8", "p_town_9"), #Khudan
      (call_script, "script_set_trade_route_between_centers", "p_town_8", "p_town_11"), #Curaw
      (call_script, "script_set_trade_route_between_centers", "p_town_8", "p_town_12"), #Wercheg
      (call_script, "script_set_trade_route_between_centers", "p_town_8", "p_town_13"), #Rivacheg
      (call_script, "script_set_trade_route_between_centers", "p_town_8", "p_town_16"), #Dhirim
      (call_script, "script_set_trade_route_between_centers", "p_town_8", "p_town_18"), #Narra
      (call_script, "script_set_trade_route_between_centers", "p_town_8", "p_town_17"), #Ichamur

	  #KHUDAN - 9 Routes
	  #Sargoth, Reyvadin
      (call_script, "script_set_trade_route_between_centers", "p_town_9", "p_town_11"), #Curaw
      (call_script, "script_set_trade_route_between_centers", "p_town_9", "p_town_13"), #Rivacheg
      (call_script, "script_set_trade_route_between_centers", "p_town_9", "p_town_12"), #Wercheg
      (call_script, "script_set_trade_route_between_centers", "p_town_9", "p_town_17"), #Ichamur
      (call_script, "script_set_trade_route_between_centers", "p_town_9", "p_town_10"), #Tulga
      (call_script, "script_set_trade_route_between_centers", "p_town_9", "p_town_16"), #Dhirim
      (call_script, "script_set_trade_route_between_centers", "p_town_9", "p_town_18"), #Narra

	  #TULGA - 7 Routes
	  #Khudan
      (call_script, "script_set_trade_route_between_centers", "p_town_10", "p_town_17"), #Ichamur
      (call_script, "script_set_trade_route_between_centers", "p_town_10", "p_town_18"), #Narra
      (call_script, "script_set_trade_route_between_centers", "p_town_10", "p_town_22"), #Bariyye
      (call_script, "script_set_trade_route_between_centers", "p_town_10", "p_town_21"), #Ahmerrad
      (call_script, "script_set_trade_route_between_centers", "p_town_10", "p_town_14"), #Halmar
      (call_script, "script_set_trade_route_between_centers", "p_town_10", "p_town_20"), #Durquba

	  #CURAW - 9 Routes
	  #Khudan, Reyvadin, Sargoth, Suno
      (call_script, "script_set_trade_route_between_centers", "p_town_11", "p_town_12"), #Wercheg
      (call_script, "script_set_trade_route_between_centers", "p_town_11", "p_town_13"), #Rivacheg
      (call_script, "script_set_trade_route_between_centers", "p_town_11", "p_town_14"), #Halmar
      (call_script, "script_set_trade_route_between_centers", "p_town_11", "p_town_16"), #Dhirim
      (call_script, "script_set_trade_route_between_centers", "p_town_11", "p_town_17"), #Ichamur

	  #WERCHEG - 7 Routes
	  #Sargoth, Suno, Reyvadin, Khudan, Curaw, Tihr
      (call_script, "script_set_trade_route_between_centers", "p_town_12", "p_town_13"), #Rivacheg

	  #RIVACHEG - 6 Routes
	  #Sargoth, Reyvadin, Khudan, Curaw, Wercheg
      (call_script, "script_set_trade_route_between_centers", "p_town_13", "p_town_17"), #Ichamur

	  #HALMAR- 11 Routes
	  #Veluca, Uxkhal, Tulga, Curaw
      (call_script, "script_set_trade_route_between_centers", "p_town_14", "p_town_17"), #Ichamur
      (call_script, "script_set_trade_route_between_centers", "p_town_14", "p_town_18"), #Narra
      (call_script, "script_set_trade_route_between_centers", "p_town_14", "p_town_21"), #Ahmerrad
      (call_script, "script_set_trade_route_between_centers", "p_town_14", "p_town_22"), #Bariyye
      (call_script, "script_set_trade_route_between_centers", "p_town_14", "p_town_20"), #Durquba
      (call_script, "script_set_trade_route_between_centers", "p_town_14", "p_town_19"), #Shariz
      (call_script, "script_set_trade_route_between_centers", "p_town_14", "p_town_16"), #Dhirim

	  #YALEN - 7 Routes
	  #Sargoth, Tihr, Veluca, Suno, Jelkala, Praven, Uxkhal

	  #DHIRIM - 13 Routes
	  #Sargoth, Thir, Veluca, Suno, Praven, Uxkhal, Reyvadin, Khudan, Curaw, Halmar
      (call_script, "script_set_trade_route_between_centers", "p_town_16", "p_town_18"), #Narra
      (call_script, "script_set_trade_route_between_centers", "p_town_16", "p_town_20"), #Durquba
      (call_script, "script_set_trade_route_between_centers", "p_town_16", "p_town_19"), #Shariz

	  #ICHAMUR - 7 Routes
      #Reyvadin, Khudan, Tulga, Curaw, Rivacheg, Halmar
      (call_script, "script_set_trade_route_between_centers", "p_town_17", "p_town_18"), #Narra

	  #NARRA - 9 Routes
      #Reyvadin, Khudan, Tulga, Halmar, Dhirim, Ichamur
      (call_script, "script_set_trade_route_between_centers", "p_town_18", "p_town_20"), #Durquba
      (call_script, "script_set_trade_route_between_centers", "p_town_18", "p_town_21"), #Ahmerrad
      (call_script, "script_set_trade_route_between_centers", "p_town_18", "p_town_22"), #Bariyye

	  #SHARIZ - 8 Routes
      #Veluca, Jelkala, Uxkhal, Halmar, Dhirim
      (call_script, "script_set_trade_route_between_centers", "p_town_19", "p_town_20"), #Durquba
      (call_script, "script_set_trade_route_between_centers", "p_town_19", "p_town_21"), #Ahmerrad
      (call_script, "script_set_trade_route_between_centers", "p_town_19", "p_town_22"), #Bariyye

	  #DURQUBA - 7 Routes
      #Tulga, Halmar, Dhirim, Narra, Shariz
      (call_script, "script_set_trade_route_between_centers", "p_town_20", "p_town_21"), #Ahmerrad
      (call_script, "script_set_trade_route_between_centers", "p_town_20", "p_town_22"), #Bariyye

	  #AHMERRAD - 6 Routes
      #Tulga, Halmar, Narra, Shariz, Durquba
      (call_script, "script_set_trade_route_between_centers", "p_town_21", "p_town_22"), #Bariyye

	  #BARIYYE - 6 Routes
      #Tulga, Halmar, Narra, Shariz, Durquba, Ahmerrad
	]),



    ("initialize_faction_troop_types",
    [

      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (faction_get_slot, ":culture", ":faction_no", slot_faction_culture),

        (faction_get_slot, ":troop", ":culture",  slot_faction_tier_1_troop),
        (faction_set_slot, ":faction_no",  slot_faction_tier_1_troop, ":troop"),
        (faction_get_slot, ":troop", ":culture",  slot_faction_tier_2_troop),
        (faction_set_slot, ":faction_no",  slot_faction_tier_2_troop, ":troop"),
        (faction_get_slot, ":troop", ":culture",  slot_faction_tier_3_troop),
        (faction_set_slot, ":faction_no",  slot_faction_tier_3_troop, ":troop"),
        (faction_get_slot, ":troop", ":culture",  slot_faction_tier_4_troop),
        (faction_set_slot, ":faction_no",  slot_faction_tier_4_troop, ":troop"),
        (faction_get_slot, ":troop", ":culture",  slot_faction_tier_5_troop),
        (faction_set_slot, ":faction_no",  slot_faction_tier_5_troop, ":troop"),

        (try_begin),
          (faction_slot_eq, ":faction_no", slot_faction_culture, "fac_culture_1"),

          (faction_set_slot, ":faction_no",  slot_faction_deserter_troop, "trp_swadian_deserter"),
          (faction_set_slot, ":faction_no",  slot_faction_guard_troop, "trp_swadian_sergeant"),
          (faction_set_slot, ":faction_no",  slot_faction_messenger_troop, "trp_swadian_messenger"),
          (faction_set_slot, ":faction_no",  slot_faction_prison_guard_troop, "trp_swadian_prison_guard"),
          (faction_set_slot, ":faction_no",  slot_faction_castle_guard_troop, "trp_swadian_castle_guard"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_a, "pt_kingdom_1_reinforcements_a"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_b, "pt_kingdom_1_reinforcements_b"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_c, "pt_kingdom_1_reinforcements_c"),
        (else_try),
          (faction_slot_eq, ":faction_no", slot_faction_culture, "fac_culture_2"),

          (faction_set_slot, ":faction_no", slot_faction_deserter_troop, "trp_vaegir_deserter"),
          (faction_set_slot, ":faction_no", slot_faction_guard_troop, "trp_vaegir_guard"),
          (faction_set_slot, ":faction_no", slot_faction_messenger_troop, "trp_vaegir_messenger"),
          (faction_set_slot, ":faction_no", slot_faction_prison_guard_troop, "trp_vaegir_prison_guard"),
          (faction_set_slot, ":faction_no", slot_faction_castle_guard_troop, "trp_vaegir_castle_guard"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_a, "pt_kingdom_2_reinforcements_a"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_b, "pt_kingdom_2_reinforcements_b"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_c, "pt_kingdom_2_reinforcements_c"),
        (else_try),
          (faction_slot_eq, ":faction_no", slot_faction_culture, "fac_culture_3"),

          (faction_set_slot, ":faction_no", slot_faction_deserter_troop, "trp_khergit_deserter"),
          (faction_set_slot, ":faction_no", slot_faction_guard_troop, "trp_khergit_horseman"),
          (faction_set_slot, ":faction_no", slot_faction_messenger_troop, "trp_khergit_messenger"),
          (faction_set_slot, ":faction_no", slot_faction_prison_guard_troop, "trp_khergit_prison_guard"),
          (faction_set_slot, ":faction_no", slot_faction_castle_guard_troop, "trp_khergit_castle_guard"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_a, "pt_kingdom_3_reinforcements_a"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_b, "pt_kingdom_3_reinforcements_b"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_c, "pt_kingdom_3_reinforcements_c"),
        (else_try),
          (faction_slot_eq, ":faction_no", slot_faction_culture, "fac_culture_4"),

          (faction_set_slot, ":faction_no", slot_faction_deserter_troop, "trp_nord_deserter"),
          (faction_set_slot, ":faction_no", slot_faction_guard_troop, "trp_nord_warrior"),
          (faction_set_slot, ":faction_no", slot_faction_messenger_troop, "trp_nord_messenger"),
          (faction_set_slot, ":faction_no", slot_faction_prison_guard_troop, "trp_nord_prison_guard"),
          (faction_set_slot, ":faction_no", slot_faction_castle_guard_troop, "trp_nord_castle_guard"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_a, "pt_kingdom_4_reinforcements_a"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_b, "pt_kingdom_4_reinforcements_b"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_c, "pt_kingdom_4_reinforcements_c"),
        (else_try),
          (faction_slot_eq, ":faction_no", slot_faction_culture, "fac_culture_5"),

          (faction_set_slot, ":faction_no", slot_faction_deserter_troop, "trp_rhodok_deserter"),
          (faction_set_slot, ":faction_no", slot_faction_guard_troop, "trp_rhodok_veteran_spearman"),
          (faction_set_slot, ":faction_no", slot_faction_messenger_troop, "trp_rhodok_messenger"),
          (faction_set_slot, ":faction_no", slot_faction_prison_guard_troop, "trp_rhodok_prison_guard"),
          (faction_set_slot, ":faction_no", slot_faction_castle_guard_troop, "trp_rhodok_castle_guard"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_a, "pt_kingdom_5_reinforcements_a"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_b, "pt_kingdom_5_reinforcements_b"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_c, "pt_kingdom_5_reinforcements_c"),
        (else_try),
          (faction_slot_eq, ":faction_no", slot_faction_culture, "fac_culture_6"),

          (faction_set_slot, ":faction_no", slot_faction_deserter_troop, "trp_sarranid_deserter"),
          (faction_set_slot, ":faction_no", slot_faction_guard_troop, "trp_sarranid_castle_guard"),
          (faction_set_slot, ":faction_no", slot_faction_messenger_troop, "trp_sarranid_messenger"),
          (faction_set_slot, ":faction_no", slot_faction_prison_guard_troop, "trp_sarranid_prison_guard"),
          (faction_set_slot, ":faction_no", slot_faction_castle_guard_troop, "trp_sarranid_castle_guard"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_a, "pt_kingdom_6_reinforcements_a"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_b, "pt_kingdom_6_reinforcements_b"),
          (faction_set_slot, ":faction_no",  slot_faction_reinforcements_c, "pt_kingdom_6_reinforcements_c"),
        (try_end),
      (try_end),
	]),

    ("initialize_item_info",
    [
	  # Setting food bonuses - these have been changed to incentivize using historical rations. Bread is the most cost-efficient
	  #Staples
      (item_set_slot, "itm_bread", slot_item_food_bonus, 8), #brought up from 4
      (item_set_slot, "itm_grain", slot_item_food_bonus, 2), #new - can be boiled as porridge

	  #Fat sources - preserved
      (item_set_slot, "itm_smoked_fish", slot_item_food_bonus, 4),
      (item_set_slot, "itm_dried_meat", slot_item_food_bonus, 5),
      (item_set_slot, "itm_cheese", slot_item_food_bonus, 5),
      (item_set_slot, "itm_sausages", slot_item_food_bonus, 5),
      (item_set_slot, "itm_butter", slot_item_food_bonus, 4), #brought down from 8

	  #Fat sources - perishable
      (item_set_slot, "itm_chicken", slot_item_food_bonus, 8), #brought up from 7
      (item_set_slot, "itm_cattle_meat", slot_item_food_bonus, 7), #brought down from 7
      (item_set_slot, "itm_pork", slot_item_food_bonus, 6), #brought down from 6

	  #Produce
      (item_set_slot, "itm_raw_olives", slot_item_food_bonus, 1),
      (item_set_slot, "itm_cabbages", slot_item_food_bonus, 2),
      (item_set_slot, "itm_raw_grapes", slot_item_food_bonus, 3),
      (item_set_slot, "itm_apples", slot_item_food_bonus, 4), #brought down from 5

	  #Sweet items
      (item_set_slot, "itm_raw_date_fruit", slot_item_food_bonus, 4), #brought down from 8
      (item_set_slot, "itm_honey", slot_item_food_bonus, 6), #brought down from 12

      (item_set_slot, "itm_wine", slot_item_food_bonus, 5),
      (item_set_slot, "itm_ale", slot_item_food_bonus, 4),

	  #Item economic settings
	  (item_set_slot, "itm_grain", slot_item_urban_demand, 20),
      (item_set_slot, "itm_grain", slot_item_rural_demand, 20),
      (item_set_slot, "itm_grain", slot_item_desert_demand, 20),
      (item_set_slot, "itm_grain", slot_item_production_slot, slot_center_acres_grain),
      (item_set_slot, "itm_grain", slot_item_production_string, "str_acres_grain"),
      (item_set_slot, "itm_grain", slot_item_base_price, 30),

      (item_set_slot, "itm_bread", slot_item_urban_demand, 30),
      (item_set_slot, "itm_bread", slot_item_rural_demand, 30),
      (item_set_slot, "itm_bread", slot_item_desert_demand, 30),
      (item_set_slot, "itm_bread", slot_item_production_slot, slot_center_mills),
      (item_set_slot, "itm_bread", slot_item_production_string, "str_mills"),
      (item_set_slot, "itm_bread", slot_item_primary_raw_material, "itm_grain"),
      (item_set_slot, "itm_bread", slot_item_input_number, 6),
      (item_set_slot, "itm_bread", slot_item_output_per_run, 6),
      (item_set_slot, "itm_bread", slot_item_overhead_per_run, 30),
      (item_set_slot, "itm_bread", slot_item_base_price, 50),
      (item_set_slot, "itm_bread", slot_item_enterprise_building_cost, 1500),

	  (item_set_slot, "itm_ale", slot_item_urban_demand, 10),
	  (item_set_slot, "itm_ale", slot_item_rural_demand, 15),
      (item_set_slot, "itm_ale", slot_item_desert_demand, 0),
      (item_set_slot, "itm_ale", slot_item_production_slot, slot_center_breweries),
      (item_set_slot, "itm_ale", slot_item_production_string, "str_breweries"),
      (item_set_slot, "itm_ale", slot_item_base_price, 120),
      (item_set_slot, "itm_ale", slot_item_primary_raw_material, "itm_grain"),
	  (item_set_slot, "itm_ale", slot_item_input_number, 1),
      (item_set_slot, "itm_ale", slot_item_output_per_run, 2),
      (item_set_slot, "itm_ale", slot_item_overhead_per_run, 50),
      (item_set_slot, "itm_ale", slot_item_base_price, 120),
      (item_set_slot, "itm_ale", slot_item_enterprise_building_cost, 2500),

	  (item_set_slot, "itm_wine", slot_item_urban_demand, 15),
	  (item_set_slot, "itm_wine", slot_item_rural_demand, 10),
      (item_set_slot, "itm_wine", slot_item_desert_demand, 25),
      (item_set_slot, "itm_wine", slot_item_production_slot, slot_center_wine_presses),
      (item_set_slot, "itm_wine", slot_item_production_string, "str_presses"),
      (item_set_slot, "itm_wine", slot_item_primary_raw_material, "itm_raw_grapes"),
      (item_set_slot, "itm_wine", slot_item_input_number, 4),
      (item_set_slot, "itm_wine", slot_item_output_per_run, 2),
	  (item_set_slot, "itm_wine", slot_item_overhead_per_run, 60),
      (item_set_slot, "itm_wine", slot_item_base_price, 220),
      (item_set_slot, "itm_wine", slot_item_enterprise_building_cost, 5000),

	  (item_set_slot, "itm_raw_grapes", slot_item_urban_demand, 0),
	  (item_set_slot, "itm_raw_grapes", slot_item_rural_demand, 0),
      (item_set_slot, "itm_raw_grapes", slot_item_desert_demand, 0),
      (item_set_slot, "itm_raw_grapes", slot_item_production_slot, slot_center_acres_vineyard),
      (item_set_slot, "itm_raw_grapes", slot_item_production_string, "str_acres_orchard"),
      (item_set_slot, "itm_raw_grapes", slot_item_is_raw_material_only_for, "itm_wine"),
      (item_set_slot, "itm_raw_grapes", slot_item_base_price, 75),

	  (item_set_slot, "itm_apples", slot_item_urban_demand, 4),
	  (item_set_slot, "itm_apples", slot_item_rural_demand, 4),
	  (item_set_slot, "itm_apples", slot_item_desert_demand, 0),
      (item_set_slot, "itm_apples", slot_item_production_slot, slot_center_acres_vineyard),
      (item_set_slot, "itm_apples", slot_item_production_string, "str_acres_orchard"),
      (item_set_slot, "itm_apples", slot_item_base_price, 44),

      (item_set_slot, "itm_smoked_fish", slot_item_urban_demand, 16),
      (item_set_slot, "itm_smoked_fish", slot_item_rural_demand, 16),
      (item_set_slot, "itm_smoked_fish", slot_item_desert_demand, 16),
      (item_set_slot, "itm_smoked_fish", slot_item_production_slot, slot_center_fishing_fleet),
      (item_set_slot, "itm_smoked_fish", slot_item_production_string, "str_boats"),

      (item_set_slot, "itm_salt", slot_item_urban_demand, 5),
      (item_set_slot, "itm_salt", slot_item_rural_demand, 3),
      (item_set_slot, "itm_salt", slot_item_desert_demand, -1),
      (item_set_slot, "itm_salt", slot_item_production_slot, slot_center_salt_pans),
      (item_set_slot, "itm_salt", slot_item_production_string, "str_pans"),

      (item_set_slot, "itm_dried_meat", slot_item_urban_demand, 20),
      (item_set_slot, "itm_dried_meat", slot_item_rural_demand, 5),
      (item_set_slot, "itm_dried_meat", slot_item_desert_demand, -1),
      (item_set_slot, "itm_dried_meat", slot_item_production_slot, slot_center_head_cattle),
      (item_set_slot, "itm_dried_meat", slot_item_production_string, "str_head_cattle"),

      (item_set_slot, "itm_cattle_meat", slot_item_urban_demand, 12),
      (item_set_slot, "itm_cattle_meat", slot_item_rural_demand, 3),
      (item_set_slot, "itm_cattle_meat", slot_item_desert_demand, -1),
      (item_set_slot, "itm_cattle_meat", slot_item_production_slot, slot_center_head_cattle),
      (item_set_slot, "itm_cattle_meat", slot_item_production_string, "str_head_cattle"),

      (item_set_slot, "itm_cheese", slot_item_urban_demand, 10),
      (item_set_slot, "itm_cheese", slot_item_rural_demand, 10),
      (item_set_slot, "itm_cheese", slot_item_desert_demand, 10),
      (item_set_slot, "itm_cheese", slot_item_production_slot, slot_center_head_cattle),
      (item_set_slot, "itm_cheese", slot_item_production_string, "str_head_cattle"),

      (item_set_slot, "itm_butter", slot_item_urban_demand, 2),
      (item_set_slot, "itm_butter", slot_item_rural_demand, 2),
      (item_set_slot, "itm_butter", slot_item_desert_demand, 2),
      (item_set_slot, "itm_butter", slot_item_production_slot, slot_center_head_cattle),
      (item_set_slot, "itm_butter", slot_item_production_string, "str_head_cattle"),

      (item_set_slot, "itm_leatherwork", slot_item_urban_demand, 10),
      (item_set_slot, "itm_leatherwork", slot_item_rural_demand, 10),
      (item_set_slot, "itm_leatherwork", slot_item_desert_demand, 10),
      (item_set_slot, "itm_leatherwork", slot_item_production_slot, slot_center_tanneries),
      (item_set_slot, "itm_leatherwork", slot_item_production_string, "str_tanneries"),
      (item_set_slot, "itm_leatherwork", slot_item_primary_raw_material, "itm_raw_leather"),
      (item_set_slot, "itm_leatherwork", slot_item_input_number, 3),
      (item_set_slot, "itm_leatherwork", slot_item_output_per_run, 3),
      (item_set_slot, "itm_leatherwork", slot_item_overhead_per_run, 50),
	  (item_set_slot, "itm_leatherwork", slot_item_base_price, 220),
	  (item_set_slot, "itm_leatherwork", slot_item_enterprise_building_cost, 8000),

      (item_set_slot, "itm_raw_leather", slot_item_urban_demand, 0),
      (item_set_slot, "itm_raw_leather", slot_item_rural_demand, 0),
      (item_set_slot, "itm_raw_leather", slot_item_desert_demand, 0),
      (item_set_slot, "itm_raw_leather", slot_item_production_slot, slot_center_head_cattle),
      (item_set_slot, "itm_raw_leather", slot_item_production_string, "str_head_cattle"),
      (item_set_slot, "itm_raw_leather", slot_item_is_raw_material_only_for, "itm_leatherwork"),
	  (item_set_slot, "itm_raw_leather", slot_item_base_price, 120),

  	  (item_set_slot, "itm_sausages", slot_item_urban_demand, 12),
	  (item_set_slot, "itm_sausages", slot_item_rural_demand, 3),
	  (item_set_slot, "itm_sausages", slot_item_desert_demand, -1),
      (item_set_slot, "itm_sausages", slot_item_production_slot, slot_center_head_sheep),
      (item_set_slot, "itm_sausages", slot_item_production_string, "str_head_sheep"),

	  (item_set_slot, "itm_wool", slot_item_urban_demand, 0),
	  (item_set_slot, "itm_wool", slot_item_rural_demand, 0),
	  (item_set_slot, "itm_wool", slot_item_desert_demand, 0),
      (item_set_slot, "itm_wool", slot_item_production_slot, slot_center_head_sheep),
      (item_set_slot, "itm_wool", slot_item_production_string, "str_head_sheep"),
	  (item_set_slot, "itm_wool", slot_item_is_raw_material_only_for, "itm_wool_cloth"),
	  (item_set_slot, "itm_wool", slot_item_base_price,130),

	  (item_set_slot, "itm_wool_cloth", slot_item_urban_demand, 15),
	  (item_set_slot, "itm_wool_cloth", slot_item_rural_demand, 20),
	  (item_set_slot, "itm_wool_cloth", slot_item_desert_demand, 5),
      (item_set_slot, "itm_wool_cloth", slot_item_production_slot, slot_center_wool_looms),
      (item_set_slot, "itm_wool_cloth", slot_item_production_string, "str_looms"),
	  (item_set_slot, "itm_wool_cloth", slot_item_primary_raw_material, "itm_wool"),
      (item_set_slot, "itm_wool_cloth", slot_item_input_number, 2),
      (item_set_slot, "itm_wool_cloth", slot_item_output_per_run, 2),
      (item_set_slot, "itm_wool_cloth", slot_item_overhead_per_run, 120),
	  (item_set_slot, "itm_wool_cloth", slot_item_base_price, 250),
	  (item_set_slot, "itm_wool_cloth", slot_item_enterprise_building_cost, 6000),

	  (item_set_slot, "itm_raw_flax", slot_item_urban_demand, 0),
	  (item_set_slot, "itm_raw_flax", slot_item_rural_demand, 0),
	  (item_set_slot, "itm_raw_flax", slot_item_desert_demand, 0),
      (item_set_slot, "itm_raw_flax", slot_item_production_slot, slot_center_acres_flax),
      (item_set_slot, "itm_raw_flax", slot_item_production_string, "str_acres_flax"),
      (item_set_slot, "itm_raw_flax", slot_item_is_raw_material_only_for, "itm_linen"),
	  (item_set_slot, "itm_raw_flax", slot_item_base_price, 150),

	  (item_set_slot, "itm_linen", slot_item_urban_demand, 7),
	  (item_set_slot, "itm_linen", slot_item_rural_demand, 3),
	  (item_set_slot, "itm_linen", slot_item_desert_demand, 15),
      (item_set_slot, "itm_linen", slot_item_production_slot, slot_center_linen_looms),
      (item_set_slot, "itm_linen", slot_item_production_string, "str_looms"),
      (item_set_slot, "itm_linen", slot_item_primary_raw_material, "itm_raw_flax"),
      (item_set_slot, "itm_linen", slot_item_input_number, 2),
      (item_set_slot, "itm_linen", slot_item_output_per_run, 2),
      (item_set_slot, "itm_linen", slot_item_overhead_per_run, 120),
	  (item_set_slot, "itm_linen", slot_item_base_price, 250),
	  (item_set_slot, "itm_linen", slot_item_enterprise_building_cost, 6000),

	  (item_set_slot, "itm_iron", slot_item_urban_demand, 0),
	  (item_set_slot, "itm_iron", slot_item_rural_demand, 0),
	  (item_set_slot, "itm_iron", slot_item_desert_demand, 0),
      (item_set_slot, "itm_iron", slot_item_production_slot, slot_center_iron_deposits),
      (item_set_slot, "itm_iron", slot_item_production_string, "str_deposits"),
      (item_set_slot, "itm_iron", slot_item_is_raw_material_only_for, "itm_tools"),
	  (item_set_slot, "itm_iron", slot_item_base_price, 264),

	  (item_set_slot, "itm_tools", slot_item_urban_demand, 7),
	  (item_set_slot, "itm_tools", slot_item_rural_demand, 7),
	  (item_set_slot, "itm_tools", slot_item_desert_demand, 7),
      (item_set_slot, "itm_tools", slot_item_production_slot, slot_center_smithies),
      (item_set_slot, "itm_tools", slot_item_production_string, "str_smithies"),
      (item_set_slot, "itm_tools", slot_item_primary_raw_material, "itm_iron"),
      (item_set_slot, "itm_tools", slot_item_input_number, 2),
      (item_set_slot, "itm_tools", slot_item_output_per_run, 2),
      (item_set_slot, "itm_tools", slot_item_overhead_per_run, 60),
	  (item_set_slot, "itm_tools", slot_item_base_price, 410),
	  (item_set_slot, "itm_tools", slot_item_enterprise_building_cost, 3500),

	  (item_set_slot, "itm_pottery", slot_item_urban_demand, 15),
	  (item_set_slot, "itm_pottery", slot_item_rural_demand, 5),
	  (item_set_slot, "itm_pottery", slot_item_desert_demand, -1),
      (item_set_slot, "itm_pottery", slot_item_production_slot, slot_center_pottery_kilns),
      (item_set_slot, "itm_pottery", slot_item_production_string, "str_kilns"),

	  (item_set_slot, "itm_oil", slot_item_urban_demand, 10),
	  (item_set_slot, "itm_oil", slot_item_rural_demand, 5),
	  (item_set_slot, "itm_oil", slot_item_desert_demand, -1),
      (item_set_slot, "itm_oil", slot_item_production_slot, slot_center_olive_presses),
      (item_set_slot, "itm_oil", slot_item_production_string, "str_presses"),
      (item_set_slot, "itm_oil", slot_item_primary_raw_material, "itm_raw_olives"),
      (item_set_slot, "itm_oil", slot_item_input_number, 6),
      (item_set_slot, "itm_oil", slot_item_output_per_run, 2),
      (item_set_slot, "itm_oil", slot_item_overhead_per_run, 80),
	  (item_set_slot, "itm_oil", slot_item_base_price, 450),
	  (item_set_slot, "itm_oil", slot_item_enterprise_building_cost, 4500),

	  (item_set_slot, "itm_raw_olives", slot_item_urban_demand, 0),
	  (item_set_slot, "itm_raw_olives", slot_item_rural_demand, 0),
	  (item_set_slot, "itm_raw_olives", slot_item_desert_demand, 0),
      (item_set_slot, "itm_raw_olives", slot_item_production_slot, slot_center_acres_olives),
      (item_set_slot, "itm_raw_olives", slot_item_production_string, "str_olive_groves"),
      (item_set_slot, "itm_raw_olives", slot_item_is_raw_material_only_for, "itm_oil"),
	  (item_set_slot, "itm_raw_olives", slot_item_base_price, 100),

	  (item_set_slot, "itm_velvet", slot_item_urban_demand, 5),
	  (item_set_slot, "itm_velvet", slot_item_rural_demand, 0),
	  (item_set_slot, "itm_velvet", slot_item_desert_demand, -1),
      (item_set_slot, "itm_velvet", slot_item_production_slot, slot_center_silk_looms),
      (item_set_slot, "itm_velvet", slot_item_production_string, "str_looms"),
	  (item_set_slot, "itm_velvet", slot_item_primary_raw_material, "itm_raw_silk"),
      (item_set_slot, "itm_velvet", slot_item_input_number, 2),
      (item_set_slot, "itm_velvet", slot_item_output_per_run, 2),
      (item_set_slot, "itm_velvet", slot_item_overhead_per_run, 160),
	  (item_set_slot, "itm_velvet", slot_item_base_price, 1025),
	  (item_set_slot, "itm_velvet", slot_item_secondary_raw_material, "itm_raw_dyes"),
	  (item_set_slot, "itm_velvet", slot_item_enterprise_building_cost, 10000),

	  (item_set_slot, "itm_raw_silk", slot_item_urban_demand, 0),
	  (item_set_slot, "itm_raw_silk", slot_item_rural_demand, 0),
      (item_set_slot, "itm_raw_silk", slot_item_production_slot, slot_center_silk_farms),
      (item_set_slot, "itm_raw_silk", slot_item_production_string, "str_mulberry_groves"),
      (item_set_slot, "itm_raw_silk", slot_item_is_raw_material_only_for, "itm_velvet"),
      (item_set_slot, "itm_raw_silk", slot_item_base_price, 600),

	  (item_set_slot, "itm_raw_dyes", slot_item_urban_demand, 3),
	  (item_set_slot, "itm_raw_dyes", slot_item_rural_demand, 0),
	  (item_set_slot, "itm_raw_dyes", slot_item_desert_demand, -1),
	  (item_set_slot, "itm_raw_dyes", slot_item_production_string, "str_caravans"),
	  (item_set_slot, "itm_raw_dyes", slot_item_base_price, 200),

	  (item_set_slot, "itm_spice", slot_item_urban_demand, 5),
	  (item_set_slot, "itm_spice", slot_item_rural_demand, 0),
	  (item_set_slot, "itm_spice", slot_item_desert_demand, 5),
	  (item_set_slot, "itm_spice", slot_item_production_string, "str_caravans"),

	  (item_set_slot, "itm_furs", slot_item_urban_demand, 5),
	  (item_set_slot, "itm_furs", slot_item_rural_demand, 0),
	  (item_set_slot, "itm_furs", slot_item_desert_demand, -1),
	  (item_set_slot, "itm_furs", slot_item_production_slot, slot_center_fur_traps),
	  (item_set_slot, "itm_furs", slot_item_production_string, "str_traps"),

      (item_set_slot, "itm_honey", slot_item_urban_demand, 12),
      (item_set_slot, "itm_honey", slot_item_rural_demand, 3),
      (item_set_slot, "itm_honey", slot_item_desert_demand, -1),
      (item_set_slot, "itm_honey", slot_item_production_slot, slot_center_apiaries),
      (item_set_slot, "itm_honey", slot_item_production_string, "str_hives"),

      (item_set_slot, "itm_cabbages", slot_item_urban_demand, 7),
      (item_set_slot, "itm_cabbages", slot_item_rural_demand, 7),
      (item_set_slot, "itm_cabbages", slot_item_desert_demand, 7),
      (item_set_slot, "itm_cabbages", slot_item_production_slot, slot_center_household_gardens),
      (item_set_slot, "itm_cabbages", slot_item_production_string, "str_gardens"),

      (item_set_slot, "itm_raw_date_fruit", slot_item_urban_demand, 7),
      (item_set_slot, "itm_raw_date_fruit", slot_item_rural_demand, 7),
      (item_set_slot, "itm_raw_date_fruit", slot_item_desert_demand, 7),
      (item_set_slot, "itm_raw_date_fruit", slot_item_production_slot, slot_center_household_gardens),
      (item_set_slot, "itm_raw_date_fruit", slot_item_production_string, "str_acres_oasis"),

      (item_set_slot, "itm_chicken", slot_item_urban_demand, 40),
      (item_set_slot, "itm_chicken", slot_item_rural_demand, 10),
      (item_set_slot, "itm_chicken", slot_item_desert_demand, -1),

      (item_set_slot, "itm_pork", slot_item_urban_demand, 40),
      (item_set_slot, "itm_pork", slot_item_rural_demand, 10),
      (item_set_slot, "itm_pork", slot_item_desert_demand, -1),

      # Setting book intelligence requirements
      (item_set_slot, "itm_book_tactics", slot_item_intelligence_requirement, 9),
      (item_set_slot, "itm_book_persuasion", slot_item_intelligence_requirement, 8),
      (item_set_slot, "itm_book_leadership", slot_item_intelligence_requirement, 7),
      (item_set_slot, "itm_book_intelligence", slot_item_intelligence_requirement, 10),
      (item_set_slot, "itm_book_trade", slot_item_intelligence_requirement, 11),
      (item_set_slot, "itm_book_weapon_mastery", slot_item_intelligence_requirement, 9),
      (item_set_slot, "itm_book_engineering", slot_item_intelligence_requirement, 12),

      (item_set_slot, "itm_book_wound_treatment_reference", slot_item_intelligence_requirement, 10),
      (item_set_slot, "itm_book_training_reference", slot_item_intelligence_requirement, 10),
      (item_set_slot, "itm_book_surgery_reference", slot_item_intelligence_requirement, 10),
	 ]),


    ("initialize_town_arena_info",
    [
      (try_for_range, ":town_no", towns_begin, towns_end),
        (party_set_slot, ":town_no", slot_town_tournament_max_teams, 4),
        (party_set_slot, ":town_no", slot_town_tournament_max_team_size, 8),
      (try_end),
      (party_set_slot, "p_town_6", slot_town_tournament_max_team_size, 2),

      (party_set_slot,"p_town_1", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_1", slot_town_arena_melee_1_team_size,   1),
      (party_set_slot,"p_town_1", slot_town_arena_melee_2_num_teams,   4),
      (party_set_slot,"p_town_1", slot_town_arena_melee_2_team_size,   1),
      (party_set_slot,"p_town_1", slot_town_arena_melee_3_num_teams,   4),
      (party_set_slot,"p_town_1", slot_town_arena_melee_3_team_size,   1),

      (party_set_slot,"p_town_2", slot_town_arena_melee_1_num_teams,   4),
      (party_set_slot,"p_town_2", slot_town_arena_melee_1_team_size,   4),
      (party_set_slot,"p_town_2", slot_town_arena_melee_2_num_teams,   4),
      (party_set_slot,"p_town_2", slot_town_arena_melee_2_team_size,   6),
      (party_set_slot,"p_town_2", slot_town_arena_melee_3_num_teams,   4),
      (party_set_slot,"p_town_2", slot_town_arena_melee_3_team_size,   8),

      (party_set_slot,"p_town_3", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_3", slot_town_arena_melee_1_team_size,   8),
      (party_set_slot,"p_town_3", slot_town_arena_melee_2_num_teams,   2),
      (party_set_slot,"p_town_3", slot_town_arena_melee_2_team_size,   8),
      (party_set_slot,"p_town_3", slot_town_arena_melee_3_num_teams,   2),
      (party_set_slot,"p_town_3", slot_town_arena_melee_3_team_size,   8),

      (party_set_slot,"p_town_4", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_4", slot_town_arena_melee_1_team_size,   8),
      (party_set_slot,"p_town_4", slot_town_arena_melee_2_num_teams,   3),
      (party_set_slot,"p_town_4", slot_town_arena_melee_2_team_size,   8),
      (party_set_slot,"p_town_4", slot_town_arena_melee_3_num_teams,   2),
      (party_set_slot,"p_town_4", slot_town_arena_melee_3_team_size,   5),

      (party_set_slot,"p_town_5", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_5", slot_town_arena_melee_1_team_size,   3),
      (party_set_slot,"p_town_5", slot_town_arena_melee_2_num_teams,   2),
      (party_set_slot,"p_town_5", slot_town_arena_melee_2_team_size,   5),
      (party_set_slot,"p_town_5", slot_town_arena_melee_3_num_teams,   2),
      (party_set_slot,"p_town_5", slot_town_arena_melee_3_team_size,   8),

      (party_set_slot,"p_town_6", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_6", slot_town_arena_melee_1_team_size,   4),
      (party_set_slot,"p_town_6", slot_town_arena_melee_2_num_teams,   3),
      (party_set_slot,"p_town_6", slot_town_arena_melee_2_team_size,   4),
      (party_set_slot,"p_town_6", slot_town_arena_melee_3_num_teams,   3),
      (party_set_slot,"p_town_6", slot_town_arena_melee_3_team_size,   6),

      (party_set_slot,"p_town_7", slot_town_arena_melee_1_num_teams,   4),
      (party_set_slot,"p_town_7", slot_town_arena_melee_1_team_size,   4),
      (party_set_slot,"p_town_7", slot_town_arena_melee_2_num_teams,   4),
      (party_set_slot,"p_town_7", slot_town_arena_melee_2_team_size,   6),
      (party_set_slot,"p_town_7", slot_town_arena_melee_3_num_teams,   4),
      (party_set_slot,"p_town_7", slot_town_arena_melee_3_team_size,   8),

      (party_set_slot,"p_town_8", slot_town_arena_melee_1_num_teams,   3),
      (party_set_slot,"p_town_8", slot_town_arena_melee_1_team_size,   1),
      (party_set_slot,"p_town_8", slot_town_arena_melee_2_num_teams,   3),
      (party_set_slot,"p_town_8", slot_town_arena_melee_2_team_size,   3),
      (party_set_slot,"p_town_8", slot_town_arena_melee_3_num_teams,   3),
      (party_set_slot,"p_town_8", slot_town_arena_melee_3_team_size,   7),

      (party_set_slot,"p_town_9", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_9", slot_town_arena_melee_1_team_size,   2),
      (party_set_slot,"p_town_9", slot_town_arena_melee_2_num_teams,   2),
      (party_set_slot,"p_town_9", slot_town_arena_melee_2_team_size,   5),
      (party_set_slot,"p_town_9", slot_town_arena_melee_3_num_teams,   2),
      (party_set_slot,"p_town_9", slot_town_arena_melee_3_team_size,   8),

      (party_set_slot,"p_town_10", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_10", slot_town_arena_melee_1_team_size,   3),
      (party_set_slot,"p_town_10", slot_town_arena_melee_2_num_teams,   2),
      (party_set_slot,"p_town_10", slot_town_arena_melee_2_team_size,   5),
      (party_set_slot,"p_town_10", slot_town_arena_melee_3_num_teams,   2),
      (party_set_slot,"p_town_10", slot_town_arena_melee_3_team_size,   8),

      (party_set_slot,"p_town_11", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_11", slot_town_arena_melee_1_team_size,   8),
      (party_set_slot,"p_town_11", slot_town_arena_melee_2_num_teams,   3),
      (party_set_slot,"p_town_11", slot_town_arena_melee_2_team_size,   4),
      (party_set_slot,"p_town_11", slot_town_arena_melee_3_num_teams,   3),
      (party_set_slot,"p_town_11", slot_town_arena_melee_3_team_size,   6),

      (party_set_slot,"p_town_12", slot_town_arena_melee_1_num_teams,   3),
      (party_set_slot,"p_town_12", slot_town_arena_melee_1_team_size,   8),
      (party_set_slot,"p_town_12", slot_town_arena_melee_2_num_teams,   4),
      (party_set_slot,"p_town_12", slot_town_arena_melee_2_team_size,   6),
      (party_set_slot,"p_town_12", slot_town_arena_melee_3_num_teams,   4),
      (party_set_slot,"p_town_12", slot_town_arena_melee_3_team_size,   5),

      (party_set_slot,"p_town_13", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_13", slot_town_arena_melee_1_team_size,   8),
      (party_set_slot,"p_town_13", slot_town_arena_melee_2_num_teams,   4),
      (party_set_slot,"p_town_13", slot_town_arena_melee_2_team_size,   5),
      (party_set_slot,"p_town_13", slot_town_arena_melee_3_num_teams,   4),
      (party_set_slot,"p_town_13", slot_town_arena_melee_3_team_size,   7),

      (party_set_slot,"p_town_14", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_14", slot_town_arena_melee_1_team_size,   4),
      (party_set_slot,"p_town_14", slot_town_arena_melee_2_num_teams,   2),
      (party_set_slot,"p_town_14", slot_town_arena_melee_2_team_size,   5),
      (party_set_slot,"p_town_14", slot_town_arena_melee_3_num_teams,   2),
      (party_set_slot,"p_town_14", slot_town_arena_melee_3_team_size,   6),

      (party_set_slot,"p_town_15", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_15", slot_town_arena_melee_1_team_size,   8),
      (party_set_slot,"p_town_15", slot_town_arena_melee_2_num_teams,   3),
      (party_set_slot,"p_town_15", slot_town_arena_melee_2_team_size,   4),
      (party_set_slot,"p_town_15", slot_town_arena_melee_3_num_teams,   3),
      (party_set_slot,"p_town_15", slot_town_arena_melee_3_team_size,   6),

      (party_set_slot,"p_town_16", slot_town_arena_melee_1_num_teams,   3),
      (party_set_slot,"p_town_16", slot_town_arena_melee_1_team_size,   8),
      (party_set_slot,"p_town_16", slot_town_arena_melee_2_num_teams,   4),
      (party_set_slot,"p_town_16", slot_town_arena_melee_2_team_size,   6),
      (party_set_slot,"p_town_16", slot_town_arena_melee_3_num_teams,   4),
      (party_set_slot,"p_town_16", slot_town_arena_melee_3_team_size,   5),

      (party_set_slot,"p_town_17", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_17", slot_town_arena_melee_1_team_size,   8),
      (party_set_slot,"p_town_17", slot_town_arena_melee_2_num_teams,   4),
      (party_set_slot,"p_town_17", slot_town_arena_melee_2_team_size,   5),
      (party_set_slot,"p_town_17", slot_town_arena_melee_3_num_teams,   4),
      (party_set_slot,"p_town_17", slot_town_arena_melee_3_team_size,   7),

      (party_set_slot,"p_town_18", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_18", slot_town_arena_melee_1_team_size,   4),
      (party_set_slot,"p_town_18", slot_town_arena_melee_2_num_teams,   2),
      (party_set_slot,"p_town_18", slot_town_arena_melee_2_team_size,   5),
      (party_set_slot,"p_town_18", slot_town_arena_melee_3_num_teams,   2),
      (party_set_slot,"p_town_18", slot_town_arena_melee_3_team_size,   6),

      (party_set_slot,"p_town_19", slot_town_arena_melee_1_num_teams,   2),
      (party_set_slot,"p_town_19", slot_town_arena_melee_1_team_size,   8),
      (party_set_slot,"p_town_19", slot_town_arena_melee_2_num_teams,   4),
      (party_set_slot,"p_town_19", slot_town_arena_melee_2_team_size,   4),
      (party_set_slot,"p_town_19", slot_town_arena_melee_3_num_teams,   4),
      (party_set_slot,"p_town_19", slot_town_arena_melee_3_team_size,   6),

      (party_set_slot,"p_town_20", slot_town_arena_melee_1_num_teams,   4),
      (party_set_slot,"p_town_20", slot_town_arena_melee_1_team_size,   2),
      (party_set_slot,"p_town_20", slot_town_arena_melee_2_num_teams,   4),
      (party_set_slot,"p_town_20", slot_town_arena_melee_2_team_size,   4),
      (party_set_slot,"p_town_20", slot_town_arena_melee_3_num_teams,   4),
      (party_set_slot,"p_town_20", slot_town_arena_melee_3_team_size,   6),

      (party_set_slot,"p_town_21", slot_town_arena_melee_1_num_teams,   3),
      (party_set_slot,"p_town_21", slot_town_arena_melee_1_team_size,   3),
      (party_set_slot,"p_town_21", slot_town_arena_melee_2_num_teams,   2),
      (party_set_slot,"p_town_21", slot_town_arena_melee_2_team_size,   6),
      (party_set_slot,"p_town_21", slot_town_arena_melee_3_num_teams,   2),
      (party_set_slot,"p_town_21", slot_town_arena_melee_3_team_size,   8),

      (party_set_slot,"p_town_22", slot_town_arena_melee_1_num_teams,   4),
      (party_set_slot,"p_town_22", slot_town_arena_melee_1_team_size,   3),
      (party_set_slot,"p_town_22", slot_town_arena_melee_2_num_teams,   3),
      (party_set_slot,"p_town_22", slot_town_arena_melee_2_team_size,   4),
      (party_set_slot,"p_town_22", slot_town_arena_melee_3_num_teams,   2),
      (party_set_slot,"p_town_22", slot_town_arena_melee_3_team_size,   6),
	]),

	("initialize_banner_info",
	[
	  #Banners
      (try_for_range, ":cur_troop", active_npcs_begin, kingdom_ladies_end),
        (troop_set_slot, ":cur_troop", slot_troop_custom_banner_flag_type, -1),
        (troop_set_slot, ":cur_troop", slot_troop_custom_banner_map_flag_type, -1),
      (try_end),
      (troop_set_slot, "trp_player", slot_troop_custom_banner_flag_type, -1),
      (troop_set_slot, "trp_player", slot_troop_custom_banner_map_flag_type, -1),
      #(store_random_in_range, "$g_election_date", 0, 45), #setting a random election date
      (assign, "$g_election_date", 45),
      #Assigning global constant
      #(call_script, "script_store_average_center_value_per_faction"),

      (troop_set_slot, "trp_player", slot_troop_custom_banner_bg_color_1, 0xFFFFFFFF),
      (troop_set_slot, "trp_player", slot_troop_custom_banner_bg_color_2, 0xFFFFFFFF),
      (troop_set_slot, "trp_player", slot_troop_custom_banner_charge_color_1, 0xFFFFFFFF),
      (troop_set_slot, "trp_player", slot_troop_custom_banner_charge_color_2, 0xFFFFFFFF),
      (troop_set_slot, "trp_player", slot_troop_custom_banner_charge_color_3, 0xFFFFFFFF),
      (troop_set_slot, "trp_player", slot_troop_custom_banner_charge_color_4, 0xFFFFFFFF),

      #Setting background colors for banners
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_relations_begin, 4287579441),
        (troop_set_slot, "trp_banner_background_color_array", 1, 4292466641),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_occupation, 4281808694),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_state, 4288973608),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_last_talk_time, 4283004725),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_met, 4286723629),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_party_template, 4286133033),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_renown, 4280689953),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_prisoner_of_party, 4292467409),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_present_at_event, 4283581795),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_leaded_party, 4287705388),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_wealth, 4289700401),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_cur_center, 4285558076),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_banner_scene_prop, 4292269006),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_original_faction, 4283571208),
        (troop_set_slot, "trp_banner_background_color_array", 15, 4281943428),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_player_order_state, 4282541614),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_player_order_object, 4292861654),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_age, 4280887076),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_age_appearance, 4283982107),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_does_not_give_quest, 4281416295),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_player_debt, 4288451146),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_player_relation, 4289437989),
        (troop_set_slot, "trp_banner_background_color_array", 23, 4281749864),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_last_quest, 4292269006),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_last_quest_betrayed, 4287931970),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_last_persuasion_time, 4287906097),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_last_comment_time, 4287183668),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_spawned_before, 4282537232),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_last_comment_slot, 4287907118),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_spouse, 4282866324),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_father, 4291932721),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_mother, 4292993759),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_guardian, 4288248862),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_betrothed, 4291213133),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_love_interest_1, 4289567256),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_love_interest_2, 4280362017),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_love_interest_3, 4289083444),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_love_interests_end, 4283265334),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_betrothal_time, 4281949572),
        (troop_set_slot, "trp_banner_background_color_array", slot_lady_used_tournament, 4283594041),
        (troop_set_slot, "trp_banner_background_color_array", 41, 4288429113),
        (troop_set_slot, "trp_banner_background_color_array", 42, 4282536332),
        (troop_set_slot, "trp_banner_background_color_array", 43, 4288965164),
        (troop_set_slot, "trp_banner_background_color_array", 44, 4288631105),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_current_rumor, 4281098633),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_temp_slot, 4283786273),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_promised_fief, 4288504350),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_set_decision_seed, 4292796118),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_temp_decision_seed, 4285417617),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_recruitment_random, 4287728456),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_intrigue_impatience, 4292796377),
        (troop_set_slot, "trp_banner_background_color_array", slot_lord_reputation_type, 4283060097),
        (troop_set_slot, "trp_banner_background_color_array", slot_lord_recruitment_argument, 4287379489),
        (troop_set_slot, "trp_banner_background_color_array", slot_lord_recruitment_candidate, 4283646580),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_change_to_faction, 4293387230),
        (troop_set_slot, "trp_banner_background_color_array", 56, 4288032313),
        (troop_set_slot, "trp_banner_background_color_array", 57, 4281883011),
        (troop_set_slot, "trp_banner_background_color_array", 58, 4292270038),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_first_encountered, 4288515353),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_home, 4292072403),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_morality_state, 4281947524),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_morality_type, 4281413681),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_morality_value, 4286463790),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_2ary_morality_type, 4281611316),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_2ary_morality_state, 4282141035),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_2ary_morality_value, 4292466897),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_town_with_contacts, 4288250428),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_town_contact_type, 4288643630),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_morality_penalties, 4281940025),
        (troop_set_slot, "trp_banner_background_color_array", 70, 4289022257),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalityclash_object, 4292861142),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalityclash_state, 4288629302),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalityclash2_object, 4287395105),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalityclash2_state, 4288628273),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalitymatch_object, 4286133028),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalitymatch_state, 4281946230),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalityclash_penalties, 4281084716),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_home_speech_delivered, 4284838177),
        (troop_set_slot, "trp_banner_background_color_array", 79, 4286460193),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_met_previously, 4285944110),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_turned_down_twice, 4293387230),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_playerparty_history, 4287920417),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_playerparty_history_string, 4283267964),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_return_renown, 4281611057),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_bg_color_1, 4289154358),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_bg_color_2, 4293387230),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_charge_color_1, 4292270286),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_charge_color_2, 4282273127),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_charge_color_3, 4288644142),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_charge_color_4, 4283263380),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_bg_type, 4283064600),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_charge_type_1, 4287904809),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_charge_type_2, 4281943161),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_charge_type_3, 4281611057),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_charge_type_4, 4282338653),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_flag_type, 4283065481),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_num_charges, 4281413681),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_positioning, 4292270030),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_custom_banner_map_flag_type, 4291206656),
        (troop_set_slot, "trp_banner_background_color_array", 100, 4284714578),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_intro, 4292664275),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_intro_response_1, 4292598995),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_intro_response_2, 4286855217),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_backstory_a, 4291743686),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_backstory_b, 4291009841),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_backstory_c, 4291540592),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_backstory_delayed, 4281944600),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_backstory_response_1, 4281804552),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_backstory_response_2, 4288309264),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_signup, 4289886480),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_signup_2, 4287399457),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_signup_response_1, 4288109059),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_signup_response_2, 4281084196),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_mentions_payment, 4289369644),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_payment_response, 4288840238),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_morality_speech, 4286286476),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_2ary_morality_speech, 4282124552),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalityclash_speech, 4294902015),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalityclash_speech_b, 4284947988),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalityclash2_speech, 4279251010),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalityclash2_speech_b, 4283057408),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalitymatch_speech, 4285543204),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_personalitymatch_speech_b, 4280559932),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_retirement_speech, 4284311910),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_rehire_speech, 4287250991),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_home_intro, 4284492071),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_home_description, 4291809222),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_home_description_2, 4292467153),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_home_recap, 4284444459),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_honorific, 4287913033),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_string_1, 4292072651),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_string_2, 4281479729),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_string_2a, 4292401361),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_string_2b, 4283451237),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_string_3, 4280634471),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_objection_string, 4289241485),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_intel_gathering_string, 4283639858),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_fief_acceptance_string, 4281553956),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_woman_to_woman_string, 4289170496),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_turn_against_string, 4283112728),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_strings_end, 4287443504),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_state, 4280361505),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_argument, 4280361505),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_opponent, 4281219856),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_kingsupport_objection_state, 4282539387),
        (troop_set_slot, "trp_banner_background_color_array", slot_troop_player_routed_agents, 4281943560), #146
      # (troop_set_slot, "trp_banner_background_color_array", 128, 0xFF212221),
      # (troop_set_slot, "trp_banner_background_color_array", 129, 0xFF212221),
      # (troop_set_slot, "trp_banner_background_color_array", 130, 0xFF2E3B10),
      # (troop_set_slot, "trp_banner_background_color_array", 131, 0xFF425D7B),
      # (troop_set_slot, "trp_banner_background_color_array", 132, 0xFF394608),

	  ]),


    ("initialize_economic_information",
    [
	    #All towns produce tools, pottery, and wool cloth for sale in countryside
	(try_for_range, ":town_no", towns_begin, towns_end),
		(store_random_in_range, ":random_average_20_variation_10", 10, 31), #10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29 or 30
		(party_set_slot, ":town_no", slot_center_wool_looms, ":random_average_20_variation_10"),

		(store_random_in_range, ":random_average_2_variation_1", 1, 4), #1,2 or 3
		(party_set_slot, ":town_no", slot_center_breweries, ":random_average_2_variation_1"),

		(store_random_in_range, ":random_average_5_variation_3", 3, 9), #2,3,4,5,6,7 or 8
		(party_set_slot, ":town_no", slot_center_pottery_kilns, ":random_average_5_variation_3"),

		(store_random_in_range, ":random_average_15_variation_9", 6, 25), #6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 or 24
		(party_set_slot, ":town_no", slot_center_smithies, ":random_average_15_variation_9"),

		(store_random_in_range, ":random_average_5_variation_3", 3, 9), #2,3,4,5,6,7 or 8
		(party_set_slot, ":town_no", slot_center_mills, ":random_average_5_variation_3"),

		(store_random_in_range, ":random_average_2_variation_1", 1, 4), #1,2 or 3
		(party_set_slot, ":town_no", slot_center_tanneries, ":random_average_2_variation_1"),

		(store_random_in_range, ":random_average_1_variation_1", 0, 3), #0,1 or 2
		(party_set_slot, ":town_no", slot_center_wine_presses, ":random_average_1_variation_1"),

		(store_random_in_range, ":random_average_2_variation_1", 1, 4), #1,2 or 3
		(party_set_slot, ":town_no", slot_center_olive_presses, ":random_average_2_variation_1"),

		(store_random_in_range, ":random_average_1000_variation_1000", 0, 2001), #0..2000
		(party_set_slot, ":town_no", slot_center_acres_grain, ":random_average_1000_variation_1000"), #0..2000

		(store_random_in_range, ":random_average_1000_variation_1000", 0, 2001), #0..2000
		(party_set_slot, ":town_no", slot_center_acres_vineyard, ":random_average_1000_variation_1000"), #0..2000
    (try_end),

	#Sargoth (linen, wine)
	(party_set_slot, "p_town_1", slot_center_linen_looms, 15),
	(party_set_slot, "p_town_1", slot_center_wine_presses, 4),

	#Tihr (salt, smoked fish, linen)
	(party_set_slot, "p_town_2", slot_center_salt_pans, 3),
	(party_set_slot, "p_town_2", slot_center_fishing_fleet, 25),
	(party_set_slot, "p_town_2", slot_center_linen_looms, 15),

	#Veluca	(wine, velvet)
	(party_set_slot, "p_town_3", slot_center_wine_presses, 10),
	(party_set_slot, "p_town_3", slot_center_silk_looms, 12),

	#Suno (velvet, oil)
	(party_set_slot, "p_town_4", slot_center_silk_looms, 12),
	(party_set_slot, "p_town_4", slot_center_olive_presses, 15),

	#Jelkala (velvet, smoked fish)
	(party_set_slot, "p_town_5", slot_center_silk_looms, 24),
	(party_set_slot, "p_town_5", slot_center_fishing_fleet, 30),

	#Praven (ale, leatherwork, smoked fish)
	(party_set_slot, "p_town_6", slot_center_breweries, 10),
	(party_set_slot, "p_town_6", slot_center_tanneries, 4),
	(party_set_slot, "p_town_6", slot_center_fishing_fleet, 10),

	#Uxkhal (bread, leatherwork, oil)
	(party_set_slot, "p_town_7", slot_center_mills, 15),
	(party_set_slot, "p_town_7", slot_center_tanneries, 4),
	(party_set_slot, "p_town_7", slot_center_olive_presses, 5),

	#Reyvadin (tools, wool cloth, wine)
	(party_set_slot, "p_town_8", slot_center_smithies, 25),
	(party_set_slot, "p_town_8", slot_center_wool_looms, 35),
	(party_set_slot, "p_town_8", slot_center_wine_presses, 4),

	#Khudan (tools, leatherwork, smoked fish)
	(party_set_slot, "p_town_9", slot_center_smithies, 18),
	(party_set_slot, "p_town_9", slot_center_tanneries, 3),
	(party_set_slot, "p_town_9", slot_center_fishing_fleet, 5),

	#Tulga (salt, spice)
	(party_set_slot, "p_town_10", slot_center_salt_pans, 2),
	#also produces 100 spice

	#Curaw (tools, iron, smoked fish)
	(party_set_slot, "p_town_11", slot_center_smithies, 19),
	(party_set_slot, "p_town_11", slot_center_iron_deposits, 10),
	(party_set_slot, "p_town_11", slot_center_fishing_fleet, 10),

	#Wercheg (salt, smoked fish)
    (party_set_slot, "p_town_12", slot_center_salt_pans, 3),
	(party_set_slot, "p_town_12", slot_center_fishing_fleet, 25),

	#Rivacheg (wool cloth, leatherwork, smoked fish)
	(party_set_slot, "p_town_13", slot_center_wool_looms, 30),
	(party_set_slot, "p_town_13", slot_center_tanneries, 5),
	(party_set_slot, "p_town_13", slot_center_fishing_fleet, 20),

	#Halmar (leatherwork, pottery)
	(party_set_slot, "p_town_14", slot_center_tanneries, 3),
	(party_set_slot, "p_town_14", slot_center_pottery_kilns, 18),

	#Yalen (tools, wine, oil, smoked fish)
	(party_set_slot, "p_town_15", slot_center_smithies, 20),
	(party_set_slot, "p_town_15", slot_center_wine_presses, 6),
	(party_set_slot, "p_town_15", slot_center_olive_presses, 5),
	(party_set_slot, "p_town_15", slot_center_fishing_fleet, 25),

	#Dhirim (tools, leatherwork)
	(party_set_slot, "p_town_16", slot_center_smithies, 30),
	(party_set_slot, "p_town_16", slot_center_tanneries, 4),

	#Ichamur (wool cloth, spice)
	(party_set_slot, "p_town_17", slot_center_wool_looms, 40),
	#also produces 50 spice

	#Narra (wool cloth, oil)
	(party_set_slot, "p_town_18", slot_center_wool_looms, 35),
	(party_set_slot, "p_town_18", slot_center_olive_presses, 10),

	#Shariz (leatherwork, smoked fish, oil)
	(party_set_slot, "p_town_19", slot_center_tanneries, 5),
	(party_set_slot, "p_town_19", slot_center_breweries, 0), 	    #no alcohol (ale) in arabic region
	(party_set_slot, "p_town_19", slot_center_wine_presses, 0), 	#no alcohol (wine) in arabic region
	(party_set_slot, "p_town_19", slot_center_fishing_fleet, 5),
	(party_set_slot, "p_town_19", slot_center_olive_presses, 5),
	#also produces 50 spice

	#Darquba (linen, pottery, oil)
	(party_set_slot, "p_town_20", slot_center_breweries, 0), 	    #no alcohol (ale) in arabic region
	(party_set_slot, "p_town_20", slot_center_wine_presses, 0), 	#no alcohol (wine) in arabic region
	(party_set_slot, "p_town_20", slot_center_linen_looms, 15),
	(party_set_slot, "p_town_20", slot_center_pottery_kilns, 12),
	(party_set_slot, "p_town_19", slot_center_olive_presses, 3),

	#Ahmerrad (pottery, salt)
	(party_set_slot, "p_town_21", slot_center_breweries, 0), 	    #no alcohol (ale) in arabic region
	(party_set_slot, "p_town_21", slot_center_wine_presses, 0), 	#no alcohol (wine) in arabic region
	(party_set_slot, "p_town_21", slot_center_pottery_kilns, 24),
	(party_set_slot, "p_town_21", slot_center_salt_pans, 1),

	#Bariyye (salt, pottery, spice)
	(party_set_slot, "p_town_22", slot_center_breweries, 0), 	    #no alcohol (ale) in arabic region
	(party_set_slot, "p_town_22", slot_center_wine_presses, 0), 	#no alcohol (wine) in arabic region
	(party_set_slot, "p_town_22", slot_center_pottery_kilns, 12),
	(party_set_slot, "p_town_22", slot_center_salt_pans, 2),
	#also produces 50 spice

    (try_for_range, ":village_no", villages_begin, villages_end),
      (try_begin),
      ##diplomacy start+ Replace the explicit "is desert" list with a terrain check.
      ##This is less brittle to map changes.
            (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),#In Diplomacy this is true at the start of the module, but the player could re-initialize economic stats during the game with cheat codes, or derived mods could change the default.
            (party_get_current_terrain, ":village_is_at_desert", ":village_no"),#Will be changed to either 0 or 1
	    (this_or_next|eq, ":village_is_at_desert", rt_desert),
	    (eq, ":village_is_at_desert", rt_desert_forest),#If false, will fall through and be assigned to 0 below
	    (assign, ":village_is_at_desert", 1),
      (else_try),
	    (lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW), #Fall back to old behavior
      ##diplomacy end+
	    (this_or_next|eq, ":village_no", "p_village_93"), #mazigh
		(this_or_next|eq, ":village_no", "p_village_94"), #sekhtem
		(this_or_next|eq, ":village_no", "p_village_95"), #qalyut
		(this_or_next|eq, ":village_no", "p_village_96"), #tilimsal
		(this_or_next|eq, ":village_no", "p_village_97"), #shibal zumr
		(this_or_next|eq, ":village_no", "p_village_102"), #tamnuh
		(this_or_next|eq, ":village_no", "p_village_109"), #habba
		(this_or_next|eq, ":village_no", "p_village_98"), #mawiti
		(this_or_next|eq, ":village_no", "p_village_103"), #mijayet
		(this_or_next|eq, ":village_no", "p_village_105"), #aab
		(this_or_next|eq, ":village_no", "p_village_99"), #fishara
		(this_or_next|eq, ":village_no", "p_village_100"), #iqbayl
		(this_or_next|eq, ":village_no", "p_village_107"), #unriya
		(this_or_next|eq, ":village_no", "p_village_101"), #uzgha
		(this_or_next|eq, ":village_no", "p_village_104"), #tazjunat
        (this_or_next|eq, ":village_no", "p_village_110"), #rushdigh
		(this_or_next|eq, ":village_no", "p_village_108"), #mit nun
		(eq, ":village_no", "p_village_92"), #dhibbain

		(assign, ":village_is_at_desert", 1),
	  (else_try),
		(assign, ":village_is_at_desert", 0),
	  (try_end),

      (store_random_in_range, ":random_cattle", 20, 100),
	  (try_begin),
	    (eq, ":village_is_at_desert", 1),
		(val_div, ":random_cattle", 5),
	  (try_end),
      (party_set_slot, ":village_no", slot_center_head_cattle, ":random_cattle"), #average : 50, min : 25, max : 75

      (store_random_in_range, ":random_sheep", 40, 200),
	  (try_begin),
	    (eq, ":village_is_at_desert", 1),
		(val_div, ":random_sheep", 5),
	  (try_end),
      (party_set_slot, ":village_no", slot_center_head_sheep, ":random_sheep"), #average : 100, min : 50, max : 150

	  #grain production
      (store_random_in_range, ":random_value_between_0_and_40000", 0, 40000),
	  (store_random_in_range, ":random_value_between_0_and_average_20000", 0, ":random_value_between_0_and_40000"),
	  (try_begin),
	    (eq, ":village_is_at_desert", 1),
		(val_div, ":random_value_between_0_and_average_20000", 5),
	  (try_end),
	  (party_set_slot, ":village_no", slot_center_acres_grain, ":random_value_between_0_and_average_20000"), #average : 10000, min : 0, max : 40000

      #grape production
	  (store_random_in_range, ":random_value_between_0_and_2000", 0, 2000),
	  (store_random_in_range, ":random_value_between_0_and_average_1000", 0, ":random_value_between_0_and_2000"),
	  (try_begin),
	    (eq, ":village_is_at_desert", 1),
		(val_div, ":random_value_between_0_and_average_1000", 5),
	  (try_end),
	  (party_set_slot, ":village_no", slot_center_acres_vineyard, ":random_value_between_0_and_average_1000"), #average : 500, min : 0, max : 2000

	  #olive production
      (store_random_in_range, ":random_value_between_0_and_2000", 0, 2000),
	  (store_random_in_range, ":random_value_between_0_and_average_1000", 0, ":random_value_between_0_and_2000"),
	  (try_begin),
	    (eq, ":village_is_at_desert", 1),
		(val_div, ":random_value_between_0_and_average_1000", 5),
	  (try_end),
	  (party_set_slot, ":village_no", slot_center_acres_olives, ":random_value_between_0_and_average_1000"), #average : 500, min : 0, max : 2000

	  #honey production
	  (store_random_in_range, ":random_value_between_0_and_3", 0, 3),
	  (try_begin),
	    (eq, ":village_is_at_desert", 1),
		(assign, ":random_value_between_0_and_3", 0), #at desert regions no honey production
	  (try_end),
	  (party_set_slot, ":village_no", slot_center_apiaries, ":random_value_between_0_and_3"),

	  #cabbage and fruit production
	  (store_random_in_range, ":random_value_between_0_and_5", 0, 5),
	  (try_begin),
	    (eq, ":village_is_at_desert", 1),
		(assign, ":random_value_between_0_and_5", 0), #at desert regions no cabbage and fruit production
	  (try_end),
	  (party_set_slot, ":village_no", slot_center_household_gardens, ":random_value_between_0_and_5"),

	  #bread production
      (store_random_in_range, ":random_value_between_0_and_3", 0, 3),
	  (party_set_slot, ":village_no", slot_center_mills, ":random_value_between_0_and_3"),

	  #pottery production
	  (store_random_in_range, ":random_value_between_0_and_5", 0, 5),
		(try_begin),
	    (eq, ":village_is_at_desert", 1),
		(val_mul, ":random_value_between_0_and_5", 5), #at desert regions pottery production 4x more than normal (totally 5x)
	  (try_end),
	  (party_set_slot, ":village_no", slot_center_pottery_kilns, ":random_value_between_0_and_5"),

	  #Sargoth (village productions : Ambean, Fearichen and Fenada)
	  (try_begin),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_1"),
		(party_set_slot, ":village_no", slot_center_acres_flax, 4000),
		(party_set_slot, ":village_no", slot_center_acres_vineyard, 8000),

	  #Tihr (village productions : Kulum, Haen and Aldelen)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_2"),
		(party_set_slot, ":village_no", slot_center_acres_vineyard, 8000),
		(party_set_slot, ":village_no", slot_center_household_gardens, 10),

	  #Veluca (village productions : Emer, Fedner, Chaeza and Sarimish)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_3"),
		(party_set_slot, ":village_no", slot_center_acres_vineyard, 6000),
		(party_set_slot, ":village_no", slot_center_acres_olives, 6000),

	  #Suno (village productions : Ruluns and Lyindah)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_4"),
		(party_set_slot, ":village_no", slot_center_fur_traps, 2),
		(party_set_slot, ":village_no", slot_center_acres_olives, 8000),

	  #Jelkala (village productions : Buvran, Ruldi and Chelez)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_5"),
		(party_set_slot, ":village_no", slot_center_silk_farms, 1500),
		(party_set_slot, ":village_no", slot_center_kirmiz_farms, 1500),

	  #Praven (village productions : Azgad, Veidar, Elberl and Gisim)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_6"),
		(party_set_slot, ":village_no", slot_center_acres_flax, 4000),
		(party_set_slot, ":village_no", slot_center_breweries, 4),

	  #Uxkhal (village productions : Nomar, Ibiran and Tahlberl)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_7"),
		(party_set_slot, ":village_no", slot_center_fur_traps, 1),
		(party_set_slot, ":village_no", slot_center_acres_olives, 8000),
		(party_set_slot, ":village_no", slot_center_apiaries, 8),

      #Reyvadin (village productions : Ulburban and Ayyike)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_8"),
		(party_set_slot, ":village_no", slot_center_fur_traps, 2),
			(party_set_slot, ":village_no", slot_center_head_cattle, 100),
		(party_set_slot, ":village_no", slot_center_iron_deposits, 6),

      #Khudan (village productions : Uslum, Shulus and Tismirr)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_9"),
		(party_set_slot, ":village_no", slot_center_fur_traps, 2),
		(party_set_slot, ":village_no", slot_center_acres_olives, 4000),

      #Tulga (village productions : Dusturil and Dashbigha)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_10"),
			(party_set_slot, ":village_no", slot_center_head_sheep, 150),
			(party_set_slot, ":village_no", slot_center_salt_pans, 1),
			(party_set_slot, ":village_no", slot_center_fur_traps, 1),
		(party_set_slot, ":village_no", slot_center_apiaries, 8),

      #Curaw (village productions : Bazeck and Rebache)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_11"),
		(party_set_slot, ":village_no", slot_center_iron_deposits, 6),
		(party_set_slot, ":village_no", slot_center_fur_traps, 2),

      #Wercheg (village productions : Ruvar and Odasan)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_12"),
		(party_set_slot, ":village_no", slot_center_acres_vineyard, 8000),
		(party_set_slot, ":village_no", slot_center_household_gardens, 10),
		(party_set_slot, ":village_no", slot_center_salt_pans, 1),

      #Rivacheg (village productions : Shapeshte, Vezin and Fisdnar)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_13"),
		(party_set_slot, ":village_no", slot_center_fur_traps, 2),
		(party_set_slot, ":village_no", slot_center_head_cattle, 100),
		(party_set_slot, ":village_no", slot_center_silk_farms, 1500),

      #Halmar (village productions : Peshmi)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_14"),
		(party_set_slot, ":village_no", slot_center_acres_grain, 40000),
		(party_set_slot, ":village_no", slot_center_mills, 5),

      #Yalen (village productions : Ilvia, Glunmar, Epeshe and Istiniar)
		(else_try),
	    (party_slot_eq, ":village_no", slot_village_market_town, "p_town_15"),
		(party_set_slot, ":village_no", slot_center_acres_vineyard, 8000),
		(party_set_slot, ":village_no", slot_center_acres_olives, 8000),
		(party_set_slot, ":village_no", slot_center_household_gardens, 10),

      #Dhirim (village productions : Burglen, Amere, Ushkuru, Tshibtin and Yalibe)
		(else_try),
        (party_slot_eq, ":village_no", slot_village_market_town, "p_town_16"),
        (party_set_slot, ":village_no", slot_center_acres_grain, 40000),
        (party_set_slot, ":village_no", slot_center_iron_deposits, 3),
		(party_set_slot, ":village_no", slot_center_mills, 5),

      #Ichamur (village productions : Ada Kulun and Drigh Aban)
		(else_try),
        (party_slot_eq, ":village_no", slot_village_market_town, "p_town_17"),
        (party_set_slot, ":village_no", slot_center_acres_grain, 20000),
			(party_set_slot, ":village_no", slot_center_fur_traps, 1),

      #Narra (village productions : Zagush and Kedelke)
		(else_try),
        (party_slot_eq, ":village_no", slot_village_market_town, "p_town_18"),
        (party_set_slot, ":village_no", slot_center_acres_grain, 20000),
        (party_set_slot, ":village_no", slot_center_iron_deposits, 3),
		(party_set_slot, ":village_no", slot_center_apiaries, 8),
		(party_set_slot, ":village_no", slot_center_acres_flax, 4000),

      #Shariz (village productions : Ayn Assuadi, Dhibbain, Qalyut, Tilimsal and Rushdigh)
		(else_try),
        (party_slot_eq, ":village_no", slot_village_market_town, "p_town_19"),
        (party_set_slot, ":village_no", slot_center_acres_grain, 6000), #low grain (partially desert)
			(party_set_slot, ":village_no", slot_center_acres_flax, 2000),
			(party_set_slot, ":village_no", slot_center_acres_olives, 3000),
        (party_set_slot, ":village_no", slot_center_acres_dates, 5000),

      #Durquba (village productions : Tamnuh and Sekhtem)
		(else_try),
        (party_slot_eq, ":village_no", slot_village_market_town, "p_town_20"),
        (party_set_slot, ":village_no", slot_center_acres_grain, 3000), #low grain (heavy desert)
        (party_set_slot, ":village_no", slot_center_acres_dates, 10000),
			(party_set_slot, ":village_no", slot_center_salt_pans, 1),

      #Ahmerrad (village productions : Mawiti, Uzgha and Mijayet)
		(else_try),
        (party_slot_eq, ":village_no", slot_village_market_town, "p_town_21"),
        (party_set_slot, ":village_no", slot_center_acres_grain, 3000), #low grain (heavy desert)
        (party_set_slot, ":village_no", slot_center_acres_dates, 5000),
		(party_set_slot, ":village_no", slot_center_kirmiz_farms, 1500),

      #Bariyye (village productions : Fishara and Iqbayl)
		(else_try),
        (party_slot_eq, ":village_no", slot_village_market_town, "p_town_22"),
        (party_set_slot, ":village_no", slot_center_acres_grain, 2000), #low grain (heavy desert)
			(party_set_slot, ":village_no", slot_center_acres_flax, 2000),
        (party_set_slot, ":village_no", slot_center_acres_dates, 10000),
        (party_set_slot, ":village_no", slot_center_salt_pans, 1),
        (party_set_slot, ":village_no", slot_center_kirmiz_farms, 1500),

		(try_end),
    (try_end),

	#determining village productions which are bounded by castle by nearby village productions which are bounded by a town.
	(try_for_range, ":village_no", villages_begin, villages_end),
	  (party_get_slot, ":bound_center", ":village_no", slot_village_bound_center),
	  (is_between, ":bound_center", castles_begin, castles_end),

	  (try_for_range, ":cur_production_source", slot_production_sources_begin, slot_production_sources_end),

		(assign, ":total_averaged_production", 0),
		(try_for_range, ":effected_village_no", villages_begin, villages_end),
		  (party_get_slot, ":bound_center", ":effected_village_no", slot_village_bound_center),
	      (is_between, ":bound_center", towns_begin, towns_end),

		  (store_distance_to_party_from_party, ":dist", ":village_no", ":effected_village_no"),
		  (le, ":dist", 72),

		  (party_get_slot, ":production", ":village_no", ":cur_production_source"),

		  (store_add, ":dist_plus_24", ":dist", 24),
		  (store_mul, ":production_mul_12", ":production", 12),
		  (store_div, ":averaged_production", ":production_mul_12", ":dist_plus_24"), #if close (12/24=1/2) else (12/96=1/8)
		  (val_div, ":averaged_production", 2), #if close (1/4) else (1/16)
		  (val_add, ":total_averaged_production", ":averaged_production"),
		(try_end),

		(party_set_slot, ":village_no", ":cur_production_source", ":total_averaged_production"),
      (try_end),
	(try_end),

	#Ocean and river villages, new map
    (party_set_slot, "p_village_1", slot_center_fishing_fleet, 15), #Yaragar
    (party_set_slot, "p_village_3", slot_center_fishing_fleet, 15), #Azgad
    (party_set_slot, "p_village_5", slot_center_fishing_fleet, 15), #Kulum

    (party_set_slot, "p_village_8", slot_center_fishing_fleet, 15), #Haen
    (party_set_slot, "p_village_9", slot_center_fishing_fleet, 15), #Buvran

    (party_set_slot, "p_village_20", slot_center_fishing_fleet, 15), #Uslum
    (party_set_slot, "p_village_21", slot_center_fishing_fleet, 15), #Bazeck
    (party_set_slot, "p_village_23", slot_center_fishing_fleet, 15), #Ilvia
    (party_set_slot, "p_village_27", slot_center_fishing_fleet, 15), #Glunmar

    (party_set_slot, "p_village_30", slot_center_fishing_fleet, 20), #Ruvar
    (party_set_slot, "p_village_31", slot_center_fishing_fleet, 15), #Ambean
    (party_set_slot, "p_village_35", slot_center_fishing_fleet, 15), #Feacharin

    (party_set_slot, "p_village_47", slot_center_fishing_fleet, 15), #Epeshe
    (party_set_slot, "p_village_49", slot_center_fishing_fleet, 15), #Tismirr

    (party_set_slot, "p_village_51", slot_center_fishing_fleet, 15), #Jelbegi
    (party_set_slot, "p_village_56", slot_center_fishing_fleet, 15), #Fenada

    (party_set_slot, "p_village_66", slot_center_fishing_fleet, 15), #Fisdnar
    (party_set_slot, "p_village_68", slot_center_fishing_fleet, 15), #Ibdeles
    (party_set_slot, "p_village_69", slot_center_fishing_fleet, 15), #Kwynn

    (party_set_slot, "p_village_77", slot_center_fishing_fleet, 25), #Rizi - Estuary
    (party_set_slot, "p_village_79", slot_center_fishing_fleet, 15), #Istiniar

	(party_set_slot, "p_village_81", slot_center_fishing_fleet, 15), #Odasan
    (party_set_slot, "p_village_85", slot_center_fishing_fleet, 15), #Ismirala
    (party_set_slot, "p_village_87", slot_center_fishing_fleet, 15), #Udiniad

    (party_set_slot, "p_village_90", slot_center_fishing_fleet, 15), #Jamiche

	#Initialize pastureland
	(try_for_range, ":center", centers_begin, centers_end),
		(party_get_slot, ":head_cattle", ":center", slot_center_head_cattle),
		(party_get_slot, ":head_sheep", ":center", slot_center_head_sheep),
		(store_mul, ":num_acres", ":head_cattle", 4),
		(val_add, ":num_acres", ":head_sheep"),
		(val_add, ":num_acres", ":head_sheep"),
		(val_mul, ":num_acres", 6),
		(val_div, ":num_acres", 5),

		(store_random_in_range, ":random", 60, 150),
		(val_mul, ":num_acres", ":random"),
		(val_div, ":num_acres", 100),

		(party_set_slot, ":center", slot_center_acres_pasture, ":num_acres"),
	(try_end),

	#Initialize prices based on production, etc
    (try_for_range, ":unused", 0, 3), #15 cycles = 45 days. For a village with -20 production, this should lead to approximate +1000, modified
        (call_script, "script_update_trade_good_prices"), #changes prices based on production
    (try_end),

	#Initialize prosperity based on final prices
    (try_for_range, ":center_no", centers_begin, centers_end),
      (neg|is_between, ":center_no", castles_begin, castles_end),
      (store_random_in_range, ":random_prosperity_adder", -10, 10),
      (call_script, "script_get_center_ideal_prosperity", ":center_no"),
      (assign, ":prosperity", reg0),
      (val_add, ":prosperity", ":random_prosperity_adder"),
      (val_clamp, ":prosperity", 0, 100),
      (party_set_slot, ":center_no", slot_town_prosperity, ":prosperity"),
	(try_end),

	(call_script, "script_calculate_castle_prosperities_by_using_its_villages"),
    ]),

  #script_initialize_all_scene_prop_slots
  # INPUT: arg1 = scene_prop_no
  # OUTPUT: none
  ("initialize_all_scene_prop_slots",
   [
     (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_6m"),
     (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_8m"),
     (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_10m"),
     (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_12m"),
     (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_14m"),
     (call_script, "script_initialize_scene_prop_slots", "spr_castle_e_sally_door_a"),
     (call_script, "script_initialize_scene_prop_slots", "spr_castle_f_sally_door_a"),
     (call_script, "script_initialize_scene_prop_slots", "spr_earth_sally_gate_left"),
     (call_script, "script_initialize_scene_prop_slots", "spr_earth_sally_gate_right"),
     (call_script, "script_initialize_scene_prop_slots", "spr_viking_keep_destroy_sally_door_left"),
     (call_script, "script_initialize_scene_prop_slots", "spr_viking_keep_destroy_sally_door_right"),
     (call_script, "script_initialize_scene_prop_slots", "spr_castle_f_door_a"),
     (call_script, "script_initialize_scene_prop_slots", "spr_belfry_a"),
     (call_script, "script_initialize_scene_prop_slots", "spr_belfry_b"),
     (call_script, "script_initialize_scene_prop_slots", "spr_winch_b"),
    ]),

  #script_initialize_scene_prop_slots
  # INPUT: arg1 = scene_prop_no
  # OUTPUT: none
  ("initialize_scene_prop_slots",
   [
     (store_script_param, ":scene_prop_no", 1),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", ":scene_prop_no"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", ":scene_prop_no", ":cur_instance"),
       (try_for_range, ":cur_slot", 0, scene_prop_slots_end),
         (scene_prop_set_slot, ":cur_instance_id", ":cur_slot", 0),
       (try_end),
     (try_end),
     ]),

  #script_use_item
  # INPUT: arg1 = agent_id, arg2 = instance_id
  # OUTPUT: none
  ("use_item",
   [
     (store_script_param, ":instance_id", 1),
     (store_script_param, ":user_id", 2),

     (try_begin),
       (game_in_multiplayer_mode),
       (prop_instance_get_scene_prop_kind, ":scene_prop_id", ":instance_id"),
       (eq, ":scene_prop_id", "spr_winch_b"),

       (multiplayer_get_my_player, ":my_player_no"),

       (this_or_next|gt, ":my_player_no", 0),
       (neg|multiplayer_is_dedicated_server),

       (ge, ":my_player_no", 0),
       (player_get_agent_id, ":my_agent_id", ":my_player_no"),
       (ge, ":my_agent_id", 0),
       (agent_is_active, ":my_agent_id"),
       (agent_get_team, ":my_team_no", ":my_agent_id"),
       (eq, ":my_team_no", 0),

       (scene_prop_get_slot, ":opened_or_closed", ":instance_id", scene_prop_open_or_close_slot),
       (ge, ":user_id", 0),
       (agent_is_active, ":user_id"),
       (agent_get_player_id, ":user_player", ":user_id"),
       (str_store_player_username, s7, ":user_player"),

       (try_begin),
         (eq, ":opened_or_closed", 0),
         (display_message, "@{s7} opened the gate"),
       (else_try),
         (display_message, "@{s7} closed the gate"),
       (try_end),
     (try_end),

     (prop_instance_get_scene_prop_kind, ":scene_prop_id", ":instance_id"),

     (try_begin),
       (this_or_next|eq, ":scene_prop_id", "spr_winch_b"),
       (eq, ":scene_prop_id", "spr_winch"),
       (assign, ":effected_object", "spr_portcullis"),
     (else_try),
       (this_or_next|eq, ":scene_prop_id", "spr_door_destructible"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_b"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_e_sally_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_sally_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),
       (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_right"),
       (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),
       (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_right"),
       (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_a"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_6m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_8m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_10m"),
       (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_12m"),
       (eq, ":scene_prop_id", "spr_siege_ladder_move_14m"),
       (assign, ":effected_object", ":scene_prop_id"),
     (try_end),

     (assign, ":smallest_dist", -1),
     (prop_instance_get_position, pos0, ":instance_id"),
     (scene_prop_get_num_instances, ":num_instances_of_effected_object", ":effected_object"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_effected_object"),
       (scene_prop_get_instance, ":cur_instance_id", ":effected_object", ":cur_instance"),
       (prop_instance_get_position, pos1, ":cur_instance_id"),
       (get_sq_distance_between_positions, ":dist", pos0, pos1),
       (this_or_next|eq, ":smallest_dist", -1),
       (lt, ":dist", ":smallest_dist"),
       (assign, ":smallest_dist", ":dist"),
       (assign, ":effected_object_instance_id", ":cur_instance_id"),
     (try_end),

     (try_begin),
       (ge, ":instance_id", 0),
       (ge, ":smallest_dist", 0),

       (try_begin),
         (eq, ":effected_object", "spr_portcullis"),
         (scene_prop_get_slot, ":opened_or_closed", ":instance_id", scene_prop_open_or_close_slot),

         (try_begin),
           (eq, ":opened_or_closed", 0), #open gate

           (scene_prop_enable_after_time, ":instance_id", 400), #4 seconds
           (try_begin),
             (this_or_next|multiplayer_is_server),
             (neg|game_in_multiplayer_mode),
             (prop_instance_get_position, pos0, ":effected_object_instance_id"),
             (position_move_z, pos0, 375),
             (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 400),
           (try_end),
           (scene_prop_set_slot, ":instance_id", scene_prop_open_or_close_slot, 1),

           (try_begin),
             (eq, ":scene_prop_id", "spr_winch_b"),
             (this_or_next|multiplayer_is_server),
             (neg|game_in_multiplayer_mode),
             (prop_instance_get_position, pos1, ":instance_id"),
             (prop_instance_rotate_to_position, ":instance_id", pos1, 400, 72000),
           (try_end),
         (else_try), #close gate
           (scene_prop_enable_after_time, ":instance_id", 400), #4 seconds
           (try_begin),
             (this_or_next|multiplayer_is_server),
             (neg|game_in_multiplayer_mode),
             (prop_instance_get_position, pos0, ":effected_object_instance_id"),
             (position_move_z, pos0, -375),
             (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 400),
           (try_end),
           (scene_prop_set_slot, ":instance_id", scene_prop_open_or_close_slot, 0),

           (try_begin),
             (eq, ":scene_prop_id", "spr_winch_b"),
             (this_or_next|multiplayer_is_server),
             (neg|game_in_multiplayer_mode),
             (prop_instance_get_position, pos1, ":instance_id"),
             (prop_instance_rotate_to_position, ":instance_id", pos1, 400, -72000),
           (try_end),
         (try_end),
       (else_try),
         (this_or_next|eq, ":effected_object", "spr_siege_ladder_move_6m"),
         (this_or_next|eq, ":effected_object", "spr_siege_ladder_move_8m"),
         (this_or_next|eq, ":effected_object", "spr_siege_ladder_move_10m"),
         (this_or_next|eq, ":effected_object", "spr_siege_ladder_move_12m"),
         (eq, ":effected_object", "spr_siege_ladder_move_14m"),

         (try_begin),
           (eq, ":effected_object", "spr_siege_ladder_move_6m"),
           (assign, ":animation_time_drop", 120),
           (assign, ":animation_time_elevate", 240),
         (else_try),
           (eq, ":effected_object", "spr_siege_ladder_move_8m"),
           (assign, ":animation_time_drop", 140),
           (assign, ":animation_time_elevate", 280),
         (else_try),
           (eq, ":effected_object", "spr_siege_ladder_move_10m"),
           (assign, ":animation_time_drop", 160),
           (assign, ":animation_time_elevate", 320),
         (else_try),
           (eq, ":effected_object", "spr_siege_ladder_move_12m"),
           (assign, ":animation_time_drop", 190),
           (assign, ":animation_time_elevate", 360),
         (else_try),
           (eq, ":effected_object", "spr_siege_ladder_move_14m"),
           (assign, ":animation_time_drop", 230),
           (assign, ":animation_time_elevate", 400),
         (try_end),

         (scene_prop_get_slot, ":opened_or_closed", ":instance_id", scene_prop_open_or_close_slot),

         (try_begin),
           (scene_prop_enable_after_time, ":effected_object_instance_id", ":animation_time_elevate"), #3 seconds in average
           (eq, ":opened_or_closed", 0), #ladder at ground
           (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),
           (prop_instance_enable_physics, ":effected_object_instance_id", 0),
           (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 300),
           (scene_prop_set_slot, ":effected_object_instance_id", scene_prop_open_or_close_slot, 1),
         (else_try), #ladder at wall
           (scene_prop_enable_after_time, ":effected_object_instance_id", ":animation_time_drop"), #1.5 seconds in average
           (prop_instance_get_position, pos0, ":instance_id"),

           (assign, ":smallest_dist", -1),
           (try_for_range, ":entry_point_no", multi_entry_points_for_usable_items_start, multi_entry_points_for_usable_items_end),
             (entry_point_get_position, pos1, ":entry_point_no"),
             (get_sq_distance_between_positions, ":dist", pos0, pos1),
             (this_or_next|eq, ":smallest_dist", -1),
             (lt, ":dist", ":smallest_dist"),
             (assign, ":smallest_dist", ":dist"),
             (assign, ":nearest_entry_point", ":entry_point_no"),
           (try_end),

           (try_begin),
             (ge, ":smallest_dist", 0),
             (lt, ":smallest_dist", 22500), #max 15m distance
             (entry_point_get_position, pos1, ":nearest_entry_point"),
             (position_rotate_x, pos1, -90),
             (scene_prop_set_slot, ":effected_object_instance_id", scene_prop_smoke_effect_done, 0),
             (prop_instance_enable_physics, ":effected_object_instance_id", 0),
             (prop_instance_animate_to_position, ":effected_object_instance_id", pos1, 130),
           (try_end),

           (scene_prop_set_slot, ":effected_object_instance_id", scene_prop_open_or_close_slot, 0),
         (try_end),
       (else_try),
         (this_or_next|eq, ":effected_object", "spr_door_destructible"),
         (this_or_next|eq, ":effected_object", "spr_castle_f_door_b"),
         (this_or_next|eq, ":scene_prop_id", "spr_castle_e_sally_door_a"),
         (this_or_next|eq, ":scene_prop_id", "spr_castle_f_sally_door_a"),
         (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),
         (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_right"),
         (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),
         (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_right"),
         (eq, ":scene_prop_id", "spr_castle_f_door_a"),

         (assign, ":effected_object_instance_id", ":instance_id"),
         (scene_prop_get_slot, ":opened_or_closed", ":effected_object_instance_id", scene_prop_open_or_close_slot),

         (try_begin),
           (eq, ":opened_or_closed", 0),

           (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),

           (scene_prop_enable_after_time, ":effected_object_instance_id", 100),

           (try_begin),
             (neg|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),
             (neg|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),

             (position_rotate_z, pos0, -85),
           (else_try),
             (position_rotate_z, pos0, 85),
           (try_end),

           (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 100),

           (scene_prop_set_slot, ":effected_object_instance_id", scene_prop_open_or_close_slot, 1),
         (else_try),
           (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),

           (scene_prop_enable_after_time, ":effected_object_instance_id", 100),

           (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 100),

           (scene_prop_set_slot, ":effected_object_instance_id", scene_prop_open_or_close_slot, 0),
         (try_end),
       (try_end),
     (try_end),
     ]),

  #script_determine_team_flags
  # INPUT: none
  # OUTPUT: none
  ("determine_team_flags",
   [
     (store_script_param, ":team_no", 1),

     (try_begin),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),

       (try_begin),
         (eq, ":team_no", 0),

         (team_get_faction, ":team_faction_no", 0),
         (try_begin),
           (eq, ":team_faction_no", "fac_kingdom_1"),
           (assign, "$team_1_flag_scene_prop", "spr_ctf_flag_kingdom_1"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_2"),
           (assign, "$team_1_flag_scene_prop", "spr_ctf_flag_kingdom_2"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_3"),
           (assign, "$team_1_flag_scene_prop", "spr_ctf_flag_kingdom_3"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_4"),
           (assign, "$team_1_flag_scene_prop", "spr_ctf_flag_kingdom_4"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_5"),
           (assign, "$team_1_flag_scene_prop", "spr_ctf_flag_kingdom_5"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_6"),
           (assign, "$team_1_flag_scene_prop", "spr_ctf_flag_kingdom_6"),
         (try_end),
       (else_try),
         (team_get_faction, ":team_faction_no", 1),
         (try_begin),
           (eq, ":team_faction_no", "fac_kingdom_1"),
           (assign, "$team_2_flag_scene_prop", "spr_ctf_flag_kingdom_1"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_2"),
           (assign, "$team_2_flag_scene_prop", "spr_ctf_flag_kingdom_2"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_3"),
           (assign, "$team_2_flag_scene_prop", "spr_ctf_flag_kingdom_3"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_4"),
           (assign, "$team_2_flag_scene_prop", "spr_ctf_flag_kingdom_4"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_5"),
           (assign, "$team_2_flag_scene_prop", "spr_ctf_flag_kingdom_5"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_6"),
           (assign, "$team_2_flag_scene_prop", "spr_ctf_flag_kingdom_6"),
         (try_end),

         (try_begin),
           (eq, "$team_1_flag_scene_prop", "$team_2_flag_scene_prop"),
           (assign, "$team_2_flag_scene_prop", "spr_ctf_flag_kingdom_7"),
         (try_end),
       (try_end),
     (else_try),
       (try_begin),
         (eq, ":team_no", 0),

         (team_get_faction, ":team_faction_no", 0),
         (try_begin),
           (eq, ":team_faction_no", "fac_kingdom_1"),
           (assign, "$team_1_flag_scene_prop", "spr_headquarters_flag_swadian"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_2"),
           (assign, "$team_1_flag_scene_prop", "spr_headquarters_flag_vaegir"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_3"),
           (assign, "$team_1_flag_scene_prop", "spr_headquarters_flag_khergit"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_4"),
           (assign, "$team_1_flag_scene_prop", "spr_headquarters_flag_nord"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_5"),
           (assign, "$team_1_flag_scene_prop", "spr_headquarters_flag_rhodok"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_6"),
           (assign, "$team_1_flag_scene_prop", "spr_headquarters_flag_sarranid"),
         (try_end),
       (else_try),
         (team_get_faction, ":team_faction_no", 1),
         (try_begin),
           (eq, ":team_faction_no", "fac_kingdom_1"),
           (assign, "$team_2_flag_scene_prop", "spr_headquarters_flag_swadian"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_2"),
           (assign, "$team_2_flag_scene_prop", "spr_headquarters_flag_vaegir"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_3"),
           (assign, "$team_2_flag_scene_prop", "spr_headquarters_flag_khergit"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_4"),
           (assign, "$team_2_flag_scene_prop", "spr_headquarters_flag_nord"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_5"),
           (assign, "$team_2_flag_scene_prop", "spr_headquarters_flag_rhodok"),
         (else_try),
           (eq, ":team_faction_no", "fac_kingdom_6"),
           (assign, "$team_2_flag_scene_prop", "spr_headquarters_flag_sarranid"),
         (try_end),

         (try_begin),
           (eq, "$team_1_flag_scene_prop", "$team_2_flag_scene_prop"),
           (assign, "$team_2_flag_scene_prop", "spr_headquarters_flag_rebel"),
         (try_end),
       (try_end),
     (try_end),
   ]),


  #script_calculate_flag_move_time
  # INPUT: arg1 = number_of_total_agents_around_flag, arg2 = dist_between_flag_and_its_pole
  # OUTPUT: reg0 = flag move time
  ("calculate_flag_move_time",
   [
     (store_script_param, ":number_of_total_agents_around_flag", 1),
     (store_script_param, ":dist_between_flag_and_its_target", 2),

     (try_begin), #(if no one is around flag it again moves to its current owner situation but 5 times slower than normal)
       (eq, ":number_of_total_agents_around_flag", 0),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 2500),#5.00 * 1.00 * (500 stable) = 2000
     (else_try),
       (eq, ":number_of_total_agents_around_flag", 1),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 500), #1.00 * (500 stable) = 500
     (else_try),
       (eq, ":number_of_total_agents_around_flag", 2),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 300), #0.60(0.60) * (500 stable) = 300
     (else_try),
       (eq, ":number_of_total_agents_around_flag", 3),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 195), #0.39(0.60 * 0.65) * (500 stable) = 195
     (else_try),
       (eq, ":number_of_total_agents_around_flag", 4),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 137), #0.273(0.60 * 0.65 * 0.70) * (500 stable) = 136.5 >rounding> 137
     (else_try),
       (eq, ":number_of_total_agents_around_flag", 5),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 102), #0.20475(0.60 * 0.65 * 0.70 * 0.75) * (500 stable) = 102.375 >rounding> 102
     (else_try),
       (eq, ":number_of_total_agents_around_flag", 6),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 82),  #0.1638(0.60 * 0.65 * 0.70 * 0.75 * 0.80) * (500 stable) = 81.9 >rounding> 82
     (else_try),
       (eq, ":number_of_total_agents_around_flag", 7),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 66),  #0.13104(0.60 * 0.65 * 0.70 * 0.75 * 0.80 * 0.85) * (500 stable) = 65.52 >rounding> 66
     (else_try),
       (eq, ":number_of_total_agents_around_flag", 8),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 59),  #0.117936(0.60 * 0.65 * 0.70 * 0.75 * 0.80 * 0.85 * 0.90) * (500 stable) = 58.968 >rounding> 59
     (else_try),
       (store_mul, reg0, ":dist_between_flag_and_its_target", 56),  #0.1120392(0.60 * 0.65 * 0.70 * 0.75 * 0.80 * 0.85 * 0.90 * 0.95) * (500 stable) = 56.0196 >rounding> 56
     (try_end),

     (assign, ":number_of_players", 0),
     (get_max_players, ":num_players"),
     (try_for_range, ":cur_player", 0, ":num_players"),
       (player_is_active, ":cur_player"),
       (val_add, ":number_of_players", 1),
     (try_end),

     (try_begin),
       (lt, ":number_of_players", 10),
       (val_mul, reg0, 50),
     (else_try),
       (lt, ":number_of_players", 35),
       (store_sub, ":number_of_players_multipication", 35, ":number_of_players"),
       (val_mul, ":number_of_players_multipication", 2),
       (store_sub, ":number_of_players_multipication", 100, ":number_of_players_multipication"),
       (val_mul, reg0, ":number_of_players_multipication"),
     (else_try),
       (val_mul, reg0, 100),
     (try_end),

     (try_begin),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
       (val_mul, reg0, 2),
     (try_end),

     (val_div, reg0, 10000), #100x for number of players around flag, 100x for number of players in game
     ]),

  #script_move_death_mode_flags_down
  # INPUT: none
  # OUTPUT: none
  ("move_death_mode_flags_down",
   [
     (try_begin),
       (scene_prop_get_instance, ":pole_1_id", "spr_headquarters_pole_code_only", 0),
       (prop_instance_get_position, pos0, ":pole_1_id"),
       (position_move_z, pos0, -2000),
       (prop_instance_set_position, ":pole_1_id", pos0),
     (try_end),

     (try_begin),
       (scene_prop_get_instance, ":pole_2_id", "spr_headquarters_pole_code_only", 1),
       (prop_instance_get_position, pos1, ":pole_2_id"),
       (position_move_z, pos1, -2000),
       (prop_instance_set_position, ":pole_2_id", pos1),
     (try_end),

     (try_begin),
       (scene_prop_get_instance, ":pole_1_id", "spr_headquarters_pole_code_only", 0),
       (prop_instance_get_position, pos0, ":pole_1_id"),
       (scene_prop_get_instance, ":flag_1_id", "$team_1_flag_scene_prop", 0),
       (prop_instance_stop_animating, ":flag_1_id"),
       (position_move_z, pos0, multi_headquarters_flag_initial_height),
       (prop_instance_set_position, ":flag_1_id", pos0),
     (try_end),

     (try_begin),
       (scene_prop_get_instance, ":pole_2_id", "spr_headquarters_pole_code_only", 1),
       (prop_instance_get_position, pos1, ":pole_2_id"),
       (scene_prop_get_instance, ":flag_2_id", "$team_2_flag_scene_prop", 0),
       (prop_instance_stop_animating, ":flag_2_id"),
       (position_move_z, pos1, multi_headquarters_flag_initial_height),
       (prop_instance_set_position, ":flag_2_id", pos1),
     (try_end),
   ]),

  #script_move_flag
  # INPUT: arg1 = shown_flag_id, arg2 = move time in seconds, pos0 = target position
  # OUTPUT: none
  ("move_flag",
   [
     (store_script_param, ":shown_flag_id", 1),
     (store_script_param, ":shown_flag_move_time", 2),

     (try_begin),
       (multiplayer_is_server), #added after auto-animating

       (try_begin),
         (eq, ":shown_flag_move_time", 0), #stop
         (prop_instance_stop_animating, ":shown_flag_id"),
       (else_try),
         (prop_instance_animate_to_position, ":shown_flag_id", pos0, ":shown_flag_move_time"),
       (try_end),
     (try_end),
   ]),

  #script_move_headquarters_flags
  # INPUT: arg1 = current_owner, arg2 = number_of_agents_around_flag_team_1, arg3 = number_of_agents_around_flag_team_2
  # OUTPUT: none
  ("move_headquarters_flags",
   [
     (store_script_param, ":flag_no", 1),
     (store_script_param, ":number_of_agents_around_flag_team_1", 2),
     (store_script_param, ":number_of_agents_around_flag_team_2", 3),

     (store_add, ":cur_flag_slot", multi_data_flag_owner_begin, ":flag_no"),
     (troop_get_slot, ":current_owner", "trp_multiplayer_data", ":cur_flag_slot"),

     (scene_prop_get_num_instances, ":num_instances", "spr_headquarters_flag_gray_code_only"),
     (try_begin),
       (assign, ":visibility", 0),
       (lt, ":flag_no", ":num_instances"),
       (scene_prop_get_instance, ":flag_id", "spr_headquarters_flag_gray_code_only", ":flag_no"),
       (scene_prop_get_visibility, ":visibility", ":flag_id"),
     (try_end),

     (try_begin),
       (eq, ":visibility", 1),
       (assign, ":shown_flag", 0),
       (assign, ":shown_flag_id", ":flag_id"),
     (else_try),
       (scene_prop_get_num_instances, ":num_instances", "$team_1_flag_scene_prop"),
       (try_begin),
         (assign, ":visibility", 0),
         (lt, ":flag_no", ":num_instances"),
         (scene_prop_get_instance, ":flag_id", "$team_1_flag_scene_prop", ":flag_no"),
         (scene_prop_get_visibility, ":visibility", ":flag_id"),
       (try_end),

       #(scene_prop_get_instance, ":flag_id", "$team_1_flag_scene_prop", ":flag_no"),
       #(scene_prop_get_visibility, ":visibility", ":flag_id"),
       (try_begin),
         (eq, ":visibility", 1),
         (assign, ":shown_flag", 1),
         (assign, ":shown_flag_id", ":flag_id"),
       (else_try),
         (scene_prop_get_num_instances, ":num_instances", "$team_2_flag_scene_prop"),
         (try_begin),
           (assign, ":visibility", 0),
           (lt, ":flag_no", ":num_instances"),
           (scene_prop_get_instance, ":flag_id", "$team_2_flag_scene_prop", ":flag_no"),
           (scene_prop_get_visibility, ":visibility", ":flag_id"),
         (try_end),

         #(scene_prop_get_instance, ":flag_id", "$team_2_flag_scene_prop", ":flag_no"),
         #(scene_prop_get_visibility, ":visibility", ":flag_id"),
         (try_begin),
           (eq, ":visibility", 1),
           (assign, ":shown_flag", 2),
           (assign, ":shown_flag_id", ":flag_id"),
         (try_end),
       (try_end),
     (try_end),

     (try_begin),
       (scene_prop_get_instance, ":pole_id", "spr_headquarters_pole_code_only", ":flag_no"),
     (try_end),

     (try_begin),
       (eq, ":shown_flag", ":current_owner"), #situation 1 : (current owner is equal shown flag)
       (try_begin),
         (ge, ":number_of_agents_around_flag_team_1", 1),
         (ge, ":number_of_agents_around_flag_team_2", 1),
         (assign, ":flag_movement", 0), #0:stop
       (else_try),
         (eq, ":number_of_agents_around_flag_team_1", 0),
         (eq, ":number_of_agents_around_flag_team_2", 0),
         (assign, ":flag_movement", 1), #1:rise (slow)
       (else_try),
         (try_begin),
           (ge, ":number_of_agents_around_flag_team_1", 1),
           (eq, ":number_of_agents_around_flag_team_2", 0),
           (eq, ":current_owner", 1),
           (assign, ":flag_movement", 1), #1:rise (fast)
         (else_try),
           (eq, ":number_of_agents_around_flag_team_1", 0),
           (ge, ":number_of_agents_around_flag_team_2", 1),
           (eq, ":current_owner", 2),
           (assign, ":flag_movement", 1), #1:rise (fast)
         (else_try),
           (assign, ":flag_movement", -1), #-1:drop (fast)
         (try_end),
       (try_end),
     (else_try), #situation 2 : (current owner is different than shown flag)
       (try_begin),
         (ge, ":number_of_agents_around_flag_team_1", 1),
         (ge, ":number_of_agents_around_flag_team_2", 1),
         (assign, ":flag_movement", 0), #0:stop
       (else_try),
         (eq, ":number_of_agents_around_flag_team_1", 0),
         (eq, ":number_of_agents_around_flag_team_2", 0),
         (assign, ":flag_movement", -1), #-1:drop (slow)
       (else_try),
         (try_begin),
           (ge, ":number_of_agents_around_flag_team_1", 1),
           (eq, ":number_of_agents_around_flag_team_2", 0),
           (try_begin),
             (eq, ":shown_flag", 1),
             (assign, ":flag_movement", 1), #1:rise (fast)
           (else_try),
             (neq, ":current_owner", 1),
             (assign, ":flag_movement", -1), #-1:drop (fast)
           (try_end),
         (else_try),
           (eq, ":number_of_agents_around_flag_team_1", 0),
           (ge, ":number_of_agents_around_flag_team_2", 1),
           (try_begin),
             (eq, ":shown_flag", 2),
             (assign, ":flag_movement", 1), #1:rise (fast)
           (else_try),
             (neq, ":current_owner", 2),
             (assign, ":flag_movement", -1), #-1:drop (fast)
           (try_end),
         (try_end),
       (try_end),
     (try_end),

     (store_add, ":number_of_total_agents_around_flag", ":number_of_agents_around_flag_team_1", ":number_of_agents_around_flag_team_2"),

     (try_begin),
       (eq, ":flag_movement", 0),
       (assign, reg0, 0),
     (else_try),
       (eq, ":flag_movement", 1),
       (prop_instance_get_position, pos1, ":shown_flag_id"),
       (prop_instance_get_position, pos0, ":pole_id"),
       (position_move_z, pos0, multi_headquarters_pole_height),
       (get_distance_between_positions, ":dist_between_flag_and_its_target", pos0, pos1),
       (call_script, "script_calculate_flag_move_time", ":number_of_total_agents_around_flag", ":dist_between_flag_and_its_target"),
     (else_try),
       (eq, ":flag_movement", -1),
       (prop_instance_get_position, pos1, ":shown_flag_id"),
       (prop_instance_get_position, pos0, ":pole_id"),
       (get_distance_between_positions, ":dist_between_flag_and_its_target", pos0, pos1),
       (call_script, "script_calculate_flag_move_time", ":number_of_total_agents_around_flag", ":dist_between_flag_and_its_target"),
     (try_end),

     (call_script, "script_move_flag", ":shown_flag_id", reg0), #pos0 : target position
     ]),

  #script_set_num_agents_around_flag
  # INPUT: arg1 = flag_no, arg2 = owner_code
  # OUTPUT: none
  ("set_num_agents_around_flag",
   [
     (store_script_param, ":flag_no", 1),
     (store_script_param, ":current_owner_code", 2),

     (store_div, ":number_of_agents_around_flag_team_1", ":current_owner_code", 100),
     (store_mod, ":number_of_agents_around_flag_team_2", ":current_owner_code", 100),

     (store_add, ":cur_flag_owner_counts_slot", multi_data_flag_players_around_begin, ":flag_no"),
     (troop_set_slot, "trp_multiplayer_data", ":cur_flag_owner_counts_slot", ":current_owner_code"),

     (call_script, "script_move_headquarters_flags", ":flag_no", ":number_of_agents_around_flag_team_1", ":number_of_agents_around_flag_team_2"),
  ]),

  #script_change_flag_owner
  # INPUT: arg1 = flag_no, arg2 = owner_code
  # OUTPUT: none
  ("change_flag_owner",
   [
     (store_script_param, ":flag_no", 1),
     (store_script_param, ":owner_code", 2),

     (try_begin),
       (lt, ":owner_code", 0),
       (val_add, ":owner_code", 1),
       (val_mul, ":owner_code", -1),
     (try_end),

     (store_div, ":owner_team_no", ":owner_code", 100),
     (store_mod, ":shown_flag_no", ":owner_code", 100),

     (store_add, ":cur_flag_slot", multi_data_flag_owner_begin, ":flag_no"),
     (troop_get_slot, ":older_owner_team_no", "trp_multiplayer_data", ":cur_flag_slot"),

     (store_add, ":cur_flag_slot", multi_data_flag_owner_begin, ":flag_no"),
     (troop_set_slot, "trp_multiplayer_data", ":cur_flag_slot", ":owner_team_no"),

     #senchronizing flag positions
     (try_begin),
       #(this_or_next|eq, ":initial_flags", 0), #moved after auto-animating
       (multiplayer_is_server),

       (scene_prop_get_instance, ":pole_id", "spr_headquarters_pole_code_only", ":flag_no"),
       (try_begin),
         (eq, ":owner_team_no", 0), #if new owner team is 0 then flags are at bottom
         (neq, ":older_owner_team_no", -1), #clients
         (assign, ":continue", 1),
         (try_begin),
           (multiplayer_is_server),
           (eq, "$g_placing_initial_flags", 1),
           (assign, ":continue", 0),
         (try_end),
         (eq, ":continue", 1),
         (prop_instance_get_position, pos0, ":pole_id"),
         (position_move_z, pos0, multi_headquarters_distance_to_change_flag),
       (else_try),
         (prop_instance_get_position, pos0, ":pole_id"), #if new owner team is not 0 then flags are at top
         (position_move_z, pos0, multi_headquarters_pole_height),
       (try_end),

       (scene_prop_get_instance, ":flag_id", "$team_1_flag_scene_prop", ":flag_no"),
         (prop_instance_stop_animating, ":flag_id"),
       (prop_instance_set_position, ":flag_id", pos0),

       (scene_prop_get_instance, ":flag_id", "$team_2_flag_scene_prop", ":flag_no"),
         (prop_instance_stop_animating, ":flag_id"),
       (prop_instance_set_position, ":flag_id", pos0),

       (scene_prop_get_instance, ":flag_id", "spr_headquarters_flag_gray_code_only", ":flag_no"),
         (prop_instance_stop_animating, ":flag_id"),
       (prop_instance_set_position, ":flag_id", pos0),
     (try_end),

     #setting visibilities of flags
     (try_begin),
       (eq, ":shown_flag_no", 0),
       (scene_prop_get_instance, ":flag_id", "$team_1_flag_scene_prop", ":flag_no"),
       (scene_prop_set_visibility, ":flag_id", 0),
       (scene_prop_get_instance, ":flag_id", "$team_2_flag_scene_prop", ":flag_no"),
       (scene_prop_set_visibility, ":flag_id", 0),
       (scene_prop_get_instance, ":flag_id", "spr_headquarters_flag_gray_code_only", ":flag_no"),
       (scene_prop_set_visibility, ":flag_id", 1),
     (else_try),
       (eq, ":shown_flag_no", 1),
       (scene_prop_get_instance, ":flag_id", "$team_1_flag_scene_prop", ":flag_no"),
       (scene_prop_set_visibility, ":flag_id", 1),
       (scene_prop_get_instance, ":flag_id", "$team_2_flag_scene_prop", ":flag_no"),
       (scene_prop_set_visibility, ":flag_id", 0),
       (scene_prop_get_instance, ":flag_id", "spr_headquarters_flag_gray_code_only", ":flag_no"),
       (scene_prop_set_visibility, ":flag_id", 0),
     (else_try),
       (eq, ":shown_flag_no", 2),
       (scene_prop_get_instance, ":flag_id", "$team_1_flag_scene_prop", ":flag_no"),
       (scene_prop_set_visibility, ":flag_id", 0),
       (scene_prop_get_instance, ":flag_id", "$team_2_flag_scene_prop", ":flag_no"),
       (scene_prop_set_visibility, ":flag_id", 1),
       (scene_prop_get_instance, ":flag_id", "spr_headquarters_flag_gray_code_only", ":flag_no"),
       (scene_prop_set_visibility, ":flag_id", 0),
     (try_end),

     #other
     (store_add, ":cur_flag_players_around_slot", multi_data_flag_players_around_begin, ":flag_no"),
     (troop_get_slot, ":players_around_code", "trp_multiplayer_data", ":cur_flag_players_around_slot"),

     (store_div, ":number_of_agents_around_flag_team_1", ":players_around_code", 100),
     (store_mod, ":number_of_agents_around_flag_team_2", ":players_around_code", 100),

     (call_script, "script_move_headquarters_flags", ":flag_no", ":number_of_agents_around_flag_team_1", ":number_of_agents_around_flag_team_2"),
   ]),

  #script_move_object_to_nearest_entry_point
  # INPUT: none
  # OUTPUT: none
  ("move_object_to_nearest_entry_point",
   [
     (store_script_param, ":scene_prop_no", 1),

     (scene_prop_get_num_instances, ":num_instances", ":scene_prop_no"),

     (try_for_range, ":instance_no", 0, ":num_instances"),
       (scene_prop_get_instance, ":instance_id", ":scene_prop_no", ":instance_no"),
       (prop_instance_get_position, pos0, ":instance_id"),

       (assign, ":smallest_dist", -1),
       (try_for_range, ":entry_point_no", multi_entry_points_for_usable_items_start, multi_entry_points_for_usable_items_end),
         (entry_point_get_position, pos1, ":entry_point_no"),
         (get_sq_distance_between_positions, ":dist", pos0, pos1),
         (this_or_next|eq, ":smallest_dist", -1),
         (lt, ":dist", ":smallest_dist"),
         (assign, ":smallest_dist", ":dist"),
         (assign, ":nearest_entry_point", ":entry_point_no"),
       (try_end),

       (try_begin),
         (ge, ":smallest_dist", 0),
         (lt, ":smallest_dist", 22500), #max 15m distance
         (entry_point_get_position, pos1, ":nearest_entry_point"),
         (position_rotate_x, pos1, -90),
         (prop_instance_animate_to_position, ":instance_id", pos1, 1),
       (try_end),
     (try_end),
   ]),


  #script_multiplayer_server_on_agent_spawn_common
  # INPUT: arg1 = agent_no
  # OUTPUT: none
  ("multiplayer_server_on_agent_spawn_common",
   [
     (store_script_param, ":agent_no", 1),
     (agent_set_slot, ":agent_no", slot_agent_in_duel_with, -1),
     (try_begin),
       (agent_is_non_player, ":agent_no"),
       (assign, "$g_multiplayer_ready_for_spawning_agent", 1),
     (try_end),
     ]),

  #script_multiplayer_server_player_joined_common
  # INPUT: arg1 = player_no
  # OUTPUT: none
  ("multiplayer_server_player_joined_common",
   [
     (store_script_param, ":player_no", 1),
     (try_begin),
       (this_or_next|player_is_active, ":player_no"),
       (eq, ":player_no", 0),
       (call_script, "script_multiplayer_init_player_slots", ":player_no"),
       (store_mission_timer_a, ":player_join_time"),
       (player_set_slot, ":player_no", slot_player_join_time, ":player_join_time"),
       (player_set_slot, ":player_no", slot_player_first_spawn, 1),
       #fight and destroy only
       (player_set_slot, ":player_no", slot_player_damage_given_to_target_1, 0),
       (player_set_slot, ":player_no", slot_player_damage_given_to_target_2, 0),
       #fight and destroy only end
       (try_begin),
         (multiplayer_is_server),
         (assign, ":initial_gold", multi_initial_gold_value),
         (val_mul, ":initial_gold", "$g_multiplayer_initial_gold_multiplier"),
         (val_div, ":initial_gold", 100),
         (player_set_gold, ":player_no", ":initial_gold"),
         (call_script, "script_multiplayer_send_initial_information", ":player_no"),
       (try_end),
     (try_end),
     ]),

  #script_multiplayer_server_before_mission_start_common
  # INPUT: none
  # OUTPUT: none
  ("multiplayer_server_before_mission_start_common",
   [
     (try_begin),
       (scene_allows_mounted_units),
       (assign, "$g_horses_are_avaliable", 1),
     (else_try),
       (assign, "$g_horses_are_avaliable", 0),
     (try_end),
     (scene_set_day_time, 15),
     (assign, "$g_multiplayer_mission_end_screen", 0),

     (get_max_players, ":num_players"),
     (try_for_range, ":player_no", 0, ":num_players"),
       (player_is_active, ":player_no"),
       (call_script, "script_multiplayer_init_player_slots", ":player_no"),
       (assign, ":initial_gold", multi_initial_gold_value),
       (val_mul, ":initial_gold", "$g_multiplayer_initial_gold_multiplier"),
       (val_div, ":initial_gold", 100),
       (player_set_gold, ":player_no", ":initial_gold"),
       (player_set_slot, ":player_no", slot_player_first_spawn, 1), #not required in siege, bt, fd
     (try_end),
     ]),

  #script_multiplayer_server_on_agent_killed_or_wounded_common
  # INPUT: arg1 = dead_agent_no, arg2 = killer_agent_no
  # OUTPUT: none
  ("multiplayer_server_on_agent_killed_or_wounded_common",
   [
     (store_script_param, ":dead_agent_no", 1),
     (store_script_param, ":killer_agent_no", 2),

     (call_script, "script_multiplayer_event_agent_killed_or_wounded", ":dead_agent_no", ":killer_agent_no"),
     #adding 1 score points to agent which kills enemy agent at server
     (try_begin),
       (multiplayer_is_server),
       (try_begin), #killing myself because of some reason (friend hit, fall, team change)
         (lt, ":killer_agent_no", 0),
         (ge, ":dead_agent_no", 0),
         (neg|agent_is_non_player, ":dead_agent_no"),
         (agent_get_player_id, ":dead_agent_player_id", ":dead_agent_no"),
         (player_is_active, ":dead_agent_player_id"),
         (player_get_score, ":dead_agent_player_score", ":dead_agent_player_id"),
         (val_add, ":dead_agent_player_score", -1),
         (player_set_score, ":dead_agent_player_id", ":dead_agent_player_score"),
       (else_try), #killing teammate
         (ge, ":killer_agent_no", 0),
         (ge, ":dead_agent_no", 0),
         (agent_get_team, ":killer_team_no", ":killer_agent_no"),
         (agent_get_team, ":dead_team_no", ":dead_agent_no"),
         (eq, ":killer_team_no", ":dead_team_no"),
         (neg|agent_is_non_player, ":killer_agent_no"),
         (agent_get_player_id, ":killer_agent_player_id", ":killer_agent_no"),
         (player_is_active, ":killer_agent_player_id"),
         (player_get_score, ":killer_agent_player_score", ":killer_agent_player_id"),
         (val_add, ":killer_agent_player_score", -1),
         (player_set_score, ":killer_agent_player_id", ":killer_agent_player_score"),
         #(player_get_kill_count, ":killer_agent_player_kill_count", ":killer_agent_player_id"),
         #(val_add, ":killer_agent_player_kill_count", -2),
         #(player_set_kill_count, ":killer_agent_player_id", ":killer_agent_player_kill_count"),
       (else_try), #killing enemy
         (ge, ":killer_agent_no", 0),
         (ge, ":dead_agent_no", 0),
         (agent_is_human, ":dead_agent_no"),
         (agent_is_human, ":killer_agent_no"),
         (try_begin),
           (eq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
           (try_begin),
             (eq, "$g_battle_death_mode_started", 1),
             (neq, ":dead_agent_no", ":killer_agent_no"),
             (call_script, "script_calculate_new_death_waiting_time_at_death_mod"),
           (try_end),
         (try_end),
         (try_begin),
           (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
           (eq, "$g_multiplayer_game_type", multiplayer_game_type_destroy),
           (agent_get_player_id, ":dead_player_no", ":dead_agent_no"),
           (try_begin),
             (ge, ":dead_player_no", 0),
             (player_is_active, ":dead_player_no"),
             (neg|agent_is_non_player, ":dead_agent_no"),
             (try_for_agents, ":cur_agent"),
               (agent_is_non_player, ":cur_agent"),
               (agent_is_human, ":cur_agent"),
               (agent_is_alive, ":cur_agent"),
               (agent_get_group, ":agent_group", ":cur_agent"),
               (try_begin),
                 (eq, ":dead_player_no", ":agent_group"),
                 (agent_set_group, ":cur_agent", -1),
               (try_end),
             (try_end),
           (try_end),
         (try_end),
         (neg|agent_is_non_player, ":killer_agent_no"),
         (agent_get_player_id, ":killer_agent_player_id", ":killer_agent_no"),
         (player_is_active, ":killer_agent_player_id"),
         (player_get_score, ":killer_agent_player_score", ":killer_agent_player_id"),
         (agent_get_team, ":killer_agent_team", ":killer_agent_no"),
         (agent_get_team, ":dead_agent_team", ":dead_agent_no"),
         (try_begin),
           (neq, ":killer_agent_team", ":dead_agent_team"),
           (val_add, ":killer_agent_player_score", 1),
         (else_try),
           (val_add, ":killer_agent_player_score", -1),
         (try_end),
         (player_set_score, ":killer_agent_player_id", ":killer_agent_player_score"),
       (try_end),
     (try_end),

     (call_script, "script_add_kill_death_counts", ":killer_agent_no", ":dead_agent_no"),
     #money management
     (call_script, "script_money_management_after_agent_death", ":killer_agent_no", ":dead_agent_no"),
     ]),

  #script_multiplayer_close_gate_if_it_is_open
  # INPUT: none
  # OUTPUT: none
  ("multiplayer_close_gate_if_it_is_open",
   [
     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_winch_b"),
     (try_for_range, ":cur_prop_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":prop_instance_id", "spr_winch_b", ":cur_prop_instance"),
       (scene_prop_slot_eq, ":prop_instance_id", scene_prop_open_or_close_slot, 1),
       (scene_prop_get_instance, ":effected_object_instance_id", "spr_portcullis", ":cur_prop_instance"),
       (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),
       (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 1),
     (try_end),
   ]),

  #script_multiplayer_move_moveable_objects_initial_positions
  # INPUT: none
  # OUTPUT: none
  ("multiplayer_move_moveable_objects_initial_positions",
   [
     (call_script, "script_move_object_to_nearest_entry_point", "spr_siege_ladder_move_6m"),
     (call_script, "script_move_object_to_nearest_entry_point", "spr_siege_ladder_move_8m"),
     (call_script, "script_move_object_to_nearest_entry_point", "spr_siege_ladder_move_10m"),
     (call_script, "script_move_object_to_nearest_entry_point", "spr_siege_ladder_move_12m"),
     (call_script, "script_move_object_to_nearest_entry_point", "spr_siege_ladder_move_14m"),
   ]),

  #script_move_belfries_to_their_first_entry_point
  # INPUT: none
  # OUTPUT: none
  ("move_belfries_to_their_first_entry_point",
   [
    (store_script_param, ":belfry_body_scene_prop", 1),

    (set_fixed_point_multiplier, 100),
    (scene_prop_get_num_instances, ":num_belfries", ":belfry_body_scene_prop"),

    (try_for_range, ":belfry_no", 0, ":num_belfries"),
      #belfry
      (scene_prop_get_instance, ":belfry_scene_prop_id", ":belfry_body_scene_prop", ":belfry_no"),
      (prop_instance_get_position, pos0, ":belfry_scene_prop_id"),

      (try_begin),
        (eq, ":belfry_body_scene_prop", "spr_belfry_a"),
        #belfry platform_a
        (scene_prop_get_instance, ":belfry_platform_a_scene_prop_id", "spr_belfry_platform_a", ":belfry_no"),
        #belfry platform_b
        (scene_prop_get_instance, ":belfry_platform_b_scene_prop_id", "spr_belfry_platform_b", ":belfry_no"),
      (else_try),
        #belfry platform_a
        (scene_prop_get_instance, ":belfry_platform_a_scene_prop_id", "spr_belfry_b_platform_a", ":belfry_no"),
      (try_end),

      #belfry wheel_1
      (store_mul, ":wheel_no", ":belfry_no", 3),
      (try_begin),
        (eq, ":belfry_body_scene_prop", "spr_belfry_b"),
        (scene_prop_get_num_instances, ":number_of_belfry_a", "spr_belfry_a"),
        (store_mul, ":number_of_belfry_a_wheels", ":number_of_belfry_a", 3),
        (val_add, ":wheel_no", ":number_of_belfry_a_wheels"),
      (try_end),
      (scene_prop_get_instance, ":belfry_wheel_1_scene_prop_id", "spr_belfry_wheel", ":wheel_no"),
      #belfry wheel_2
      (val_add, ":wheel_no", 1),
      (scene_prop_get_instance, ":belfry_wheel_2_scene_prop_id", "spr_belfry_wheel", ":wheel_no"),
      #belfry wheel_3
      (val_add, ":wheel_no", 1),
      (scene_prop_get_instance, ":belfry_wheel_3_scene_prop_id", "spr_belfry_wheel", ":wheel_no"),

      (store_add, ":belfry_first_entry_point_id", 11, ":belfry_no"), #belfry entry points are 110..119 and 120..129 and 130..139
      (try_begin),
        (eq, ":belfry_body_scene_prop", "spr_belfry_b"),
        (scene_prop_get_num_instances, ":number_of_belfry_a", "spr_belfry_a"),
        (val_add, ":belfry_first_entry_point_id", ":number_of_belfry_a"),
      (try_end),
      (val_mul, ":belfry_first_entry_point_id", 10),
      (entry_point_get_position, pos1, ":belfry_first_entry_point_id"),

      #this code block is taken from module_mission_templates.py (multiplayer_server_check_belfry_movement)
      #up down rotation of belfry's next entry point
      (init_position, pos9),
      (position_set_y, pos9, -500), #go 5.0 meters back
      (position_set_x, pos9, -300), #go 3.0 meters left
      (position_transform_position_to_parent, pos10, pos1, pos9),
      (position_get_distance_to_terrain, ":height_to_terrain_1", pos10), #learn distance between 5 meters back of entry point(pos10) and ground level at left part of belfry

      (init_position, pos9),
      (position_set_y, pos9, -500), #go 5.0 meters back
      (position_set_x, pos9, 300), #go 3.0 meters right
      (position_transform_position_to_parent, pos10, pos1, pos9),
      (position_get_distance_to_terrain, ":height_to_terrain_2", pos10), #learn distance between 5 meters back of entry point(pos10) and ground level at right part of belfry

      (store_add, ":height_to_terrain", ":height_to_terrain_1", ":height_to_terrain_2"),
      (val_mul, ":height_to_terrain", 100), #because of fixed point multiplier

      (store_div, ":rotate_angle_of_next_entry_point", ":height_to_terrain", 24), #if there is 1 meters of distance (100cm) then next target position will rotate by 2 degrees. #ac sonra
      (init_position, pos20),
      (position_rotate_x_floating, pos20, ":rotate_angle_of_next_entry_point"),
      (position_transform_position_to_parent, pos23, pos1, pos20),

      #right left rotation of belfry's next entry point
      (init_position, pos9),
      (position_set_x, pos9, -300), #go 3.0 meters left
      (position_transform_position_to_parent, pos10, pos1, pos9), #applying 3.0 meters in -x to position of next entry point target, final result is in pos10
      (position_get_distance_to_terrain, ":height_to_terrain_at_left", pos10), #learn distance between 3.0 meters left of entry point(pos10) and ground level
      (init_position, pos9),
      (position_set_x, pos9, 300), #go 3.0 meters left
      (position_transform_position_to_parent, pos10, pos1, pos9), #applying 3.0 meters in x to position of next entry point target, final result is in pos10
      (position_get_distance_to_terrain, ":height_to_terrain_at_right", pos10), #learn distance between 3.0 meters right of entry point(pos10) and ground level
      (store_sub, ":height_to_terrain_1", ":height_to_terrain_at_left", ":height_to_terrain_at_right"),

      (init_position, pos9),
      (position_set_x, pos9, -300), #go 3.0 meters left
      (position_set_y, pos9, -500), #go 5.0 meters forward
      (position_transform_position_to_parent, pos10, pos1, pos9), #applying 3.0 meters in -x to position of next entry point target, final result is in pos10
      (position_get_distance_to_terrain, ":height_to_terrain_at_left", pos10), #learn distance between 3.0 meters left of entry point(pos10) and ground level
      (init_position, pos9),
      (position_set_x, pos9, 300), #go 3.0 meters left
      (position_set_y, pos9, -500), #go 5.0 meters forward
      (position_transform_position_to_parent, pos10, pos1, pos9), #applying 3.0 meters in x to position of next entry point target, final result is in pos10
      (position_get_distance_to_terrain, ":height_to_terrain_at_right", pos10), #learn distance between 3.0 meters right of entry point(pos10) and ground level
      (store_sub, ":height_to_terrain_2", ":height_to_terrain_at_left", ":height_to_terrain_at_right"),

      (store_add, ":height_to_terrain", ":height_to_terrain_1", ":height_to_terrain_2"),
      (val_mul, ":height_to_terrain", 100), #100 is because of fixed_point_multiplier
      (store_div, ":rotate_angle_of_next_entry_point", ":height_to_terrain", 24), #if there is 1 meters of distance (100cm) then next target position will rotate by 25 degrees.
      (val_mul, ":rotate_angle_of_next_entry_point", -1),

      (init_position, pos20),
      (position_rotate_y_floating, pos20, ":rotate_angle_of_next_entry_point"),
      (position_transform_position_to_parent, pos22, pos23, pos20),

      (copy_position, pos1, pos22),
      #end of code block

      #belfry
      (prop_instance_stop_animating, ":belfry_scene_prop_id"),
      (prop_instance_set_position, ":belfry_scene_prop_id", pos1),

      #belfry platforms
      (try_begin),
        (eq, ":belfry_body_scene_prop", "spr_belfry_a"),

        #belfry platform_a
        (prop_instance_get_position, pos6, ":belfry_platform_a_scene_prop_id"),
        (position_transform_position_to_local, pos7, pos0, pos6),
        (position_transform_position_to_parent, pos8, pos1, pos7),
        (try_begin),
          (neg|scene_prop_slot_eq, ":belfry_scene_prop_id", scene_prop_belfry_platform_moved, 0),

          (init_position, pos20),
          (position_rotate_x, pos20, 90),
          (position_transform_position_to_parent, pos8, pos8, pos20),
        (try_end),
        (prop_instance_stop_animating, ":belfry_platform_a_scene_prop_id"),
        (prop_instance_set_position, ":belfry_platform_a_scene_prop_id", pos8),
        #belfry platform_b
        (prop_instance_get_position, pos6, ":belfry_platform_b_scene_prop_id"),
        (position_transform_position_to_local, pos7, pos0, pos6),
        (position_transform_position_to_parent, pos8, pos1, pos7),
        (prop_instance_stop_animating, ":belfry_platform_b_scene_prop_id"),
        (prop_instance_set_position, ":belfry_platform_b_scene_prop_id", pos8),
      (else_try),
        #belfry platform_a
        (prop_instance_get_position, pos6, ":belfry_platform_a_scene_prop_id"),
        (position_transform_position_to_local, pos7, pos0, pos6),
        (position_transform_position_to_parent, pos8, pos1, pos7),
        (try_begin),
          (neg|scene_prop_slot_eq, ":belfry_scene_prop_id", scene_prop_belfry_platform_moved, 0),

          (init_position, pos20),
          (position_rotate_x, pos20, 50),
          (position_transform_position_to_parent, pos8, pos8, pos20),
        (try_end),
        (prop_instance_stop_animating, ":belfry_platform_a_scene_prop_id"),
        (prop_instance_set_position, ":belfry_platform_a_scene_prop_id", pos8),
      (try_end),

      #belfry wheel_1
      (store_mul, ":wheel_no", ":belfry_no", 3),
      (try_begin),
        (eq, ":belfry_body_scene_prop", "spr_belfry_b"),
        (scene_prop_get_num_instances, ":number_of_belfry_a", "spr_belfry_a"),
        (store_mul, ":number_of_belfry_a_wheels", ":number_of_belfry_a", 3),
        (val_add, ":wheel_no", ":number_of_belfry_a_wheels"),
      (try_end),
      (prop_instance_get_position, pos6, ":belfry_wheel_1_scene_prop_id"),
      (position_transform_position_to_local, pos7, pos0, pos6),
      (position_transform_position_to_parent, pos8, pos1, pos7),
      (prop_instance_stop_animating, ":belfry_wheel_1_scene_prop_id"),
      (prop_instance_set_position, ":belfry_wheel_1_scene_prop_id", pos8),
      #belfry wheel_2
      (prop_instance_get_position, pos6, ":belfry_wheel_2_scene_prop_id"),
      (position_transform_position_to_local, pos7, pos0, pos6),
      (position_transform_position_to_parent, pos8, pos1, pos7),
      (prop_instance_stop_animating, ":belfry_wheel_2_scene_prop_id"),
      (prop_instance_set_position, ":belfry_wheel_2_scene_prop_id", pos8),
      #belfry wheel_3
      (prop_instance_get_position, pos6, ":belfry_wheel_3_scene_prop_id"),
      (position_transform_position_to_local, pos7, pos0, pos6),
      (position_transform_position_to_parent, pos8, pos1, pos7),
      (prop_instance_stop_animating, ":belfry_wheel_3_scene_prop_id"),
      (prop_instance_set_position, ":belfry_wheel_3_scene_prop_id", pos8),
    (try_end),
    ]),

  #script_team_set_score
  # INPUT: arg1 = team_no, arg2 = score
  # OUTPUT: none
  ("team_set_score",
   [
     (store_script_param, ":team_no", 1),
     (store_script_param, ":score", 2),

     (team_set_score, ":team_no", ":score"),
   ]),

  #script_player_set_score
  # INPUT: arg1 = player_no, arg2 = score
  # OUTPUT: none
  ("player_set_score",
   [
     (store_script_param, ":player_no", 1),
     (store_script_param, ":score", 2),

     (player_set_score, ":player_no", ":score"),
   ]),

  #script_player_set_kill_count
  # INPUT: arg1 = player_no, arg2 = score
  # OUTPUT: none
  ("player_set_kill_count",
   [
     (store_script_param, ":player_no", 1),
     (store_script_param, ":score", 2),

     (player_set_kill_count, ":player_no", ":score"),
   ]),

  #script_player_set_death_count
  # INPUT: arg1 = player_no, arg2 = score
  # OUTPUT: none
  ("player_set_death_count",
   [
     (store_script_param, ":player_no", 1),
     (store_script_param, ":score", 2),

     (player_set_death_count, ":player_no", ":score"),
   ]),

  #script_set_attached_scene_prop
  # INPUT: arg1 = agent_id, arg2 = flag_id
  # OUTPUT: none
  ("set_attached_scene_prop",
   [
     (store_script_param, ":agent_id", 1),
     (store_script_param, ":flag_id", 2),

     (try_begin), #if current mod is capture the flag and attached scene prop is flag then change flag situation of flag owner team.
       (scene_prop_get_instance, ":red_flag_id", "spr_tutorial_flag_red", 0),
       (scene_prop_get_instance, ":blue_flag_id", "spr_tutorial_flag_blue", 0),
       (assign, ":flag_owner_team", -1),
       (try_begin),
         (ge, ":red_flag_id", 0),
         (eq, ":flag_id", ":red_flag_id"),
         (assign, ":flag_owner_team", 0),
       (else_try),
         (ge, ":blue_flag_id", 0),
         (eq, ":flag_id", ":blue_flag_id"),
         (assign, ":flag_owner_team", 1),
       (try_end),
       (ge, ":flag_owner_team", 0),
       (team_set_slot, ":flag_owner_team", slot_team_flag_situation, 1), #1-stolen flag
     (try_end),

     (agent_set_attached_scene_prop, ":agent_id", ":flag_id"),
     (agent_set_attached_scene_prop_x, ":agent_id", 20),
     (agent_set_attached_scene_prop_z, ":agent_id", 50),
   ]),

  #script_set_team_flag_situation
  # INPUT: arg1 = team_no, arg2 = score
  # OUTPUT: none
  ("set_team_flag_situation",
   [
     (store_script_param, ":team_no", 1),
     (store_script_param, ":flag_situation", 2),

     (team_set_slot, ":team_no", slot_team_flag_situation, ":flag_situation"),
   ]),

  #script_start_death_mode
  # INPUT: none
  # OUTPUT: none
  ("start_death_mode",
   [
     (assign, "$g_multiplayer_message_type", multiplayer_message_type_start_death_mode),
     (start_presentation, "prsnt_multiplayer_message_1"),
   ]),

  #script_calculate_new_death_waiting_time_at_death_mod
  # INPUT: none
  # OUTPUT: none
  ("calculate_new_death_waiting_time_at_death_mod",
   [
     (assign, ":num_living_players", 0), #count number of living players to find out death wait time
     (try_begin),
       (try_for_agents, ":agent_no"),
         (agent_is_human, ":agent_no"),
         (agent_is_alive, ":agent_no"),
         (val_add, ":num_living_players", 1),
       (try_end),
     (try_end),

     (val_add, ":num_living_players", multiplayer_battle_formula_value_a),
     (set_fixed_point_multiplier, 100),
     (store_mul, ":num_living_players", ":num_living_players", 100),
     (store_sqrt, ":sqrt_num_living_players", ":num_living_players"),
     (store_div, "$g_battle_waiting_seconds", multiplayer_battle_formula_value_b, ":sqrt_num_living_players"),
     (store_mission_timer_a, "$g_death_mode_part_1_start_time"),
   ]),

  #script_calculate_number_of_targets_destroyed
  # INPUT: none
  # OUTPUT: none

  ("calculate_number_of_targets_destroyed",
   [
     (assign, "$g_number_of_targets_destroyed", 0),
     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_catapult_destructible"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_catapult_destructible", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_get_position, pos1, ":cur_instance_id"),
       (get_sq_distance_between_positions_in_meters, ":dist", pos0, pos1),
       (gt, ":dist", 2), #this can be 0 or 1 too.
       (val_add, "$g_number_of_targets_destroyed", 1),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_trebuchet_destructible"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_trebuchet_destructible", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_get_position, pos1, ":cur_instance_id"),
       (get_sq_distance_between_positions_in_meters, ":dist", pos0, pos1),
       (gt, ":dist", 2), #this can be 0 or 1 too.
       (val_add, "$g_number_of_targets_destroyed", 1),
     (try_end),
     ]),

  #script_initialize_objects
  # INPUT: none
  # OUTPUT: none
  ("initialize_objects",
   [
     (assign, ":number_of_players", 0),
     (get_max_players, ":num_players"),
     (try_for_range, ":player_no", 0, ":num_players"),
       (player_is_active, ":player_no"),
       (val_add, ":number_of_players", 1),
     (try_end),

     #1 player = (Sqrt(1) - 1) * 200 + 1200 = 1200, 1800 (minimum)
     #4 player = (Sqrt(4) - 1) * 200 + 1200 = 1400, 2100
     #9 player = (Sqrt(9) - 1) * 200 + 1200 = 1600, 2400
     #16 player = (Sqrt(16) - 1) * 200 + 1200 = 1800, 2700 (general used)
     #25 player = (Sqrt(25) - 1) * 200 + 1200 = 2000, 3000 (average)
     #36 player = (Sqrt(36) - 1) * 200 + 1200 = 2200, 3300
     #49 player = (Sqrt(49) - 1) * 200 + 1200 = 2400, 3600
     #64 player = (Sqrt(49) - 1) * 200 + 1200 = 2600, 3900

     (set_fixed_point_multiplier, 100),
     (val_mul, ":number_of_players", 100),
     (store_sqrt, ":number_of_players", ":number_of_players"),
     (val_sub, ":number_of_players", 100),
     (val_max, ":number_of_players", 0),
     (store_mul, ":effect_of_number_of_players", ":number_of_players", 2),
     (store_add, ":health_catapult", multi_minimum_target_health, ":effect_of_number_of_players"),
     (store_mul, ":health_trebuchet", ":health_catapult", 15), #trebuchet's health is 1.5x of catapult's
     (val_div, ":health_trebuchet", 10),
     (store_mul, ":health_sally_door", ":health_catapult", 18), #sally door's health is 1.8x of catapult's
     (val_div, ":health_sally_door", 10),
     (store_mul, ":health_sally_door_double", ":health_sally_door", 2),

     (assign, "$g_number_of_targets_destroyed", 0),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_catapult_destructible"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_catapult_destructible", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_catapult"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_trebuchet_destructible"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_trebuchet_destructible", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_trebuchet"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_castle_e_sally_door_a"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_castle_e_sally_door_a", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_castle_f_sally_door_a"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_castle_f_sally_door_a", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_earth_sally_gate_left"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_earth_sally_gate_left", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door_double"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_earth_sally_gate_right"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_earth_sally_gate_right", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door_double"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_viking_keep_destroy_sally_door_left"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_viking_keep_destroy_sally_door_left", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_viking_keep_destroy_sally_door_right"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_viking_keep_destroy_sally_door_right", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door"),
     (try_end),

     (store_div, ":health_sally_door_div_3", ":health_sally_door", 3),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_castle_f_door_a"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_castle_f_door_a", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door_div_3"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_castle_f_door_b"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_castle_f_door_b", ":cur_instance"),
       (prop_instance_get_starting_position, pos0, ":cur_instance_id"),
       (prop_instance_stop_animating, ":cur_instance_id"),
       (prop_instance_set_position, ":cur_instance_id", pos0),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door_div_3"),
     (try_end),
     ]),

  #script_initialize_objects_clients
  # INPUT: none
  # OUTPUT: none
  ("initialize_objects_clients",
   [
     (assign, ":number_of_players", 0),
     (get_max_players, ":num_players"),
     (try_for_range, ":player_no", 0, ":num_players"),
       (player_is_active, ":player_no"),
       (val_add, ":number_of_players", 1),
     (try_end),

     #1 player = (Sqrt(1) - 1) * 200 + 1200 = 1200, 1800 (minimum)
     #4 player = (Sqrt(4) - 1) * 200 + 1200 = 1400, 2100
     #9 player = (Sqrt(9) - 1) * 200 + 1200 = 1600, 2400
     #16 player = (Sqrt(16) - 1) * 200 + 1200 = 1800, 2700 (general used)
     #25 player = (Sqrt(25) - 1) * 200 + 1200 = 2000, 3000 (average)
     #36 player = (Sqrt(36) - 1) * 200 + 1200 = 2200, 3300
     #49 player = (Sqrt(49) - 1) * 200 + 1200 = 2400, 3600
     #64 player = (Sqrt(49) - 1) * 200 + 1200 = 2600, 3900

     (set_fixed_point_multiplier, 100),
     (val_mul, ":number_of_players", 100),
     (store_sqrt, ":number_of_players", ":number_of_players"),
     (val_sub, ":number_of_players", 100),
     (val_max, ":number_of_players", 0),
     (store_mul, ":effect_of_number_of_players", ":number_of_players", 2),
     (store_add, ":health_catapult", multi_minimum_target_health, ":effect_of_number_of_players"),
     (store_mul, ":health_trebuchet", ":health_catapult", 15), #trebuchet's health is 1.5x of catapult's
     (val_div, ":health_trebuchet", 10),
     (store_mul, ":health_sally_door", ":health_catapult", 18), #trebuchet's health is 1.8x of trebuchet's
     (val_div, ":health_sally_door", 10),
     (store_mul, ":health_sally_door_double", ":health_sally_door", 2),

     (assign, "$g_number_of_targets_destroyed", 0),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_catapult_destructible"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_catapult_destructible", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_catapult"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_trebuchet_destructible"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_trebuchet_destructible", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_trebuchet"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_castle_e_sally_door_a"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_castle_e_sally_door_a", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_castle_f_sally_door_a"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_castle_f_sally_door_a", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_earth_sally_gate_left"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_earth_sally_gate_left", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door_double"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_earth_sally_gate_right"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_earth_sally_gate_right", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door_double"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_viking_keep_destroy_sally_door_left"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_viking_keep_destroy_sally_door_left", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_viking_keep_destroy_sally_door_right"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_viking_keep_destroy_sally_door_right", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door"),
     (try_end),

     (store_div, ":health_sally_door_div_3", ":health_sally_door", 3),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_castle_f_door_a"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_castle_f_door_a", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door_div_3"),
     (try_end),

     (scene_prop_get_num_instances, ":num_instances_of_scene_prop", "spr_castle_f_door_b"),
     (try_for_range, ":cur_instance", 0, ":num_instances_of_scene_prop"),
       (scene_prop_get_instance, ":cur_instance_id", "spr_castle_f_door_b", ":cur_instance"),
       (prop_instance_enable_physics, ":cur_instance_id", 1),
       (scene_prop_set_hit_points, ":cur_instance_id", ":health_sally_door_div_3"),
     (try_end),
     ]),

  #script_show_multiplayer_message
  # INPUT: arg1 = multiplayer_message_type
  # OUTPUT: none
  ("show_multiplayer_message",
   [
    (store_script_param, ":multiplayer_message_type", 1),
    (store_script_param, ":value", 2),

    (assign, "$g_multiplayer_message_type", ":multiplayer_message_type"),

    (try_begin),
      (eq, ":multiplayer_message_type", multiplayer_message_type_round_result_in_battle_mode),
      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_1"),

      (try_begin), #end of round in clients
        (neg|multiplayer_is_server),
        (assign, "$g_battle_death_mode_started", 0),
      (try_end),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_auto_team_balance_done),
      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_2"),
      (assign, "$g_team_balance_next_round", 0),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_auto_team_balance_next),
      (assign, "$g_team_balance_next_round", 1),
      (call_script, "script_warn_player_about_auto_team_balance"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_auto_team_balance_no_need),
      (assign, "$g_team_balance_next_round", 0),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_capture_the_flag_score),
      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_flag_returned_home),
      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_capture_the_flag_stole),
      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_poll_result),
      (assign, "$g_multiplayer_message_value_3", ":value"),
      (start_presentation, "prsnt_multiplayer_message_3"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_flag_neutralized),
      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_flag_captured),
      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_flag_is_pulling),
      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_round_draw),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_target_destroyed),

      (try_begin), #destroy score (condition : a target destroyed)
        (eq, "$g_defender_team", 0),
        (assign, ":attacker_team_no", 1),
      (else_try),
        (assign, ":attacker_team_no", 0),
      (try_end),

      (team_get_score, ":team_score", ":attacker_team_no"),
      (val_add, ":team_score", 1),
      (call_script, "script_team_set_score", ":attacker_team_no", ":team_score"), #destroy score end

      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_defenders_saved_n_targets),
      (assign, "$g_multiplayer_message_value_1", ":value"),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":multiplayer_message_type", multiplayer_message_type_attackers_won_the_round),
      (try_begin),
        (eq, "$g_defender_team", 0),
        (assign, "$g_multiplayer_message_value_1", 1),
      (else_try),
        (assign, "$g_multiplayer_message_value_1", 0),
      (try_end),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (try_end),
    ]),

  #script_get_headquarters_scores
  # INPUT: none
  # OUTPUT: reg0 = team_1_num_flags, reg1 = team_2_num_flags
  ("get_headquarters_scores",
   [
     (assign, ":team_1_num_flags", 0),
     (assign, ":team_2_num_flags", 0),
     (try_for_range, ":flag_no", 0, "$g_number_of_flags"),
       (store_add, ":cur_flag_owner_slot", multi_data_flag_owner_begin, ":flag_no"),
       (troop_get_slot, ":cur_flag_owner", "trp_multiplayer_data", ":cur_flag_owner_slot"),
       (neq, ":cur_flag_owner", 0),
       (try_begin),
         (eq, ":cur_flag_owner", 1),
         (val_add, ":team_1_num_flags", 1),
       (else_try),
         (val_add, ":team_2_num_flags", 1),
       (try_end),
     (try_end),
     (assign, reg0, ":team_1_num_flags"),
     (assign, reg1, ":team_2_num_flags"),
     ]),


  #script_draw_this_round
  # INPUT: arg1 = value
  ("draw_this_round",
   [
    (store_script_param, ":value", 1),
    (try_begin),
      (eq, ":value", -9), #destroy mod round end
      (assign, "$g_round_ended", 1),
      (store_mission_timer_a, "$g_round_finish_time"),
      #(assign, "$g_multiplayer_message_value_1", -1),
      #(assign, "$g_multiplayer_message_type", multiplayer_message_type_round_draw),
      #(start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":value", -1), #draw
      (assign, "$g_round_ended", 1),
      (store_mission_timer_a, "$g_round_finish_time"),
      (assign, "$g_multiplayer_message_value_1", -1),
      (assign, "$g_multiplayer_message_type", multiplayer_message_type_round_draw),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":value", 0), #defender wins
      #THIS_IS_OUR_LAND achievement
      (try_begin),
        (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
        (multiplayer_get_my_player, ":my_player_no"),
        (is_between, ":my_player_no", 0, multiplayer_max_possible_player_id),
        (player_get_agent_id, ":my_player_agent", ":my_player_no"),
        (ge, ":my_player_agent", 0),
        (agent_is_alive, ":my_player_agent"),
        (agent_get_team, ":my_player_agent_team_no", ":my_player_agent"),
        (eq, ":my_player_agent_team_no", 0), #defender
        (unlock_achievement, ACHIEVEMENT_THIS_IS_OUR_LAND),
      (try_end),
      #THIS_IS_OUR_LAND achievement end
      (assign, "$g_round_ended", 1),
      (store_mission_timer_a, "$g_round_finish_time"),

      (team_get_faction, ":faction_of_winner_team", 0),
      (team_get_score, ":team_1_score", 0),
      (val_add, ":team_1_score", 1),
      (team_set_score, 0, ":team_1_score"),
      (assign, "$g_winner_team", 0),
      (str_store_faction_name, s1, ":faction_of_winner_team"),

      (assign, "$g_multiplayer_message_value_1", ":value"),
      (try_begin),
        (neq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
        (neq, "$g_multiplayer_game_type", multiplayer_game_type_destroy),
        (assign, "$g_multiplayer_message_type", multiplayer_message_type_round_result_in_siege_mode),
      (else_try),
        (assign, "$g_multiplayer_message_type", multiplayer_message_type_round_result_in_battle_mode),
      (try_end),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (else_try),
      (eq, ":value", 1), #attacker wins
      (assign, "$g_round_ended", 1),
      (store_mission_timer_a, "$g_round_finish_time"),

      (team_get_faction, ":faction_of_winner_team", 1),
      (team_get_score, ":team_2_score", 1),
      (val_add, ":team_2_score", 1),
      (team_set_score, 1, ":team_2_score"),
      (assign, "$g_winner_team", 1),
      (str_store_faction_name, s1, ":faction_of_winner_team"),

      (assign, "$g_multiplayer_message_value_1", ":value"),
      (try_begin),
        (neq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
        (neq, "$g_multiplayer_game_type", multiplayer_game_type_destroy),
        (assign, "$g_multiplayer_message_type", multiplayer_message_type_round_result_in_siege_mode),
      (else_try),
        (assign, "$g_multiplayer_message_type", multiplayer_message_type_round_result_in_battle_mode),
      (try_end),
      (start_presentation, "prsnt_multiplayer_message_1"),
    (try_end),
    #LAST_MAN_STANDING achievement
    (try_begin),
      (is_between, ":value", 0, 2), #defender or attacker wins
      (try_begin),
        (eq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
        (multiplayer_get_my_player, ":my_player_no"),
        (is_between, ":my_player_no", 0, multiplayer_max_possible_player_id),
        (player_get_agent_id, ":my_player_agent", ":my_player_no"),
        (ge, ":my_player_agent", 0),
        (agent_is_alive, ":my_player_agent"),
        (agent_get_team, ":my_player_agent_team_no", ":my_player_agent"),
        (eq, ":my_player_agent_team_no", ":value"), #winner team
        (unlock_achievement, ACHIEVEMENT_LAST_MAN_STANDING),
      (try_end),
    (try_end),
    #LAST_MAN_STANDING achievement end
    ]),

  #script_check_achievement_last_man_standing
  #INPUT: arg1 = value
  ("check_achievement_last_man_standing",
   [
   #LAST_MAN_STANDING achievement
	  (try_begin),
	    (store_script_param, ":value", 1),
		(is_between, ":value", 0, 2), #defender or attacker wins
	    (try_begin),
		  (eq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
		  (multiplayer_get_my_player, ":my_player_no"),
		  (is_between, ":my_player_no", 0, multiplayer_max_possible_player_id),
		  (player_get_agent_id, ":my_player_agent", ":my_player_no"),
		  (ge, ":my_player_agent", 0),
		  (agent_is_alive, ":my_player_agent"),
		  (agent_get_team, ":my_player_agent_team_no", ":my_player_agent"),
		  (eq, ":my_player_agent_team_no", ":value"), #winner team
		  (unlock_achievement, ACHIEVEMENT_LAST_MAN_STANDING),
		(try_end),
	  (try_end),
    #LAST_MAN_STANDING achievement end
    ]),

  #script_find_most_suitable_bot_to_control
  # INPUT: arg1 = value
  ("find_most_suitable_bot_to_control",
   [
      (set_fixed_point_multiplier, 100),
      (store_script_param, ":player_no", 1),
      (player_get_team_no, ":player_team", ":player_no"),

      (player_get_slot, ":x_coor", ":player_no", slot_player_death_pos_x),
      (player_get_slot, ":y_coor", ":player_no", slot_player_death_pos_y),
      (player_get_slot, ":z_coor", ":player_no", slot_player_death_pos_z),

      (init_position, pos0),
      (position_set_x, pos0, ":x_coor"),
      (position_set_y, pos0, ":y_coor"),
      (position_set_z, pos0, ":z_coor"),

      (assign, ":most_suitable_bot", -1),
      (assign, ":max_bot_score", -1),

      (try_for_agents, ":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_is_non_player, ":cur_agent"),
        (agent_get_team ,":cur_team", ":cur_agent"),
        (eq, ":cur_team", ":player_team"),
        (agent_get_position, pos1, ":cur_agent"),

        #getting score for distance of agent to death point (0..3000)
        (get_distance_between_positions_in_meters, ":dist", pos0, pos1),

        (try_begin),
          (lt, ":dist", 500),
          (store_sub, ":bot_score", 500, ":dist"),
        (else_try),
          (assign, ":bot_score", 0),
        (try_end),
        (val_mul, ":bot_score", 6),

        #getting score for distance of agent to enemy & friend agents (0..300 x agents)
        (try_for_agents, ":cur_agent_2"),
          (agent_is_alive, ":cur_agent_2"),
          (agent_is_human, ":cur_agent_2"),
          (neq, ":cur_agent", ":cur_agent_2"),
          (agent_get_team ,":cur_team_2", ":cur_agent_2"),
          (try_begin),
            (neq, ":cur_team_2", ":player_team"),
            (agent_get_position, pos1, ":cur_agent_2"),
            (get_distance_between_positions, ":dist_2", pos0, pos1),
            (try_begin),
              (lt, ":dist_2", 300),
              (assign, ":enemy_near_score", ":dist_2"),
            (else_try),
              (assign, ":enemy_near_score", 300),
            (try_end),
            (val_add, ":bot_score", ":enemy_near_score"),
          (else_try),
            (agent_get_position, pos1, ":cur_agent_2"),
            (get_distance_between_positions, ":dist_2", pos0, pos1),
            (try_begin),
              (lt, ":dist_2", 300),
              (assign, ":friend_near_score", 300, ":dist_2"),
            (else_try),
              (assign, ":friend_near_score", 0),
            (try_end),
            (val_add, ":bot_score", ":friend_near_score"),
          (try_end),
        (try_end),

        #getting score for health (0..200)
        (store_agent_hit_points, ":agent_hit_points", ":cur_agent"),
        (val_mul, ":agent_hit_points", 2),
        (val_add, ":bot_score", ":agent_hit_points"),

        (ge, ":bot_score", ":max_bot_score"),
        (assign, ":max_bot_score", ":bot_score"),
        (assign, ":most_suitable_bot", ":cur_agent"),
      (try_end),

      (assign, reg0, ":most_suitable_bot"),
    ]),

  #script_game_receive_url_response
  #response format should be like this:
  #  [a number or a string]|[another number or a string]|[yet another number or a string] ...
  # here is an example response:
  # 12|Player|100|another string|142|323542|34454|yet another string
  # INPUT: arg1 = num_integers, arg2 = num_strings
  # reg0, reg1, reg2, ... up to 128 registers contain the integer values
  # s0, s1, s2, ... up to 128 strings contain the string values
  ("game_receive_url_response",
    [
      #here is an example usage
##      (store_script_param, ":num_integers", 1),
##      (store_script_param, ":num_strings", 2),
##      (try_begin),
##        (gt, ":num_integers", 4),
##        (display_message, "@{reg0}, {reg1}, {reg2}, {reg3}, {reg4}"),
##      (try_end),
##      (try_begin),
##        (gt, ":num_strings", 4),
##        (display_message, "@{s0}, {s1}, {s2}, {s3}, {s4}"),
##      (try_end),
      ]),

  ("game_get_cheat_mode",
  [
    (assign, reg0, "$cheat_mode"),
  ]),

  #script_game_receive_network_message
  # This script is called from the game engine when a new network message is received.
  # INPUT: arg1 = player_no, arg2 = event_type, arg3 = value, arg4 = value_2, arg5 = value_3, arg6 = value_4
  ("game_receive_network_message",
    [
      (store_script_param, ":player_no", 1),
      (store_script_param, ":event_type", 2),
      (try_begin),
        ###############
        #SERVER EVENTS#
        ###############
        (eq, ":event_type", multiplayer_event_set_item_selection),
        (store_script_param, ":slot_no", 3),
        (store_script_param, ":value", 4),
        (try_begin),
          #valid slot check
          (is_between, ":slot_no", slot_player_selected_item_indices_begin, slot_player_selected_item_indices_end),
          #valid item check
          (assign, ":valid_item", 0),
          (try_begin),
            (eq, ":value", -1),
            (assign, ":valid_item", 1),
          (else_try),
            (ge, ":value", 0),
            (player_get_troop_id, ":player_troop_no", ":player_no"),
            (is_between, ":player_troop_no", multiplayer_troops_begin, multiplayer_troops_end),
            (store_sub, ":troop_index", ":player_troop_no", multiplayer_troops_begin),
            (val_add, ":troop_index", slot_item_multiplayer_availability_linked_list_begin),
            (item_get_slot, ":prev_next_item_ids", ":value", ":troop_index"),
            (gt, ":prev_next_item_ids", 0), #0 if the item is not valid for the multiplayer mode
            (assign, ":valid_item", 1),
            (try_begin),
              (neq, "$g_horses_are_avaliable", 1),
              (item_get_slot, ":item_class", ":value", slot_item_multiplayer_item_class),
              (is_between, ":item_class", multi_item_class_type_horses_begin, multi_item_class_type_horses_end),
              (assign, ":valid_item", 0),
            (try_end),
            (try_begin),
              (eq, "$g_multiplayer_disallow_ranged_weapons", 1),
              (item_get_slot, ":item_class", ":value", slot_item_multiplayer_item_class),
              (is_between, ":item_class", multi_item_class_type_ranged_weapons_begin, multi_item_class_type_ranged_weapons_end),
              (assign, ":valid_item", 0),
            (try_end),
          (try_end),
          (eq, ":valid_item", 1),
          #condition checks are done
          (player_set_slot, ":player_no", ":slot_no", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_set_bot_selection),
        (store_script_param, ":slot_no", 3),
        (store_script_param, ":value", 4),
        (try_begin),
          #condition check
          (is_between, ":slot_no", slot_player_bot_type_1_wanted, slot_player_bot_type_4_wanted + 1),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (player_set_slot, ":player_no", ":slot_no", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_change_team_no),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_get_team_no, ":player_team", ":player_no"),
          (neq, ":player_team", ":value"),

          #condition checks are done
          (try_begin),
            #check if available
            (call_script, "script_cf_multiplayer_team_is_available", ":player_no", ":value"),
            #reset troop_id to -1
            (player_set_troop_id, ":player_no", -1),
            (player_set_team_no, ":player_no", ":value"),
            (try_begin),
              (neq, ":value", multi_team_spectator),
              (neq, ":value", multi_team_unassigned),

              (store_mission_timer_a, ":player_last_team_select_time"),
              (player_set_slot, ":player_no", slot_player_last_team_select_time, ":player_last_team_select_time"),

              (multiplayer_send_message_to_player, ":player_no", multiplayer_event_return_confirmation),
            (try_end),
          (else_try),
            #reject request
            (multiplayer_send_message_to_player, ":player_no", multiplayer_event_return_rejection),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_change_troop_id),
        (store_script_param, ":value", 3),
        #troop-faction validity check
        (try_begin),
          (eq, ":value", -1),
          (player_set_troop_id, ":player_no", -1),
        (else_try),
          (is_between, ":value", multiplayer_troops_begin, multiplayer_troops_end),
          (player_get_team_no, ":player_team", ":player_no"),
          (is_between, ":player_team", 0, multi_team_spectator),
          (team_get_faction, ":team_faction", ":player_team"),
          (store_troop_faction, ":new_troop_faction", ":value"),
          (eq, ":new_troop_faction", ":team_faction"),
          (player_set_troop_id, ":player_no", ":value"),
          (call_script, "script_multiplayer_clear_player_selected_items", ":player_no"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_start_map),
        (store_script_param, ":value", 3),
        (store_script_param, ":value_2", 4),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", multiplayer_scenes_begin, multiplayer_scenes_end),
          (is_between, ":value_2", 0, multiplayer_num_game_types),
          (server_get_changing_game_type_allowed, "$g_multiplayer_changing_game_type_allowed"),
          (this_or_next|eq, "$g_multiplayer_changing_game_type_allowed", 1),
          (eq, "$g_multiplayer_game_type", ":value_2"),
          (call_script, "script_multiplayer_fill_map_game_types", ":value_2"),
          (assign, ":num_maps", reg0),
          (assign, ":is_valid", 0),
          (store_add, ":end_cond", multi_data_maps_for_game_type_begin, ":num_maps"),
          (try_for_range, ":i_map", multi_data_maps_for_game_type_begin, ":end_cond"),
            (troop_slot_eq, "trp_multiplayer_data", ":i_map", ":value"),
            (assign, ":is_valid", 1),
            (assign, ":end_cond", 0),
          (try_end),
          (eq, ":is_valid", 1),
          #condition checks are done
          (assign, "$g_multiplayer_game_type", ":value_2"),
          (assign, "$g_multiplayer_selected_map", ":value"),
          (team_set_faction, 0, "$g_multiplayer_next_team_1_faction"),
          (team_set_faction, 1, "$g_multiplayer_next_team_2_faction"),
          (call_script, "script_game_multiplayer_get_game_type_mission_template", "$g_multiplayer_game_type"),
          (start_multiplayer_mission, reg0, "$g_multiplayer_selected_map", 1),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_max_num_players),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 2, 201),
          #condition checks are done
          (server_set_max_num_players, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_num_bots_in_team),
        (store_script_param, ":value", 3),
        (store_script_param, ":value_2", 4),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 1, 3),
          (is_between, ":value_2", 0, "$g_multiplayer_max_num_bots"),
          #condition checks are done
          (try_begin),
            (eq, ":value", 1),
            (assign, "$g_multiplayer_num_bots_team_1", ":value_2"),
          (else_try),
            (assign, "$g_multiplayer_num_bots_team_2", ":value_2"),
          (try_end),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_2_int_to_player, ":cur_player", multiplayer_event_return_num_bots_in_team, ":value", ":value_2"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_anti_cheat),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (server_set_anti_cheat, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_friendly_fire),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (server_set_friendly_fire, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_melee_friendly_fire),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (server_set_melee_friendly_fire, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_friendly_fire_damage_self_ratio),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 101),
          #condition checks are done
          (server_set_friendly_fire_damage_self_ratio, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_friendly_fire_damage_friend_ratio),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 101),
          #condition checks are done
          (server_set_friendly_fire_damage_friend_ratio, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_ghost_mode),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 4),
          #condition checks are done
          (server_set_ghost_mode, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_control_block_dir),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (server_set_control_block_dir, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_combat_speed),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 5),
          #condition checks are done
          (server_set_combat_speed, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_respawn_count),
        (store_script_param, ":value", 3),
        #validity check
        (player_is_admin, ":player_no"),
        (is_between, ":value", 0, 6),
        #condition checks are done
        (assign, "$g_multiplayer_number_of_respawn_count", ":value"),
        (get_max_players, ":num_players"),
        (try_for_range, ":cur_player", 1, ":num_players"),
          (player_is_active, ":cur_player"),
          (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_respawn_count, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_add_to_servers_list),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          #condition checks are done
          (server_set_add_to_game_servers_list, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_respawn_period),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 3, 31),
          #condition checks are done
          (assign, "$g_multiplayer_respawn_period", ":value"),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_respawn_period, ":value"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_game_max_minutes),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 5, 121),
          #condition checks are done
          (assign, "$g_multiplayer_game_max_minutes", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_round_max_seconds),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 60, 901),
          #condition checks are done
          (assign, "$g_multiplayer_round_max_seconds", ":value"),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_round_max_seconds, ":value"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_player_respawn_as_bot),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (assign, "$g_multiplayer_player_respawn_as_bot", ":value"),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_player_respawn_as_bot, ":value"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_game_max_points),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 3, 1001),
          #condition checks are done
          (assign, "$g_multiplayer_game_max_points", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_point_gained_from_flags),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 25, 401),
          #condition checks are done
          (assign, "$g_multiplayer_point_gained_from_flags", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_point_gained_from_capturing_flag),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 11),
          #condition checks are done
          (assign, "$g_multiplayer_point_gained_from_capturing_flag", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_initial_gold_multiplier),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 1001),
          #condition checks are done
          (assign, "$g_multiplayer_initial_gold_multiplier", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_battle_earnings_multiplier),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 1001),
          #condition checks are done
          (assign, "$g_multiplayer_battle_earnings_multiplier", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_round_earnings_multiplier),
        (store_script_param, ":value", 3),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 1001),
          #condition checks are done
          (assign, "$g_multiplayer_round_earnings_multiplier", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_server_name),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (server_get_renaming_server_allowed, "$g_multiplayer_renaming_server_allowed"),
          (eq, "$g_multiplayer_renaming_server_allowed", 1),
          #condition checks are done
          (server_set_name, s0), #validity is checked inside this function
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_game_password),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          #condition checks are done
          (server_set_password, s0), #validity is checked inside this function
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_welcome_message),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          #condition checks are done
          (server_set_welcome_message, s0), #validity is checked inside this function
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_team_faction),
        (store_script_param, ":value", 3),
        (store_script_param, ":value_2", 4),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 1, 3),
          (is_between, ":value_2", npc_kingdoms_begin, npc_kingdoms_end),
##          (assign, ":is_valid", 0),
##          (try_begin),
##            (eq, ":value", 1),
##            (neq, ":value_2", "$g_multiplayer_next_team_2_faction"),
##            (assign, ":is_valid", 1),
##          (else_try),
##            (neq, ":value_2", "$g_multiplayer_next_team_1_faction"),
##            (assign, ":is_valid", 1),
##          (try_end),
##          (eq, ":is_valid", 1),
          #condition checks are done
          (try_begin),
            (eq, ":value", 1),
            (assign, "$g_multiplayer_next_team_1_faction", ":value_2"),
          (else_try),
            (assign, "$g_multiplayer_next_team_2_faction", ":value_2"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_open_game_rules),
        (try_begin),
          #no validity check
          (server_get_max_num_players, ":max_num_players"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_max_num_players, ":max_num_players"),
          (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_next_team_faction, 1, "$g_multiplayer_next_team_1_faction"),
          (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_next_team_faction, 2, "$g_multiplayer_next_team_2_faction"),
          (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_num_bots_in_team, 1, "$g_multiplayer_num_bots_team_1"),
          (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_num_bots_in_team, 2, "$g_multiplayer_num_bots_team_2"),
          (server_get_anti_cheat, ":server_anti_cheat"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_anti_cheat, ":server_anti_cheat"),
          (server_get_friendly_fire, ":server_friendly_fire"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_friendly_fire, ":server_friendly_fire"),
          (server_get_melee_friendly_fire, ":server_melee_friendly_fire"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_melee_friendly_fire, ":server_melee_friendly_fire"),
          (server_get_friendly_fire_damage_self_ratio, ":friendly_fire_damage_self_ratio"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_friendly_fire_damage_self_ratio, ":friendly_fire_damage_self_ratio"),
          (server_get_friendly_fire_damage_friend_ratio, ":friendly_fire_damage_friend_ratio"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_friendly_fire_damage_friend_ratio, ":friendly_fire_damage_friend_ratio"),
          (server_get_ghost_mode, ":server_ghost_mode"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_ghost_mode, ":server_ghost_mode"),
          (server_get_control_block_dir, ":server_control_block_dir"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_control_block_dir, ":server_control_block_dir"),
          (server_get_combat_speed, ":server_combat_speed"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_combat_speed, ":server_combat_speed"),
          (server_get_add_to_game_servers_list, ":server_add_to_servers_list"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_add_to_servers_list, ":server_add_to_servers_list"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_respawn_period, "$g_multiplayer_respawn_period"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_game_max_minutes, "$g_multiplayer_game_max_minutes"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_round_max_seconds, "$g_multiplayer_round_max_seconds"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_player_respawn_as_bot, "$g_multiplayer_player_respawn_as_bot"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_game_max_points, "$g_multiplayer_game_max_points"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_point_gained_from_flags, "$g_multiplayer_point_gained_from_flags"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_point_gained_from_capturing_flag, "$g_multiplayer_point_gained_from_capturing_flag"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_initial_gold_multiplier, "$g_multiplayer_initial_gold_multiplier"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_battle_earnings_multiplier, "$g_multiplayer_battle_earnings_multiplier"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_round_earnings_multiplier, "$g_multiplayer_round_earnings_multiplier"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_valid_vote_ratio, "$g_multiplayer_valid_vote_ratio"),
          (str_store_server_name, s0),
          (multiplayer_send_string_to_player, ":player_no", multiplayer_event_return_server_name, s0),
          (multiplayer_send_message_to_player, ":player_no", multiplayer_event_return_open_game_rules),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_open_admin_panel),
        (try_begin),
          #validity check
          (player_is_admin, ":player_no"),
          #condition checks are done
          (server_get_renaming_server_allowed, "$g_multiplayer_renaming_server_allowed"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_renaming_server_allowed, "$g_multiplayer_renaming_server_allowed"),
          (server_get_changing_game_type_allowed, "$g_multiplayer_changing_game_type_allowed"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_changing_game_type_allowed, "$g_multiplayer_changing_game_type_allowed"),
          (server_get_max_num_players, ":max_num_players"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_max_num_players, ":max_num_players"),
          (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_next_team_faction, 1, "$g_multiplayer_next_team_1_faction"),
          (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_next_team_faction, 2, "$g_multiplayer_next_team_2_faction"),
          (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_num_bots_in_team, 1, "$g_multiplayer_num_bots_team_1"),
          (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_num_bots_in_team, 2, "$g_multiplayer_num_bots_team_2"),
          (server_get_anti_cheat, ":server_anti_cheat"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_anti_cheat, ":server_anti_cheat"),
          (server_get_friendly_fire, ":server_friendly_fire"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_friendly_fire, ":server_friendly_fire"),
          (server_get_melee_friendly_fire, ":server_melee_friendly_fire"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_melee_friendly_fire, ":server_melee_friendly_fire"),
          (server_get_friendly_fire_damage_self_ratio, ":friendly_fire_damage_self_ratio"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_friendly_fire_damage_self_ratio, ":friendly_fire_damage_self_ratio"),
          (server_get_friendly_fire_damage_friend_ratio, ":friendly_fire_damage_friend_ratio"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_friendly_fire_damage_friend_ratio, ":friendly_fire_damage_friend_ratio"),
          (server_get_ghost_mode, ":server_ghost_mode"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_ghost_mode, ":server_ghost_mode"),
          (server_get_control_block_dir, ":server_control_block_dir"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_control_block_dir, ":server_control_block_dir"),
          (server_get_combat_speed, ":server_combat_speed"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_combat_speed, ":server_combat_speed"),
          (server_get_add_to_game_servers_list, ":server_add_to_servers_list"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_add_to_servers_list, ":server_add_to_servers_list"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_respawn_period, "$g_multiplayer_respawn_period"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_game_max_minutes, "$g_multiplayer_game_max_minutes"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_round_max_seconds, "$g_multiplayer_round_max_seconds"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_player_respawn_as_bot, "$g_multiplayer_player_respawn_as_bot"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_game_max_points, "$g_multiplayer_game_max_points"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_point_gained_from_flags, "$g_multiplayer_point_gained_from_flags"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_point_gained_from_capturing_flag, "$g_multiplayer_point_gained_from_capturing_flag"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_initial_gold_multiplier, "$g_multiplayer_initial_gold_multiplier"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_battle_earnings_multiplier, "$g_multiplayer_battle_earnings_multiplier"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_round_earnings_multiplier, "$g_multiplayer_round_earnings_multiplier"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_valid_vote_ratio, "$g_multiplayer_valid_vote_ratio"),
          (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_max_num_bots, "$g_multiplayer_max_num_bots"),
          (str_store_server_name, s0),
          (multiplayer_send_string_to_player, ":player_no", multiplayer_event_return_server_name, s0),
          (str_store_server_password, s0),
          (multiplayer_send_string_to_player, ":player_no", multiplayer_event_return_game_password, s0),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_start_new_poll),
        (try_begin),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
           #validity check
          (eq, "$g_multiplayer_poll_running", 0),
          (store_mission_timer_a, ":mission_timer"),
          (player_get_slot, ":poll_disable_time", ":player_no", slot_player_poll_disabled_until_time),
          (ge, ":mission_timer", ":poll_disable_time"),
          (assign, ":continue", 0),
          (try_begin),
            (eq, ":value", 1), # kicking a player
            (try_begin),
              (eq, "$g_multiplayer_kick_voteable", 1),
              (player_is_active, ":value_2"),
              (assign, ":continue", 1),
            (try_end),
          (else_try),
            (eq, ":value", 2), # banning a player
            (try_begin),
              (eq, "$g_multiplayer_ban_voteable", 1),
              (player_is_active, ":value_2"),
              (save_ban_info_of_player, ":value_2"),
              (assign, ":continue", 1),
            (try_end),
          (else_try), # vote for map
            (eq, ":value", 0),
            (try_begin),
              (eq, "$g_multiplayer_maps_voteable", 1),
              (call_script, "script_multiplayer_fill_map_game_types", "$g_multiplayer_game_type"),
              (assign, ":num_maps", reg0),
              (try_for_range, ":i_map", 0, ":num_maps"),
                (store_add, ":map_slot", ":i_map", multi_data_maps_for_game_type_begin),
                (troop_slot_eq, "trp_multiplayer_data", ":map_slot", ":value_2"),
                (assign, ":continue", 1),
                (assign, ":num_maps", 0), #break
              (try_end),
            (try_end),
          (else_try),
            (eq, ":value", 3), #vote for map and factions
            (try_begin),
              (eq, "$g_multiplayer_factions_voteable", 1),
              (store_script_param, ":value_3", 5),
              (store_script_param, ":value_4", 6),
              (call_script, "script_multiplayer_fill_map_game_types", "$g_multiplayer_game_type"),
              (assign, ":num_maps", reg0),
              (try_for_range, ":i_map", 0, ":num_maps"),
                (store_add, ":map_slot", ":i_map", multi_data_maps_for_game_type_begin),
                (troop_slot_eq, "trp_multiplayer_data", ":map_slot", ":value_2"),
                (assign, ":continue", 1),
                (assign, ":num_maps", 0), #break
              (try_end),
              (try_begin),
                (eq, ":continue", 1),
                (this_or_next|neg|is_between, ":value_3", npc_kingdoms_begin, npc_kingdoms_end),
                (this_or_next|neg|is_between, ":value_4", npc_kingdoms_begin, npc_kingdoms_end),
                (eq, ":value_3", ":value_4"),
                (assign, ":continue", 0),
              (try_end),
            (try_end),
          (else_try),
            (eq, ":value", 4), #vote for number of bots
            (store_script_param, ":value_3", 5),
            (store_add, ":upper_limit", "$g_multiplayer_num_bots_voteable", 1),
            (is_between, ":value_2", 0, ":upper_limit"),
            (is_between, ":value_3", 0, ":upper_limit"),
            (assign, ":continue", 1),
          (try_end),
          (eq, ":continue", 1),
          #condition checks are done
          (str_store_player_username, s0, ":player_no"),
          (try_begin),
            (eq, ":value", 1), #kicking a player
            (str_store_player_username, s1, ":value_2"),
            (server_add_message_to_log, "str_poll_kick_player_s1_by_s0"),
          (else_try),
            (eq, ":value", 2), #banning a player
            (str_store_player_username, s1, ":value_2"),
            (server_add_message_to_log, "str_poll_ban_player_s1_by_s0"),
          (else_try),
            (eq, ":value", 0), #vote for map
            (store_sub, ":string_index", ":value_2", multiplayer_scenes_begin),
            (val_add, ":string_index", multiplayer_scene_names_begin),
            (str_store_string, s1, ":string_index"),
            (server_add_message_to_log, "str_poll_change_map_to_s1_by_s0"),
          (else_try),
            (eq, ":value", 3), #vote for map and factions
            (store_sub, ":string_index", ":value_2", multiplayer_scenes_begin),
            (val_add, ":string_index", multiplayer_scene_names_begin),
            (str_store_string, s1, ":string_index"),
            (str_store_faction_name, s2, ":value_3"),
            (str_store_faction_name, s3, ":value_4"),
            (server_add_message_to_log, "str_poll_change_map_to_s1_and_factions_to_s2_and_s3_by_s0"),
          (else_try),
            (eq, ":value", 4), #vote for number of bots
            (assign, reg0, ":value_2"),
            (assign, reg1, ":value_3"),
            (server_add_message_to_log, "str_poll_change_number_of_bots_to_reg0_and_reg1_by_s0"),
          (try_end),
          (assign, "$g_multiplayer_poll_running", 1),
          (assign, "$g_multiplayer_poll_ended", 0),
          (assign, "$g_multiplayer_poll_num_sent", 0),
          (assign, "$g_multiplayer_poll_yes_count", 0),
          (assign, "$g_multiplayer_poll_no_count", 0),
          (assign, "$g_multiplayer_poll_to_show", ":value"),
          (assign, "$g_multiplayer_poll_value_to_show", ":value_2"),
          (try_begin),
            (eq, ":value", 3),
            (assign, "$g_multiplayer_poll_value_2_to_show", ":value_3"),
            (assign, "$g_multiplayer_poll_value_3_to_show", ":value_4"),
          (else_try),
            (eq, ":value", 4),
            (assign, "$g_multiplayer_poll_value_2_to_show", ":value_3"),
            (assign, "$g_multiplayer_poll_value_3_to_show", -1),
          (else_try),
            (assign, "$g_multiplayer_poll_value_2_to_show", -1),
            (assign, "$g_multiplayer_poll_value_3_to_show", -1),
          (try_end),
          (store_add, ":poll_disable_until", ":mission_timer", multiplayer_poll_disable_period),
          (player_set_slot, ":player_no", slot_player_poll_disabled_until_time, ":poll_disable_until"),
          (store_add, "$g_multiplayer_poll_end_time", ":mission_timer", 60),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 0, ":num_players"),
            (player_is_active, ":cur_player"),
            (player_set_slot, ":cur_player", slot_player_can_answer_poll, 1),
            (val_add, "$g_multiplayer_poll_num_sent", 1),
            (multiplayer_send_4_int_to_player, ":cur_player", multiplayer_event_ask_for_poll, "$g_multiplayer_poll_to_show", "$g_multiplayer_poll_value_to_show", "$g_multiplayer_poll_value_2_to_show", "$g_multiplayer_poll_value_3_to_show"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_answer_to_poll),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (eq, "$g_multiplayer_poll_running", 1),
          (is_between, ":value", 0, 2),
          (player_slot_eq, ":player_no", slot_player_can_answer_poll, 1),
          #condition checks are done
          (player_set_slot, ":player_no", slot_player_can_answer_poll, 0),
          (try_begin),
            (eq, ":value", 0),
            (val_add, "$g_multiplayer_poll_no_count", 1),
          (else_try),
            (eq, ":value", 1),
            (val_add, "$g_multiplayer_poll_yes_count", 1),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_kick_player),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (player_is_active, ":value"),
          #condition checks are done
          (kick_player, ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_ban_player),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (player_is_active, ":value"),
          #condition checks are done
          (ban_player, ":value", 0, ":player_no"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_valid_vote_ratio),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 50, 101),
          #condition checks are done
          (assign, "$g_multiplayer_valid_vote_ratio", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_auto_team_balance_limit),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (this_or_next|is_between, ":value", 2, 7),
          (eq, ":value", 1000),
          #condition checks are done
          (assign, "$g_multiplayer_auto_team_balance_limit", ":value"),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_auto_team_balance_limit, ":value"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_num_bots_voteable),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 51),
          (is_between, ":value", 0, "$g_multiplayer_max_num_bots"),
          #condition checks are done
          (assign, "$g_multiplayer_num_bots_voteable", ":value"),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_num_bots_voteable, ":value"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_factions_voteable),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (assign, "$g_multiplayer_factions_voteable", ":value"),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_factions_voteable, ":value"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_maps_voteable),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (assign, "$g_multiplayer_maps_voteable", ":value"),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_maps_voteable, ":value"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_kick_voteable),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (assign, "$g_multiplayer_kick_voteable", ":value"),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_kick_voteable, ":value"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_ban_voteable),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (assign, "$g_multiplayer_ban_voteable", ":value"),
          (get_max_players, ":num_players"),
          (try_for_range, ":cur_player", 1, ":num_players"),
            (player_is_active, ":cur_player"),
            (multiplayer_send_int_to_player, ":cur_player", multiplayer_event_return_ban_voteable, ":value"),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_allow_player_banners),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (assign, "$g_multiplayer_allow_player_banners", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_force_default_armor),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (assign, "$g_multiplayer_force_default_armor", ":value"),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_offer_duel),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (eq, "$g_multiplayer_game_type", multiplayer_game_type_duel),
          (agent_is_active, ":value"),
          (agent_is_alive, ":value"),
          (agent_is_human, ":value"),
          (player_get_agent_id, ":player_agent_no", ":player_no"),
          (agent_is_active, ":player_agent_no"),
          (agent_is_alive, ":player_agent_no"),
          (agent_get_position, pos0, ":player_agent_no"),
          (agent_get_position, pos1, ":value"),
          (get_sq_distance_between_positions_in_meters, ":agent_dist_sq", pos0, pos1),
          (le, ":agent_dist_sq", 49),
          #allow duelists to receive new offers
          (this_or_next|agent_check_offer_from_agent, ":player_agent_no", ":value"),
          (agent_slot_eq, ":player_agent_no", slot_agent_in_duel_with, -1),
          (neg|agent_slot_eq, ":player_agent_no", slot_agent_in_duel_with, ":value"), #don't allow spamming duel offers during countdown
          #condition checks are done
          (try_begin),
            #accepting a duel
            (agent_check_offer_from_agent, ":player_agent_no", ":value"),
            (call_script, "script_multiplayer_accept_duel", ":player_agent_no", ":value"),
          (else_try),
            #sending a duel request
            (assign, ":display_notification", 1),
            (try_begin),
              (agent_check_offer_from_agent, ":value", ":player_agent_no"),
              (assign, ":display_notification", 0),
            (try_end),
            (agent_add_offer_with_timeout, ":value", ":player_agent_no", 10000), #10 second timeout
            (agent_get_player_id, ":value_player", ":value"),
            (try_begin),
              (player_is_active, ":value_player"), #might be AI
              (try_begin),
                (eq, ":display_notification", 1),
                (multiplayer_send_int_to_player, ":value_player", multiplayer_event_show_duel_request, ":player_agent_no"),
              (try_end),
            (else_try),
              (call_script, "script_multiplayer_accept_duel", ":value", ":player_agent_no"),
            (try_end),
          (try_end),
        (try_end),
      (else_try),
        (eq, ":event_type", multiplayer_event_admin_set_disallow_ranged_weapons),
        (try_begin),
          (store_script_param, ":value", 3),
          #validity check
          (player_is_admin, ":player_no"),
          (is_between, ":value", 0, 2),
          #condition checks are done
          (assign, "$g_multiplayer_disallow_ranged_weapons", ":value"),
        (try_end),
      (else_try),
        ###############
        #CLIENT EVENTS#
        ###############
        (neg|multiplayer_is_dedicated_server),
        (try_begin),
          (eq, ":event_type", multiplayer_event_return_renaming_server_allowed),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_renaming_server_allowed", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_changing_game_type_allowed),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_changing_game_type_allowed", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_max_num_players),
          (store_script_param, ":value", 3),
          (server_set_max_num_players, ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_next_team_faction),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
          (try_begin),
            (eq, ":value", 1),
            (assign, "$g_multiplayer_next_team_1_faction", ":value_2"),
          (else_try),
            (assign, "$g_multiplayer_next_team_2_faction", ":value_2"),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_num_bots_in_team),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
          (try_begin),
            (eq, ":value", 1),
            (assign, "$g_multiplayer_num_bots_team_1", ":value_2"),
          (else_try),
            (assign, "$g_multiplayer_num_bots_team_2", ":value_2"),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_anti_cheat),
          (store_script_param, ":value", 3),
          (server_set_anti_cheat, ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_friendly_fire),
          (store_script_param, ":value", 3),
          (server_set_friendly_fire, ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_melee_friendly_fire),
          (store_script_param, ":value", 3),
          (server_set_melee_friendly_fire, ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_friendly_fire_damage_self_ratio),
          (store_script_param, ":value", 3),
          (server_set_friendly_fire_damage_self_ratio, ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_friendly_fire_damage_friend_ratio),
          (store_script_param, ":value", 3),
          (server_set_friendly_fire_damage_friend_ratio, ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_ghost_mode),
          (store_script_param, ":value", 3),
          (server_set_ghost_mode, ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_control_block_dir),
          (store_script_param, ":value", 3),
          (server_set_control_block_dir, ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_add_to_servers_list),
          (store_script_param, ":value", 3),
          (server_set_add_to_game_servers_list, ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_respawn_period),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_respawn_period", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_game_max_minutes),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_game_max_minutes", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_round_max_seconds),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_round_max_seconds", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_player_respawn_as_bot),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_player_respawn_as_bot", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_game_max_points),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_game_max_points", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_point_gained_from_flags),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_point_gained_from_flags", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_point_gained_from_capturing_flag),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_point_gained_from_capturing_flag", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_initial_gold_multiplier),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_initial_gold_multiplier", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_battle_earnings_multiplier),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_battle_earnings_multiplier", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_round_earnings_multiplier),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_round_earnings_multiplier", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_respawn_count),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_number_of_respawn_count", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_server_name),
          (server_set_name, s0),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_game_password),
          (server_set_password, s0),
          #this is the last option in admin panel, so start the presentation
          (start_presentation, "prsnt_game_multiplayer_admin_panel"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_open_game_rules),
          #this is the last message for game rules, so start the presentation
          (assign, "$g_multiplayer_show_server_rules", 1),
          (start_presentation, "prsnt_multiplayer_welcome_message"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_game_type),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_game_type", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_valid_vote_ratio),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_valid_vote_ratio", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_max_num_bots),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_max_num_bots", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_server_mission_timer_while_player_joined),
          (store_script_param, ":value", 3),
          (assign, "$server_mission_timer_while_player_joined", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_auto_team_balance_limit),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_auto_team_balance_limit", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_num_bots_voteable),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_num_bots_voteable", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_factions_voteable),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_factions_voteable", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_maps_voteable),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_maps_voteable", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_kick_voteable),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_kick_voteable", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_ban_voteable),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_ban_voteable", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_allow_player_banners),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_allow_player_banners", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_force_default_armor),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_force_default_armor", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_disallow_ranged_weapons),
          (store_script_param, ":value", 3),
          (assign, "$g_multiplayer_disallow_ranged_weapons", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_confirmation),
          (assign, "$g_confirmation_result", 1),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_rejection),
          (assign, "$g_confirmation_result", -1),
        (else_try),
          (eq, ":event_type", multiplayer_event_show_multiplayer_message),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
          (call_script, "script_show_multiplayer_message", ":value", ":value_2"),
        (else_try),
          (eq, ":event_type", multiplayer_event_draw_this_round),
          (store_script_param, ":value", 3),
          (call_script, "script_draw_this_round", ":value"),
        (else_try),
          (eq, ":event_type", multiplayer_event_set_attached_scene_prop),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
          (call_script, "script_set_attached_scene_prop", ":value", ":value_2"),
          (try_begin),
            (eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
            (try_begin),
              (neq, ":value_2", -1),
              (agent_set_horse_speed_factor, ":value", 75),
            (else_try),
              (agent_set_horse_speed_factor, ":value", 100),
            (try_end),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_set_team_flag_situation),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
          (call_script, "script_set_team_flag_situation", ":value", ":value_2"),
        (else_try),
          (eq, ":event_type", multiplayer_event_set_team_score),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
          (call_script, "script_team_set_score", ":value", ":value_2"),
        (else_try),
          (eq, ":event_type", multiplayer_event_set_player_score_kill_death),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
          (store_script_param, ":value_3", 5),
          (store_script_param, ":value_4", 6),
          (call_script, "script_player_set_score", ":value", ":value_2"),
          (call_script, "script_player_set_kill_count", ":value", ":value_3"),
          (call_script, "script_player_set_death_count", ":value", ":value_4"),
        (else_try),
          (eq, ":event_type", multiplayer_event_set_num_agents_around_flag),
          (store_script_param, ":flag_no", 3),
          (store_script_param, ":current_owner_code", 4),
          (call_script, "script_set_num_agents_around_flag", ":flag_no", ":current_owner_code"),
        (else_try),
          (eq, ":event_type", multiplayer_event_ask_for_poll),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
          (store_script_param, ":value_3", 5),
          (store_script_param, ":value_4", 6),
          (assign, ":continue_to_poll", 0),
          (try_begin),
            (this_or_next|eq, ":value", 1),
            (eq, ":value", 2),
            (player_is_active, ":value_2"), #might go offline before here
            (assign, ":continue_to_poll", 1),
          (else_try),
            (assign, ":continue_to_poll", 1),
          (try_end),
          (try_begin),
            (eq, ":continue_to_poll", 1),
            (assign, "$g_multiplayer_poll_to_show", ":value"),
            (assign, "$g_multiplayer_poll_value_to_show", ":value_2"),
            (assign, "$g_multiplayer_poll_value_2_to_show", ":value_3"),
            (assign, "$g_multiplayer_poll_value_3_to_show", ":value_4"),
            (store_mission_timer_a, ":mission_timer"),
            (store_add, "$g_multiplayer_poll_client_end_time", ":mission_timer", 60),
            (start_presentation, "prsnt_multiplayer_poll"),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_change_flag_owner),
          (store_script_param, ":flag_no", 3),
          (store_script_param, ":owner_code", 4),
          (call_script, "script_change_flag_owner", ":flag_no", ":owner_code"),
        (else_try),
          (eq, ":event_type", multiplayer_event_use_item),
          (store_script_param, ":value", 3),
          (store_script_param, ":value_2", 4),
          (call_script, "script_use_item", ":value", ":value_2"),
        (else_try),
          (eq, ":event_type", multiplayer_event_set_scene_prop_open_or_close),
          (store_script_param, ":instance_id", 3),

          (scene_prop_set_slot, ":instance_id", scene_prop_open_or_close_slot, 1),

          (prop_instance_get_scene_prop_kind, ":scene_prop_id", ":instance_id"),

          (try_begin),
            (eq, ":scene_prop_id", "spr_winch_b"),
            (assign, ":effected_object", "spr_portcullis"),
          (else_try),
            (this_or_next|eq, ":scene_prop_id", "spr_castle_e_sally_door_a"),
            (this_or_next|eq, ":scene_prop_id", "spr_castle_f_sally_door_a"),
            (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),
            (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_right"),
            (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),
            (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_right"),
            (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_a"),
            (this_or_next|eq, ":scene_prop_id", "spr_door_destructible"),
            (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_b"),
            (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_6m"),
            (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_8m"),
            (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_10m"),
            (this_or_next|eq, ":scene_prop_id", "spr_siege_ladder_move_12m"),
            (eq, ":scene_prop_id", "spr_siege_ladder_move_14m"),
            (assign, ":effected_object", ":scene_prop_id"),
          (try_end),

          (try_begin),
            (eq, ":effected_object", "spr_portcullis"),

            (assign, ":smallest_dist", -1),
            (prop_instance_get_position, pos0, ":instance_id"),
            (scene_prop_get_num_instances, ":num_instances_of_effected_object", ":effected_object"),
            (try_for_range, ":cur_instance", 0, ":num_instances_of_effected_object"),
              (scene_prop_get_instance, ":cur_instance_id", ":effected_object", ":cur_instance"),
              (prop_instance_get_position, pos1, ":cur_instance_id"),
              (get_sq_distance_between_positions, ":dist", pos0, pos1),
              (this_or_next|eq, ":smallest_dist", -1),
              (lt, ":dist", ":smallest_dist"),
              (assign, ":smallest_dist", ":dist"),
              (assign, ":effected_object_instance_id", ":cur_instance_id"),
            (try_end),

            (ge, ":smallest_dist", 0),
            (prop_instance_is_animating, ":is_animating", ":effected_object_instance_id"),
            (eq, ":is_animating", 0),

            (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),
            (position_move_z, pos0, 375),
            (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 1),
          (else_try),
            (this_or_next|eq, ":scene_prop_id", "spr_castle_e_sally_door_a"),
            (this_or_next|eq, ":scene_prop_id", "spr_castle_f_sally_door_a"),
            (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_left"),
            (this_or_next|eq, ":scene_prop_id", "spr_earth_sally_gate_right"),
            (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_left"),
            (this_or_next|eq, ":scene_prop_id", "spr_viking_keep_destroy_sally_door_right"),
            (this_or_next|eq, ":scene_prop_id", "spr_castle_f_door_a"),
            (this_or_next|eq, ":scene_prop_id", "spr_door_destructible"),
            (eq, ":scene_prop_id", "spr_castle_f_door_b"),
            (assign, ":effected_object_instance_id", ":instance_id"),
            (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),
            (position_rotate_z, pos0, -80),
            (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 1),
          (else_try),
            (assign, ":effected_object_instance_id", ":instance_id"),
            (prop_instance_is_animating, ":is_animating", ":effected_object_instance_id"),
            (eq, ":is_animating", 0),
            (prop_instance_get_starting_position, pos0, ":effected_object_instance_id"),
            (prop_instance_animate_to_position, ":effected_object_instance_id", pos0, 1),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_set_round_start_time),
          (store_script_param, ":value", 3),

          (try_begin),
            (neq, ":value", -9999),
            (assign, "$g_round_start_time", ":value"),
          (else_try),
            (store_mission_timer_a, "$g_round_start_time"),

            #if round start time is assigning to current time (so new round is starting) then also initialize moveable object slots too.
            (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_6m"),
            (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_8m"),
            (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_10m"),
            (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_12m"),
            (call_script, "script_initialize_scene_prop_slots", "spr_siege_ladder_move_14m"),
            (call_script, "script_initialize_scene_prop_slots", "spr_winch_b"),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_force_start_team_selection),
          (try_begin),
            (is_presentation_active, "prsnt_multiplayer_item_select"),
            (assign, "$g_close_equipment_selection", 1),
          (try_end),
          (start_presentation, "prsnt_multiplayer_troop_select"),
        (else_try),
          (eq, ":event_type", multiplayer_event_start_death_mode),
          (assign, "$g_battle_death_mode_started", 2),
          (start_presentation, "prsnt_multiplayer_flag_projection_display_bt"),
          (call_script, "script_start_death_mode"),
        (else_try),
          (eq, ":event_type", multiplayer_event_return_player_respawn_spent),
          (store_script_param, ":value", 3),
          (try_begin),
            (gt, "$g_my_spawn_count", 0),
            (store_add, "$g_my_spawn_count", "$g_my_spawn_count", ":value"),
          (else_try),
            (assign, "$g_my_spawn_count", ":value"),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_show_duel_request),
          (store_script_param, ":value", 3),
          (try_begin),
            (agent_is_active, ":value"),
            (agent_get_player_id, ":value_player_no", ":value"),
            (try_begin),
              (player_is_active, ":value_player_no"),
              (str_store_player_username, s0, ":value_player_no"),
            (else_try),
              (str_store_agent_name, s0, ":value"),
            (try_end),
            (display_message, "str_s0_offers_a_duel_with_you"),
            (try_begin),
              (get_player_agent_no, ":player_agent"),
              (agent_is_active, ":player_agent"),
              (agent_add_offer_with_timeout, ":player_agent", ":value", 10000), #10 second timeout
            (try_end),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_start_duel),
          (store_script_param, ":value", 3),
          (store_mission_timer_a, ":mission_timer"),
          (try_begin),
            (agent_is_active, ":value"),
            (get_player_agent_no, ":player_agent"),
            (agent_is_active, ":player_agent"),
            (agent_get_player_id, ":value_player_no", ":value"),
            (try_begin),
              (player_is_active, ":value_player_no"),
              (str_store_player_username, s0, ":value_player_no"),
            (else_try),
              (str_store_agent_name, s0, ":value"),
            (try_end),
            (display_message, "str_a_duel_between_you_and_s0_will_start_in_3_seconds"),
            (assign, "$g_multiplayer_duel_start_time", ":mission_timer"),
            (start_presentation, "prsnt_multiplayer_duel_start_counter"),
            (agent_set_slot, ":player_agent", slot_agent_in_duel_with, ":value"),
            (agent_set_slot, ":value", slot_agent_in_duel_with, ":player_agent"),
            (agent_set_slot, ":player_agent", slot_agent_duel_start_time, ":mission_timer"),
            (agent_set_slot, ":value", slot_agent_duel_start_time, ":mission_timer"),
            (agent_clear_relations_with_agents, ":player_agent"),
            (agent_clear_relations_with_agents, ":value"),
##            (agent_add_relation_with_agent, ":player_agent", ":value", -1),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_cancel_duel),
          (store_script_param, ":value", 3),
          (try_begin),
            (agent_is_active, ":value"),
            (agent_get_player_id, ":value_player_no", ":value"),
            (try_begin),
              (player_is_active, ":value_player_no"),
              (str_store_player_username, s0, ":value_player_no"),
            (else_try),
              (str_store_agent_name, s0, ":value"),
            (try_end),
            (display_message, "str_your_duel_with_s0_is_cancelled"),
          (try_end),
          (try_begin),
            (get_player_agent_no, ":player_agent"),
            (agent_is_active, ":player_agent"),
            (agent_set_slot, ":player_agent", slot_agent_in_duel_with, -1),
            (agent_clear_relations_with_agents, ":player_agent"),
          (try_end),
        (else_try),
          (eq, ":event_type", multiplayer_event_show_server_message),
          (display_message, "str_server_s0", 0xFFFF6666),
        (try_end),
      (try_end),
     ]),

  # script_cf_multiplayer_evaluate_poll
  # Input: none
  # Output: none (can fail)
  ("cf_multiplayer_evaluate_poll",
   [
     (assign, ":result", 0),
     (assign, "$g_multiplayer_poll_ended", 1),
     (store_add, ":total_votes", "$g_multiplayer_poll_yes_count", "$g_multiplayer_poll_no_count"),
     (store_sub, ":abstain_votes", "$g_multiplayer_poll_num_sent", ":total_votes"),
     (store_mul, ":nos_from_abstains", 3, ":abstain_votes"),
     (val_div, ":nos_from_abstains", 10), #30% of abstains are counted as no
     (val_add, ":total_votes", ":nos_from_abstains"),
     (val_max, ":total_votes", 1), #if someone votes and only 1-3 abstain occurs?
     (store_mul, ":vote_ratio", 100, "$g_multiplayer_poll_yes_count"),
     (val_div, ":vote_ratio", ":total_votes"),
     (try_begin),
       (ge, ":vote_ratio", "$g_multiplayer_valid_vote_ratio"),
       (assign, ":result", 1),
       (try_begin),
         (eq, "$g_multiplayer_poll_to_show", 1), #kick player
         (try_begin),
           (player_is_active, "$g_multiplayer_poll_value_to_show"),
           (kick_player, "$g_multiplayer_poll_value_to_show"),
         (try_end),
       (else_try),
         (eq, "$g_multiplayer_poll_to_show", 2), #ban player
         (ban_player_using_saved_ban_info), #already loaded at the beginning of the poll
       (else_try),
         (eq, "$g_multiplayer_poll_to_show", 3), #change map with factions
         (team_set_faction, 0, "$g_multiplayer_poll_value_2_to_show"),
         (team_set_faction, 1, "$g_multiplayer_poll_value_3_to_show"),
       (else_try),
         (eq, "$g_multiplayer_poll_to_show", 4), #change number of bots
         (assign, "$g_multiplayer_num_bots_team_1", "$g_multiplayer_poll_value_to_show"),
         (assign, "$g_multiplayer_num_bots_team_2", "$g_multiplayer_poll_value_2_to_show"),
         (get_max_players, ":num_players"),
         (try_for_range, ":cur_player", 1, ":num_players"),
           (player_is_active, ":cur_player"),
           (multiplayer_send_2_int_to_player, ":cur_player", multiplayer_event_return_num_bots_in_team, 1, "$g_multiplayer_num_bots_team_1"),
           (multiplayer_send_2_int_to_player, ":cur_player", multiplayer_event_return_num_bots_in_team, 2, "$g_multiplayer_num_bots_team_2"),
         (try_end),
       (try_end),
     (else_try),
       (assign, "$g_multiplayer_poll_running", 0), #end immediately if poll fails. but end after some time if poll succeeds (apply the results first)
     (try_end),
     (get_max_players, ":num_players"),
     #for only server itself-----------------------------------------------------------------------------------------------
     (call_script, "script_show_multiplayer_message", multiplayer_message_type_poll_result, ":result"), #0 is useless here
     #for only server itself-----------------------------------------------------------------------------------------------
     (try_for_range, ":cur_player", 1, ":num_players"),
       (player_is_active, ":cur_player"),
       (multiplayer_send_2_int_to_player, ":cur_player", multiplayer_event_show_multiplayer_message, multiplayer_message_type_poll_result, ":result"),
     (try_end),
     (eq, ":result", 1),
     ]),

  # script_multiplayer_accept_duel
  # Input: arg1 = agent_no, arg2 = agent_no_offerer
  # Output: none
  ("multiplayer_accept_duel",
   [
     (store_script_param, ":agent_no", 1),
     (store_script_param, ":agent_no_offerer", 2),
     (try_begin),
       (agent_slot_ge, ":agent_no", slot_agent_in_duel_with, 0),
       (agent_get_slot, ":ex_duelist", ":agent_no", slot_agent_in_duel_with),
       (agent_is_active, ":ex_duelist"),
       (agent_clear_relations_with_agents, ":ex_duelist"),
       (agent_set_slot, ":ex_duelist", slot_agent_in_duel_with, -1),
       (agent_get_player_id, ":player_no", ":ex_duelist"),
       (try_begin),
         (player_is_active, ":player_no"), #might be AI
         (multiplayer_send_int_to_player, ":player_no", multiplayer_event_cancel_duel, ":agent_no"),
       (else_try),
         (agent_force_rethink, ":ex_duelist"),
       (try_end),
     (try_end),
     (try_begin),
       (agent_slot_ge, ":agent_no_offerer", slot_agent_in_duel_with, 0),
       (agent_get_slot, ":ex_duelist", ":agent_no_offerer", slot_agent_in_duel_with),
       (agent_is_active, ":ex_duelist"),
       (agent_clear_relations_with_agents, ":ex_duelist"),
       (agent_set_slot, ":ex_duelist", slot_agent_in_duel_with, -1),
       (try_begin),
         (player_is_active, ":player_no"), #might be AI
         (multiplayer_send_int_to_player, ":player_no", multiplayer_event_cancel_duel, ":agent_no_offerer"),
       (else_try),
         (agent_force_rethink, ":ex_duelist"),
       (try_end),
     (try_end),
     (agent_set_slot, ":agent_no", slot_agent_in_duel_with, ":agent_no_offerer"),
     (agent_set_slot, ":agent_no_offerer", slot_agent_in_duel_with, ":agent_no"),
     (agent_clear_relations_with_agents, ":agent_no"),
     (agent_clear_relations_with_agents, ":agent_no_offerer"),
##     (agent_add_relation_with_agent, ":agent_no", ":agent_no_offerer", -1),
##     (agent_add_relation_with_agent, ":agent_no_offerer", ":agent_no", -1),
     (agent_get_player_id, ":player_no", ":agent_no"),
     (store_mission_timer_a, ":mission_timer"),
     (try_begin),
       (player_is_active, ":player_no"), #might be AI
       (multiplayer_send_int_to_player, ":player_no", multiplayer_event_start_duel, ":agent_no_offerer"),
     (else_try),
       (agent_force_rethink, ":agent_no"),
     (try_end),
     (agent_set_slot, ":agent_no", slot_agent_duel_start_time, ":mission_timer"),
     (agent_get_player_id, ":agent_no_offerer_player", ":agent_no_offerer"),
     (try_begin),
       (player_is_active, ":agent_no_offerer_player"), #might be AI
       (multiplayer_send_int_to_player, ":agent_no_offerer_player", multiplayer_event_start_duel, ":agent_no"),
     (else_try),
       (agent_force_rethink, ":agent_no_offerer"),
     (try_end),
     (agent_set_slot, ":agent_no_offerer", slot_agent_duel_start_time, ":mission_timer"),
     ]),

  # script_game_get_multiplayer_server_option_for_mission_template
  # Input: arg1 = mission_template_id, arg2 = option_index
  # Output: trigger_result = 1 for option available, 0 for not available
  # reg0 = option_value
  ("game_get_multiplayer_server_option_for_mission_template",
   [
     (store_script_param, ":mission_template_id", 1),
     (store_script_param, ":option_index", 2),
     (try_begin),
       (eq, ":option_index", 0),
       (assign, reg0, "$g_multiplayer_team_1_faction"),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 1),
       (assign, reg0, "$g_multiplayer_team_2_faction"),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 2),
       (assign, reg0, "$g_multiplayer_num_bots_team_1"),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 3),
       (assign, reg0, "$g_multiplayer_num_bots_team_2"),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 4),
       (server_get_friendly_fire, reg0),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 5),
       (server_get_melee_friendly_fire, reg0),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 6),
       (server_get_friendly_fire_damage_self_ratio, reg0),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 7),
       (server_get_friendly_fire_damage_friend_ratio, reg0),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 8),
       (server_get_ghost_mode, reg0),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 9),
       (server_get_control_block_dir, reg0),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 10),
       (server_get_combat_speed, reg0),
       (set_trigger_result, 1),
     (else_try),
       (try_begin),
         (eq, ":mission_template_id", "mt_multiplayer_hq"),
         (val_add, ":option_index", 1), #max game time
       (try_end),
       (eq, ":option_index", 11),
       (assign, reg0, "$g_multiplayer_game_max_minutes"),
       (set_trigger_result, 1),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_bt"),
         (neq, ":mission_template_id", "mt_multiplayer_fd"),
         (neq, ":mission_template_id", "mt_multiplayer_sg"),
         (val_add, ":option_index", 1), #max round time
       (try_end),
       (eq, ":option_index", 12),
       (assign, reg0, "$g_multiplayer_round_max_seconds"),
       (set_trigger_result, 1),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_bt"),
         (neq, ":mission_template_id", "mt_multiplayer_fd"),
         (val_add, ":option_index", 1), #respawn as bot
       (try_end),
       (eq, ":option_index", 13),
       (assign, reg0, "$g_multiplayer_player_respawn_as_bot"),
       (set_trigger_result, 1),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_sg"),
         (val_add, ":option_index", 1), #respawn limit
       (try_end),
       (eq, ":option_index", 14),
       (assign, reg0, "$g_multiplayer_number_of_respawn_count"),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 15),
       (assign, reg0, "$g_multiplayer_game_max_points"),
       (set_trigger_result, 1),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_hq"),
         (val_add, ":option_index", 1), #point gained from flags
       (try_end),
       (eq, ":option_index", 16),
       (assign, reg0, "$g_multiplayer_point_gained_from_flags"),
       (set_trigger_result, 1),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_cf"),
         (val_add, ":option_index", 1), #point gained from capturing flag
       (try_end),
       (eq, ":option_index", 17),
       (assign, reg0, "$g_multiplayer_point_gained_from_capturing_flag"),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 18),
       (assign, reg0, "$g_multiplayer_respawn_period"),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 19),
       (assign, reg0, "$g_multiplayer_initial_gold_multiplier"),
       (set_trigger_result, 1),
     (else_try),
       (eq, ":option_index", 20),
       (assign, reg0, "$g_multiplayer_battle_earnings_multiplier"),
       (set_trigger_result, 1),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_bt"),
         (neq, ":mission_template_id", "mt_multiplayer_fd"),
         (neq, ":mission_template_id", "mt_multiplayer_sg"),
         (val_add, ":option_index", 1),
       (try_end),
       (eq, ":option_index", 21),
       (assign, reg0, "$g_multiplayer_round_earnings_multiplier"),
       (set_trigger_result, 1),
     (try_end),
     ]),

  # script_game_multiplayer_server_option_for_mission_template_to_string
  # Input: arg1 = mission_template_id, arg2 = option_index, arg3 = option_value
  # Output: s0 = option_text
  ("game_multiplayer_server_option_for_mission_template_to_string",
   [
     (store_script_param, ":mission_template_id", 1),
     (store_script_param, ":option_index", 2),
     (store_script_param, ":option_value", 3),
     (str_clear, s0),
     (try_begin),
       (eq, ":option_index", 0),
       (assign, reg1, 1),
       (str_store_string, s0, "str_team_reg1_faction"),
       (str_store_faction_name, s1, ":option_value"),
       (str_store_string, s0, "str_s0_s1"),
     (else_try),
       (eq, ":option_index", 1),
       (assign, reg1, 2),
       (str_store_string, s0, "str_team_reg1_faction"),
       (str_store_faction_name, s1, ":option_value"),
       (str_store_string, s0, "str_s0_s1"),
     (else_try),
       (eq, ":option_index", 2),
       (assign, reg1, 1),
       (str_store_string, s0, "str_number_of_bots_in_team_reg1"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (eq, ":option_index", 3),
       (assign, reg1, 2),
       (str_store_string, s0, "str_number_of_bots_in_team_reg1"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (eq, ":option_index", 4),
       (str_store_string, s0, "str_allow_friendly_fire"),
       (try_begin),
         (eq, ":option_value", 0),
         (str_store_string, s1, "str_no_wo_dot"),
       (else_try),
         (str_store_string, s1, "str_yes_wo_dot"),
       (try_end),
       (str_store_string, s0, "str_s0_s1"),
     (else_try),
       (eq, ":option_index", 5),
       (str_store_string, s0, "str_allow_melee_friendly_fire"),
       (try_begin),
         (eq, ":option_value", 0),
         (str_store_string, s1, "str_no_wo_dot"),
       (else_try),
         (str_store_string, s1, "str_yes_wo_dot"),
       (try_end),
       (str_store_string, s0, "str_s0_s1"),
     (else_try),
       (eq, ":option_index", 6),
       (str_store_string, s0, "str_friendly_fire_damage_self_ratio"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (eq, ":option_index", 7),
       (str_store_string, s0, "str_friendly_fire_damage_friend_ratio"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (eq, ":option_index", 8),
       (str_store_string, s0, "str_spectator_camera"),
       (try_begin),
         (eq, ":option_value", 0),
         (str_store_string, s1, "str_free"),
       (else_try),
         (eq, ":option_value", 1),
         (str_store_string, s1, "str_stick_to_any_player"),
       (else_try),
         (eq, ":option_value", 2),
         (str_store_string, s1, "str_stick_to_team_members"),
       (else_try),
         (str_store_string, s1, "str_stick_to_team_members_view"),
       (try_end),
       (str_store_string, s0, "str_s0_s1"),
     (else_try),
       (eq, ":option_index", 9),
       (str_store_string, s0, "str_control_block_direction"),
       (try_begin),
         (eq, ":option_value", 0),
         (str_store_string, s1, "str_automatic"),
       (else_try),
         (str_store_string, s1, "str_by_mouse_movement"),
       (try_end),
       (str_store_string, s0, "str_s0_s1"),
     (else_try),
       (eq, ":option_index", 10),
       (str_store_string, s0, "str_combat_speed"),
       (try_begin),
         (eq, ":option_value", 0),
         (str_store_string, s1, "str_combat_speed_0"),
       (else_try),
         (eq, ":option_value", 1),
         (str_store_string, s1, "str_combat_speed_1"),
       (else_try),
         (eq, ":option_value", 2),
         (str_store_string, s1, "str_combat_speed_2"),
       (else_try),
         (eq, ":option_value", 3),
         (str_store_string, s1, "str_combat_speed_3"),
       (else_try),
         (str_store_string, s1, "str_combat_speed_4"),
       (try_end),
       (str_store_string, s0, "str_s0_s1"),
     (else_try),
       (try_begin),
         (eq, ":mission_template_id", "mt_multiplayer_hq"),
         (val_add, ":option_index", 1), #max game time
       (try_end),
       (eq, ":option_index", 11),
       (str_store_string, s0, "str_map_time_limit"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_bt"),
         (neq, ":mission_template_id", "mt_multiplayer_fd"),
         (neq, ":mission_template_id", "mt_multiplayer_sg"),
         (val_add, ":option_index", 1), #max round time
       (try_end),
       (eq, ":option_index", 12),
       (str_store_string, s0, "str_round_time_limit"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_bt"),
         (neq, ":mission_template_id", "mt_multiplayer_fd"),
         (val_add, ":option_index", 1), #respawn as bot
       (try_end),
       (eq, ":option_index", 13),
       (str_store_string, s0, "str_players_take_control_of_a_bot_after_death"),
       (try_begin),
         (eq, ":option_value", 0),
         (str_store_string, s1, "str_no_wo_dot"),
       (else_try),
         (str_store_string, s1, "str_yes_wo_dot"),
       (try_end),
       (str_store_string, s0, "str_s0_s1"),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_sg"),
         (val_add, ":option_index", 1), #respawn limit
       (try_end),
       (eq, ":option_index", 14),
       (str_store_string, s0, "str_defender_spawn_count_limit"),
       (try_begin),
         (eq, ":option_value", 0),
         (str_store_string, s1, "str_unlimited"),
       (else_try),
         (assign, reg1, ":option_value"),
         (str_store_string, s1, "str_reg1"),
       (try_end),
       (str_store_string, s0, "str_s0_s1"),
     (else_try),
       (eq, ":option_index", 15),
       (str_store_string, s0, "str_team_points_limit"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_hq"),
         (val_add, ":option_index", 1), #point gained from flags
       (try_end),
       (eq, ":option_index", 16),
       (str_store_string, s0, "str_point_gained_from_flags"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_cf"),
         (val_add, ":option_index", 1), #point gained from capturing flag
       (try_end),
       (eq, ":option_index", 17),
       (str_store_string, s0, "str_point_gained_from_capturing_flag"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (eq, ":option_index", 18),
       (str_store_string, s0, "str_respawn_period"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (eq, ":option_index", 19),
       (str_store_string, s0, "str_initial_gold_multiplier"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (eq, ":option_index", 20),
       (str_store_string, s0, "str_battle_earnings_multiplier"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (else_try),
       (try_begin),
         (neq, ":mission_template_id", "mt_multiplayer_bt"),
         (neq, ":mission_template_id", "mt_multiplayer_fd"),
         (neq, ":mission_template_id", "mt_multiplayer_sg"),
         (val_add, ":option_index", 1),
       (try_end),
       (eq, ":option_index", 21),
       (str_store_string, s0, "str_round_earnings_multiplier"),
       (assign, reg0, ":option_value"),
       (str_store_string, s0, "str_s0_reg0"),
     (try_end),
     ]),

  # script_cf_multiplayer_team_is_available
  # Input: arg1 = player_no, arg2 = team_no
  # Output: none, true or false
  ("cf_multiplayer_team_is_available",
   [
     (store_script_param, ":player_no", 1),
     (store_script_param, ":team_no", 2),
     (assign, ":continue_change_team", 1),
     (try_begin),
       (neq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch),
       (neq, "$g_multiplayer_game_type", multiplayer_game_type_duel),
       (is_between, ":team_no", 0, multi_team_spectator),
       (neg|teams_are_enemies, ":team_no", ":team_no"), #checking if it is a deathmatch or not
       (assign, ":continue_change_team", 0),
       #counting number of players for team balance checks
       (assign, ":number_of_players_at_team_1", 0),
       (assign, ":number_of_players_at_team_2", 0),
       (get_max_players, ":num_players"),
       (try_for_range, ":cur_player", 0, ":num_players"),
         (player_is_active, ":cur_player"),
         (neq, ":cur_player", ":player_no"),
         (player_get_team_no, ":player_team", ":cur_player"),
         (try_begin),
           (eq, ":player_team", 0),
           (val_add, ":number_of_players_at_team_1", 1),
         (else_try),
           (eq, ":player_team", 1),
           (val_add, ":number_of_players_at_team_2", 1),
         (try_end),
       (try_end),
       (store_sub, ":difference_of_number_of_players", ":number_of_players_at_team_1", ":number_of_players_at_team_2"),

       (try_begin),
         (ge, ":difference_of_number_of_players", 0),
         (val_add, ":difference_of_number_of_players", 1),
       (else_try),
         (val_add, ":difference_of_number_of_players", -1),
       (try_end),

       (try_begin),
         (eq, ":team_no", 0),
         (lt, ":difference_of_number_of_players", "$g_multiplayer_auto_team_balance_limit"),
         (assign, ":continue_change_team", 1),
       (else_try),
         (eq, ":team_no", 1),
         (store_mul, ":checked_value", "$g_multiplayer_auto_team_balance_limit", -1),
         (gt, ":difference_of_number_of_players", ":checked_value"),
         (assign, ":continue_change_team", 1),
       (try_end),
     (try_end),
     (eq, ":continue_change_team", 1),
     ]),

  # script_find_number_of_agents_constant
  # Input: none
  # Output: reg0 = 100xconstant (100..500)
  ("find_number_of_agents_constant",
   [
     (assign, ":num_dead_or_alive_agents", 0),

     (try_for_agents, ":cur_agent"),
       (agent_is_human, ":cur_agent"),
       (val_add, ":num_dead_or_alive_agents", 1),
     (try_end),

     (try_begin),
       (le, ":num_dead_or_alive_agents", 2), #2
       (assign, reg0, 100),
     (else_try),
       (le, ":num_dead_or_alive_agents", 4), #2+2
       (assign, reg0, 140),
     (else_try),
       (le, ":num_dead_or_alive_agents", 7), #2+2+3
       (assign, reg0, 180),
     (else_try),
       (le, ":num_dead_or_alive_agents", 11), #2+2+3+4
       (assign, reg0, 220),
     (else_try),
       (le, ":num_dead_or_alive_agents", 17), #2+2+3+4+6
       (assign, reg0, 260),
     (else_try),
       (le, ":num_dead_or_alive_agents", 25), #2+2+3+4+6+8
       (assign, reg0, 300),
     (else_try),
       (le, ":num_dead_or_alive_agents", 36), #2+2+3+4+6+8+11
       (assign, reg0, 340),
     (else_try),
       (le, ":num_dead_or_alive_agents", 50), #2+2+3+4+6+8+11+14
       (assign, reg0, 380),
     (else_try),
       (le, ":num_dead_or_alive_agents", 68), #2+2+3+4+6+8+11+14+18
       (assign, reg0, 420),
     (else_try),
       (le, ":num_dead_or_alive_agents", 91), #2+2+3+4+6+8+11+14+18+23
       (assign, reg0, 460),
     (else_try),
       (assign, reg0, 500),
     (try_end),
     ]),

  # script_game_multiplayer_event_duel_offered
  # Input: arg1 = agent_no
  # Output: none
  ("game_multiplayer_event_duel_offered",
   [
     (store_script_param, ":agent_no", 1),
     (get_player_agent_no, ":player_agent_no"),
     (try_begin),
       (agent_is_active, ":player_agent_no"),
       (this_or_next|agent_slot_eq, ":player_agent_no", slot_agent_in_duel_with, -1),
       (agent_check_offer_from_agent, ":player_agent_no", ":agent_no"),
       (neg|agent_slot_eq, ":player_agent_no", slot_agent_in_duel_with, ":agent_no"), #don't allow spamming duel offers during countdown
       (multiplayer_send_int_to_server, multiplayer_event_offer_duel, ":agent_no"),
       (agent_get_player_id, ":player_no", ":agent_no"),
       (try_begin),
         (player_is_active, ":player_no"),
         (str_store_player_username, s0, ":player_no"),
       (else_try),
         (str_store_agent_name, s0, ":agent_no"),
       (try_end),
       (display_message, "str_a_duel_request_is_sent_to_s0"),
     (try_end),
     ]),

  # script_game_get_multiplayer_game_type_enum
  # Input: none
  # Output: reg0:first type, reg1:type count
  ("game_get_multiplayer_game_type_enum",
   [
     (assign, reg0, multiplayer_game_type_deathmatch),
	 (assign, reg1, multiplayer_num_game_types),
	 ]),

  # script_game_multiplayer_get_game_type_mission_template
  # Input: arg1 = game_type
  # Output: mission_template
  ("game_multiplayer_get_game_type_mission_template",
   [
     (assign, ":selected_mt", -1),
     (store_script_param, ":game_type", 1),
     (try_begin),
       (eq, ":game_type", multiplayer_game_type_deathmatch),
       (assign, ":selected_mt", "mt_multiplayer_dm"),
     (else_try),
       (eq, ":game_type", multiplayer_game_type_team_deathmatch),
       (assign, ":selected_mt", "mt_multiplayer_tdm"),
     (else_try),
       (eq, ":game_type", multiplayer_game_type_battle),
       (assign, ":selected_mt", "mt_multiplayer_bt"),
     (else_try),
       (eq, ":game_type", multiplayer_game_type_destroy),
       (assign, ":selected_mt", "mt_multiplayer_fd"),
     (else_try),
       (eq, ":game_type", multiplayer_game_type_capture_the_flag),
       (assign, ":selected_mt", "mt_multiplayer_cf"),
     (else_try),
       (eq, ":game_type", multiplayer_game_type_headquarters),
       (assign, ":selected_mt", "mt_multiplayer_hq"),
     (else_try),
       (eq, ":game_type", multiplayer_game_type_siege),
       (assign, ":selected_mt", "mt_multiplayer_sg"),
     (else_try),
       (eq, ":game_type", multiplayer_game_type_duel),
       (assign, ":selected_mt", "mt_multiplayer_duel"),
     (try_end),
     (assign, reg0, ":selected_mt"),
     ]),

  # script_multiplayer_get_mission_template_game_type
  # Input: arg1 = mission_template_no
  # Output: game_type
  ("multiplayer_get_mission_template_game_type",
   [
     (store_script_param, ":mission_template_no", 1),
     (assign, ":game_type", -1),
     (try_begin),
       (eq, ":mission_template_no", "mt_multiplayer_dm"),
       (assign, ":game_type", multiplayer_game_type_deathmatch),
     (else_try),
       (eq, ":mission_template_no", "mt_multiplayer_tdm"),
       (assign, ":game_type", multiplayer_game_type_team_deathmatch),
     (else_try),
       (eq, ":mission_template_no", "mt_multiplayer_bt"),
       (assign, ":game_type", multiplayer_game_type_battle),
     (else_try),
       (eq, ":mission_template_no", "mt_multiplayer_fd"),
       (assign, ":game_type", multiplayer_game_type_destroy),
     (else_try),
       (eq, ":mission_template_no", "mt_multiplayer_cf"),
       (assign, ":game_type", multiplayer_game_type_capture_the_flag),
     (else_try),
       (eq, ":mission_template_no", "mt_multiplayer_hq"),
       (assign, ":game_type", multiplayer_game_type_headquarters),
     (else_try),
       (eq, ":mission_template_no", "mt_multiplayer_sg"),
       (assign, ":game_type", multiplayer_game_type_siege),
     (else_try),
       (eq, ":mission_template_no", "mt_multiplayer_duel"),
       (assign, ":game_type", multiplayer_game_type_duel),
     (try_end),
     (assign, reg0, ":game_type"),
     ]),


  # script_multiplayer_fill_available_factions_combo_button
  # Input: arg1 = overlay_id, arg2 = selected_faction_no, arg3 = opposite_team_selected_faction_no
  # Output: none
  ("multiplayer_fill_available_factions_combo_button",
   [
     (store_script_param, ":overlay_id", 1),
     (store_script_param, ":selected_faction_no", 2),
##     (store_script_param, ":opposite_team_selected_faction_no", 3),
##     (try_for_range, ":cur_faction", "fac_kingdom_1", "fac_kingdoms_end"),
##       (try_begin),
##         (eq, ":opposite_team_selected_faction_no", ":cur_faction"),
##         (try_begin),
##           (gt, ":selected_faction_no", ":opposite_team_selected_faction_no"),
##           (val_sub, ":selected_faction_no", 1),
##         (try_end),
##       (else_try),
##         (str_store_faction_name, s0, ":cur_faction"),
##         (overlay_add_item, ":overlay_id", s0),
##       (try_end),
##     (try_end),
##     (val_sub, ":selected_faction_no", "fac_kingdom_1"),
##     (overlay_set_val, ":overlay_id", ":selected_faction_no"),
     (try_for_range, ":cur_faction", npc_kingdoms_begin, npc_kingdoms_end),
       (str_store_faction_name, s0, ":cur_faction"),
       (overlay_add_item, ":overlay_id", s0),
     (try_end),
     (val_sub, ":selected_faction_no", "fac_kingdom_1"),
     (overlay_set_val, ":overlay_id", ":selected_faction_no"),
     ]),


  # script_multiplayer_get_troop_class
  # Input: arg1 = troop_no
  # Output: reg0: troop_class
  ("multiplayer_get_troop_class",
   [
     (store_script_param_1, ":troop_no"),
     (assign, ":troop_class", multi_troop_class_other),
     (try_begin),
       (this_or_next|eq, ":troop_no", "trp_vaegir_archer_multiplayer"),
       (this_or_next|eq, ":troop_no", "trp_nord_archer_multiplayer"),
       (eq, ":troop_no", "trp_sarranid_archer_multiplayer"),
       (assign, ":troop_class", multi_troop_class_archer),
     (else_try),
       (this_or_next|eq, ":troop_no", "trp_swadian_man_at_arms_multiplayer"),
       (this_or_next|eq, ":troop_no", "trp_nord_scout_multiplayer"),
       (this_or_next|eq, ":troop_no", "trp_rhodok_horseman_multiplayer"),
       (this_or_next|eq, ":troop_no", "trp_sarranid_mamluke_multiplayer"),
       (eq, ":troop_no", "trp_vaegir_horseman_multiplayer"),
       (assign, ":troop_class", multi_troop_class_cavalry),
     (else_try),
       (eq, ":troop_no", "trp_khergit_veteran_horse_archer_multiplayer"),
       (assign, ":troop_class", multi_troop_class_mounted_archer),
#     (else_try),
#       (eq, ":troop_no", "trp_swadian_mounted_crossbowman_multiplayer"),
#       (assign, ":troop_class", multi_troop_class_mounted_crossbowman),
     (else_try),
       (this_or_next|eq, ":troop_no", "trp_swadian_crossbowman_multiplayer"),
       (eq, ":troop_no", "trp_rhodok_veteran_crossbowman_multiplayer"),
       (assign, ":troop_class", multi_troop_class_crossbowman),
     (else_try),
       (this_or_next|eq, ":troop_no", "trp_swadian_infantry_multiplayer"),
       (this_or_next|eq, ":troop_no", "trp_sarranid_footman_multiplayer"),
       (eq, ":troop_no", "trp_nord_veteran_multiplayer"),
       (assign, ":troop_class", multi_troop_class_infantry),
     (else_try),
       (eq, ":troop_no", "trp_vaegir_spearman_multiplayer"),
       (assign, ":troop_class", multi_troop_class_spearman),
     (try_end),
     (assign, reg0, ":troop_class"),
     ]),

  #script_multiplayer_clear_player_selected_items
  # Input: arg1 = player_no
  # Output: none
  ("multiplayer_clear_player_selected_items",
   [
     (store_script_param, ":player_no", 1),
     (try_for_range, ":slot_no", slot_player_selected_item_indices_begin, slot_player_selected_item_indices_end),
       (player_set_slot, ":player_no", ":slot_no", -1),
     (try_end),
     ]),


  #script_multiplayer_init_player_slots
  # Input: arg1 = player_no
  # Output: none
  ("multiplayer_init_player_slots",
   [
     (store_script_param, ":player_no", 1),
     (call_script, "script_multiplayer_clear_player_selected_items", ":player_no"),
     (player_set_slot, ":player_no", slot_player_spawned_this_round, 0),
     (player_set_slot, ":player_no", slot_player_last_rounds_used_item_earnings, 0),
     (player_set_slot, ":player_no", slot_player_poll_disabled_until_time, 0),

     (player_set_slot, ":player_no", slot_player_bot_type_1_wanted, 0),
     (player_set_slot, ":player_no", slot_player_bot_type_2_wanted, 0),
     (player_set_slot, ":player_no", slot_player_bot_type_3_wanted, 0),
     (player_set_slot, ":player_no", slot_player_bot_type_4_wanted, 0),
     ]),

  #script_multiplayer_initialize_belfry_wheel_rotations
  # Input: none
  # Output: none
  ("multiplayer_initialize_belfry_wheel_rotations",
   [
##    (scene_prop_get_num_instances, ":num_belfries", "spr_belfry_a"),
##    (try_for_range, ":belfry_no", 0, ":num_belfries"),
##      (store_mul, ":wheel_no", ":belfry_no", 3),
##      (scene_prop_get_instance, ":belfry_wheel_1_scene_prop_id", "spr_belfry_wheel", ":wheel_no"),
##      (prop_instance_initialize_rotation_angles, ":belfry_wheel_1_scene_prop_id"),
##      #belfry wheel_2
##      (val_add, ":wheel_no", 1),
##      (scene_prop_get_instance, ":belfry_wheel_2_scene_prop_id", "spr_belfry_wheel", ":wheel_no"),
##      (prop_instance_initialize_rotation_angles, ":belfry_wheel_2_scene_prop_id"),
##      #belfry wheel_3
##      (val_add, ":wheel_no", 1),
##      (scene_prop_get_instance, ":belfry_wheel_3_scene_prop_id", "spr_belfry_wheel", ":wheel_no"),
##      (prop_instance_initialize_rotation_angles, ":belfry_wheel_3_scene_prop_id"),
##    (try_end),
##
##    (scene_prop_get_num_instances, ":num_belfries_a", "spr_belfry_a"),
##
##    (scene_prop_get_num_instances, ":num_belfries", "spr_belfry_b"),
##    (try_for_range, ":belfry_no", 0, ":num_belfries"),
##      (store_add, ":wheel_no_plus_num_belfries_a", ":wheel_no", ":num_belfries_a"),
##      (store_mul, ":wheel_no_plus_num_belfries_a", ":belfry_no", 3),
##      (scene_prop_get_instance, ":belfry_wheel_1_scene_prop_id", "spr_belfry_wheel", ":wheel_no_plus_num_belfries_a"),
##      (prop_instance_initialize_rotation_angles, ":belfry_wheel_1_scene_prop_id"),
##      #belfry wheel_2
##      (val_add, ":wheel_no_plus_num_belfries_a", 1),
##      (scene_prop_get_instance, ":belfry_wheel_2_scene_prop_id", "spr_belfry_wheel", ":wheel_no_plus_num_belfries_a"),
##      (prop_instance_initialize_rotation_angles, ":belfry_wheel_2_scene_prop_id"),
##      #belfry wheel_3
##      (val_add, ":wheel_no_plus_num_belfries_a", 1),
##      (scene_prop_get_instance, ":belfry_wheel_3_scene_prop_id", "spr_belfry_wheel", ":wheel_no_plus_num_belfries_a"),
##      (prop_instance_initialize_rotation_angles, ":belfry_wheel_3_scene_prop_id"),
##    (try_end),

      (scene_prop_get_num_instances, ":num_wheel", "spr_belfry_wheel"),
      (try_for_range, ":wheel_no", 0, ":num_wheel"),
        (scene_prop_get_instance, ":wheel_id", "spr_belfry_wheel", ":wheel_no"),
        (prop_instance_initialize_rotation_angles, ":wheel_id"),
      (try_end),

      (scene_prop_get_num_instances, ":num_winch", "spr_winch"),
      (try_for_range, ":winch_no", 0, ":num_winch"),
        (scene_prop_get_instance, ":winch_id", "spr_winch", ":winch_no"),
        (prop_instance_initialize_rotation_angles, ":winch_id"),
      (try_end),

      (scene_prop_get_num_instances, ":num_winch_b", "spr_winch_b"),
      (try_for_range, ":winch_b_no", 0, ":num_winch_b"),
        (scene_prop_get_instance, ":winch_b_id", "spr_winch_b", ":winch_b_no"),
        (prop_instance_initialize_rotation_angles, ":winch_b_id"),
      (try_end),
     ]),

  #script_send_open_close_information_of_object
  # Input: arg1 = mission_object_id
  # Output: none
  ("send_open_close_information_of_object",
   [
     (store_script_param, ":player_no", 1),
     (store_script_param, ":scene_prop_no", 2),

     (scene_prop_get_num_instances, ":num_instances", ":scene_prop_no"),

     (try_for_range, ":instance_no", 0, ":num_instances"),
       (scene_prop_get_instance, ":instance_id", ":scene_prop_no", ":instance_no"),
       (scene_prop_get_slot, ":opened_or_closed", ":instance_id", scene_prop_open_or_close_slot),
       (try_begin),
         (eq, ":opened_or_closed", 1),
         (multiplayer_send_int_to_player, ":player_no", multiplayer_event_set_scene_prop_open_or_close, ":instance_id"),
       (try_end),
     (try_end),
     ]),

  #script_multiplayer_send_initial_information
  # Input: arg1 = player_no
  # Output: none
  ("multiplayer_send_initial_information",
   [
     (store_script_param, ":player_no", 1),

     (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_num_bots_in_team, 1, "$g_multiplayer_num_bots_team_1"),
     (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_return_num_bots_in_team, 2, "$g_multiplayer_num_bots_team_2"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_auto_team_balance_limit, "$g_multiplayer_auto_team_balance_limit"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_num_bots_voteable, "$g_multiplayer_num_bots_voteable"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_factions_voteable, "$g_multiplayer_factions_voteable"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_maps_voteable, "$g_multiplayer_maps_voteable"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_kick_voteable, "$g_multiplayer_kick_voteable"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_ban_voteable, "$g_multiplayer_ban_voteable"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_allow_player_banners, "$g_multiplayer_allow_player_banners"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_force_default_armor, "$g_multiplayer_force_default_armor"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_disallow_ranged_weapons, "$g_multiplayer_disallow_ranged_weapons"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_respawn_period, "$g_multiplayer_respawn_period"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_round_max_seconds, "$g_multiplayer_round_max_seconds"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_game_type, "$g_multiplayer_game_type"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_player_respawn_as_bot, "$g_multiplayer_player_respawn_as_bot"),

     (store_mission_timer_a, ":mission_timer"),
     (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_server_mission_timer_while_player_joined, ":mission_timer"),

     (try_begin),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
       (multiplayer_send_int_to_player, ":player_no", multiplayer_event_return_respawn_count, "$g_multiplayer_number_of_respawn_count"),
     (try_end),

     (try_for_agents, ":cur_agent"), #send if any agent is carrying any scene object
       (agent_is_human, ":cur_agent"),
       (agent_get_attached_scene_prop, ":attached_scene_prop", ":cur_agent"),
       (ge, ":attached_scene_prop", 0),
       (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_set_attached_scene_prop, ":cur_agent", ":attached_scene_prop"),
     (try_end),

     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_siege_ladder_move_6m"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_siege_ladder_move_8m"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_siege_ladder_move_10m"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_siege_ladder_move_12m"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_siege_ladder_move_14m"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_winch_b"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_castle_e_sally_door_a"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_castle_f_sally_door_a"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_earth_sally_gate_left"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_earth_sally_gate_right"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_viking_keep_destroy_sally_door_left"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_viking_keep_destroy_sally_door_right"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_castle_f_door_a"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_door_destructible"),
     (call_script, "script_send_open_close_information_of_object", ":player_no", "spr_castle_f_door_b"),

     (try_begin),
       (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
       (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_destroy),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),

       (store_mission_timer_a, ":current_time"),
       (val_sub, ":current_time", "$g_round_start_time"),
       (val_mul, ":current_time", -1),

       (multiplayer_send_int_to_player, ":player_no", multiplayer_event_set_round_start_time, ":current_time"),
     (else_try),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
       #if game type is capture the flag send current flag situations to each player.
       (team_get_slot, ":flag_situation_team_1", 0, slot_team_flag_situation),
       (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_set_team_flag_situation, 0, ":flag_situation_team_1"),
       (team_get_slot, ":flag_situation_team_2", 1, slot_team_flag_situation),
       (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_set_team_flag_situation, 1, ":flag_situation_team_2"),
     (else_try),
       (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
       #if game type is headquarters send number of agents placed around each pole's around to player.
       (try_for_range, ":flag_no", 0, "$g_number_of_flags"),
         (assign, ":number_of_agents_around_flag_team_1", 0),
         (assign, ":number_of_agents_around_flag_team_2", 0),

         (scene_prop_get_instance, ":pole_id", "spr_headquarters_pole_code_only", ":flag_no"),
         (prop_instance_get_position, pos0, ":pole_id"), #pos0 holds pole position.

         (try_for_agents, ":cur_agent"),
           (agent_is_human, ":cur_agent"),
           (agent_is_alive, ":cur_agent"),
           (neg|agent_is_non_player, ":cur_agent"),
           (agent_get_team, ":cur_agent_team", ":cur_agent"),
           (agent_get_position, pos1, ":cur_agent"), #pos1 holds agent's position.
           (get_sq_distance_between_positions, ":squared_dist", pos0, pos1),
           (get_sq_distance_between_position_heights, ":squared_height_dist", pos0, pos1),
           (val_add, ":squared_dist", ":squared_height_dist"),
           (lt, ":squared_dist", multi_headquarters_max_distance_sq_to_raise_flags),
           (try_begin),
             (eq, ":cur_agent_team", 0),
             (val_add, ":number_of_agents_around_flag_team_1", 1),
           (else_try),
             (eq, ":cur_agent_team", 1),
             (val_add, ":number_of_agents_around_flag_team_2", 1),
           (try_end),
         (try_end),

         (store_mul, ":current_owner_code", ":number_of_agents_around_flag_team_1", 100),
         (val_add, ":current_owner_code", ":number_of_agents_around_flag_team_2"),
         (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_set_num_agents_around_flag, ":flag_no", ":current_owner_code"),
       (try_end),

       #if game type is headquarters send owners of each pole to player.
       (assign, "$g_placing_initial_flags", 1),
       (try_for_range, ":cur_flag", 0, "$g_number_of_flags"),
         (store_add, ":cur_flag_slot", multi_data_flag_owner_begin, ":cur_flag"),
         (troop_get_slot, ":cur_flag_owner", "trp_multiplayer_data", ":cur_flag_slot"),
         (store_mul, ":cur_flag_owner_code", ":cur_flag_owner", 100),
         (val_add, ":cur_flag_owner_code", ":cur_flag_owner"),
         (val_add, ":cur_flag_owner_code", 1),
         (val_mul, ":cur_flag_owner_code", -1),
         (multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_change_flag_owner, ":cur_flag", ":cur_flag_owner_code"),
       (try_end),
       (assign, "$g_placing_initial_flags", 0),
     (try_end),

     #(multiplayer_send_2_int_to_player, ":player_no", multiplayer_event_set_day_time, "$g_round_day_time"),
    ]),

  #script_multiplayer_remove_headquarters_flags
  # Input: none
  # Output: none
  ("multiplayer_remove_headquarters_flags",
   [
     (store_add, ":end_cond", "spr_headquarters_flag_gray", 1),
     (try_for_range, ":headquarters_flag_no", "spr_headquarters_flag_red", ":end_cond"),
       (replace_scene_props, ":headquarters_flag_no", "spr_empty"),
     (try_end),
     ]),

  #script_multiplayer_remove_destroy_mod_targets
  # Input: none
  # Output: none
  ("multiplayer_remove_destroy_mod_targets",
   [
       (replace_scene_props, "spr_catapult_destructible", "spr_empty"),
       (replace_scene_props, "spr_trebuchet_destructible", "spr_empty"),
     ]),

  #script_multiplayer_init_mission_variables
  ("multiplayer_init_mission_variables",
   [
     (assign, "$g_multiplayer_team_1_first_spawn", 1),
     (assign, "$g_multiplayer_team_2_first_spawn", 1),
     (assign, "$g_multiplayer_poll_running", 0),
##     (assign, "$g_multiplayer_show_poll_when_suitable", 0),
     (assign, "$g_waiting_for_confirmation_to_terminate", 0),
     (assign, "$g_confirmation_result", 0),
     (assign, "$g_team_balance_next_round", 0),
     (team_get_faction, "$g_multiplayer_team_1_faction", 0),
     (team_get_faction, "$g_multiplayer_team_2_faction", 1),
     (assign, "$g_multiplayer_next_team_1_faction", "$g_multiplayer_team_1_faction"),
     (assign, "$g_multiplayer_next_team_2_faction", "$g_multiplayer_team_2_faction"),

     (assign, "$g_multiplayer_bot_type_1_wanted", 0),
     (assign, "$g_multiplayer_bot_type_2_wanted", 0),
     (assign, "$g_multiplayer_bot_type_3_wanted", 0),
     (assign, "$g_multiplayer_bot_type_4_wanted", 0),

     (call_script, "script_music_set_situation_with_culture", mtf_sit_multiplayer_fight),
     ]),

  #script_multiplayer_event_mission_end
  # Input: none
  # Output: none
  ("multiplayer_event_mission_end",
   [
     #EVERY_BREATH_YOU_TAKE achievement
     (try_begin),
       (multiplayer_get_my_player, ":my_player_no"),
       (is_between, ":my_player_no", 0, multiplayer_max_possible_player_id),
       (player_get_kill_count, ":kill_count", ":my_player_no"),
       (player_get_death_count, ":death_count", ":my_player_no"),
       (gt, ":kill_count", ":death_count"),
       (unlock_achievement, ACHIEVEMENT_EVERY_BREATH_YOU_TAKE),
     (try_end),
     #EVERY_BREATH_YOU_TAKE achievement end
     ]),


  #script_multiplayer_event_agent_killed_or_wounded
  # Input: arg1 = dead_agent_no, arg2 = killer_agent_no
  # Output: none
  ("multiplayer_event_agent_killed_or_wounded",
   [
     (store_script_param, ":dead_agent_no", 1),
     (store_script_param, ":killer_agent_no", 2),

     (multiplayer_get_my_player, ":my_player_no"),
     (try_begin),
       (is_between, ":my_player_no", 0, multiplayer_max_possible_player_id),
       (player_get_agent_id, ":my_player_agent", ":my_player_no"),
       (ge, ":my_player_agent", 0),
       (try_begin),
         (eq, ":my_player_agent", ":dead_agent_no"),
         (store_mission_timer_a, "$g_multiplayer_respawn_start_time"),
       (try_end),
       (try_begin),
         (eq, ":my_player_agent", ":killer_agent_no"),
         (neq, ":my_player_agent", ":dead_agent_no"),
         (agent_is_human, ":dead_agent_no"),
         (agent_is_alive, ":my_player_agent"),
         (neg|agent_is_ally, ":dead_agent_no"),
         (agent_get_horse, ":my_horse_agent", ":my_player_agent"),
         (agent_get_wielded_item, ":my_wielded_item", ":my_player_agent", 0),
         (assign, ":my_item_class", -1),
         (try_begin),
           (ge, ":my_wielded_item", 0),
           (item_get_slot, ":my_item_class", ":my_wielded_item", slot_item_multiplayer_item_class),
         (try_end),
         #SPOIL_THE_CHARGE achievement
         (try_begin),
           (lt, ":my_horse_agent", 0),
           (agent_get_horse, ":dead_agent_horse_agent", ":dead_agent_no"),
           (ge, ":dead_agent_horse_agent", 0),
           (get_achievement_stat, ":achievement_stat", ACHIEVEMENT_SPOIL_THE_CHARGE, 0),
           (lt, ":achievement_stat", 50),
           (val_add, ":achievement_stat", 1),
           (set_achievement_stat, ACHIEVEMENT_SPOIL_THE_CHARGE, 0, ":achievement_stat"),
           (ge, ":achievement_stat", 50),
           (unlock_achievement, ACHIEVEMENT_SPOIL_THE_CHARGE),
         (try_end),
         #SPOIL_THE_CHARGE achievement end
         #HARASSING_HORSEMAN achievement
         (try_begin),
           (ge, ":my_horse_agent", 0),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_bow),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_crossbow),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_throwing),
           (eq, ":my_item_class", multi_item_class_type_throwing_axe),
           (get_achievement_stat, ":achievement_stat", ACHIEVEMENT_HARASSING_HORSEMAN, 0),
           (lt, ":achievement_stat", 100),
           (val_add, ":achievement_stat", 1),
           (set_achievement_stat, ACHIEVEMENT_HARASSING_HORSEMAN, 0, ":achievement_stat"),
           (ge, ":achievement_stat", 100),
           (unlock_achievement, ACHIEVEMENT_HARASSING_HORSEMAN),
         (try_end),
         #HARASSING_HORSEMAN achievement end
         #THROWING_STAR achievement
         (try_begin),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_throwing),
           (eq, ":my_item_class", multi_item_class_type_throwing_axe),
           (get_achievement_stat, ":achievement_stat", ACHIEVEMENT_THROWING_STAR, 0),
           (lt, ":achievement_stat", 25),
           (val_add, ":achievement_stat", 1),
           (set_achievement_stat, ACHIEVEMENT_THROWING_STAR, 0, ":achievement_stat"),
           (ge, ":achievement_stat", 25),
           (unlock_achievement, ACHIEVEMENT_THROWING_STAR),
         (try_end),
         #THROWING_STAR achievement end
         #SHISH_KEBAB achievement
         (try_begin),
           (ge, ":my_horse_agent", 0),
           (eq, ":my_item_class", multi_item_class_type_lance),
           (get_achievement_stat, ":achievement_stat", ACHIEVEMENT_SHISH_KEBAB, 0),
           (lt, ":achievement_stat", 25),
           (val_add, ":achievement_stat", 1),
           (set_achievement_stat, ACHIEVEMENT_SHISH_KEBAB, 0, ":achievement_stat"),
           (ge, ":achievement_stat", 25),
           (unlock_achievement, ACHIEVEMENT_SHISH_KEBAB),
         (try_end),
         #SHISH_KEBAB achievement end
         #CHOPPY_CHOP_CHOP achievement
         (try_begin),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_sword),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_axe),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_cleavers),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_two_handed_sword),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_two_handed_axe),
           (this_or_next|eq, ":my_wielded_item", "itm_sarranid_axe_a"), #sarranid item exception
           (eq, ":my_wielded_item", "itm_sarranid_axe_b"), #sarranid item exception
           (neq, ":my_wielded_item", "itm_sarranid_two_handed_mace_1"), #sarranid item exception
           (get_achievement_stat, ":achievement_stat", ACHIEVEMENT_CHOPPY_CHOP_CHOP, 0),
           (lt, ":achievement_stat", 50),
           (val_add, ":achievement_stat", 1),
           (set_achievement_stat, ACHIEVEMENT_CHOPPY_CHOP_CHOP, 0, ":achievement_stat"),
           (ge, ":achievement_stat", 50),
           (unlock_achievement, ACHIEVEMENT_CHOPPY_CHOP_CHOP),
         (try_end),
         #CHOPPY_CHOP_CHOP achievement end
         #MACE_IN_YER_FACE achievement
         (try_begin),
           (this_or_next|eq, ":my_item_class", multi_item_class_type_blunt),
           (eq, ":my_wielded_item", "itm_sarranid_two_handed_mace_1"), #sarranid item exception
           (neq, ":my_wielded_item", "itm_sarranid_axe_b"), #sarranid item exception
           (neq, ":my_wielded_item", "itm_sarranid_axe_a"), #sarranid item exception
           (get_achievement_stat, ":achievement_stat", ACHIEVEMENT_MACE_IN_YER_FACE, 0),
           (lt, ":achievement_stat", 25),
           (val_add, ":achievement_stat", 1),
           (set_achievement_stat, ACHIEVEMENT_MACE_IN_YER_FACE, 0, ":achievement_stat"),
           (ge, ":achievement_stat", 25),
           (unlock_achievement, ACHIEVEMENT_MACE_IN_YER_FACE),
         (try_end),
         #MACE_IN_YER_FACE achievement end
         #THE_HUSCARL achievement
         (try_begin),
           (eq, ":my_item_class", multi_item_class_type_throwing_axe),
           (get_achievement_stat, ":achievement_stat", ACHIEVEMENT_THE_HUSCARL, 0),
           (lt, ":achievement_stat", 50),
           (val_add, ":achievement_stat", 1),
           (set_achievement_stat, ACHIEVEMENT_THE_HUSCARL, 0, ":achievement_stat"),
           (ge, ":achievement_stat", 50),
           (unlock_achievement, ACHIEVEMENT_THE_HUSCARL),
         (try_end),
         #THE_HUSCARL achievement end
       (try_end),
     (try_end),

     (try_begin),
       (is_between, ":my_player_no", 0, multiplayer_max_possible_player_id),
       (player_get_agent_id, ":player_agent", ":my_player_no"),
       (eq, ":dead_agent_no", ":player_agent"),

       (assign, ":show_respawn_counter", 0),
       (try_begin),
         #TODO: add other game types with no respawns here
         (neq, "$g_multiplayer_game_type", multiplayer_game_type_battle),
         (neq, "$g_multiplayer_game_type", multiplayer_game_type_destroy),
         (assign, ":show_respawn_counter", 1),
       (else_try),
         (eq, "$g_multiplayer_player_respawn_as_bot", 1),
         (player_get_team_no, ":my_player_team", ":my_player_no"),
         (assign, ":is_found", 0),
         (try_for_agents, ":cur_agent"),
           (eq, ":is_found", 0),
           (agent_is_alive, ":cur_agent"),
           (agent_is_human, ":cur_agent"),
           (agent_is_non_player, ":cur_agent"),
           (agent_get_team ,":cur_team", ":cur_agent"),
           (eq, ":cur_team", ":my_player_team"),
           (assign, ":is_found", 1),
         (try_end),
         (eq, ":is_found", 1),
         (assign, ":show_respawn_counter", 1),
       (try_end),

       (try_begin),
         #(player_get_slot, ":spawn_count", ":player_no", slot_player_spawn_count),
         (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
         (gt, "$g_multiplayer_number_of_respawn_count", 0),

         (ge, "$g_my_spawn_count", "$g_multiplayer_number_of_respawn_count"),

         (multiplayer_get_my_player, ":my_player_no"),
         (player_get_team_no, ":my_player_team", ":my_player_no"),

         (this_or_next|eq, ":my_player_team", 0),
         (ge, "$g_my_spawn_count", 999),

         (assign, "$g_show_no_more_respawns_remained", 1),
       (else_try),
         (assign, "$g_show_no_more_respawns_remained", 0),
       (try_end),

       (eq, ":show_respawn_counter", 1),

       (start_presentation, "prsnt_multiplayer_respawn_time_counter"),
     (try_end),
     ]),

  #script_multiplayer_get_item_value_for_troop
  # Input: arg1 = item_no, arg2 = troop_no
  # Output: reg0: item_value
  ("multiplayer_get_item_value_for_troop",
   [
     (store_script_param, ":item_no", 1),
     (store_script_param, ":troop_no", 2),
     (try_begin),
       (call_script, "script_cf_multiplayer_is_item_default_for_troop", ":item_no", ":troop_no"),
       (assign, ":item_value", 0),
     (else_try),
       (store_item_value, ":item_value", ":item_no"),
       (store_troop_faction, ":faction_no", ":troop_no"),
       (store_sub, ":faction_slot", ":faction_no", npc_kingdoms_begin),
       (val_add, ":faction_slot", slot_item_multiplayer_faction_price_multipliers_begin),
       (item_get_slot, ":price_multiplier", ":item_no", ":faction_slot"),
       (val_mul, ":item_value", ":price_multiplier"),
       (val_div, ":item_value", 100),
     (try_end),
     (assign, reg0, ":item_value"),
     ]),

  #script_multiplayer_get_previous_item_for_item_and_troop
  # Input: arg1 = item_no, arg2 = troop_no
  # Output: reg0: previous_item_no (-1 if it is the root item, 0 if the item is invalid)
  ("multiplayer_get_previous_item_for_item_and_troop",
   [
     (store_script_param, ":item_no", 1),
     (store_script_param, ":troop_no", 2),
     (item_get_slot, ":item_class", ":item_no", slot_item_multiplayer_item_class),
     (call_script, "script_multiplayer_get_item_value_for_troop", ":item_no", ":troop_no"),
     (assign, ":item_value", reg0),
     (store_sub, ":troop_index", ":troop_no", multiplayer_troops_begin),
     (val_add, ":troop_index", slot_item_multiplayer_availability_linked_list_begin),
     (assign, ":max_item_no", -1),
     (assign, ":max_item_value", -1),
     (try_for_range, ":i_item", all_items_begin, all_items_end),
       (item_slot_eq, ":i_item", slot_item_multiplayer_item_class, ":item_class"),
       (item_slot_ge, ":i_item", ":troop_index", 1),
       (call_script, "script_multiplayer_get_item_value_for_troop", ":i_item", ":troop_no"),
       (assign, ":i_item_value", reg0),
       (try_begin),
         (eq, ":i_item_value", 0),
         (eq, ":max_item_value", 0),
         #choose between 2 default items
         (store_item_value, ":i_item_real_value", ":i_item"),
         (store_item_value, ":max_item_real_value", ":max_item_no"),
         (try_begin),
           (gt, ":i_item_real_value", ":max_item_real_value"),
           (assign, ":max_item_value", ":i_item_value"),
           (assign, ":max_item_no", ":i_item"),
         (try_end),
       (else_try),
         (gt, ":i_item_value", ":max_item_value"),
         (lt, ":i_item_value", ":item_value"),
         (assign, ":max_item_value", ":i_item_value"),
         (assign, ":max_item_no", ":i_item"),
       (try_end),
     (try_end),
     (try_begin),
       (eq, ":max_item_no", -1),
       (assign, ":item_upper_class", -1),
       (try_begin),
         (is_between, ":item_class", multi_item_class_type_melee_weapons_begin, multi_item_class_type_melee_weapons_end),
         (assign, ":item_upper_class", 0),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_shields_begin, multi_item_class_type_shields_end),
         (assign, ":item_upper_class", 1),
       (else_try),
         (eq, ":item_class", multi_item_class_type_bow),
         (assign, ":item_upper_class", 2),
       (else_try),
         (eq, ":item_class", multi_item_class_type_crossbow),
         (assign, ":item_upper_class", 3),
       (else_try),
         (eq, ":item_class", multi_item_class_type_arrow),
         (assign, ":item_upper_class", 4),
       (else_try),
         (eq, ":item_class", multi_item_class_type_bolt),
         (assign, ":item_upper_class", 5),
       (else_try),
         (eq, ":item_class", multi_item_class_type_throwing),
         (assign, ":item_upper_class", 6),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_heads_begin, multi_item_class_type_heads_end),
         (assign, ":item_upper_class", 7),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_bodies_begin, multi_item_class_type_bodies_end),
         (assign, ":item_upper_class", 8),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_feet_begin, multi_item_class_type_feet_end),
         (assign, ":item_upper_class", 9),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_gloves_begin, multi_item_class_type_gloves_end),
         (assign, ":item_upper_class", 10),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_horses_begin, multi_item_class_type_horses_end),
         (assign, ":item_upper_class", 11),
       (try_end),
       (neq, ":item_upper_class", 0),
       #search for the default item for non-weapon classes (only 1 slot is easy to fill)
       (assign, ":end_cond", all_items_end),
       (try_for_range, ":i_item", all_items_begin, ":end_cond"),
         (item_slot_ge, ":i_item", ":troop_index", 1),
         (item_get_slot, ":i_item_class", ":i_item", slot_item_multiplayer_item_class),
         (try_begin),
           (is_between, ":i_item_class", multi_item_class_type_melee_weapons_begin, multi_item_class_type_melee_weapons_end),
           (assign, ":i_item_upper_class", 0),
         (else_try),
           (is_between, ":i_item_class", multi_item_class_type_shields_begin, multi_item_class_type_shields_end),
           (assign, ":i_item_upper_class", 1),
         (else_try),
           (eq, ":i_item_class", multi_item_class_type_bow),
           (assign, ":i_item_upper_class", 2),
         (else_try),
           (eq, ":i_item_class", multi_item_class_type_crossbow),
           (assign, ":i_item_upper_class", 3),
         (else_try),
           (eq, ":i_item_class", multi_item_class_type_arrow),
           (assign, ":i_item_upper_class", 4),
         (else_try),
           (eq, ":i_item_class", multi_item_class_type_bolt),
           (assign, ":i_item_upper_class", 5),
         (else_try),
           (eq, ":i_item_class", multi_item_class_type_throwing),
           (assign, ":i_item_upper_class", 6),
         (else_try),
           (is_between, ":i_item_class", multi_item_class_type_heads_begin, multi_item_class_type_heads_end),
           (assign, ":i_item_upper_class", 7),
         (else_try),
           (is_between, ":i_item_class", multi_item_class_type_bodies_begin, multi_item_class_type_bodies_end),
           (assign, ":i_item_upper_class", 8),
         (else_try),
           (is_between, ":i_item_class", multi_item_class_type_feet_begin, multi_item_class_type_feet_end),
           (assign, ":i_item_upper_class", 9),
         (else_try),
           (is_between, ":i_item_class", multi_item_class_type_gloves_begin, multi_item_class_type_gloves_end),
           (assign, ":i_item_upper_class", 10),
         (else_try),
           (is_between, ":i_item_class", multi_item_class_type_horses_begin, multi_item_class_type_horses_end),
           (assign, ":i_item_upper_class", 11),
         (try_end),
         (eq, ":i_item_upper_class", ":item_upper_class"),
         (call_script, "script_cf_multiplayer_is_item_default_for_troop", ":i_item", ":troop_no"),
         (assign, ":max_item_no", ":i_item"),
         (assign, ":end_cond", 0), #break
       (try_end),
     (try_end),
     (assign, reg0, ":max_item_no"),
     ]),

  #script_cf_multiplayer_is_item_default_for_troop
  # Input: arg1 = item_no, arg2 = troop_no
  # Output: reg0: total_cost
  ("cf_multiplayer_is_item_default_for_troop",
   [
     (store_script_param, ":item_no", 1),
     (store_script_param, ":troop_no", 2),
     (assign, ":default_item", 0),
     (try_begin),
       (neg|is_between, ":item_no", horses_begin, horses_end),
       (neq, ":item_no", "itm_warhorse_sarranid"),
       (neq, ":item_no", "itm_warhorse_steppe"),

       (troop_get_inventory_capacity, ":end_cond", ":troop_no"), #troop no can come -1 here error occured at friday
       (try_for_range, ":i_slot", 0, ":end_cond"),
         (troop_get_inventory_slot, ":default_item_id", ":troop_no", ":i_slot"),
         (eq, ":item_no", ":default_item_id"),
         (assign, ":default_item", 1),
         (assign, ":end_cond", 0), #break
       (try_end),
     (try_end),
     (eq, ":default_item", 1),
     ]),

  #script_multiplayer_calculate_cur_selected_items_cost
  # Input: arg1 = player_no
  # Output: reg0: total_cost
  ("multiplayer_calculate_cur_selected_items_cost",
   [
     (store_script_param, ":player_no", 1),
     (store_script_param, ":calculation_type", 2), #0 for normal calculation
     (assign, ":total_cost", 0),
     (player_get_troop_id, ":troop_no", ":player_no"),

     (try_begin),
       (eq, ":calculation_type", 0),
       (assign, ":begin_cond", slot_player_cur_selected_item_indices_begin),
       (assign, ":end_cond", slot_player_cur_selected_item_indices_end),
     (else_try),
       (assign, ":begin_cond", slot_player_selected_item_indices_begin),
       (assign, ":end_cond", slot_player_selected_item_indices_end),
     (try_end),

     (try_for_range, ":i_item", ":begin_cond", ":end_cond"),
       (player_get_slot, ":item_id", ":player_no", ":i_item"),
       (ge, ":item_id", 0), #might be -1 for horses etc.
       (call_script, "script_multiplayer_get_item_value_for_troop", ":item_id", ":troop_no"),
       (val_add, ":total_cost", reg0),
     (try_end),
     (assign, reg0, ":total_cost"),
     ]),

  #script_multiplayer_set_item_available_for_troop
  # Input: arg1 = item_no, arg2 = troop_no
  # Output: none
  ("multiplayer_set_item_available_for_troop",
   [
     (store_script_param, ":item_no", 1),
     (store_script_param, ":troop_no", 2),
     (store_sub, ":item_troop_slot", ":troop_no", multiplayer_troops_begin),
     (val_add, ":item_troop_slot", slot_item_multiplayer_availability_linked_list_begin),
     (item_set_slot, ":item_no", ":item_troop_slot", 1),
     ]),

  #script_multiplayer_send_item_selections
  # Input: none
  # Output: none
  ("multiplayer_send_item_selections",
   [
     (multiplayer_get_my_player, ":my_player_no"),
     (try_for_range, ":i_item", slot_player_selected_item_indices_begin, slot_player_selected_item_indices_end),
       (player_get_slot, ":item_id", ":my_player_no", ":i_item"),
       (multiplayer_send_2_int_to_server, multiplayer_event_set_item_selection, ":i_item", ":item_id"),
     (try_end),
     ]),

  #script_multiplayer_set_default_item_selections_for_troop
  # Input: arg1 = troop_no
  # Output: none
  ("multiplayer_set_default_item_selections_for_troop",
   [
     (store_script_param, ":troop_no", 1),
     (multiplayer_get_my_player, ":my_player_no"),
     (call_script, "script_multiplayer_clear_player_selected_items", ":my_player_no"),
     (assign, ":cur_weapon_slot", 0),
     (troop_get_inventory_capacity, ":inv_cap", ":troop_no"),
     (try_for_range, ":i_slot", 0, ":inv_cap"),
       (troop_get_inventory_slot, ":item_id", ":troop_no", ":i_slot"),
       (ge, ":item_id", 0),
       (item_get_slot, ":item_class", ":item_id", slot_item_multiplayer_item_class),
       (try_begin),
         (is_between, ":item_class", multi_item_class_type_weapons_begin, multi_item_class_type_weapons_end),
         (this_or_next|eq, "$g_multiplayer_disallow_ranged_weapons", 0),
         (neg|is_between, ":item_class", multi_item_class_type_ranged_weapons_begin, multi_item_class_type_ranged_weapons_end),
         (store_add, ":selected_item_slot", slot_player_selected_item_indices_begin, ":cur_weapon_slot"),
         (player_set_slot, ":my_player_no", ":selected_item_slot", ":item_id"),
         (val_add, ":cur_weapon_slot", 1),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_heads_begin, multi_item_class_type_heads_end),
         (store_add, ":selected_item_slot", slot_player_selected_item_indices_begin, 4),
         (player_set_slot, ":my_player_no", ":selected_item_slot", ":item_id"),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_bodies_begin, multi_item_class_type_bodies_end),
         (store_add, ":selected_item_slot", slot_player_selected_item_indices_begin, 5),
         (player_set_slot, ":my_player_no", ":selected_item_slot", ":item_id"),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_feet_begin, multi_item_class_type_feet_end),
         (store_add, ":selected_item_slot", slot_player_selected_item_indices_begin, 6),
         (player_set_slot, ":my_player_no", ":selected_item_slot", ":item_id"),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_gloves_begin, multi_item_class_type_gloves_end),
         (store_add, ":selected_item_slot", slot_player_selected_item_indices_begin, 7),
         (player_set_slot, ":my_player_no", ":selected_item_slot", ":item_id"),
       (else_try),
         (is_between, ":item_class", multi_item_class_type_horses_begin, multi_item_class_type_horses_end),
         (eq, "$g_horses_are_avaliable", 1),
         (store_add, ":selected_item_slot", slot_player_selected_item_indices_begin, 8),
         (player_set_slot, ":my_player_no", ":selected_item_slot", ":item_id"),
       (try_end),
     (try_end),
     ]),

  #script_multiplayer_display_available_items_for_troop_and_item_classes
  # Input: arg1 = troop_no, arg2 = item_classes_begin, arg3 = item_classes_end, arg4 = pos_x_begin, arg5 = pos_y_begin
  # Output: none
  ("multiplayer_display_available_items_for_troop_and_item_classes",
   [
     (store_script_param, ":troop_no", 1),
     (store_script_param, ":item_classes_begin", 2),
     (store_script_param, ":item_classes_end", 3),
     (store_script_param, ":pos_x_begin", 4),
     (store_script_param, ":pos_y_begin", 5),

     (assign, ":x_adder", 100),
     (try_begin),
       (gt, ":pos_x_begin", 500),
       (assign, ":x_adder", -100),
     (try_end),

     (store_sub, ":item_troop_slot", ":troop_no", multiplayer_troops_begin),
     (val_add, ":item_troop_slot", slot_item_multiplayer_availability_linked_list_begin),

     (try_for_range, ":cur_slot", multi_data_item_button_indices_begin, multi_data_item_button_indices_end),
       (troop_set_slot, "trp_multiplayer_data", ":cur_slot", -1),
     (try_end),

     (assign, ":num_available_items", 0),

     (try_for_range, ":item_no", all_items_begin, all_items_end),
       (item_get_slot, ":item_class", ":item_no", slot_item_multiplayer_item_class),
       (is_between, ":item_class", ":item_classes_begin", ":item_classes_end"),
       (this_or_next|eq, "$g_multiplayer_disallow_ranged_weapons", 0),
       (neg|is_between, ":item_class", multi_item_class_type_ranged_weapons_begin, multi_item_class_type_ranged_weapons_end),
       (item_slot_ge, ":item_no", ":item_troop_slot", 1),
       (store_add, ":cur_slot_index", ":num_available_items", multi_data_item_button_indices_begin),
       #using the result array for item_ids
       (troop_set_slot, "trp_multiplayer_data", ":cur_slot_index", ":item_no"),
       (val_add, ":num_available_items", 1),
     (try_end),

     #sorting
     (store_add, ":item_slots_end", ":num_available_items", multi_data_item_button_indices_begin),
     (store_sub, ":item_slots_end_minus_one", ":item_slots_end", 1),
     (try_for_range, ":cur_slot", multi_data_item_button_indices_begin, ":item_slots_end_minus_one"),
       (store_add, ":cur_slot_2_begin", ":cur_slot", 1),
       (try_for_range, ":cur_slot_2", ":cur_slot_2_begin", ":item_slots_end"),
         (troop_get_slot, ":item_1", "trp_multiplayer_data", ":cur_slot"),
         (troop_get_slot, ":item_2", "trp_multiplayer_data", ":cur_slot_2"),
         (call_script, "script_multiplayer_get_item_value_for_troop", ":item_1", ":troop_no"),
         (assign, ":item_1_point", reg0),
         (call_script, "script_multiplayer_get_item_value_for_troop", ":item_2", ":troop_no"),
         (assign, ":item_2_point", reg0),
         (item_get_slot, ":item_1_class", ":item_1", slot_item_multiplayer_item_class),
         (item_get_slot, ":item_2_class", ":item_2", slot_item_multiplayer_item_class),
         (val_mul, ":item_1_class", 1000000), #assuming maximum item price is 1000000
         (val_mul, ":item_2_class", 1000000), #assuming maximum item price is 1000000
         (val_add, ":item_1_point", ":item_1_class"),
         (val_add, ":item_2_point", ":item_2_class"),
         (lt, ":item_2_point", ":item_1_point"),
         (troop_set_slot, "trp_multiplayer_data", ":cur_slot", ":item_2"),
         (troop_set_slot, "trp_multiplayer_data", ":cur_slot_2", ":item_1"),
       (try_end),
     (try_end),

     (troop_get_slot, ":last_item_no", "trp_multiplayer_data", multi_data_item_button_indices_begin),
     (assign, ":num_item_classes", 0),
     (try_begin),
       (ge, ":last_item_no", 0),
       (item_get_slot, ":last_item_class", ":last_item_no", slot_item_multiplayer_item_class),

       (try_for_range, ":cur_slot", multi_data_item_button_indices_begin, ":item_slots_end"),
         (troop_get_slot, ":item_no", "trp_multiplayer_data", ":cur_slot"),
         (item_get_slot, ":item_class", ":item_no", slot_item_multiplayer_item_class),
         (neq, ":item_class", ":last_item_class"),
         (val_add, ":num_item_classes", 1),
         (assign, ":last_item_class", ":item_class"),
       (try_end),

       (try_begin),
         (store_mul, ":required_y", ":num_item_classes", 100),
         (gt, ":required_y", ":pos_y_begin"),
         (store_sub, ":dif", ":required_y", ":pos_y_begin"),
         (val_div, ":dif", 100),
         (val_add, ":dif", 1),
         (val_mul, ":dif", 100),
         (val_add, ":pos_y_begin", ":dif"),
       (try_end),

       (item_get_slot, ":last_item_class", ":last_item_no", slot_item_multiplayer_item_class),
     (try_end),
     (assign, ":cur_x", ":pos_x_begin"),
     (assign, ":cur_y", ":pos_y_begin"),
     (try_for_range, ":cur_slot", multi_data_item_button_indices_begin, ":item_slots_end"),
       (troop_get_slot, ":item_no", "trp_multiplayer_data", ":cur_slot"),
       (item_get_slot, ":item_class", ":item_no", slot_item_multiplayer_item_class),
       (try_begin),
         (neq, ":item_class", ":last_item_class"),
         (val_sub, ":cur_y", 100),
         (assign, ":cur_x", ":pos_x_begin"),
         (assign, ":last_item_class", ":item_class"),
       (try_end),
       (create_image_button_overlay, ":cur_obj", "mesh_mp_inventory_choose", "mesh_mp_inventory_choose"),
       (position_set_x, pos1, 800),
       (position_set_y, pos1, 800),
       (overlay_set_size, ":cur_obj", pos1),
       (position_set_x, pos1, ":cur_x"),
       (position_set_y, pos1, ":cur_y"),
       (overlay_set_position, ":cur_obj", pos1),
       (create_mesh_overlay_with_item_id, reg0, ":item_no"),
       (store_add, ":item_x", ":cur_x", 50),
       (store_add, ":item_y", ":cur_y", 50),
       (position_set_x, pos1, ":item_x"),
       (position_set_y, pos1, ":item_y"),
       (overlay_set_position, reg0, pos1),
       (val_add, ":cur_x", ":x_adder"),
     (try_end),
     ]),

  # script_multiplayer_fill_map_game_types
  # Input: game_type
  # Output: num_maps
  ("multiplayer_fill_map_game_types",
    [
      (store_script_param, ":game_type", 1),
      (try_for_range, ":i_multi", multi_data_maps_for_game_type_begin, multi_data_maps_for_game_type_end),
        (troop_set_slot, "trp_multiplayer_data", ":i_multi", -1),
      (try_end),
      (assign, ":num_maps", 0),
      (try_begin),
        (this_or_next|eq, ":game_type", multiplayer_game_type_deathmatch),
        (this_or_next|eq, ":game_type", multiplayer_game_type_duel),
        (eq, ":game_type", multiplayer_game_type_team_deathmatch),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin, "scn_multi_scene_1"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 1, "scn_multi_scene_2"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 2, "scn_multi_scene_4"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 3, "scn_multi_scene_7"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 4, "scn_multi_scene_9"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 5, "scn_multi_scene_11"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 6, "scn_multi_scene_12"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 7, "scn_multi_scene_14"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 8, "scn_multi_scene_17"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 9, "scn_multi_scene_18"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 10, "scn_multi_scene_19"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 11, "scn_multi_scene_20"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 12, "scn_random_multi_plain_medium"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 13, "scn_random_multi_plain_large"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 14, "scn_random_multi_steppe_medium"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 15, "scn_random_multi_steppe_large"),
        (assign, ":num_maps", 16),
      (else_try),
        (eq, ":game_type", multiplayer_game_type_battle),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin, "scn_multi_scene_1"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 1, "scn_multi_scene_2"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 2, "scn_multi_scene_4"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 3, "scn_multi_scene_7"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 4, "scn_multi_scene_9"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 5, "scn_multi_scene_11"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 6, "scn_multi_scene_12"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 7, "scn_multi_scene_14"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 8, "scn_multi_scene_17"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 9, "scn_multi_scene_18"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 10, "scn_multi_scene_19"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 11, "scn_multi_scene_20"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 12, "scn_random_multi_plain_medium"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 13, "scn_random_multi_plain_large"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 14, "scn_random_multi_steppe_medium"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 15, "scn_random_multi_steppe_large"),
        (assign, ":num_maps", 16),
      (else_try),
        (eq, ":game_type", multiplayer_game_type_destroy),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin, "scn_multi_scene_1"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 1, "scn_multi_scene_2"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 2, "scn_multi_scene_4"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 3, "scn_multi_scene_7"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 4, "scn_multi_scene_9"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 5, "scn_multi_scene_12"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 6, "scn_multi_scene_14"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 7, "scn_multi_scene_19"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 8, "scn_multi_scene_20"),
        (assign, ":num_maps", 9),
      (else_try),
        (eq, ":game_type", multiplayer_game_type_capture_the_flag),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin, "scn_multi_scene_1"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 1, "scn_multi_scene_2"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 2, "scn_multi_scene_4"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 3, "scn_multi_scene_7"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 4, "scn_multi_scene_9"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 5, "scn_multi_scene_11"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 6, "scn_multi_scene_12"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 7, "scn_multi_scene_14"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 8, "scn_multi_scene_17"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 9, "scn_multi_scene_18"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 10, "scn_multi_scene_19"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 11, "scn_multi_scene_20"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 12, "scn_random_multi_plain_medium"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 13, "scn_random_multi_plain_large"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 14, "scn_random_multi_steppe_medium"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 15, "scn_random_multi_steppe_large"),
        (assign, ":num_maps", 16),
      (else_try),
        (eq, ":game_type", multiplayer_game_type_headquarters),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin, "scn_multi_scene_1"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 1, "scn_multi_scene_2"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 2, "scn_multi_scene_4"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 3, "scn_multi_scene_7"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 4, "scn_multi_scene_9"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 5, "scn_multi_scene_11"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 6, "scn_multi_scene_12"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 7, "scn_multi_scene_14"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 8, "scn_multi_scene_17"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 9, "scn_multi_scene_18"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 10, "scn_multi_scene_19"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 11, "scn_multi_scene_20"),
        (assign, ":num_maps", 12),
      (else_try),
        (eq, ":game_type", multiplayer_game_type_siege),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin, "scn_multi_scene_3"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 1, "scn_multi_scene_8"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 2, "scn_multi_scene_10"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 3, "scn_multi_scene_13"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 4, "scn_multi_scene_15"),
        (troop_set_slot, "trp_multiplayer_data", multi_data_maps_for_game_type_begin + 5, "scn_multi_scene_16"),
        (assign, ":num_maps", 6),
      (try_end),
      (assign, reg0, ":num_maps"),
      ]),


  # script_multiplayer_count_players_bots
  # Input: none
  # Output: none
  ("multiplayer_count_players_bots",
    [
      (get_max_players, ":num_players"),
      (try_for_range, ":cur_player", 0, ":num_players"),
        (player_is_active, ":cur_player"),
        (player_set_slot, ":cur_player", slot_player_last_bot_count, 0),
      (try_end),

      (try_for_agents, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_get_player_id, ":agent_player", ":cur_agent"),
        (lt, ":agent_player", 0), #not a player
        (agent_get_group, ":agent_group", ":cur_agent"),
        (player_is_active, ":agent_group"),
        (player_get_slot, ":bot_count", ":agent_group", slot_player_last_bot_count),
        (val_add, ":bot_count", 1),
        (player_set_slot, ":agent_group", slot_player_last_bot_count, ":bot_count"),
      (try_end),
      ]),

  # script_multiplayer_find_player_leader_for_bot
  # Input: arg1 = team_no
  # Output: reg0 = player_no
  ("multiplayer_find_player_leader_for_bot",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":look_only_actives", 2),

      (team_get_faction, ":team_faction", ":team_no"),
      (assign, ":num_ai_troops", 0),
      (try_for_range, ":cur_ai_troop", multiplayer_ai_troops_begin, multiplayer_ai_troops_end),
        (store_troop_faction, ":ai_troop_faction", ":cur_ai_troop"),
        (eq, ":ai_troop_faction", ":team_faction"),
        (val_add, ":num_ai_troops", 1),
      (try_end),

      (call_script, "script_multiplayer_count_players_bots"),

      (assign, ":team_player_count", 0),

      (get_max_players, ":num_players"),
      (try_for_range, ":cur_player", 0, ":num_players"),
        (assign, ":continue", 0),
        (player_is_active, ":cur_player"),
        (try_begin),
          (eq, ":look_only_actives", 0),
          (assign, ":continue", 1),
        (else_try),
          (neq, ":look_only_actives", 0),
          (player_get_agent_id, ":cur_agent", ":cur_player"),
          (ge, ":cur_agent", 0),
          (agent_is_alive, ":cur_agent"),
          (assign, ":continue", 1),
        (try_end),

        (eq, ":continue", 1),

        (player_get_team_no, ":player_team", ":cur_player"),
        (eq, ":team_no", ":player_team"),
        (val_add, ":team_player_count", 1),
      (try_end),
      (assign, ":result_leader", -1),
      (try_begin),
        (gt, ":team_player_count", 0),
        (assign, ":total_bot_count", "$g_multiplayer_num_bots_team_1"),
        (try_begin),
          (eq, ":team_no", 1),
          (assign, ":total_bot_count", "$g_multiplayer_num_bots_team_2"),
        (try_end),
        (store_div, ":num_bots_for_each_player", ":total_bot_count", ":team_player_count"),
        (store_mul, ":check_remainder", ":num_bots_for_each_player", ":team_player_count"),
        (try_begin),
          (lt, ":check_remainder", ":total_bot_count"),
          (val_add, ":num_bots_for_each_player", 1),
        (try_end),

        (assign, ":total_bot_req", 0),
        (try_for_range, ":cur_player", 0, ":num_players"),
          (player_is_active, ":cur_player"),

          (player_get_agent_id, ":cur_agent", ":cur_player"),
          (ge, ":cur_agent", 0),
          (agent_is_alive, ":cur_agent"),

          (player_get_team_no, ":player_team", ":cur_player"),
          (eq, ":team_no", ":player_team"),
          (assign, ":ai_wanted", 0),
          (store_add, ":end_cond", slot_player_bot_type_1_wanted, ":num_ai_troops"),
          (try_for_range, ":bot_type_wanted_slot", slot_player_bot_type_1_wanted, ":end_cond"),
            (player_slot_ge, ":cur_player", ":bot_type_wanted_slot", 1),
            (assign, ":ai_wanted", 1),
            (assign, ":end_cond", 0), #break
          (try_end),
          (eq, ":ai_wanted", 1),
          (player_get_slot, ":player_bot_count", ":cur_player", slot_player_last_bot_count),
          (lt, ":player_bot_count", ":num_bots_for_each_player"),
          (val_add, ":total_bot_req", ":num_bots_for_each_player"),
          (val_sub, ":total_bot_req", ":player_bot_count"),
        (try_end),
        (gt, ":total_bot_req", 0),

        (store_random_in_range, ":random_bot", 0, ":total_bot_req"),
        (try_for_range, ":cur_player", 0, ":num_players"),
          (player_is_active, ":cur_player"),

          (player_get_agent_id, ":cur_agent", ":cur_player"),
          (ge, ":cur_agent", 0),
          (agent_is_alive, ":cur_agent"),

          (player_get_team_no, ":player_team", ":cur_player"),
          (eq, ":team_no", ":player_team"),
          (assign, ":ai_wanted", 0),
          (store_add, ":end_cond", slot_player_bot_type_1_wanted, ":num_ai_troops"),
          (try_for_range, ":bot_type_wanted_slot", slot_player_bot_type_1_wanted, ":end_cond"),
            (player_slot_ge, ":cur_player", ":bot_type_wanted_slot", 1),
            (assign, ":ai_wanted", 1),
            (assign, ":end_cond", 0), #break
          (try_end),
          (eq, ":ai_wanted", 1),
          (player_get_slot, ":player_bot_count", ":cur_player", slot_player_last_bot_count),
          (lt, ":player_bot_count", ":num_bots_for_each_player"),
          (val_sub, ":random_bot", ":num_bots_for_each_player"),
          (val_add, ":random_bot", ":player_bot_count"),
          (lt, ":random_bot", 0),
          (assign, ":result_leader", ":cur_player"),
          (assign, ":num_players", 0), #break
        (try_end),
      (try_end),
      (assign, reg0, ":result_leader"),
      ]),

  # script_multiplayer_find_bot_troop_and_group_for_spawn
  # Input: arg1 = team_no
  # Output: reg0 = troop_id, reg1 = group_id
  ("multiplayer_find_bot_troop_and_group_for_spawn",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":look_only_actives", 2),

      (call_script, "script_multiplayer_find_player_leader_for_bot", ":team_no", ":look_only_actives"),
      (assign, ":leader_player", reg0),

      (assign, ":available_troops_in_faction", 0),
      (assign, ":available_troops_to_spawn", 0),
      (team_get_faction, ":team_faction_no", ":team_no"),

      (try_for_range, ":troop_no", multiplayer_ai_troops_begin, multiplayer_ai_troops_end),
        (store_troop_faction, ":troop_faction", ":troop_no"),
        (eq, ":troop_faction", ":team_faction_no"),
        (store_add, ":wanted_slot", slot_player_bot_type_1_wanted, ":available_troops_in_faction"),
        (val_add, ":available_troops_in_faction", 1),
        (try_begin),
          (this_or_next|lt, ":leader_player", 0),
          (player_slot_ge, ":leader_player", ":wanted_slot", 1),
          (val_add, ":available_troops_to_spawn", 1),
        (try_end),
      (try_end),

      (assign, ":available_troops_in_faction", 0),

      (store_random_in_range, ":random_troop_index", 0, ":available_troops_to_spawn"),
      (assign, ":end_cond", multiplayer_ai_troops_end),
      (try_for_range, ":troop_no", multiplayer_ai_troops_begin, ":end_cond"),
        (store_troop_faction, ":troop_faction", ":troop_no"),
        (eq, ":troop_faction", ":team_faction_no"),
        (store_add, ":wanted_slot", slot_player_bot_type_1_wanted, ":available_troops_in_faction"),
        (val_add, ":available_troops_in_faction", 1),
        (this_or_next|lt, ":leader_player", 0),
        (player_slot_ge, ":leader_player", ":wanted_slot", 1),
        (val_sub, ":random_troop_index", 1),
        (lt, ":random_troop_index", 0),
        (assign, ":end_cond", 0),
        (assign, ":selected_troop", ":troop_no"),
      (try_end),
      (assign, reg0, ":selected_troop"),
      (assign, reg1, ":leader_player"),
      ]),

  # script_multiplayer_change_leader_of_bot
  # Input: arg1 = agent_no
  # Output: none
  ("multiplayer_change_leader_of_bot",
    [
      (store_script_param, ":agent_no", 1),
      (agent_get_team, ":team_no", ":agent_no"),
      (call_script, "script_multiplayer_find_player_leader_for_bot", ":team_no", 1),
      (assign, ":leader_player", reg0),
      (agent_set_group, ":agent_no", ":leader_player"),
      ]),

  ("multiplayer_find_spawn_point",
  [
     (store_script_param, ":team_no", 1),
     (store_script_param, ":examine_all_spawn_points", 2), #0-dm, 1-tdm, 2-cf, 3-hq, 4-sg
     (store_script_param, ":is_horseman", 3), #0:no, 1:yes, -1:do not care

     (set_fixed_point_multiplier, 100),

     (assign, ":flags", 0),

     (try_begin),
       (eq, ":examine_all_spawn_points", 1),
       (val_or, ":flags", spf_examine_all_spawn_points),
     (try_end),

     (try_begin),
       (eq, ":is_horseman", 1),
       (val_or, ":flags", spf_is_horseman),
     (try_end),

     (try_begin),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_duel),
       (val_or, ":flags", spf_all_teams_are_enemy),
       (val_or, ":flags", spf_try_to_spawn_close_to_at_least_one_enemy),
     (else_try),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_team_deathmatch),
       (val_or, ":flags", spf_try_to_spawn_close_to_at_least_one_enemy),
     (else_try),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
       (val_or, ":flags", spf_team_1_spawn_far_from_entry_66), #team 1 agents will not spawn 70 meters around of entry 0
       (val_or, ":flags", spf_team_0_walkers_spawn_at_high_points),
       (val_or, ":flags", spf_team_0_spawn_near_entry_66),
       (val_or, ":flags", spf_care_agent_to_agent_distances_less),
     (else_try),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
       (val_or, ":flags", spf_team_1_spawn_far_from_entry_0), #team 1 agents will not spawn 70 meters around of entry 0
       (val_or, ":flags", spf_team_0_spawn_far_from_entry_32), #team 0 agents will not spawn 70 meters around of entry 32
       (val_or, ":flags", spf_try_to_spawn_close_to_at_least_one_enemy),
     (else_try),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters),
       (assign, ":assigned_flag_count", 0),

       (store_sub, ":maximum_moved_flag_distance", multi_headquarters_pole_height, 50), #900 - 50 = 850
       (store_mul, ":maximum_moved_flag_distance_sq", ":maximum_moved_flag_distance", ":maximum_moved_flag_distance"),
       (val_div, ":maximum_moved_flag_distance_sq", 100), #dividing 100, because fixed point multiplier is 100 and it is included twice, look above line.

       (try_for_range, ":flag_no", 0, "$g_number_of_flags"),
         (store_add, ":cur_flag_owner_slot", multi_data_flag_owner_begin, ":flag_no"),
         (troop_get_slot, ":cur_flag_owner", "trp_multiplayer_data", ":cur_flag_owner_slot"),

         (scene_prop_get_instance, ":pole_id", "spr_headquarters_pole_code_only", ":flag_no"),
         (prop_instance_get_position, pos0, ":pole_id"),

         (try_begin),
           (eq, ":cur_flag_owner", 1),
           (scene_prop_get_instance, ":flag_of_team_1", "$team_1_flag_scene_prop", ":flag_no"),

           (prop_instance_get_position, pos1, ":flag_of_team_1"),
           (get_sq_distance_between_positions, ":flag_height_sq", pos0, pos1),
           (ge, ":flag_height_sq", ":maximum_moved_flag_distance_sq"),

           (set_spawn_effector_scene_prop_id, ":assigned_flag_count", ":flag_of_team_1"),
           (val_add, ":assigned_flag_count", 1),
         (else_try),
           (eq, ":cur_flag_owner", 2),
           (scene_prop_get_instance, ":flag_of_team_2", "$team_2_flag_scene_prop", ":flag_no"),

           (prop_instance_get_position, pos1, ":flag_of_team_2"),
           (get_sq_distance_between_positions, ":flag_height_sq", pos0, pos1),
           (ge, ":flag_height_sq", ":maximum_moved_flag_distance_sq"),

           (set_spawn_effector_scene_prop_id, ":assigned_flag_count", ":flag_of_team_2"),
           (val_add, ":assigned_flag_count", 1),
         (try_end),
       (try_end),
       (set_spawn_effector_scene_prop_id, ":assigned_flag_count", -1),
     (try_end),

     (multiplayer_find_spawn_point, reg0, ":team_no", ":flags"),
  ]),

  # script_multiplayer_find_spawn_point_2
  # Input: arg1 = team_no, arg2 = examine_all_spawn_points, arg3 = is_horseman
  # Output: reg0 = entry_point_no
  ("multiplayer_find_spawn_point_2",
   [
     (store_script_param, ":team_no", 1),
     (store_script_param, ":examine_all_spawn_points", 2), #0-dm, 1-tdm, 2-cf, 3-hq, 4-sg
     (store_script_param, ":is_horseman", 3), #0:no, 1:yes, -1:do not care

     (assign, ":best_entry_point_score", -10000000),
     (assign, ":best_entry_point", 0),

     (assign, ":num_operations", 0),

     (assign, ":num_human_agents_div_3_plus_one", 0),
     (try_begin), #counting number of agents
       (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
       (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
       (try_for_agents, ":i_agent"),
         (agent_is_alive, ":i_agent"),
         (agent_is_human, ":i_agent"),
         (val_add, ":num_human_agents_div_3_plus_one", 1),
       (try_end),
     (try_end),

     (assign, ":num_human_agents_plus_one", ":num_human_agents_div_3_plus_one"),

     (try_begin),
       (le, ":num_human_agents_plus_one", 4),
       (assign, ":random_number_upper_limit", 2), #this is not typo-mistake this should be 2 too, not 1.
     (else_try),
       (le, ":num_human_agents_plus_one", 8),
       (assign, ":random_number_upper_limit", 2),
     (else_try),
       (le, ":num_human_agents_plus_one", 16),
       (assign, ":random_number_upper_limit", 3),
     (else_try),
       (le, ":num_human_agents_plus_one", 24),
       (assign, ":random_number_upper_limit", 4),
     (else_try),
       (le, ":num_human_agents_plus_one", 32),
       (assign, ":random_number_upper_limit", 5),
     (else_try),
       (le, ":num_human_agents_plus_one", 40),
       (assign, ":random_number_upper_limit", 6),
     (else_try),
       (assign, ":random_number_upper_limit", 7),
     (try_end),

     (val_div, ":num_human_agents_div_3_plus_one", 3),
     (val_add, ":num_human_agents_div_3_plus_one", 1),
     (store_mul, ":negative_num_human_agents_div_3_plus_one", ":num_human_agents_div_3_plus_one", -1),

     (try_begin),
       (eq, ":examine_all_spawn_points", 1),
       (assign, ":random_number_upper_limit", 1),
     (try_end),

     (try_begin), #counting number of our flags and enemy flags
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters),
       (assign, ":our_flag_count", 0),
       (assign, ":enemy_flag_count", 0),
       (try_for_range, ":flag_no", 0, "$g_number_of_flags"),
         (store_add, ":cur_flag_owner_slot", multi_data_flag_owner_begin, ":flag_no"),
         (troop_get_slot, ":cur_flag_owner", "trp_multiplayer_data", ":cur_flag_owner_slot"),
         (neq, ":cur_flag_owner", 0),
         (val_sub, ":cur_flag_owner", 1),
         (try_begin),
           (eq, ":cur_flag_owner", ":team_no"),
           (val_add, ":our_flag_count", 1),
         (else_try),
           (val_add, ":enemy_flag_count", 1),
         (try_end),
       (try_end),
     (try_end),

     (assign, ":first_agent", 0),
     (try_begin), #first spawned agents will be spawned at their base points in tdm, cf and hq mods.
       (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_team_deathmatch),
       (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
       (eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters),
       (try_begin),
         (eq, ":team_no", 0),
         (eq, "$g_multiplayer_team_1_first_spawn", 1),
         (assign, ":first_agent", 1),
         (assign, "$g_multiplayer_team_1_first_spawn", 0),
       (else_try),
         (eq, ":team_no", 1),
         (eq, "$g_multiplayer_team_2_first_spawn", 1),
         (assign, ":first_agent", 1),
         (assign, "$g_multiplayer_team_2_first_spawn", 0),
       (try_end),
     (try_end),

     (try_begin),
       (eq, ":first_agent", 1),
       (store_mul, ":best_entry_point", ":team_no", multi_num_valid_entry_points_div_2),
     (else_try),
       (try_for_range, ":i_entry_point", 0, multi_num_valid_entry_points),
         (assign, ":minimum_enemy_distance", 3000),
         (assign, ":second_minimum_enemy_distance", 3000),

         (assign, ":entry_point_score", 0),
         (store_random_in_range, ":random_value", 0, ":random_number_upper_limit"), #in average it is 5
         (eq, ":random_value", 0),
         (entry_point_get_position, pos0, ":i_entry_point"), #pos0 holds current entry point position
         (try_for_agents, ":i_agent"),
           (agent_is_alive, ":i_agent"),
           (agent_is_human, ":i_agent"),
           (agent_get_team, ":agent_team", ":i_agent"),
           (try_begin),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_team_deathmatch),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters),
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
             (try_begin),
               (teams_are_enemies, ":team_no", ":agent_team"),
               (assign, ":multiplier", -2),
             (else_try),
               (assign, ":multiplier", 1),
             (try_end),
           (else_try),
             (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch),
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_duel),
             (assign, ":multiplier", -1),
           (try_end),
           (agent_get_position, pos1, ":i_agent"),
           (get_distance_between_positions_in_meters, ":distance", pos0, pos1),
           (val_add, ":num_operations", 1),
           (try_begin),
             (try_begin), #find closest enemy soldiers
               (lt, ":multiplier", 0),
               (try_begin),
                 (lt, ":distance", ":minimum_enemy_distance"),
                 (assign, ":second_minimum_enemy_distance", ":minimum_enemy_distance"),
                 (assign, ":minimum_enemy_distance", ":distance"),
               (else_try),
                 (lt, ":distance", ":second_minimum_enemy_distance"),
                 (assign, ":second_minimum_enemy_distance", ":distance"),
               (try_end),
             (try_end),

             (lt, ":distance", 100),
             (try_begin), #do not spawn over or too near to another agent (limit is 2 meters, squared 4 meters)
               (lt, ":distance", 3),
               (try_begin),
                 (this_or_next|eq, ":examine_all_spawn_points", 0),
                 (this_or_next|lt, ":multiplier", 0), #new added 20.08.08
                 (neq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
                 (try_begin),
                   (lt, ":distance", 1),
                   (assign, ":dist_point", -1000000), #never place
                 (else_try),
                   (lt, ":distance", 2),
                   (try_begin),
                     (lt, ":multiplier", 0),
                     (assign, ":dist_point", -20000),
                   (else_try),
                     (assign, ":dist_point", -2000), #can place, friend and distance is between 1-2 meters
                   (try_end),
                 (else_try),
                   (try_begin),
                     (lt, ":multiplier", 0),
                     (assign, ":dist_point", -10000),
                   (else_try),
                     (assign, ":dist_point", -1000), #can place, friend and distance is between 2-3 meters
                   (try_end),
                 (try_end),
               (else_try),
                 #if examinining all spawn points and mod is siege only. This happens in new round start placings.
                 (try_begin),
                   (lt, ":distance", 1),
                   (assign, ":dist_point", -20000), #very hard to place distance is < 1 meter
                 (else_try),
                   (lt, ":distance", 2),
                   (assign, ":dist_point", -2000),
                 (else_try),
                   (assign, ":dist_point", -1000), #can place, distance is between 2-3 meters
                 (try_end),
               (try_end),

               (val_mul, ":dist_point", ":num_human_agents_div_3_plus_one"),
             (else_try),
               (assign, ":dist_point", 0),
               (this_or_next|neq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
               (this_or_next|lt, ":multiplier", 0),
               (eq, ":team_no", 1), #only attackers are effected by positive enemy & friend distance at siege mod, defenders only get negative score effect a bit

               (try_begin), #in siege give no positive or negative score to > 40m distance. (6400 = 10000 - 3600(60 * 60))
                 (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),

                 (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch), #new added after moving below part to above
                 (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_duel), #new added after moving below part to above
                 (eq, "$g_multiplayer_game_type", multiplayer_game_type_team_deathmatch), #new added after moving below part to above

                 (store_sub, ":dist_point", multiplayer_spawn_min_enemy_dist_limit, ":distance"), #up to 40 meters give (positive(if friend) or negative(if enemy)) points
                 (val_max, ":dist_point", 0),
                 (val_mul, ":dist_point", ":dist_point"),
               (else_try),
                 (store_mul, ":one_and_half_limit", multiplayer_spawn_min_enemy_dist_limit, 3),
                 (val_div, ":one_and_half_limit", 2),
                 (store_sub, ":dist_point", ":one_and_half_limit", ":distance"), #up to 60 meters give (positive(if friend) or negative(if enemy)) points
                 (val_mul, ":dist_point", ":dist_point"),
               (try_end),

               (val_mul, ":dist_point", ":multiplier"),
             (try_end),
             (val_add, ":entry_point_score", ":dist_point"),
           (try_end),
         (try_end),

         (try_begin),
           (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
           (store_mul, ":max_enabled_agent_distance_score", 1000, ":num_human_agents_div_3_plus_one"),
           (ge, ":entry_point_score", ":max_enabled_agent_distance_score"),
           (assign, ":entry_point_score", ":max_enabled_agent_distance_score"),
         (try_end),

         (try_begin),
           (neq, "$g_multiplayer_game_type", multiplayer_game_type_siege),

           #(assign, ":minimum_enemy_dist_score", 0), #close also these with displays
           #(assign, ":second_minimum_enemy_dist_score", 0), #close also these with displays
           #(assign, reg2, ":minimum_enemy_distance"), #close also these with displays
           #(assign, reg3, ":second_minimum_enemy_distance"), #close also these with displays

           (try_begin), #if minimum enemy dist score is greater than 40(multiplayer_spawn_above_opt_enemy_dist_point) meters then give negative score
             (lt, ":minimum_enemy_distance", 3000),
             (try_begin),
               (gt, ":minimum_enemy_distance", multiplayer_spawn_above_opt_enemy_dist_point),
               (val_sub, ":minimum_enemy_distance", multiplayer_spawn_above_opt_enemy_dist_point),
               (store_mul, ":minimum_enemy_dist_score", ":minimum_enemy_distance", -50),
               (val_mul, ":minimum_enemy_dist_score", ":num_human_agents_div_3_plus_one"),
               (val_add, ":entry_point_score", ":minimum_enemy_dist_score"),
             (try_end),
           (try_end),

           (try_begin), #if second minimum enemy dist score is greater than 40(multiplayer_spawn_above_opt_enemy_dist_point) meters then give negative score
             (lt, ":second_minimum_enemy_distance", 3000), #3000 x 3000
             (try_begin),
               (gt, ":second_minimum_enemy_distance", multiplayer_spawn_above_opt_enemy_dist_point),
               (val_sub, ":second_minimum_enemy_distance", multiplayer_spawn_above_opt_enemy_dist_point),
               (store_mul, ":second_minimum_enemy_dist_score", ":second_minimum_enemy_distance", -50),
               (val_mul, ":second_minimum_enemy_dist_score", ":num_human_agents_div_3_plus_one"),
               (val_add, ":entry_point_score", ":second_minimum_enemy_dist_score"),
             (try_end),
           (try_end),

           #(assign, reg0, ":minimum_enemy_dist_score"), #close also above assignment lines with these displays
           #(assign, reg1, ":second_minimum_enemy_dist_score"), #close also above assignment lines with these displays
           #(display_message, "@{!}minimum enemy distance : {reg2}, score : {reg0}"), #close also above assignment lines with these displays
           #(display_message, "@{!}second minimum enemy distance : {reg3}, score : {reg1}"), #close also above assignment lines with these displays
         (try_end),

         (try_begin), #giving positive points for "distance of entry point position to ground" while searching for entry point for defender team
           (neq, ":is_horseman", -1), #if being horseman or rider is not (not important)

           #additional score to entry points which has distance to ground value of > 0 meters
           (position_get_distance_to_terrain, ":height_to_terrain", pos0),
           (val_max, ":height_to_terrain", 0),
           (val_min, ":height_to_terrain", 300),
           (ge, ":height_to_terrain", 40),

           (store_mul, ":height_to_terrain_score", ":height_to_terrain", ":num_human_agents_div_3_plus_one"), #it was 8

           (try_begin),
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_team_deathmatch),
             (val_mul, ":height_to_terrain_score", 16),
           (else_try),
             (val_mul, ":height_to_terrain_score", 4),
           (try_end),

           (try_begin),
             (eq, ":is_horseman", 0),
             (try_begin),
               (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege), #but only in siege mod, defender infantries will get positive points for spawning in high places.
               (eq, ":team_no", 0),
               (val_add, ":entry_point_score", ":height_to_terrain_score"),
             (try_end),
           (else_try),
             (val_mul, ":height_to_terrain_score", 5),
             (val_sub, ":entry_point_score", ":height_to_terrain_score"),
           (try_end),
         (try_end),

         (try_begin), #additional random entry point score at deathmatch, teamdethmatch, capture the flag and siege
           (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
           (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_deathmatch),
           (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_duel),
           (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
           (eq, "$g_multiplayer_game_type", multiplayer_game_type_team_deathmatch),
           (try_begin),
             (neq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
             (store_random_in_range, ":random_value", 0, 400),

             (try_begin),
               (eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
               (val_mul, ":random_value", 5),
             (try_end),
           (else_try),
             (eq, ":team_no", 1),
             (store_random_in_range, ":random_value", 0, 600), #siege-attacker
           (else_try),
             (store_random_in_range, ":random_value", 0, 200), #siege-defender
           (try_end),
           (val_mul, ":random_value", ":num_human_agents_div_3_plus_one"),
           (val_add, ":entry_point_score", ":random_value"),
         (try_end),

         (try_begin),
           (this_or_next|eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
           (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),

           (try_begin),
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),
             (try_begin),
               (eq, ":team_no", 0),
               (entry_point_get_position, pos1, multi_base_point_team_1), #our base is at pos1
               (entry_point_get_position, pos2, multi_base_point_team_2), #enemy base is at pos2
             (else_try),
               (entry_point_get_position, pos1, multi_base_point_team_2), #our base is at pos2
               (entry_point_get_position, pos2, multi_base_point_team_1), #enemy base is at pos1
             (try_end),
           (else_try),
             (try_begin), #siege
               (eq, ":team_no", 0),
               (entry_point_get_position, pos1, multi_siege_flag_point), #our base is at pos1 (it was multi_initial_spawn_point_team_1 changed at v622)
               (entry_point_get_position, pos2, multi_initial_spawn_point_team_2), #enemy base is at pos2
             (else_try),
               (entry_point_get_position, pos1, multi_initial_spawn_point_team_2), #our base is at pos2
               (entry_point_get_position, pos2, multi_siege_flag_point), #enemy base is at pos1 (it was multi_initial_spawn_point_team_1 changed at v622)
             (try_end),
           (try_end),

           (try_begin),
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
             (position_get_z, ":pos0_z", pos0),
             (position_set_z, pos1, ":pos0_z"), #make z of our base same with entry point position z
             (position_set_z, pos2, ":pos0_z"), #make z of enemy base same with entry point position z
           (try_end),

           (get_sq_distance_between_positions_in_meters, ":sq_dist_to_our_base", pos0, pos1),
           (get_sq_distance_between_positions_in_meters, ":sq_dist_to_enemy_base", pos0, pos2),
           (get_distance_between_positions_in_meters, ":dist_to_enemy_base", pos0, pos2),

           #give positive points if this entry point is near to our base.
           (assign, ":dist_to_our_base_point", 0),
           (try_begin), #capture the flag (points for being near to base)
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),

             (get_distance_between_positions_in_meters, ":dist_to_our_base", pos0, pos1),
             (lt, ":dist_to_our_base", 100),
             (store_sub, ":dist_to_our_base_point", 100, ":dist_to_our_base"),

             (try_begin), #assign all 75-100's to 75
               (gt, ":dist_to_our_base_point", 75),
               (assign, ":dist_to_our_base_point", 75),
             (try_end),

             (val_mul, ":dist_to_our_base_point", 50), #0..5000 (increase is linear)

             (val_mul, ":dist_to_our_base_point", ":num_human_agents_div_3_plus_one"),
           (else_try), #siege (points for being near to base)
             (lt, ":sq_dist_to_our_base", 10000), #in siege give entry points score until 100m distance is reached
             (try_begin),
               (eq, ":team_no", 0),
               (try_begin),
                 (lt, ":sq_dist_to_our_base", 2500), #if distance is < 50m in siege give all highest point possible
                 (assign, ":sq_dist_to_our_base", 0),
               (else_try),
                 (val_sub, ":sq_dist_to_our_base", 2500),
                 (val_mul, ":sq_dist_to_our_base", 2),
               (try_end),
             (try_end),

             (store_sub, ":dist_to_our_base_point", 10000, ":sq_dist_to_our_base"),

             #can be (10000 - (10000 - 2500) * 2) = -5000 (for only defenders) so we are adding this loss.
             (val_add, ":dist_to_our_base_point", 5000), #so score getting from being near to base changes between 0 to 15000

             (try_begin),
               (eq, ":team_no", 0),
             (else_try), #in siege mod for attackers being near to base entry point has 45 times less importance
               (val_div, ":dist_to_our_base_point", 45),
             (try_end),
             (val_mul, ":dist_to_our_base_point", ":num_human_agents_div_3_plus_one"),
           (try_end),

           (val_add, ":entry_point_score", ":dist_to_our_base_point"),


           #give negative points if this entry point is near to enemy base.
           (assign, ":dist_to_enemy_base_point", 0),
           (try_begin), #capture the flag
             (eq, "$g_multiplayer_game_type", multiplayer_game_type_capture_the_flag),

             (lt, ":dist_to_enemy_base", 150),
             (store_sub, ":dist_to_enemy_base_point", 150, ":dist_to_enemy_base"),

             (try_begin), #assign 150 to 150 + (150 - 50) * 2 = 350, assign 100 to 100 + (100 - 50) * 2 = 200
               (gt, ":dist_to_enemy_base_point", 50),
               (store_sub, ":dist_to_enemy_base_point_minus_50", ":dist_to_enemy_base_point", 50),
               (val_mul, ":dist_to_enemy_base_point_minus_50", 2),
               (val_add, ":dist_to_enemy_base_point", ":dist_to_enemy_base_point_minus_50"),
             (try_end),

             (val_mul, ":dist_to_enemy_base_point", -50), #-7500(with extras 350 * 50 = -17500)..0 (increase is linear)

             (val_mul, ":dist_to_enemy_base_point", ":num_human_agents_div_3_plus_one"),
           (else_try),
             (this_or_next|neq, "$g_multiplayer_game_type", multiplayer_game_type_siege),
             (eq, ":team_no", 1),

             (assign, ":dist_to_enemy_base_point", 0),

             (try_begin),
               (neq, "$g_multiplayer_game_type", multiplayer_game_type_siege),

               (try_begin),
                 (lt, ":sq_dist_to_enemy_base", 10000),
                 (store_sub, ":dist_to_enemy_base_point", 10000, ":sq_dist_to_enemy_base"),
                 (val_div, ":dist_to_enemy_base_point", 4),
                 (val_mul, ":dist_to_enemy_base_point", ":negative_num_human_agents_div_3_plus_one"),
               (try_end),
             (else_try),
               (val_max, ":dist_to_enemy_base", 60), #<60 meters has all most negative score

               (try_begin),
                 (eq, ":is_horseman", 1),
                 (assign, ":optimal_distance", 120),
               (else_try),
                 (assign, ":optimal_distance", 80),
               (try_end),

               (try_begin),
                 (le, ":dist_to_enemy_base", ":optimal_distance"),
                 (store_sub, ":dist_to_enemy_base_point", ":optimal_distance", ":dist_to_enemy_base"),
                 (val_mul, ":dist_to_enemy_base_point", 180), #-3600 max
               (else_try),
                 (store_sub, ":dist_to_enemy_base_point", ":dist_to_enemy_base", ":optimal_distance"),
                 (val_mul, ":dist_to_enemy_base_point", 30), #-unlimited max but lower slope
               (try_end),

               (val_sub, ":dist_to_enemy_base_point", 600),
               (val_max, ":dist_to_enemy_base_point", 0),

               (val_mul, ":dist_to_enemy_base_point", ":negative_num_human_agents_div_3_plus_one"),
             (try_end),
           (try_end),

           (val_add, ":entry_point_score", ":dist_to_enemy_base_point"),
         (else_try),
           (eq, "$g_multiplayer_game_type", multiplayer_game_type_headquarters),

           (try_for_range, ":flag_no", 0, "$g_number_of_flags"),
             (store_add, ":cur_flag_owner_slot", multi_data_flag_owner_begin, ":flag_no"),
             (troop_get_slot, ":cur_flag_owner", "trp_multiplayer_data", ":cur_flag_owner_slot"),
             (neq, ":cur_flag_owner", 0),
             (val_sub, ":cur_flag_owner", 1),

             (scene_prop_get_instance, ":pole_id", "spr_headquarters_pole_code_only", ":flag_no"),
             (prop_instance_get_position, pos1, ":pole_id"), #pos1 holds pole position.

             (get_sq_distance_between_positions_in_meters, ":sq_dist_to_cur_pole", pos0, pos1),
             (lt, ":sq_dist_to_cur_pole", 6400),

             (try_begin),
               (eq, ":cur_flag_owner", ":team_no"),
               (store_sub, ":dist_to_flag_point", 6400, ":sq_dist_to_cur_pole"), #up to 80 meters give positive points if entry point is near our base
               (val_mul, ":dist_to_flag_point", 2),
               (val_div, ":dist_to_flag_point", ":our_flag_count"),
               (val_mul, ":dist_to_flag_point", ":num_human_agents_div_3_plus_one"),
             (else_try),
               (store_sub, ":dist_to_flag_point", 6400, ":sq_dist_to_cur_pole"), #up to 80 meters give negative points if entry point is near enemy base
               (val_mul, ":dist_to_flag_point", 2),
               (val_div, ":dist_to_flag_point", ":enemy_flag_count"),
               (val_mul, ":dist_to_flag_point", ":negative_num_human_agents_div_3_plus_one"),
             (try_end),
             (val_add, ":entry_point_score", ":dist_to_flag_point"),
           (try_end),
         (try_end),

         #(assign, reg1, ":i_entry_point"),
         #(assign, reg2, ":entry_point_score"),
         #(display_message, "@{!}entry_no : {reg1} , entry_score : {reg2}"),

         (gt, ":entry_point_score", ":best_entry_point_score"),
         (assign, ":best_entry_point_score", ":entry_point_score"),
         (assign, ":best_entry_point", ":i_entry_point"),
       (try_end),

       #(assign, reg0, ":best_entry_point"),
       #(assign, reg1, ":best_entry_point_score"),
       #(assign, reg2, ":num_operations"),
       #(assign, reg7, ":is_horseman"),
       #(display_message, "@{!},is horse:{reg7}, best entry:{reg0}, best entry score:{reg1}, num_operations:{reg2}"),
     (try_end),
     (assign, reg0, ":best_entry_point"),
     ]),

  #script_multiplayer_buy_agent_equipment
  # Input: arg1 = player_no
  # Output: none
  ("multiplayer_buy_agent_equipment",
   [
     (store_script_param, ":player_no", 1),
     (player_get_troop_id, ":player_troop", ":player_no"),
     (player_get_gold, ":player_gold", ":player_no"),
     (player_get_slot, ":added_gold", ":player_no", slot_player_last_rounds_used_item_earnings),
     (player_set_slot, ":player_no", slot_player_last_rounds_used_item_earnings, 0),
     (val_add, ":player_gold", ":added_gold"),
     (assign, ":armor_bought", 0),

     #moving original values to temp slots
     (try_for_range, ":i_item", slot_player_selected_item_indices_begin, slot_player_selected_item_indices_end),
       (player_get_slot, ":selected_item_index", ":player_no", ":i_item"),
       (store_sub, ":i_cur_selected_item", ":i_item", slot_player_selected_item_indices_begin),
       (try_begin),
         (player_item_slot_is_picked_up, ":player_no", ":i_cur_selected_item"),
         (assign, ":selected_item_index", -1),
       (try_end),
       (val_add, ":i_cur_selected_item", slot_player_cur_selected_item_indices_begin),
       (player_set_slot, ":player_no", ":i_cur_selected_item", ":selected_item_index"),
     (try_end),
     (assign, ":end_cond", 1000),
     (try_for_range, ":unused", 0, ":end_cond"),
       (call_script, "script_multiplayer_calculate_cur_selected_items_cost", ":player_no", 0),
       (assign, ":total_cost", reg0),
       (try_begin),
         (gt, ":total_cost", ":player_gold"),
         #downgrade one of the selected items
         #first normalize the prices
         #then prioritize some of the weapon classes for specific troop classes
         (call_script, "script_multiplayer_get_troop_class", ":player_troop"),
         (assign, ":player_troop_class", reg0),

         (assign, ":max_cost_value", 0),
         (assign, ":max_cost_value_index", -1),
         (try_for_range, ":i_item", slot_player_cur_selected_item_indices_begin, slot_player_cur_selected_item_indices_end),
           (player_get_slot, ":item_id", ":player_no", ":i_item"),
           (ge, ":item_id", 0), #might be -1 for horses etc.
           (call_script, "script_multiplayer_get_item_value_for_troop", ":item_id", ":player_troop"),
           (assign, ":item_value", reg0),
           (store_sub, ":item_type", ":i_item", slot_player_cur_selected_item_indices_begin),
           (try_begin), #items
             (this_or_next|eq, ":item_type", 0),
             (this_or_next|eq, ":item_type", 1),
             (this_or_next|eq, ":item_type", 2),
             (eq, ":item_type", 3),
             (val_mul, ":item_value", 5),
           (else_try), #head
             (eq, ":item_type", 4),
             (val_mul, ":item_value", 4),
           (else_try), #body
             (eq, ":item_type", 5),
             (val_mul, ":item_value", 2),
           (else_try), #foot
             (eq, ":item_type", 6),
             (val_mul, ":item_value", 8),
           (else_try), #gloves
             (eq, ":item_type", 7),
             (val_mul, ":item_value", 8),
           (else_try), #horse
             #base value (most expensive)
           (try_end),
           (item_get_slot, ":item_class", ":item_id", slot_item_multiplayer_item_class),
           (try_begin),
             (eq, ":player_troop_class", multi_troop_class_infantry),
             (this_or_next|eq, ":item_class", multi_item_class_type_sword),
             (this_or_next|eq, ":item_class", multi_item_class_type_axe),
             (this_or_next|eq, ":item_class", multi_item_class_type_blunt),
             (this_or_next|eq, ":item_class", multi_item_class_type_war_picks),
             (this_or_next|eq, ":item_class", multi_item_class_type_two_handed_sword),
             (this_or_next|eq, ":item_class", multi_item_class_type_small_shield),
             (eq, ":item_class", multi_item_class_type_two_handed_axe),
             (val_div, ":item_value", 2),
           (else_try),
             (eq, ":player_troop_class", multi_troop_class_spearman),
             (this_or_next|eq, ":item_class", multi_item_class_type_spear),
             (eq, ":item_class", multi_item_class_type_large_shield),
             (val_div, ":item_value", 2),
           (else_try),
             (eq, ":player_troop_class", multi_troop_class_cavalry),
             (this_or_next|eq, ":item_class", multi_item_class_type_lance),
             (this_or_next|eq, ":item_class", multi_item_class_type_sword),
             (eq, ":item_class", multi_item_class_type_horse),
             (val_div, ":item_value", 2),
           (else_try),
             (eq, ":player_troop_class", multi_troop_class_archer),
             (this_or_next|eq, ":item_class", multi_item_class_type_bow),
             (eq, ":item_class", multi_item_class_type_arrow),
             (val_div, ":item_value", 2),
           (else_try),
             (eq, ":player_troop_class", multi_troop_class_crossbowman),
             (this_or_next|eq, ":item_class", multi_item_class_type_crossbow),
             (eq, ":item_class", multi_item_class_type_bolt),
             (val_div, ":item_value", 2),
           (else_try),
             (eq, ":player_troop_class", multi_troop_class_mounted_archer),
             (this_or_next|eq, ":item_class", multi_item_class_type_bow),
             (this_or_next|eq, ":item_class", multi_item_class_type_arrow),
             (eq, ":item_class", multi_item_class_type_horse),
             (val_div, ":item_value", 2),
           (else_try),
             (eq, ":player_troop_class", multi_troop_class_mounted_crossbowman),
             (this_or_next|eq, ":item_class", multi_item_class_type_crossbow),
             (this_or_next|eq, ":item_class", multi_item_class_type_bolt),
             (eq, ":item_class", multi_item_class_type_horse),
             (val_div, ":item_value", 2),
           (try_end),

           (try_begin),
             (gt, ":item_value", ":max_cost_value"),
             (assign, ":max_cost_value", ":item_value"),
             (assign, ":max_cost_value_index", ":i_item"),
           (try_end),
         (try_end),

         #max_cost_value and max_cost_value_index will definitely be valid
         #unless no items are left (therefore some items must cost 0 gold)
         (player_get_slot, ":item_id", ":player_no", ":max_cost_value_index"),
         (call_script, "script_multiplayer_get_previous_item_for_item_and_troop", ":item_id", ":player_troop"),
         (assign, ":item_id", reg0),
         (player_set_slot, ":player_no", ":max_cost_value_index", ":item_id"),
       (else_try),
         (assign, ":end_cond", 0),
         (val_sub, ":player_gold", ":total_cost"),
         (player_set_gold, ":player_no", ":player_gold", multi_max_gold_that_can_be_stored),
         (try_for_range, ":i_item", slot_player_cur_selected_item_indices_begin, slot_player_cur_selected_item_indices_end),
           (player_get_slot, ":item_id", ":player_no", ":i_item"),
           #checking if different class default item replace is needed for weapons
           (try_begin),
             (ge, ":item_id", 0),
             #then do nothing
           (else_try),
             (store_sub, ":base_index_slot", ":i_item", slot_player_cur_selected_item_indices_begin),
             (store_add, ":selected_item_index_slot", ":base_index_slot", slot_player_selected_item_indices_begin),
             (player_get_slot, ":selected_item_index", ":player_no", ":selected_item_index_slot"),
             (this_or_next|eq, ":selected_item_index", -1),
             (player_item_slot_is_picked_up, ":player_no", ":base_index_slot"),
             #then do nothing
           (else_try),
             #an item class without a default value is -1, then find a default weapon
             (item_get_slot, ":item_class", ":selected_item_index", slot_item_multiplayer_item_class),
             (is_between, ":item_class", multi_item_class_type_weapons_begin, multi_item_class_type_weapons_end),
             (assign, ":dc_replaced_item", -1),
             (try_for_range, ":i_dc_item_class", multi_item_class_type_melee_weapons_begin, multi_item_class_type_melee_weapons_end),
               (lt, ":dc_replaced_item", 0),
               (assign, ":dc_item_class_used", 0),
               (try_for_range, ":i_dc_item", slot_player_cur_selected_item_indices_begin, slot_player_cur_selected_item_indices_end),
                 (player_get_slot, ":dc_cur_item", ":player_no", ":i_dc_item"),
                 (ge, ":dc_cur_item", 0),
                 (item_get_slot, ":dc_item_class", ":dc_cur_item", slot_item_multiplayer_item_class),
                 (eq, ":dc_item_class", ":i_dc_item_class"),
                 (assign, ":dc_item_class_used", 1),
               (try_end),
               (eq, ":dc_item_class_used", 0),
               (assign, ":dc_end_cond", all_items_end),
               (try_for_range, ":i_dc_new_item", all_items_begin, ":dc_end_cond"),
                 (item_slot_eq, ":i_dc_new_item", slot_item_multiplayer_item_class, ":i_dc_item_class"),
                 (call_script, "script_cf_multiplayer_is_item_default_for_troop", ":i_dc_new_item", ":player_troop"),
                 (assign, ":dc_end_cond", 0), #break
                 (assign, ":dc_replaced_item", ":i_dc_new_item"),
               (try_end),
             (try_end),
             (ge, ":dc_replaced_item", 0),
             (player_set_slot, ":player_no", ":i_item", ":dc_replaced_item"),
             (assign, ":item_id", ":dc_replaced_item"),
           (try_end),

           #finally, add the item to agent
           (try_begin),
             (ge, ":item_id", 0), #might be -1 for horses etc.
             (store_sub, ":item_slot", ":i_item", slot_player_cur_selected_item_indices_begin),
             (player_add_spawn_item, ":player_no", ":item_slot", ":item_id"),
             (try_begin),
               (eq, ":item_slot", ek_body), #ek_body is the slot for armor
               (assign, ":armor_bought", 1),
             (try_end),
           (try_end),
         (try_end),

         (player_set_slot, ":player_no", slot_player_total_equipment_value, ":total_cost"),
       (try_end),
     (try_end),
     (try_begin),
       (eq, ":armor_bought", 0),
       (eq, "$g_multiplayer_force_default_armor", 1),
       (assign, ":end_cond", all_items_end),
       (try_for_range, ":i_new_item", all_items_begin, ":end_cond"),
         (this_or_next|item_slot_eq, ":i_new_item", slot_item_multiplayer_item_class, multi_item_class_type_light_armor),
         (this_or_next|item_slot_eq, ":i_new_item", slot_item_multiplayer_item_class, multi_item_class_type_medium_armor),
         (item_slot_eq, ":i_new_item", slot_item_multiplayer_item_class, multi_item_class_type_heavy_armor),
         (call_script, "script_cf_multiplayer_is_item_default_for_troop", ":i_new_item", ":player_troop"),
         (assign, ":end_cond", 0), #break
         (player_add_spawn_item, ":player_no", ek_body, ":i_new_item"), #ek_body is the slot for armor
       (try_end),
     (try_end),
     ]),

  # script_party_get_ideal_size @used for NPC parties.
  # Input: arg1 = party_no
  # Output: reg0: ideal size
  ("party_get_ideal_size",
    [
      (store_script_param_1, ":party_no"),

      #default limit is 30 for any party
      (assign, ":limit", 30),

      (try_begin),
        (party_slot_eq, ":party_no", slot_party_type, spt_kingdom_hero_party),
        (party_stack_get_troop_id, ":party_leader", ":party_no", 0),
        (store_faction_of_party, ":faction_id", ":party_no"),

        #default limit is 10 for kingdom lords
        (assign, ":limit", 10),

        #each (leadership level) gives 5 to limit
        (store_skill_level, ":skill", "skl_leadership", ":party_leader"),
        (store_attribute_level, ":charisma", ":party_leader", ca_charisma),
        (val_mul, ":skill", 5),
        (val_add, ":limit", ":skill"),

        #each (charisma level) gives 1 to limit
        (val_add, ":limit", ":charisma"),

        #each (25 renown) gives 1 to limit
        (troop_get_slot, ":troop_renown", ":party_leader", slot_troop_renown),
        (store_div, ":renown_bonus", ":troop_renown", 25),
        (val_add, ":limit", ":renown_bonus"),

        ##diplomacy begin
        (assign, ":percent", 100),
        ##diplomacy end

		##diplomacy start+
		#Limit effects of policies for nascent kingdoms.
		(assign, ":policy_min", -3),
		(assign, ":policy_max", 4),#one greater than the maximum

		(try_begin),
			(this_or_next|eq, ":faction_id", "fac_player_supporters_faction"),
				(faction_slot_eq, ":faction_id", slot_faction_leader, "trp_player"),
			(faction_get_slot, ":policy_max", ":faction_id", slot_faction_num_towns),
			(faction_get_slot, reg0, ":faction_id", slot_faction_num_castles),
			(val_add, ":policy_max", reg0),
			(val_clamp, ":policy_max", 0, 4),#0, 1, 2, 3
			(store_mul, ":policy_min", ":policy_max", -1),
			(val_add, ":policy_max", 1),#one greater than the maximum
		(try_end),
		##diplomacy end+

        (try_begin),
          (faction_slot_eq, ":faction_id", slot_faction_leader, ":party_leader"),
          (val_add, ":limit", dplmc_monarch_party_bonus),
          ##diplomacy begin
          (try_begin),
            (faction_get_slot, ":centralization", ":faction_id", dplmc_slot_faction_centralization),
            (neq, ":centralization", 0),
			##diplomacy start+ Apply constraint
			(val_clamp, ":centralization", ":policy_min", ":policy_max"),
			##diplomacy end+
            (val_mul, ":centralization", 10),
            (val_add, ":percent", ":centralization"),
          (try_end),

        (else_try),
          (try_begin),
            (faction_get_slot, ":centralization", ":faction_id", dplmc_slot_faction_centralization),
            (neq, ":centralization", 0),
			##diplomacy start+ Apply constraint
			(val_clamp, ":centralization", ":policy_min", ":policy_max"),
			##diplomacy end+
            (val_mul, ":centralization", -3),
            (val_add, ":percent", ":centralization"),
          (try_end),
          (try_begin),
            (faction_get_slot, ":aristocraty", ":faction_id", dplmc_slot_faction_aristocracy),
            (neq, ":aristocraty", 0),
			##diplomacy start+ Apply constraint
			(val_clamp, ":aristocraty", ":policy_min", ":policy_max"),
			##diplomacy end+
            (val_mul, ":aristocraty", 3),
            (val_add, ":percent", ":aristocraty"),
          (try_end),
          (try_begin),
            (faction_get_slot, ":quality", ":faction_id", dplmc_slot_faction_quality),
            (neq, ":quality", 0),
			##diplomacy start+ Apply constraint
			(val_clamp, ":quality", ":policy_min", ":policy_max"),
			##diplomacy end+
            (val_mul, ":quality", -4),
            (val_add, ":percent", ":quality"),
          (try_end),
          ##diplomacy end
        (try_end),

        ##diplomacy begin
        (try_begin),
          (faction_get_slot, ":serfdom", ":faction_id", dplmc_slot_faction_serfdom),
          (neq, ":serfdom", 0),
		  ##diplomacy start+ Apply constraint
		  (val_clamp, ":serfdom", ":policy_min", ":policy_max"),
		  ##diplomacy end+
          (val_mul, ":serfdom", 2), #SB : description says 1, this used to be 3
          (val_add, ":percent", ":serfdom"),
        (try_end),

        (val_mul, ":limit", ":percent"),
        ##nested diplomacy start+ Round correctly
        (val_add, ":limit", 50),
        ##nested diplomacy end+
        (val_div, ":limit", 100),
        ##diplomacy end

        (try_begin),
          (faction_slot_eq, ":faction_id", slot_faction_marshall, ":party_leader"),
          (val_add, ":limit", dplmc_marshal_party_bonus),
        (try_end),

        #party takes additional 20 limit per each castle its party leader owns
        (try_for_range, ":cur_center", castles_begin, castles_end),
          (party_slot_eq, ":cur_center", slot_town_lord, ":party_leader"),
          (val_add, ":limit", dplmc_castle_party_bonus),
        (try_end),
      ##diplomacy start+
      ##Extend this script so it will also work with garrisons
      (else_try),
         (party_slot_eq, ":party_no", slot_party_type, spt_town),
         (assign, ":limit", 380),#average starting town garrison size
      (else_try),
         (this_or_next|is_between, ":party_no", walled_centers_begin, walled_centers_end),
         (party_slot_eq, ":party_no", slot_party_type, spt_castle),
         (assign, ":limit", 142),#average starting castle garrison size
         #(store_faction_of_party, ":faction_id", ":party_no"),
      ##diplomacy end+
      (try_end),

      #if player has level of 0 then ideal limit will be exactly same, if player has level of 80 then ideal limit will be multiplied by 2 ((80 + 80) / 80)
      #below code will increase limits a little as the game progresses and player gains level
      (store_character_level, ":level", "trp_player"),
      (val_min, ":level", 80),
      (store_add, ":level_factor", 80, ":level"),
      (val_mul, ":limit", ":level_factor"),
      (val_div, ":limit", 80),
      (assign, reg0, ":limit"),
  ]),


  #script_game_get_party_prisoner_limit:
  # This script is called from the game engine when the prisoner limit is needed for a party.
  # INPUT: arg1 = party_no
  # OUTPUT: reg0 = prisoner_limit
  ("game_get_party_prisoner_limit",
    [
#      (store_script_param_1, ":party_no"),
      (assign, ":troop_no", "trp_player"),

      (assign, ":limit", 0),
      (store_skill_level, ":skill", "skl_prisoner_management", ":troop_no"),
      (store_mul, ":limit", ":skill", 5),
      (try_begin), #SB : override with diplomacy_var2
        (eq, "$diplomacy_var", DPLMC_CURRENT_VERSION_CODE),
        (assign, ":limit", "$diplomacy_var2"),
      (try_end),
      (assign, reg0, ":limit"),
      (set_trigger_result, reg0),
  ]),

  #script_game_get_item_extra_text:
  # This script is called from the game engine when an item's properties are displayed.
  # INPUT: arg1 = item_no, arg2 = extra_text_id (this can be between 0-7 (7 included)), arg3 = item_modifier
  # OUTPUT: result_string = item extra text, trigger_result = text color (0 for default)
  ("game_get_item_extra_text",
    [
      (store_script_param, ":item_no", 1),
      (store_script_param, ":extra_text_id", 2),
      (store_script_param, ":item_modifier", 3),
      (try_begin),
        (is_between, ":item_no", "itm_raw_date_fruit", food_end),
        (neq, ":item_no", "itm_furs"),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (assign, ":continue", 1),
          (try_begin),
            (this_or_next|eq, ":item_no", "itm_cattle_meat"),
            (this_or_next|eq, ":item_no", "itm_pork"),
            (eq, ":item_no", "itm_chicken"),

            (eq, ":item_modifier", imod_rotten),
            (assign, ":continue", 0),
          (try_end),
          (eq, ":continue", 1),
          (item_get_slot, ":food_bonus", ":item_no", slot_item_food_bonus),
          (assign, reg1, ":food_bonus"),
          (set_result_string, "@+{reg1} to party morale"),
          (set_trigger_result, 0x4444FF),
        (else_try),
          (eq, ":extra_text_id", 1),
          (assign, ":quest_no", -1), #no quest selected
          (try_begin),
            (check_quest_active, "qst_deliver_wine"),
            (quest_slot_eq, "qst_deliver_wine", slot_quest_target_item, ":item_no"),
            (assign, ":quest_no", "qst_deliver_wine"),
            (quest_get_slot, ":quest_target_center", ":quest_no", slot_quest_target_center),
          (try_end),

          (try_begin), #prioritize town missions
            (eq, ":quest_no", -1),
            (check_quest_active, "qst_deliver_grain"),
            (quest_slot_eq, "qst_deliver_grain", slot_quest_target_item, ":item_no"),
            (assign, ":quest_no", "qst_deliver_grain"),
            (quest_get_slot, ":quest_target_center", ":quest_no", slot_quest_giver_center),
          (try_end),
          (neq, ":item_modifier", imod_rotten),
          (neq, ":quest_no", -1),
          (quest_get_slot, reg5, ":quest_no", slot_quest_target_amount),
          #probably do a x/n items counter here or something
          (str_store_party_name, s5, ":quest_target_center"),
          (set_result_string, "@Deliver {reg5} units to {s5}"),
          (set_trigger_result, message_alert),
        (try_end),
      (else_try),
        (is_between, ":item_no", readable_books_begin, readable_books_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (item_get_slot, reg1, ":item_no", slot_item_intelligence_requirement),
          (set_result_string, "@Requires {reg1} intelligence to read"),
          (set_trigger_result, 0xFFEEDD),
        (else_try),
          (eq, ":extra_text_id", 1),
          (item_get_slot, ":progress", ":item_no", slot_item_book_reading_progress),
          (val_div, ":progress", 10),
          (assign, reg1, ":progress"),
          (set_result_string, "@Reading Progress: {reg1}%"),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),
        (is_between, ":item_no", reference_books_begin, reference_books_end),
        (try_begin),
          (eq, ":extra_text_id", 0),
          (try_begin),
            (eq, ":item_no", "itm_book_wound_treatment_reference"),
            (str_store_string, s1, "@wound treament"),
          (else_try),
            (eq, ":item_no", "itm_book_training_reference"),
            (str_store_string, s1, "@trainer"),
          (else_try),
            (eq, ":item_no", "itm_book_surgery_reference"),
            (str_store_string, s1, "@surgery"),
          (try_end),
          (set_result_string, "@+1 to {s1} while in inventory"),
          (set_trigger_result, 0xFFEEDD),
        (try_end),
      (else_try),

      # sb : debug
        (try_begin),
          (ge, "$cheat_mode", 1),
          (eq, ":extra_text_id", 4),
          (call_script, "script_dplmc_get_item_value_with_imod", ":item_no", ":item_modifier"),
          (assign, ":value", reg0),
          (call_script, "script_dplmc_get_item_score_with_imod", ":item_no", ":item_modifier"),
          (store_div, reg1, ":value", 100),
          (set_result_string, "@item score:{reg0}, value:{reg1}"),
          (set_trigger_result, 0x0DDEEE),
        (try_end),

        (try_begin), #SB : display this block when in item pool mode
          (eq, ":extra_text_id", 2),
          (eq, "$pool_troop", "trp_temp_troop"), #new exit code resets condition
          (this_or_next|eq, "$lord_selected", "trp_player"),
          (is_between, "$lord_selected", companions_begin, companions_end),
          (call_script, "script_item_get_type_aux", ":item_no"),
          (assign, ":meta_type", reg0),
          (gt, ":meta_type", meta_itp_mask), #has a valid meta-type
          (assign, ":string", "str_empty_string"),
          (try_begin), #doesn't need it, Native item type already shows
            # (eq, ":meta_type", dplmc_itp_morningstar),
            # (assign, ":string", "str_dplmc_hero_wpn_slot_two_handed_one_handed"),
          # (else_try),
            (eq, ":meta_type", dplmc_itp_lance),
            (assign, ":string", "str_dplmc_hero_wpn_slot_lance"),
          (else_try),
            (eq, ":meta_type", dplmc_itp_pike),
            (assign, ":string", "str_dplmc_hero_wpn_slot_pikes"),
          (else_try),
            (eq, ":meta_type", dplmc_itp_halberd),
            (assign, ":string", "str_dplmc_hero_wpn_slot_halberd"),
          (try_end),
          (gt, ":string", "str_empty_string"), #could use directly
          (set_result_string, ":string"),
          (set_trigger_result, 0xDDEEFF),
        (try_end),
      (try_end),

  ]),

  #script_game_on_disembark:
  # This script is called from the game engine when the player reaches the shore with a ship.
  # INPUT: pos0 = disembark position
  # OUTPUT: none
  ("game_on_disembark",
   [(jump_to_menu, "mnu_disembark"),
  ]),


  #script_game_context_menu_get_buttons:
  # This script is called from the game engine when the player clicks the right mouse button over a party on the map.
  # INPUT: arg1 = party_no
  # OUTPUT: none, fills the menu buttons
  ("game_context_menu_get_buttons",
   [
     (store_script_param, ":party_no", 1),
     (try_begin),
       (neq, ":party_no", "p_main_party"),
       (context_menu_add_item, "@Move here", cmenu_move),
     (try_end),

     (try_begin),
       (is_between, ":party_no", centers_begin, centers_end),
       (context_menu_add_item, "@View notes", cmenu_notes),
     (else_try),
       (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
       (gt, ":num_stacks", 0),
       (party_stack_get_troop_id, ":troop_no", ":party_no", 0),
       ##diplomacy start+ support for promoted kingdom ladies
       (is_between, ":troop_no", heroes_begin, heroes_end),
       (this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
       ##diplomacy end+
       (is_between, ":troop_no", active_npcs_begin, active_npcs_end),
       (context_menu_add_item, "@View notes", cmenu_notes), #move this to same slot
       # Lav modifications start (custom lord notes)
       (context_menu_add_item, "@Add custom note", 3),
       # Lav modifications end (custom lord notes)
     (try_end),

     (try_begin),
       (neq, ":party_no", "p_main_party"),
       (store_faction_of_party, ":party_faction", ":party_no"),

       (this_or_next|eq, ":party_faction", "$players_kingdom"),
       (this_or_next|eq, ":party_faction", "fac_player_supporters_faction"),
       (party_slot_eq, ":party_no", slot_party_type, spt_kingdom_caravan),

       (neg|is_between, ":party_no", centers_begin, centers_end),

       (context_menu_add_item, "@Accompany", cmenu_follow),
     (try_end),

      #SB : debug cheats
      (try_begin),
        (ge, "$cheat_mode", 1),
        (try_begin),
           (neq, ":party_no", "p_main_party"),
           (context_menu_add_item, "@Attach", cmenu_attach),
           # (context_menu_add_item, "@Reinforce", cmenu_reinforce),
           (context_menu_add_item, "@Inspect", cmenu_encounter),
           # (context_menu_add_item, "@Exchange", cmenu_exchange),
        (try_end),
        (try_begin),
          (party_get_num_attached_parties, ":num_attached", ":party_no"),
          (gt, ":num_attached", 0),
          (try_begin),
            (eq, ":party_no", "p_main_party"),
            (party_get_attached_party_with_rank, ":attached_party", "p_main_party", 0),
            (str_store_party_name, s1, ":attached_party"),
            (set_fixed_point_multiplier, 1000),
            (party_get_position, pos1, ":party_no"),
            (position_get_x, reg1, pos1),
            (position_get_y, reg2, pos1),
            (context_menu_add_item, "@Detach {s1} at {reg1},{reg2}", cmenu_attach),
          (try_end),
          (context_menu_add_item, "@Detach All", cmenu_detach),
        (try_end),

        (try_begin),
          (party_get_battle_opponent, ":other_party", ":party_no"),
          (party_is_active, ":other_party"),
          (context_menu_add_item, "@Win Battle", cmenu_winbattle),
          (context_menu_add_item, "@Lose Battle", cmenu_losebattle),
        # (else_try),
          # (context_menu_add_item, "@Wound All", cmenu_wound),
          # (context_menu_add_item, "@Heal All", cmenu_heal),
        (try_end),

        # (try_begin),
          # (is_between, ":party_no", centers_begin, centers_end),
          # (context_menu_add_item, "@Spawn Bandits", cmenu_spawnbandit),
        # (try_end),
      (try_end),
  ]),

  #script_game_event_context_menu_button_clicked:
  # This script is called from the game engine when the player clicks on a button at the right mouse menu.
  # INPUT: arg1 = party_no, arg2 = button_value
  # OUTPUT: none
  ("game_event_context_menu_button_clicked",
   [(store_script_param, ":party_no", 1),
    (store_script_param, ":button_value", 2),
    (try_begin),
      (eq, ":button_value", cmenu_notes),
      #SB : unify this under a single constant
      (try_begin),
        (is_between, ":party_no", centers_begin, centers_end),
        (change_screen_notes, 3, ":party_no"),
      (else_try),
        (party_stack_get_troop_id, ":troop_no", ":party_no", 0),
        (change_screen_notes, 1, ":troop_no"),
      (try_end),
    (else_try), #SB : lots of cheats
      (eq, ":button_value", cmenu_attach),
      (try_begin),
        (neq, ":party_no", "p_main_party"),
        (party_set_next_battle_simulation_time, ":party_no", -1),
        (party_leave_cur_battle, ":party_no"),
        (party_set_flags, ":party_no", pf_is_static, 0),
        (party_attach_to_party, ":party_no", "p_main_party"),
      (else_try),
        (party_get_attached_party_with_rank, ":attached_party", "p_main_party", 0),
        (party_get_position, pos1, "p_main_party"),
        (party_detach, ":attached_party"),
        (party_set_position, ":attached_party", pos1),
        (try_begin),
          (is_between, ":attached_party", centers_begin, centers_end),
          (party_set_flags, ":attached_party", pf_is_static, 1),
        (try_end),
      (try_end),
    (else_try),
      (eq, ":button_value", cmenu_detach),
      (party_get_num_attached_parties, ":num_stacks", ":party_no"),
      (try_for_range_backwards, ":stacks", 0, ":num_stacks"),
        (party_get_attached_party_with_rank, ":attached_party", ":party_no", ":stacks"),
        (party_detach, ":attached_party"),
        (party_set_ai_behavior, ":attached_party", ai_bhvr_hold),
        (party_set_flags, ":attached_party", pf_default_behavior, 1),
        (party_relocate_near_party, ":attached_party", ":party_no", 3),
        (try_begin),
          (is_between, ":attached_party", centers_begin, centers_end),
          (party_set_flags, ":attached_party", pf_is_static, 1),
        (try_end),
      (try_end),
    (else_try),
      (eq, ":button_value", cmenu_encounter),
      (assign, "$new_encounter", 2), #this lets us branch to a different menu
      (start_encounter, ":party_no"),
      # (set_encountered_party, ":party_no"),
      # (assign, "$g_encountered_party", ":party_no"),
      # (change_screen_exchange_with_party, ":party_no"),
      # (jump_to_menu, "mnu_auto_return"),
    # (else_try),
      # (eq, ":button_value", cmenu_encounter),
      # (start_encounter, ":party_no"),
    # (else_try),
      # (eq, ":button_value", cmenu_spawnbandit),
      # (set_spawn_radius, 25),
      # (try_for_range, ":unused", 0, 10),
        # (store_random_in_range, ":party_template", bandit_party_templates_begin, bandit_party_templates_end),
        # (spawn_around_party, ":party_no", ":party_template"),
      # (try_end),
      #(call_script, "script_update_bandit_pressure"),
    (else_try), #too lazy to invoke magical commands, screw around with composition
      (eq, ":button_value", cmenu_losebattle),
      (call_script, "script_party_wound_all_members", ":party_no"),
      (party_set_next_battle_simulation_time, ":party_no", -1),
    (else_try), #winning is half the battle
      (eq, ":button_value", cmenu_winbattle),
      (party_get_battle_opponent, ":other_party", ":party_no"),
      (call_script, "script_party_wound_all_members", ":other_party"),
      (party_set_next_battle_simulation_time, ":party_no", 0),
    ## Moved the following to a menu instead
    # (else_try), #refill or double-up
      # (eq, ":button_value", cmenu_reinforce),
      # (store_faction_of_party, ":faction_no", ":party_no"),
      # (try_begin), #
        # (is_between, ":party_no", villages_begin, villages_end),
        # (party_add_template, ":party_no", "pt_village_defenders"),
      # (else_try),
        # (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        # (call_script, "script_cf_reinforce_party", ":party_no"),
      # (else_try),
        # (eq, ":faction_no", "fac_deserters"),
        # (party_stack_get_troop_id, ":troop_id", ":party_no", 0),
        # (store_faction_of_troop, ":faction_no", ":troop_id"),
        # (store_random_in_range, ":slot_no", slot_faction_reinforcements_a, slot_faction_num_armies),
        # (faction_get_slot, ":party_template", ":faction_no", ":slot_no"),
        # (party_add_template, ":party_no", ":party_template"),
      # (else_try),
        # # (this_or_next|eq, ":faction_no", "fac_outlaws"),
        # # (is_between, ":faction_no", bandit_factions_begin, bandit_factions_end),
        # (party_get_template_id, ":party_template", ":party_no"),
        # (party_add_template, ":party_no", ":party_template"),
      # (try_end),
    # (else_try),
      # (eq, ":button_value", cmenu_wound),
      # (call_script, "script_party_wound_all_members", ":party_no"),
    # (else_try),
      # (eq, ":button_value", cmenu_heal),
      # # (heal_party, ":party_no"), #this does NOT work, any calls will only affect the main party
      # (try_begin),
        # (eq, ":party_no", "p_main_party"),
        # (heal_party, "p_main_party"),
      # (else_try),
        # (call_script, "script_party_heal_all_members_aux", ":party_no"),
      # (try_end),
    (try_end),
  ]),

  #script_game_get_skill_modifier_for_troop
  # This script is called from the game engine when a skill's modifiers are needed
  # INPUT: arg1 = troop_no, arg2 = skill_no
  # OUTPUT: trigger_result = modifier_value
  ("game_get_skill_modifier_for_troop",
   [(store_script_param, ":troop_no", 1),
    (store_script_param, ":skill_no", 2),
    (assign, ":modifier_value", 0),
    (try_begin),
      (eq, ":skill_no", "skl_wound_treatment"),
      (call_script, "script_get_troop_item_amount", ":troop_no", "itm_book_wound_treatment_reference"),
      (gt, reg0, 0),
      (val_add, ":modifier_value", 1),
    (else_try),
      (eq, ":skill_no", "skl_trainer"),
      (call_script, "script_get_troop_item_amount", ":troop_no", "itm_book_training_reference"),
      (gt, reg0, 0),
      (val_add, ":modifier_value", 1),
    (else_try),
      (eq, ":skill_no", "skl_surgery"),
      (call_script, "script_get_troop_item_amount", ":troop_no", "itm_book_surgery_reference"),
      (gt, reg0, 0),
      (val_add, ":modifier_value", 1),
    (try_end),
    (set_trigger_result, ":modifier_value"),
    ]),

# Note to modders: Uncomment these if you'd like to use the following.

##  #script_game_check_party_sees_party
##  # This script is called from the game engine when a party is inside the range of another party
##  # INPUT: arg1 = party_no_seer, arg2 = party_no_seen
##  # OUTPUT: trigger_result = true or false (1 = true, 0 = false)
##  ("game_check_party_sees_party",
##   [
##     (store_script_param, ":party_no_seer", 1),
##     (store_script_param, ":party_no_seen", 2),
##     (set_trigger_result, 1),
##    ]),
##

##diplomacy start+
#Enable script_game_check_party_sees_party to prevent compassionate lords from
#attacking villagers and merchant caravans.

#script_game_check_party_sees_party
# This script is called from the game engine when a party is inside the range of another party
# INPUT: arg1 = party_no_seer, arg2 = party_no_seen
# OUTPUT: trigger_result = true or false (1 = true, 0 = false)
	("game_check_party_sees_party",
	[
	(store_script_param_1, ":party_no_seer"),
	(store_script_param_2, ":party_no_seen"),

	(assign, ":trigger_result", 1),
	(assign, ":save_reg0", reg0),

	#Lords who dislike raiding caravans should not attack village_farmer or kingdom_caravan
	#parties.  Achieve this by stopping them from seeing them.
	(try_begin),
		(gt, ":party_no_seer", spawn_points_end),
		(gt, ":party_no_seen", spawn_points_end),

		#Only apply this when the "seer" is a kingdom hero party
		(party_slot_eq, ":party_no_seer", slot_party_type, spt_kingdom_hero_party),

		#Only needed if the seen party is of a hostile faction
		(call_script, "script_get_relation_between_parties", ":party_no_seer", ":party_no_seen"),
		(lt, reg0, 0),

		#Only apply this when the seen party is a merchant caravan or villagers
		(party_get_template_id, ":template", ":party_no_seen"),
		(this_or_next|party_slot_eq, ":party_no_seen", slot_party_type, spt_kingdom_caravan),
		(this_or_next|party_slot_eq,":party_no_seen", slot_party_type, dplmc_spt_gift_caravan),#custom diplomacy caravan
		(this_or_next|eq,":template", "pt_refugees"),
			(party_slot_eq, ":party_no_seen", slot_party_type, spt_village_farmer),

		#Never apply this when the seen party is engaging in hostile actions
		(party_get_battle_opponent, reg0, ":party_no_seen"),
		(lt, reg0, 0),
		(neg|party_slot_eq, ":party_no_seen", slot_party_ai_state, spai_besieging_center),
		(neg|party_slot_eq, ":party_no_seen", slot_party_ai_state, spai_raiding_around_center),
		(neg|party_slot_eq, ":party_no_seen", slot_party_ai_state, spai_engaging_army),
		(neg|party_slot_eq, ":party_no_seen", slot_party_ai_state, spai_accompanying_army),
		(neg|party_slot_eq, ":party_no_seen", slot_party_ai_state, spai_screening_army),


		#Only apply this when the leader is tmt_humanitarian, lrep_benefactor, or lrep_moralist
		(party_get_num_companion_stacks, ":num_stacks", ":party_no_seer"),
		(ge, ":num_stacks", 1),
		(party_stack_get_troop_id, ":leader", ":party_no_seer", 0),
		(ge, ":leader", 1),
		(troop_is_hero, ":leader"),
		(call_script, "script_dplmc_get_troop_morality_value", ":leader", tmt_humanitarian),
		(ge, reg0, 0),# (never apply for leaders who like raiding caravans and attacking villagers)
		(this_or_next|ge, reg0, 1),
		(this_or_next|troop_slot_eq, ":leader", slot_lord_reputation_type, lrep_benefactor),
			(troop_slot_eq, ":leader", slot_lord_reputation_type, lrep_moralist),
		(assign, ":trigger_result", 0),
	(try_end),

	(assign, reg0, ":save_reg0"),
	(set_trigger_result, ":trigger_result"),
	]),
##diplomacy end+

##  #script_game_check_party_sees_party
##  # This script is called from the game engine when a party is inside the range of another party
##  # INPUT: arg1 = party_no_seer, arg2 = party_no_seen
##  # OUTPUT: trigger_result = true or false (1 = true, 0 = false)
##  ("game_check_party_sees_party",
##   [
##     (store_script_param, ":party_no_seer", 1),
##     (store_script_param, ":party_no_seen", 2),
##     (set_trigger_result, 1),
##    ]),
##diplomacy begin
  #script_game_get_party_speed_multiplier
  # This script is called from the game engine when a skill's modifiers are needed
  # INPUT: arg1 = party_no
  # OUTPUT: trigger_result = multiplier (scaled by 100, meaning that giving 100 as the trigger result does not change the party speed)
("game_get_party_speed_multiplier",
  [
    (store_script_param_1, ":party_no"),

    (assign,":speed_multiplier",100),

    (try_begin),
      #(this_or_next|eq,":party_no","p_main_party"),
      (party_slot_eq, ":party_no", slot_party_type, spt_kingdom_hero_party),
      (party_get_skill_level, ":pathfinding_skill", ":party_no", skl_pathfinding),
      (val_mul,":pathfinding_skill",3),
      (val_add,":speed_multiplier",":pathfinding_skill"),
    (try_end),

    (try_begin),
      #(party_has_flag, ":party_no", pf_is_ship),
      (party_get_slot, ":ship_type", ":party_no", slot_party_ship_type),
      (gt, ":ship_type", 0),
      (try_begin),
        (eq, ":ship_type", 1),
        (val_add, ":speed_multiplier", 15),
      (else_try),
        (eq, ":ship_type", 2),
        (val_add, ":speed_multiplier", 20),
      (else_try),
        (eq, ":ship_type", 3),
        (val_add, ":speed_multiplier", 5),
      (else_try),
        (eq, ":ship_type", 4),
        (val_add, ":speed_multiplier", 10),
      (try_end),
    (try_end),

    # (try_begin),
      # (eq,":party_no","p_main_party"),
      # (eq,"$g_move_fast", 1),
      # (val_mul,":speed_multiplier",2),
    # (try_end),

    (try_begin),
        (get_party_ai_behavior, ":behavior", ":party_no"),
        (eq, ":behavior", ai_bhvr_driven_by_party),
        (val_add,":speed_multiplier",10),
    (try_end),

    (val_max, ":speed_multiplier", 0),
    (set_trigger_result, ":speed_multiplier"),
   ]),
##diplomacy end

  # script_npc_get_troop_wage
  # This script is called from module system to calculate troop wages for npc parties.
  # Input:
  # param1: troop_id
  # Output: reg0: weekly wage

  ("npc_get_troop_wage",
    [
      (store_script_param_1, ":troop_id"),
      (assign,":wage", 0),
      (try_begin),
        (troop_is_hero, ":troop_id"),
      (else_try),
        (store_character_level, ":wage", ":troop_id"),
        (val_mul, ":wage", ":wage"),
        (val_add, ":wage", 50),
        (val_div, ":wage", 30),
        (troop_is_mounted, ":troop_id"),
        (val_mul, ":wage", 5),
        (val_div, ":wage", 4),
      (try_end),
      (assign, reg0, ":wage"),
  ]),

  #script_setup_talk_info
  # INPUT: $g_talk_troop, $g_talk_troop_relation
  ("setup_talk_info",
    [
      # ##diplomacy start+ Ensure $character_gender is set correctly (it should have been set during character creation)
      # (try_begin),
         # (call_script, "script_cf_dplmc_troop_is_female", "trp_player"),
         # (assign, "$character_gender", tf_female),
      # (else_try),
         # (assign, "$character_gender", tf_male),
      # (try_end),
      # ##diplomacy end+
      #SB : redo order
      (talk_info_set_relation_bar, "$g_talk_troop_relation"),
      (str_store_troop_name, s61, "$g_talk_troop"),
      # (str_store_string, s61, "@{!} {s61}"),
      (assign, reg1, "$g_talk_troop_relation"),
      # (str_store_string, s62, "str_relation_reg1"),
      (talk_info_set_line, 0, "@{!} {s61}"),
      (talk_info_set_line, 1, "str_relation_reg1"),
      (call_script, "script_describe_relation_to_s63", "$g_talk_troop_relation"),
      (talk_info_set_line, 3, s63),
  ]),

#NPC companion changes begin
  #script_setup_talk_info_companions
  ("setup_talk_info_companions",
    [
      ##diplomacy start+ Ensure $character_gender is set correctly (it should have been set during character creation)
      (try_begin),
         (call_script, "script_cf_dplmc_troop_is_female", "trp_player"),
	     (assign, "$character_gender", 1),
      (else_try),
	     (assign, "$character_gender", 0),
      (try_end),
	  ##diplomacy end+
      (call_script, "script_dplmc_npc_morale", "$g_talk_troop", 1), #SB : number + bar string in s63
      (assign, ":troop_morale", reg0),
      (talk_info_set_relation_bar, ":troop_morale"),
      (talk_info_set_line, 3, s63),

      (str_store_troop_name, s61, "$g_talk_troop"),
      (talk_info_set_line, 0, s61),
      # (str_store_string, s61, "@{!} {s61}"),
      (assign, reg1, ":troop_morale"),
      (str_store_string, s62, "str_morale_reg1"),
      (talk_info_set_line, 1, s62),
  ]),
#NPC companion changes end

  #script_update_party_creation_random_limits
  # INPUT: none
  ("update_party_creation_random_limits",
    [
      (store_character_level, ":player_level", "trp_player"),
      (store_mul, ":upper_limit", ":player_level", 3),
      (val_add, ":upper_limit", 25),
      (val_min, ":upper_limit", 100),
      (set_party_creation_random_limits, 0, ":upper_limit"),
      (assign, reg0, ":upper_limit"),
  ]),

  #script_set_trade_route_between_centers
  # INPUT:
  # param1: center_no_1
  # param1: center_no_2
  ("set_trade_route_between_centers",
    [(store_script_param, ":center_no_1", 1),
     (store_script_param, ":center_no_2", 2),
     (assign, ":center_1_added", 0),
     (assign, ":center_2_added", 0),
     (try_for_range, ":cur_slot", slot_town_trade_routes_begin, slot_town_trade_routes_end),
       (try_begin),
         (eq, ":center_1_added", 0),
         (party_slot_eq, ":center_no_1", ":cur_slot", 0),
         (party_set_slot, ":center_no_1", ":cur_slot", ":center_no_2"),
         (assign, ":center_1_added", 1),
       (try_end),
       (try_begin),
         (eq, ":center_2_added", 0),
         (party_slot_eq, ":center_no_2", ":cur_slot", 0),
         (party_set_slot, ":center_no_2", ":cur_slot", ":center_no_1"),
         (assign, ":center_2_added", 1),
       (try_end),
     (try_end),
     (try_begin),
       (eq, ":center_1_added", 0),
       (str_store_party_name, s1, ":center_no_1"),
       (display_message, "@{!}DEBUG -- ERROR: More than 15 trade routes are given for {s1}."),
     (try_end),
     (try_begin),
       (eq, ":center_2_added", 0),
       (str_store_party_name, s1, ":center_no_2"),
       (display_message, "@{!}DEBUG -- ERROR: More than 15 trade routes are given for {s1}."),
     (try_end),
     ]),

  #script_center_change_trade_good_production
  # INPUT:
  # param1: center_no
  # param2: item_id
  # param3: production_rate (should be between -100 (for net consumption) and 100 (for net production)
  # param4: randomness (between 0-100)
  #("center_change_trade_good_production",
  #  [
#	  (display_message, "@CHANGING"),
#      (store_script_param, ":center_no", 1),
#      (store_script_param, ":item_no", 2),
#      (store_script_param, ":production_rate", 3),
#      (store_script_param, ":randomness", 4),
#      (store_random_in_range, ":random_num", 0, ":randomness"),
#      (store_random_in_range, ":random_sign", 0, 2),
#      (try_begin),
#        (eq, ":random_sign", 0),
#        (val_add, ":production_rate", ":random_num"),
#      (else_try),
#        (val_sub, ":production_rate", ":random_num"),
#      (try_end),
#      (val_sub, ":item_no", trade_goods_begin),
#      (val_add, ":item_no", slot_town_trade_good_productions_begin),
#
#      (party_get_slot, ":old_production_rate", ":center_no", ":item_no"),
#      (val_add, ":production_rate", ":old_production_rate"),
#      (party_set_slot, ":center_no", ":item_no", ":production_rate"),
#  ]),




  ("average_trade_good_prices", #Called from start
    [

	#This should be done by route rather than distance
      (store_sub, ":item_to_slot", slot_town_trade_good_prices_begin, trade_goods_begin),

      (try_for_range, ":center_no", towns_begin, towns_end),
        (this_or_next|is_between, ":center_no", towns_begin, towns_end),
		(is_between, ":center_no", villages_begin, villages_end),

        (try_for_range, ":other_center", centers_begin, centers_end),
          (this_or_next|is_between, ":center_no", towns_begin, towns_end),
		  (is_between, ":center_no", villages_begin, villages_end),

          (neq, ":other_center", ":center_no"),
          (store_distance_to_party_from_party, ":cur_distance", ":center_no", ":other_center"),
          (lt, ":cur_distance", 50), #Reduced from 110
          (store_sub, ":dist_factor", 50, ":cur_distance"),

          (try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
            (store_add, ":cur_good_slot", ":cur_good", ":item_to_slot"),
            (party_get_slot, ":center_price", ":center_no", ":cur_good_slot"),
            (party_get_slot, ":other_center_price", ":other_center", ":cur_good_slot"),
            (store_sub, ":price_dif", ":center_price", ":other_center_price"),

            (assign, ":price_dif_change", ":price_dif"),

            (val_mul ,":price_dif_change", ":dist_factor"),
            (val_div ,":price_dif_change", 1000), #Maximum of 1/20 per center
            (val_add, ":other_center_price", ":price_dif_change"),
            (party_set_slot, ":other_center", ":cur_good_slot", ":other_center_price"),

            (val_sub, ":center_price", ":price_dif_change"),
            (party_set_slot, ":center_no", ":cur_good_slot", ":center_price"),
          (try_end),
        (try_end),
      (try_end),
  ]),

  ("average_trade_good_prices_2", #Called from start
    [

	#This should be done by route rather than distance
      (store_sub, ":item_to_slot", slot_town_trade_good_prices_begin, trade_goods_begin),

      (try_for_range, ":center_no", towns_begin, towns_end),
        (try_for_range, ":other_center", centers_begin, centers_end),
          (this_or_next|is_between, ":other_center", towns_begin, towns_end),
			(is_between, ":other_center", villages_begin, villages_end),

		  (this_or_next|party_slot_eq, ":other_center", slot_village_market_town, ":center_no"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_1, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_2, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_3, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_4, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_5, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_6, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_7, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_8, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_9, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_10, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_11, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_12, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_13, ":other_center"),
		  (this_or_next|party_slot_eq, ":center_no", slot_town_trade_route_14, ":other_center"),
			(party_slot_eq, ":center_no", slot_town_trade_route_15, ":other_center"),

#          (neq, ":other_center", ":center_no"),
#          (store_distance_to_party_from_party, ":cur_distance", ":center_no", ":other_center"),
#          (lt, ":cur_distance", 50), #Reduced from 110
#          (store_sub, ":dist_factor", 50, ":cur_distance"),

          (try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
            (store_add, ":cur_good_slot", ":cur_good", ":item_to_slot"),
            (party_get_slot, ":center_price", ":center_no", ":cur_good_slot"),
            (party_get_slot, ":other_center_price", ":other_center", ":cur_good_slot"),
            (store_sub, ":price_dif", ":center_price", ":other_center_price"),

			(store_div, ":price_dif_change", ":price_dif", 5), #this is done twice, reduced from 4
#            (assign, ":price_dif_change", ":price_dif"),

#            (val_mul ,":price_dif_change", ":dist_factor"),
#            (val_div ,":price_dif_change", 500), #Maximum of 1/10 per center
            (val_add, ":other_center_price", ":price_dif_change"),
            (party_set_slot, ":other_center", ":cur_good_slot", ":other_center_price"),

            (val_sub, ":center_price", ":price_dif_change"),
            (party_set_slot, ":center_no", ":cur_good_slot", ":center_price"),

          (try_end),
        (try_end),
      (try_end),
  ]),



  #script_average_trade_good_productions
  # INPUT: none (called only from game start?)
  #This is currently deprecated, as I was going to try to fine-tune production
  ("average_trade_good_productions",
    [
      (store_sub, ":item_to_slot", slot_town_trade_good_productions_begin, trade_goods_begin),
      (try_for_range, ":center_no", towns_begin, towns_end),
        (this_or_next|is_between, ":center_no", towns_begin, towns_end),
        (is_between, ":center_no", villages_begin, villages_end),
        (try_for_range, ":other_center", centers_begin, centers_end),
          (this_or_next|is_between, ":center_no", towns_begin, towns_end),
          (is_between, ":center_no", villages_begin, villages_end),
          (neq, ":other_center", ":center_no"),
          (store_distance_to_party_from_party, ":cur_distance", ":center_no", ":other_center"),
          (lt, ":cur_distance", 110),
          (store_sub, ":dist_factor", 110, ":cur_distance"),
          (try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
            (store_add, ":cur_good_slot", ":cur_good", ":item_to_slot"),
            (party_get_slot, ":center_production", ":center_no", ":cur_good_slot"),
            (party_get_slot, ":other_center_production", ":other_center", ":cur_good_slot"),
            (store_sub, ":prod_dif", ":center_production", ":other_center_production"),
            (gt, ":prod_dif", 0),
            (store_mul, ":prod_dif_change", ":prod_dif", 1),
##            (try_begin),
##              (is_between, ":center_no", towns_begin, towns_end),
##              (is_between, ":other_center", towns_begin, towns_end),
##              (val_mul, ":cur_distance", 2),
##            (try_end),
            (val_mul ,":prod_dif_change", ":dist_factor"),
            (val_div ,":prod_dif_change", 110),
            (val_add, ":other_center_production", ":prod_dif_change"),
            (party_set_slot, ":other_center", ":cur_good_slot", ":other_center_production"),
          (try_end),
        (try_end),
      (try_end),
  ]),

  #script_normalize_trade_good_productions
  #Adjusts productions according to the amount of the item produced
  # INPUT: none
  # This currently deprecated, as I was going to try to fine-tune productions
  ("normalize_trade_good_productions",
    [
      (store_sub, ":item_to_slot", slot_town_trade_good_productions_begin, trade_goods_begin),
      (try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
        (assign, ":total_production", 0),
        (assign, ":num_centers", 0),
        (store_add, ":cur_good_slot", ":cur_good", ":item_to_slot"),
        (try_for_range, ":center_no", centers_begin, centers_end),
          (val_add, ":num_centers", 1),
          (try_begin),
            (is_between, ":center_no", towns_begin, towns_end), #each town is weighted as 5 villages...
            (val_add, ":num_centers", 4),
          (try_end),
          (party_get_slot, ":center_production", ":center_no", ":cur_good_slot"),
          (val_add, ":total_production", ":center_production"),
        (try_end),
        (store_div, ":new_production_difference", ":total_production", ":num_centers"),
        (neq, ":new_production_difference", 0),
        (try_for_range, ":center_no", centers_begin, centers_end),
          (this_or_next|is_between, ":center_no", towns_begin, towns_end),
          (is_between, ":center_no", villages_begin, villages_end),
          (party_get_slot, ":center_production", ":center_no", ":cur_good_slot"),
          (val_sub, ":center_production", ":new_production_difference"),
          (party_set_slot, ":center_no", ":cur_good_slot", ":center_production"),
        (try_end),
      (try_end),
  ]),

  #script_update_trade_good_prices
  # INPUT: none
  ("update_trade_good_prices",
    [
      (try_for_range, ":center_no", centers_begin, centers_end),
        (this_or_next|is_between, ":center_no", towns_begin, towns_end),
        (is_between, ":center_no", villages_begin, villages_end),
        (call_script, "script_update_trade_good_price_for_party", ":center_no"),
      (try_end),

      (try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
	    (assign, ":total_price", 0),
		(assign, ":total_constants", 0),

	    (try_for_range, ":center_no", centers_begin, centers_end),
          (this_or_next|is_between, ":center_no", towns_begin, towns_end),
          (is_between, ":center_no", villages_begin, villages_end),

          (store_sub, ":cur_good_price_slot", ":cur_good", trade_goods_begin),
          (val_add, ":cur_good_price_slot", slot_town_trade_good_prices_begin),
          (party_get_slot, ":cur_price", ":center_no", ":cur_good_price_slot"),

		  (try_begin),
		    (is_between, ":center_no", towns_begin, towns_end),
			(assign, ":constant", 5),
          (else_try),
		    (assign, ":constant", 1),
		  (try_end),

		  (val_mul, ":cur_price", ":constant"),

		  (val_add, ":total_price", ":cur_price"),
		  (val_add, ":total_constants", ":constant"),
		(try_end),

		(try_for_range, ":center_no", centers_begin, centers_end),
          (this_or_next|is_between, ":center_no", towns_begin, towns_end),
          (is_between, ":center_no", villages_begin, villages_end),

          (store_sub, ":cur_good_price_slot", ":cur_good", trade_goods_begin),
          (val_add, ":cur_good_price_slot", slot_town_trade_good_prices_begin),
          (party_get_slot, ":cur_price", ":center_no", ":cur_good_price_slot"),

		  (val_mul, ":cur_price", 1000),
		  (val_mul, ":cur_price", ":total_constants"),
		  (val_div, ":cur_price", ":total_price"),

		  (val_clamp, ":cur_price", minimum_price_factor, maximum_price_factor),
		  (party_set_slot, ":center_no", ":cur_good_price_slot", ":cur_price"),
		(try_end),
      (try_end),
  ]),

  #script_update_trade_good_price_for_party
  # INPUT: arg1 = party_no
  #Called once every 72 hours
  ("update_trade_good_price_for_party",
    [
      (store_script_param, ":center_no", 1),
      (try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
        (store_sub, ":cur_good_price_slot", ":cur_good", trade_goods_begin),
        (val_add, ":cur_good_price_slot", slot_town_trade_good_prices_begin),
		(party_get_slot, ":cur_price", ":center_no", ":cur_good_price_slot"),

        (call_script, "script_center_get_production", ":center_no", ":cur_good"),
		(assign, ":production", reg0),

        (call_script, "script_center_get_consumption", ":center_no", ":cur_good"),
		(assign, ":consumption", reg0),

		#OZANDEBUG
		#(assign, reg1, ":production"),
		#(assign, reg2, ":consumption"),
		#(str_store_party_name, s1, ":center_no"),
		#(str_store_item_name, s2, ":cur_good"),

		(val_sub, ":production", ":consumption"),

		#Change average production x 2(1+random(2)) (was average 4, random(8)) for excess demand
        (try_begin),
		  #supply is greater than demand
          (gt, ":production", 0),
		  (store_mul, ":change_factor", ":production", 1), #price will be decreased by his factor
		  (store_random_in_range, ":random_change", 0, ":change_factor"),
		  (val_add, ":random_change", ":change_factor"),
		  (val_add, ":random_change", ":change_factor"),

		  #simulation starts
          (store_sub, ":final_price", ":cur_price", ":random_change"),
		  (val_clamp, ":final_price", minimum_price_factor, maximum_price_factor),
		  (try_begin), #Excess of supply decelerates over time, as low price reduces output
		    #if expected final price is 100 then it will multiply random_change by 0.308x ((100+300)/(1300) = 400/1300).
			(lt, ":final_price", 1000),
			(store_add, ":final_price_plus_300", ":final_price", 300),
			(val_mul, ":random_change", ":final_price_plus_300"),
			(val_div, ":random_change", 1300),
		  (try_end),
          (val_sub, ":cur_price", ":random_change"),
        (else_try),
          (lt, ":production", 0),
		  (store_sub, ":change_factor", 0, ":production"), #price will be increased by his factor
		  (val_mul, ":change_factor", 1),
		  (store_random_in_range, ":random_change", 0, ":change_factor"),
		  (val_add, ":random_change", ":change_factor"),
		  (val_add, ":random_change", ":change_factor"),
          (val_add, ":cur_price", ":random_change"),
        (try_end),

        #Move price towards average by 3%...
		#Equilibrium is 33 cycles, or 100 days
		#Change per cycle is Production x 4
		#Thus, max differential = -5 x 4 x 33 = -660 for -5
		(try_begin),
		  (is_between, ":center_no", villages_begin, villages_end),
        (store_sub, ":price_difference", ":cur_price", average_price_factor),
          (val_mul, ":price_difference", 96),
        (val_div, ":price_difference", 100),
        (store_add, ":new_price", average_price_factor, ":price_difference"),
        (else_try),
          (store_sub, ":price_difference", ":cur_price", average_price_factor),
          (val_mul, ":price_difference", 96),
          (val_div, ":price_difference", 100),
          (store_add, ":new_price", average_price_factor, ":price_difference"),
        (try_end),

		#Price of manufactured goods drift towards primary raw material
		(try_begin),
			(item_get_slot, ":raw_material", ":cur_good", slot_item_primary_raw_material),
            (neq, ":raw_material", 0),
	        (store_sub, ":raw_material_price_slot", ":raw_material", trade_goods_begin),
	        (val_add, ":raw_material_price_slot", slot_town_trade_good_prices_begin),

			(party_get_slot, ":total_raw_material_price", ":center_no", ":raw_material_price_slot"),
			(val_mul, ":total_raw_material_price", 3),
            (assign, ":number_of_centers", 3),

			(try_for_range, ":village_no", villages_begin, villages_end),
			  (party_slot_eq, ":village_no", slot_village_bound_center, ":center_no"),
			  (party_get_slot, ":raw_material_price", ":village_no", ":raw_material_price_slot"),
			  (val_add, ":total_raw_material_price", ":raw_material_price"),
			  (val_add, ":number_of_centers", 1),
            (try_end),

			(store_div, ":average_raw_material_price", ":total_raw_material_price", ":number_of_centers"),

			(gt, ":average_raw_material_price", ":new_price"),
			(store_sub, ":raw_material_boost", ":average_raw_material_price", ":new_price"),
			(val_div, ":raw_material_boost", 10),
			(val_add, ":new_price", ":raw_material_boost"),
		(try_end),

        (val_clamp, ":new_price", minimum_price_factor, maximum_price_factor),
        (party_set_slot, ":center_no", ":cur_good_price_slot", ":new_price"),

		#(assign, reg3, ":new_price"),
		#(str_store_item_name, s2, ":cur_good"),
		#(display_log_message, "@DEBUG : {s1}-{s2}, prod:{reg1}, cons:{reg2}, price:{reg3}"),
      (try_end),
  ]),

  ("center_get_production",
    [
	#Actually, this could be reset somewhat to yield supply and demand as raw numbers
	#Demand could be set values for rural and urban
	#Supply could be based on capital goods -- head of cattle, head of sheep, fish ponds, fishing fleets, acres of grain fields, olive orchards, olive presses, wine presses, mills, smithies, salt pans, potters' kilns, etc
	#Prosperity would increase both demand and supply
		(store_script_param_1, ":center_no"),
		(store_script_param_2, ":cur_good"),

		(assign, ":base_production", 0),

		#Grain products
		(try_begin),
			(eq, ":cur_good", "itm_bread"), #Demand = 3000 across Calradia
			(party_get_slot, ":base_production", ":center_no", slot_center_mills),
			(val_mul, ":base_production", 20), #one mills per village, five mills per town = 160 mills
		(else_try),
			(eq, ":cur_good", "itm_grain"), #Demand =  3200+, 1600 to mills, 1500 on its own, extra to breweries
			(party_get_slot, ":base_production", ":center_no", slot_center_acres_grain),
			(val_div, ":base_production", 125), #10000 acres is the average across Calradia, extra in Swadia, less in snows and steppes, a bit from towns
		(else_try),
			(eq, ":cur_good", "itm_ale"), #
			(party_get_slot, ":base_production", ":center_no", slot_center_breweries),
			(val_mul, ":base_production", 25),

		(else_try),
			(eq, ":cur_good", "itm_smoked_fish"), #Demand = 20
			(party_get_slot, ":base_production", ":center_no", slot_center_fishing_fleet),
			(val_mul, ":base_production", 4), #was originally 5
		(else_try),
			(eq, ":cur_good", "itm_salt"),
			(party_get_slot, ":base_production", ":center_no", slot_center_salt_pans),
			(val_mul, ":base_production", 35),

		#Cattle products
		(else_try),
			(eq, ":cur_good", "itm_cattle_meat"), #Demand = 5
			(party_get_slot, ":base_production", ":center_no", slot_center_head_cattle),
			(val_div, ":base_production", 4), #was 9
		(else_try),
			(eq, ":cur_good", "itm_dried_meat"), #Demand = 15
			(party_get_slot, ":base_production", ":center_no", slot_center_head_cattle),
			(val_div, ":base_production", 2), #was 3
		(else_try),
			(eq, ":cur_good", "itm_cheese"), 	 #Demand = 10
			(party_get_slot, ":base_production", ":center_no", slot_center_head_cattle),
			(party_get_slot, ":sheep_addition", ":center_no", slot_center_head_sheep),
			(val_div, ":sheep_addition", 2),
			(val_add, ":base_production", ":sheep_addition"),
			(party_get_slot, ":gardens", ":center_no", slot_center_household_gardens),
			(val_mul, ":base_production", ":gardens"),
			(val_div, ":base_production", 10),
		(else_try),
			(eq, ":cur_good", "itm_butter"), 	 #Demand = 2
			(party_get_slot, ":base_production", ":center_no", slot_center_head_cattle),
			(party_get_slot, ":gardens", ":center_no", slot_center_household_gardens),
			(val_mul, ":base_production", ":gardens"),
			(val_div, ":base_production", 15),

		(else_try),
			(eq, ":cur_good", "itm_raw_leather"), 	 #Demand = ??
			(party_get_slot, ":base_production", ":center_no", slot_center_head_cattle),
			(val_div, ":base_production", 6),
			(party_get_slot, ":sheep_addition", ":center_no", slot_center_head_sheep),
			(val_div, ":sheep_addition", 12),
			(val_add, ":base_production", ":sheep_addition"),

		(else_try),
			(eq, ":cur_good", "itm_leatherwork"), 	 #Demand = ??
			(party_get_slot, ":base_production", ":center_no", slot_center_tanneries),
			(val_mul, ":base_production", 20),

		(else_try),
			(eq, ":cur_good", "itm_honey"), 	 #Demand = 5
			(party_get_slot, ":base_production", ":center_no", slot_center_apiaries),
			(val_mul, ":base_production", 6),
		(else_try),
			(eq, ":cur_good", "itm_cabbages"), 	 #Demand = 7
			(party_get_slot, ":base_production", ":center_no", slot_center_household_gardens),
			(val_mul, ":base_production", 10),
		(else_try),
			(eq, ":cur_good", "itm_apples"), 	 #Demand = 7
			(party_get_slot, ":base_production", ":center_no", slot_center_household_gardens),
			(val_mul, ":base_production", 10),

		#Sheep products
		(else_try),
			(eq, ":cur_good", "itm_sausages"), 	 #Demand = 5
			(party_get_slot, ":base_production", ":center_no", slot_center_head_sheep), #average of 90 sheep
			(val_div, ":base_production", 15),
		(else_try),
			(eq, ":cur_good", "itm_wool"), 	 #(Demand = 0, but 15 averaged out perhaps)
			(party_get_slot, ":base_production", ":center_no", slot_center_head_sheep), #average of 90 sheep
			(val_div, ":base_production", 5),
		(else_try),
			(eq, ":cur_good", "itm_wool_cloth"), 	 #(Demand = 1500 across Calradia)
			(party_get_slot, ":base_production", ":center_no", slot_center_wool_looms),
			(val_mul, ":base_production", 5), #300 across Calradia

		(else_try),
			(this_or_next|eq, ":cur_good", "itm_pork"),
			(eq, ":cur_good", "itm_chicken"),
			(try_begin),
			  (is_between, ":center_no", villages_begin, villages_end),
			  (assign, ":base_production", 30),
			(else_try),
			  (assign, ":base_production", 0),
			(try_end),

		(else_try),
			(eq, ":cur_good", "itm_iron"), 	 #Demand = 5, one supplies three smithies
			(party_get_slot, ":base_production", ":center_no", slot_center_iron_deposits),
			(val_mul, ":base_production", 10),
		(else_try),
			(eq, ":cur_good", "itm_tools"), 	 #Demand = 560 across Calradia
			(party_get_slot, ":base_production", ":center_no", slot_center_smithies),
			(val_mul, ":base_production", 3),

		#Other artisanal goods
		(else_try),
			(eq, ":cur_good", "itm_pottery"), #560 is total demand
			(party_get_slot, ":base_production", ":center_no", slot_center_pottery_kilns),
			(val_mul, ":base_production", 5),

		(else_try),
			(eq, ":cur_good", "itm_raw_grapes"),
			(party_get_slot, ":base_production", ":center_no", slot_center_acres_vineyard),
			(val_div, ":base_production", 100),
		(else_try),
			(eq, ":cur_good", "itm_wine"),
			(party_get_slot, ":base_production", ":center_no", slot_center_wine_presses),
			(val_mul, ":base_production", 25),
		(else_try),
			(eq, ":cur_good", "itm_raw_olives"),
			(party_get_slot, ":base_production", ":center_no", slot_center_acres_olives),
			(val_div, ":base_production", 150),
		(else_try),
			(eq, ":cur_good", "itm_oil"),
			(party_get_slot, ":base_production", ":center_no", slot_center_olive_presses),
			(val_mul, ":base_production", 12),

		#Flax and linen
		(else_try),
			(eq, ":cur_good", "itm_linen"),
			(party_get_slot, ":base_production", ":center_no", slot_center_linen_looms),
			(val_mul, ":base_production", 5),
		(else_try),
			(eq, ":cur_good", "itm_raw_flax"),
			(party_get_slot, ":base_production", ":center_no", slot_center_acres_flax),
			(val_div, ":base_production", 80),
		(else_try),
			(eq, ":cur_good", "itm_velvet"),
			(party_get_slot, ":base_production", ":center_no", slot_center_silk_looms),
			(val_mul, ":base_production", 5),
		(else_try),
			(eq, ":cur_good", "itm_raw_silk"),
			(party_get_slot, ":base_production", ":center_no", slot_center_silk_farms),
			(val_div, ":base_production", 20),
		(else_try),
			(eq, ":cur_good", "itm_raw_dyes"),
			(party_get_slot, ":base_production", ":center_no", slot_center_kirmiz_farms),
			(val_div, ":base_production", 20),
		(else_try),
			(eq, ":cur_good", "itm_raw_date_fruit"),
			(party_get_slot, ":base_production", ":center_no", slot_center_acres_dates),
			(val_div, ":base_production", 120),
		(else_try),
			(eq, ":cur_good", "itm_furs"), 	 #Demand = 90 across Calradia
			(party_get_slot, ":base_production", ":center_no", slot_center_fur_traps),
			(val_mul, ":base_production", 25),
		(else_try),
			(eq, ":cur_good", "itm_spice"),
			(try_begin),
				(eq, ":center_no", "p_town_10"), #Tulga
				(assign, ":base_production", 100),
			(else_try),
				(eq, ":center_no", "p_town_17"), #Ichamur
				(assign, ":base_production", 50),
			(else_try),
				(eq, ":center_no", "p_town_19"), #Shariz
				(assign, ":base_production", 50),
			(else_try),
				(eq, ":center_no", "p_town_22"), #Bariyye
				(assign, ":base_production", 50),
			(else_try),
				(this_or_next|eq, ":center_no", "p_village_11"), #Dusturil (village of Tulga)
				(eq, ":center_no", "p_village_25"), #Dashbigha (village of Tulga)
				(assign, ":base_production", 50),
			(else_try),
				(this_or_next|eq, ":center_no", "p_village_37"), #Ada Kulun (village of Ichlamur)
				(this_or_next|eq, ":center_no", "p_village_42"), #Dirigh Aban (village of Ichlamur)
				(this_or_next|eq, ":center_no", "p_village_99"), #Fishara (village of Bariyye)
				(eq, ":center_no", "p_village_100"), #Iqbayl (village of Bariyye)
				(assign, ":base_production", 25),
			(try_end),
		(try_end),

		#Modify production by other goods
		(assign, ":modified_production", ":base_production"),
		(try_begin),
			(eq, ":cur_good", "itm_bread"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_grain", ":base_production", 1),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_ale"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_grain", ":base_production", 2),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_dried_meat"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_salt", ":base_production", 2),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_smoked_fish"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_salt", ":base_production", 2),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_tools"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_iron", ":base_production", 1),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_wool_cloth"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_wool", ":base_production", 1),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_wine"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_raw_grapes", ":base_production", 1),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_oil"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_raw_olives", ":base_production", 1),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_velvet"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_raw_silk", ":base_production", 1),
			(assign, ":initially_modified_production", reg0),

			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_raw_dyes", ":initially_modified_production", 2),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_leatherwork"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_raw_leather", ":base_production", 1),
			(assign, ":modified_production", reg0),
		(else_try),
			(eq, ":cur_good", "itm_linen"),
			(call_script, "script_good_price_affects_good_production", ":center_no", "itm_raw_flax", ":base_production", 1),
			(assign, ":modified_production", reg0),
		(try_end),


		(assign, ":base_production_modded_by_raw_materials", ":modified_production"), #this is just logged for the report screen

	    #Increase both positive and negative production by the center's prosperity
		#Richer towns have more people and consume more, but also produce more
		(try_begin),
			(party_get_slot, ":prosperity_plus_75", ":center_no", slot_town_prosperity),
			(val_add, ":prosperity_plus_75", 75),
			(val_mul, ":modified_production", ":prosperity_plus_75"),
			(val_div, ":modified_production", 125),
		(try_end),

		(try_begin),
		    (this_or_next|party_slot_eq, ":center_no", slot_village_state, svs_being_raided),
		    (this_or_next|party_slot_eq, ":center_no", slot_village_state, svs_deserted), #SB : deserted village
		        (party_slot_eq, ":center_no", slot_village_state, svs_looted),
		    (assign, ":modified_production", 0),
		(try_end),

	    (assign, reg0, ":modified_production"), #modded by prosperity
	    (assign, reg1, ":base_production_modded_by_raw_materials"),
	    (assign, reg2, ":base_production"),

	]),

  ("center_get_consumption",
    [
		(store_script_param_1, ":center_no"),
		(store_script_param_2, ":cur_good"),

		(assign, ":consumer_consumption", 0),
		(try_begin),
##diplomacy start+ To determine if a center should be counted as a desert center or not,
#instead of using a fixed range (which is brittle to map changes) check if the terrain
#at the center is rt_desert or rt_desert_forest.
			(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
			(is_between, ":center_no", centers_begin, centers_end),
			(party_get_current_terrain, reg0, ":center_no"),
			(this_or_next|eq, reg0, rt_desert),
			(eq, reg0, rt_desert_forest),
			(item_slot_ge, ":cur_good", slot_item_desert_demand, 0), #Otherwise use rural or urban
			(item_get_slot, ":consumer_consumption", ":cur_good", slot_item_desert_demand),
		(else_try),
			(lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
#If economic changes are disabled, use the Native desert-check logic.
##diplomacy end+
			(this_or_next|is_between, ":center_no", "p_town_19", "p_castle_1"),
				(ge, ":center_no", "p_village_91"),
			(item_slot_ge, ":cur_good", slot_item_desert_demand, 0), #Otherwise use rural or urban
			(item_get_slot, ":consumer_consumption", ":cur_good", slot_item_desert_demand),
		(else_try),
			(is_between, ":center_no", villages_begin, villages_end),
			(item_get_slot, ":consumer_consumption", ":cur_good", slot_item_rural_demand),
		(else_try),
			(is_between, ":center_no", towns_begin, towns_end),
			(item_get_slot, ":consumer_consumption", ":cur_good", slot_item_urban_demand),
		(try_end),


		(assign, ":raw_material_consumption", 0),
		(try_begin),
			(eq, ":cur_good", "itm_grain"),
			(party_get_slot, ":grain_for_bread", ":center_no", slot_center_mills),
			(val_mul, ":grain_for_bread", 20),

			(party_get_slot, ":grain_for_ale", ":center_no", slot_center_breweries),
			(val_mul, ":grain_for_ale", 5),

			(store_add, ":raw_material_consumption", ":grain_for_bread", ":grain_for_ale"),

		(else_try),
			(eq, ":cur_good", "itm_iron"),
			(party_get_slot, ":raw_material_consumption", ":center_no", slot_center_smithies),
			(val_mul, ":raw_material_consumption", 3),

		(else_try),
			(eq, ":cur_good", "itm_wool"),
			(party_get_slot, ":raw_material_consumption", ":center_no", slot_center_wool_looms),
			(val_mul, ":raw_material_consumption", 5),

		(else_try),
			(eq, ":cur_good", "itm_raw_flax"),
			(party_get_slot, ":raw_material_consumption", ":center_no", slot_center_linen_looms),
			(val_mul, ":raw_material_consumption", 5),

		(else_try),
			(eq, ":cur_good", "itm_raw_leather"),
			(party_get_slot, ":raw_material_consumption", ":center_no", slot_center_tanneries),
			(val_mul, ":raw_material_consumption", 20),

		(else_try),
			(eq, ":cur_good", "itm_raw_grapes"),
			(party_get_slot, ":raw_material_consumption", ":center_no", slot_center_wine_presses),
			(val_mul, ":raw_material_consumption", 30),

		(else_try),
			(eq, ":cur_good", "itm_raw_olives"),
			(party_get_slot, ":raw_material_consumption", ":center_no", slot_center_olive_presses),
			(val_mul, ":raw_material_consumption", 12),


		(else_try),
			(eq, ":cur_good", "itm_raw_dyes"),
			(party_get_slot, ":raw_material_consumption", ":center_no", slot_center_silk_looms),
			(val_mul, ":raw_material_consumption", 1),
		(else_try),
			(eq, ":cur_good", "itm_raw_silk"),
			(party_get_slot, ":raw_material_consumption", ":center_no", slot_center_silk_looms),
			(val_mul, ":raw_material_consumption", 5),


		(else_try),
			(eq, ":cur_good", "itm_salt"),
			(party_get_slot, ":salt_for_beef", ":center_no", slot_center_head_cattle),
			(val_div, ":salt_for_beef", 10),

			(party_get_slot, ":salt_for_fish", ":center_no", slot_center_fishing_fleet),
			(val_div, ":salt_for_fish", 5),

			(store_add, ":raw_material_consumption", ":salt_for_beef", ":salt_for_fish"),
		(try_end),

		(try_begin), #Reduce consumption of raw materials if their cost is high
			(gt, ":raw_material_consumption", 0),
			(store_sub, ":item_to_price_slot", slot_town_trade_good_prices_begin, trade_goods_begin),
	        (store_add, ":cur_good_price_slot", ":cur_good", ":item_to_price_slot"),
	        (party_get_slot, ":cur_center_price", ":center_no", ":cur_good_price_slot"),
			##diplomacy start+
			(gt, ":cur_center_price", average_price_factor),#replace the hardcoded constant 1000 with average_price_factor
			(val_mul, ":raw_material_consumption", average_price_factor),#again replace the hardcoded constant 1000 with average_price_factor
			##diplomacy end+
			(val_div, ":raw_material_consumption", ":cur_center_price"),
		(try_end),



		(store_add, ":modified_consumption", ":consumer_consumption", ":raw_material_consumption"),
		(try_begin),
			(party_get_slot, ":prosperity_plus_75", ":center_no", slot_town_prosperity),
			(val_add, ":prosperity_plus_75", 75),
			(val_mul, ":modified_consumption", ":prosperity_plus_75"),
			(val_div, ":modified_consumption", 125),
		(try_end),


	    (assign, reg0, ":modified_consumption"), #modded by prosperity
	    (assign, reg1, ":raw_material_consumption"),
	    (assign, reg2, ":consumer_consumption"),
	]),

  #script_get_enterprise_name
  # INPUT: arg1 = item_no
  # Output: reg0: production string
  ("get_enterprise_name",
    [
		(store_script_param_1, ":item_produced"),
		(assign, ":enterprise_name", "str_bread_site"),
		(try_begin),
			(eq, ":item_produced", "itm_bread"),
			(assign, ":enterprise_name", "str_bread_site"),
		(else_try),
			(eq, ":item_produced", "itm_ale"),
			(assign, ":enterprise_name", "str_ale_site"),
		(else_try),
			(eq, ":item_produced", "itm_oil"),
			(assign, ":enterprise_name", "str_oil_site"),
		(else_try),
			(eq, ":item_produced", "itm_wine"),
			(assign, ":enterprise_name", "str_wine_site"),
		(else_try),
			(eq, ":item_produced", "itm_leatherwork"),
			(assign, ":enterprise_name", "str_leather_site"),
		(else_try),
			(eq, ":item_produced", "itm_wool_cloth"),
			(assign, ":enterprise_name", "str_wool_cloth_site"),
		(else_try),
			(eq, ":item_produced", "itm_linen"),
			(assign, ":enterprise_name", "str_linen_site"),
		(else_try),
			(eq, ":item_produced", "itm_velvet"),
			(assign, ":enterprise_name", "str_velvet_site"),
		(else_try),
			(eq, ":item_produced", "itm_tools"),
			(assign, ":enterprise_name", "str_tool_site"),
		(try_end),
		(assign, reg0, ":enterprise_name"),
	]),

  #script_do_merchant_town_trade
  # INPUT: arg1 = party_no (of the merchant), arg2 = center_no
  ##diplomacy start+
  # If optional economic changes are enabled, the benefits are applied to both
  # the town of origin and the destination, instead of just the latter.
  ##diplomacy end+
  ("do_merchant_town_trade",
    [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":center_no"),

	  (party_get_slot, ":origin", ":party_no", slot_party_last_traded_center),

	  (try_begin),
		(eq, "$cheat_mode", 2),
		(str_store_party_name, s4, ":center_no"),
		(str_store_party_name, s5, ":origin"),
		(display_message, "@{!}DEBUG -- Caravan trades in {s4}, originally from {s5}"),
	  (try_end),

	  (call_script, "script_add_log_entry", logent_party_traded, ":party_no", ":origin", ":center_no", -1),

      (call_script, "script_do_party_center_trade", ":party_no", ":center_no", 4), #it was first 10 then increased 20 then increased 30, now I decrease it to back 6. Because otherwise prices do not differiate much. Trade become useless in game.

      (assign, ":total_change", reg0),
      #Adding the earnings to the wealth (maximum changed price is the earning)
      (val_div, ":total_change", 2),
      (str_store_party_name, s1, ":party_no"),
      (str_store_party_name, s2, ":center_no"),
      (assign, reg1, ":total_change"),

      #Adding tariffs to the town
      (party_get_slot, ":accumulated_tariffs", ":center_no", slot_center_accumulated_tariffs),
      (party_get_slot, ":prosperity", ":center_no", slot_town_prosperity),

	  (assign, ":tariffs_generated", ":total_change"),
      (val_mul, ":tariffs_generated", ":prosperity"),
	  ##diplomacy start+
	  #Move the next two lines further down to reduce rounding error
	  #(val_div, ":tariffs_generated", 100),
	  #(val_div, ":tariffs_generated", 10), #10 for caravans, 20 for villages

	  #Re-wrote the "diplomacy" section here for greater clarity.
	  (assign, ":percent", 100),
      (try_begin), # trade agreement
        (store_faction_of_party, ":party_faction", ":party_no"),
        (store_faction_of_party, ":center_faction", ":center_no"),

        (store_add, ":truce_slot", ":party_faction", slot_faction_truce_days_with_factions_begin),
        (val_sub, ":truce_slot", kingdoms_begin),
  	    (faction_get_slot, ":truce_days", ":center_faction", ":truce_slot"),
  	    ##nested diplomacy start+ replace "20" with a named constant
  	    #(gt, ":truce_days", 20),
  	    (gt, ":truce_days", dplmc_treaty_trade_days_expire),
  	    ##nested diplomacy end+
  	    (val_add, ":percent", 30),
      (try_end),

	  #If economic changes are enabled, divide the tariffs between the source and destination.
	  (assign, ":origin_tariffs_generated", 0),#we will need this variable later, if it is set
	  (try_begin),
	    #Economic changes must be enabled
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		#verify the origin is a real town or village and not a placeholder value
		(ge, ":origin", 0),
		(this_or_next|is_between, ":origin", towns_begin, towns_end),
		(this_or_next|is_between, ":origin", villages_begin, villages_end),
		(this_or_next|party_slot_eq, ":origin", slot_party_type, spt_town),
			(party_slot_eq, ":origin", slot_party_type, spt_village),
		#give half the tariffs to the origin
		(ge, ":tariffs_generated", 0),
		(party_get_slot, ":origin_accumulated_tariffs", ":origin", slot_center_accumulated_tariffs),
		(store_div, ":origin_tariffs_generated", ":tariffs_generated", 2),
		(val_sub, ":tariffs_generated", ":origin_tariffs_generated"),
		#apply plutocracy/aristocracy modifier, and any modifier from a trade treaty
		(store_faction_of_party, ":origin_faction", ":center_no"),
		(faction_get_slot, ":aristocracy", ":origin_faction", dplmc_slot_faction_aristocracy),
		(val_mul, ":aristocracy", -5),
		(store_add, ":origin_percent", ":percent", ":aristocracy"),
		(val_mul, ":origin_tariffs_generated", ":origin_percent"),
		(val_add, ":origin_tariffs_generated", 50),#for rounding
		(val_div, ":origin_tariffs_generated", 100),
		#apply the delayed division from before (leaving the steps separated for clarity)
		(val_add, ":origin_tariffs_generated", 50),
		(val_div, ":origin_tariffs_generated", 100),#adjust for having been multiplied by prosperity
		(val_add, ":tariffs_generated", 5),
		(val_div, ":tariffs_generated", 10), #10 for caravans, 20 for villages
		#now we have the final value of origin_tariffs_generated
		(val_add, ":origin_accumulated_tariffs", ":origin_tariffs_generated"),
		(party_set_slot, ":origin", slot_center_accumulated_tariffs, ":origin_accumulated_tariffs"),
		#print economic debug message if enabled
		(ge, "$cheat_mode", 3),
		(assign, reg4, ":origin_tariffs_generated"),
		(str_store_party_name, s4, ":origin"),
		(assign, reg5, ":origin_accumulated_tariffs"),
		(display_message, "@{!}New tariffs at {s4} = {reg4}, total = {reg5}"),
	  (try_end),

	  #For this town: apply the faction plutocracy/aristocracy modifier
      (faction_get_slot, ":aristocracy", ":center_faction", dplmc_slot_faction_aristocracy),
      (val_mul, ":aristocracy", -5),
      (val_add, ":percent", ":aristocracy"),
      (val_mul, ":tariffs_generated", ":percent"),
   	  (val_add, ":tariffs_generated", 50),
      (val_div, ":tariffs_generated", 100),
	  #apply the delayed division from before (leaving the steps separated for clarity)
   	  (val_add, ":tariffs_generated", 50),
 	  (val_div, ":tariffs_generated", 100),#adjust for having been multiplied by prosperity
	  (val_add, ":tariffs_generated", 5),
	  (val_div, ":tariffs_generated", 10), #10 for caravans, 20 for villages
	  ##diplomacy end+
	  (val_add, ":accumulated_tariffs", ":tariffs_generated"),

	  (try_begin),
		(ge, "$cheat_mode", 3),
		(assign, reg4, ":tariffs_generated"),
		(str_store_party_name, s4, ":center_no"),
		(assign, reg5, ":accumulated_tariffs"),
		(display_message, "@{!}New tariffs at {s4} = {reg4}, total = {reg5}"),
	  (try_end),

      (party_set_slot, ":center_no", slot_center_accumulated_tariffs, ":accumulated_tariffs"),
      ##diplomacy start+
	  #If economic changes are enabled, 50% chance that the origin rather than
	  #the destination will receive the chance for prosperity increase.
	  (assign, ":benefit_center", ":center_no"),
	  (try_begin),
		#Economic changes must be enabled
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		#verify the origin is a real town or village and not a placeholder value
		(ge, ":origin", 0),
		(this_or_next|is_between, ":origin", towns_begin, towns_end),
		(this_or_next|is_between, ":origin", villages_begin, villages_end),
		(this_or_next|party_slot_eq, ":origin", slot_party_type, spt_town),
			(party_slot_eq, ":origin", slot_party_type, spt_village),
		(ge, ":tariffs_generated", 0),
		#50% chance
		(store_random_in_range, ":rand", 0, 64),
		(lt, ":rand", 32),
		(assign, ":benefit_center", ":origin"),
	  (try_end),
	  ##diplomacy end+
      #Adding 1 to center prosperity with 18% for each caravan in that center
      (try_begin),
        (store_random_in_range, ":rand", 0, 80),
		##diplomacy start+ in next line, changed center_no to benefit_center
        (call_script, "script_center_get_goods_availability", ":benefit_center"),
		##diplomacy end+
		(assign, ":hardship_index", reg0),
		(gt, ":rand", ":hardship_index"),
      (try_begin),
        (store_random_in_range, ":rand", 0, 100),
        (gt, ":rand", 82),
		##diplomacy start+ in next line, changed center_no to benefit_center
		(call_script, "script_change_center_prosperity", ":benefit_center", 1),
		##diplomacy end+
		(val_add, "$newglob_total_prosperity_from_caravan_trade", 1),
      (try_end),
     (try_end),
  ]),

  #script_party_calculate_regular_strength:
  # INPUT:
  # param1: Party-id
  ("party_calculate_regular_strength",
    [
      (store_script_param_1, ":party"), #Party_id

      (assign, reg0,0),
      (party_get_num_companion_stacks, ":num_stacks",":party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", ":party", ":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (store_character_level, ":stack_strength", ":stack_troop"),
        (val_add, ":stack_strength", 12),
        (val_mul, ":stack_strength", ":stack_strength"),
        (val_div, ":stack_strength", 100),
        (party_stack_get_size, ":stack_size",":party",":i_stack"),
        (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
        (val_sub, ":stack_size", ":num_wounded"),
        (val_mul, ":stack_strength", ":stack_size"),
        (val_add,reg0, ":stack_strength"),
      (try_end),
  ]),




  #script_party_calculate_strength:
  # INPUT: arg1 = party_id, arg2 = exclude leader
  # OUTPUT: reg0 = strength

  ("party_calculate_strength",
    [
      (store_script_param_1, ":party"), #Party_id
      (store_script_param_2, ":exclude_leader"), #Party_id

      (assign, reg0,0),
      (party_get_num_companion_stacks, ":num_stacks", ":party"),
      (assign, ":first_stack", 0),
      (try_begin),
        (neq, ":exclude_leader", 0),
        (assign, ":first_stack", 1),
      (try_end),
      (try_for_range, ":i_stack", ":first_stack", ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party", ":i_stack"),
        (store_character_level, ":stack_strength", ":stack_troop"),
        (val_add, ":stack_strength", 4), #new was 12 (patch 1.125)
        (val_mul, ":stack_strength", ":stack_strength"),
        (val_mul, ":stack_strength", 2), #new (patch 1.125)
        (val_div, ":stack_strength", 100),
        (val_max, ":stack_strength", 1), #new (patch 1.125)
        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size",":party",":i_stack"),
          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
          (val_sub, ":stack_size", ":num_wounded"),
          (val_mul, ":stack_strength", ":stack_size"),
        (else_try),
          (troop_is_wounded, ":stack_troop"), #hero & wounded
          (assign, ":stack_strength", 0),
        (try_end),
        (val_add, reg0, ":stack_strength"),
      (try_end),
      (party_set_slot, ":party", slot_party_cached_strength, reg0),
  ]),


  #script_loot_player_items:
  # INPUT: arg1 = enemy_party_no
  # Output: none
  ("loot_player_items",
    [
      (store_script_param, ":enemy_party_no", 1),
	  ##diplomacy start+ some enemy lords will not loot the personal equipment of a player who surrendered
	  (assign, ":save_reg0", reg0),
	  (assign, ":extra_gold", 0),
	  #I am not sure if this is historical or not, but it gives the player a reason to
	  #surrender (rather than fight to the end) even before permanent attribute loss is
	  #a possibility (or even if it is disabled outright).
	  #
	  #This also adds another layer of interaction, and makes different lords feel
	  #different from each other.
	  #
	  #Other changes:
	  # Enemy lords will receive gold they loot from the player,
	  # Books will not be looted from the player (it turns out a bug was responsible for this being possible)
	  # The enemy leader's looting skill will affect the amount of gold lootable.
	  (assign, ":merciful", 0),
	  (assign, ":party_leader", -1),
	  (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
	  (try_begin),
 	    (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),#only use this if it is explicitly enabled
	    #Possibility the player's personal equipment will be untouched if he surrendered
  	    (ge, "$g_player_surrenders", 1),
   	    (gt, ":enemy_party_no", 0),
		(party_stack_get_troop_id, ":party_leader", ":enemy_party_no", 0),
	   #(party_slot_eq, ":enemy_party_no", slot_party_type, spt_kingdom_hero_party),
		(ge, ":party_leader", walkers_end),
		(troop_is_hero, ":party_leader"),
		(call_script, "script_troop_get_player_relation", ":party_leader"),
		(assign, ":relation", reg0),
		(assign, ":probability_modifier", 0),
		(try_begin),
			#Upstanding lords are inclined to honor deals in general, and will automatically
			#do so with honorable lords they do not extremely dislike.  However, this does not
			#extend to commoners.
			(troop_slot_ge, "trp_player", slot_troop_banner_scene_prop, 1),# the player has a coat of arms
			(troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_upstanding),
			(val_max, ":probability_modifier", 10),#set to +10 unless already higher
			#They will automatically honor deals with the honorable, if they do not
			#excessively dislike them.
			(ge, "$player_honor", 1),
			(val_add, reg0, 10),
			(val_clamp, reg0, 11, 21),
			(val_max, ":probability_modifier", reg0),#set somewhere from +11 to +20 unless already higher
			(ge, ":relation", -10),
			(assign, ":merciful", 1),
		(else_try),
			#Martial lords are inclined to honor deals with lords who likewise follow the rules of war,
			#and will do so as long as they are neutral or friendly towards them.  This does not extend
			#to commoners.
			(troop_slot_ge, "trp_player", slot_troop_banner_scene_prop, 1),# the player has a coat of arms
			(this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_moralist),
			(troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_martial),
			(ge, "$player_honor", 1),
			(assign, reg0, "$player_honor"),
			(val_clamp, reg0, 1, 6),
			(val_max, ":probability_modifier", reg0),#set somewhere from +1 to +5 unless already higher
			(ge, ":relation", 0),
			(assign, ":merciful", 1),
		(else_try),
			#Good-natured lords are inclined to honor deals with everyone, commoner or not.
			#They will do so automatically unless they particularly dislike someone.
			#This also goes for Moralist ladies if they someone end up accepting your surrender.
			(this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_goodnatured),
			(troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_moralist),
			(val_max, ":probability_modifier", 21),#set to +20 unless already higher
			(ge, ":relation", -10),
			(assign, ":merciful", 1),
		(else_try),
			#Honest lords are inclined honor deals with everyone, commoner or not.
			#They will do so automatically unless they particularly dislike someone.
			(call_script, "script_dplmc_get_troop_morality_value", ":party_leader", tmt_honest),
			(assign, ":honest_val", reg0),
			(ge, ":honest_val", 1),
			(store_add, reg0, ":honest_val", 14),
			(val_max, ":probability_modifier", reg0),#set to (14 + honesty ) unless already higher
			(ge, "$player_honor", 1),
			(val_mul, reg0, -1),
			(ge, ":relation", reg0),
			(assign, ":merciful", 1),
		(else_try),
			(try_begin),
				#Penalty instead of bonus for vicious lord personalities, unless they are
				#explicitly set as honest.  (None are by default.)
				(lt, ":honest_val", 1),#Must either be negative or not given
				(this_or_next|lt, ":honest_val", 0),
				(this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_debauched),
				(this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_selfrighteous),
				(this_or_next|troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_cunning),
				(troop_slot_eq, ":party_leader", slot_lord_reputation_type, lrep_quarrelsome),
				(val_min, ":probability_modifier", -10),#set to -10 unless already lower
			(try_end),
			#Now store into reg0 the percent chance of mercy
			(try_begin),
				(le, ":reduce_campaign_ai", 0),#Hard: base chance 25% + relation
				(store_add, reg0, ":relation", 25),
			(else_try),
				(eq, ":reduce_campaign_ai", 1),#Medium: base chance 50% + relation
				(store_add, reg0, ":relation", 50),
			(else_try),
				(ge, ":reduce_campaign_ai", 2),#Easy: base chance 75% + relation
				(store_add, reg0, ":relation", 75),
			(try_end),
			(val_add, reg0, ":probability_modifier"),#modify the chance based on the captor's personality
			(val_max, reg0, ":probability_modifier"),#at least this much of a chance
			(val_max, reg0, 5),#at least a 5% chance
			(store_random_in_range, ":probability_modifier", 1, 101),
			(lt, reg0, ":probability_modifier"),
			(assign, ":merciful", 1),
		(try_end),
	  (else_try),
  	   (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),#only use this if it is explicitly enabled
		#Surrendered to a non-hero party
		(gt, ":enemy_party_no", 0),
		(ge, "$g_player_surrenders", 1),
		(store_random_in_range, reg0, 1, 101),
		(this_or_next|lt, reg0, 25),#Hard: 25% chance
			(ge, ":reduce_campaign_ai", 1),
		(this_or_next|lt, reg0, 50),#Medium: 50% chance
			(ge, ":reduce_campaign_ai", 2),
		(lt, reg0, 75),#Easy: 75% chance
		(assign, ":merciful", 1),
	  (try_end),
	  (try_begin),
		(ge, "$cheat_mode", 1),
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),#don't display when nonapplicable
		(assign, ":save_reg1", reg1),
		(assign, reg0, "$g_player_surrenders"),
		(assign, reg1, ":merciful"),
		(display_message, "@{!} DEBUG loot_player_items: g_player_surrenders = {reg0}, merciful = {reg1}"),
        (assign, reg1, ":save_reg1"),
	  (try_end),
	  ##diplomacy end+
      (troop_get_inventory_capacity, ":inv_cap", "trp_player"),
      (try_for_range, ":i_slot", 0, ":inv_cap"),
        (troop_get_inventory_slot, ":item_id", "trp_player", ":i_slot"),
        (ge, ":item_id", 0),
		##diplomacy start+ looting changes
		(neg|is_between, ":item_id", books_begin, books_end),#shouldn't be necessary, but just in case
		(assign, ":randomness", 0),#properly initialize variables
		##diplomacy end+
        (troop_get_inventory_slot_modifier, ":item_modifier", "trp_player", ":i_slot"),
        (try_begin),
          (is_between, ":item_id", trade_goods_begin, trade_goods_end),
          (assign, ":randomness", 20),
        (else_try),
          (this_or_next|is_between, ":item_id", horses_begin, horses_end),
          (this_or_next|eq, ":item_id", "itm_warhorse_sarranid"),
          (eq, ":item_id", "itm_warhorse_steppe"),
          (assign, ":randomness", 15),
        (else_try),
          (this_or_next|is_between, ":item_id", weapons_begin, weapons_end),
          (is_between, ":item_id", ranged_weapons_begin, ranged_weapons_end),
          (assign, ":randomness", 5),
        (else_try),
          (this_or_next|is_between, ":item_id", armors_begin, armors_end),
		  (this_or_next|eq, ":item_id", "itm_plate_boots"), #added to the end because of not breaking the save games
          (is_between, ":item_id", shields_begin, shields_end),
          (assign, ":randomness", 5),
        (try_end),
        (store_random_in_range, ":random_no", 0, 100),
        (lt, ":random_no", ":randomness"),
		##diplomacy start+ changes
		(try_begin),
			#If this option is enabled, personal items may be spared, and instead
			#sligthly more gold is taken (but not as much as the thing's worth).
			(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
			(ge, ":merciful", 1),
			(is_between, ":i_slot", ek_item_0, dplmc_ek_alt_items_end),
			(assign, ":random_no", 101),
			#(store_item_value, reg0, ":item_id"),#don't bother with imods #don't bother with the rest of this
			#(val_div, reg0, 2),
			#(ge, reg0, 1),
			#(val_add, ":extra_gold", reg0),##disable, as it defeats the point!
		(try_end),
		(lt, ":random_no", ":randomness"),
		##diplomacy end+
        (troop_remove_item, "trp_player", ":item_id"),

        (try_begin),
          (gt, ":enemy_party_no", 0),
          (party_get_slot, ":cur_loot_slot", ":enemy_party_no", slot_party_next_looted_item_slot),
          (val_add, ":cur_loot_slot", slot_party_looted_item_1),
          (party_set_slot, ":enemy_party_no", ":cur_loot_slot", ":item_id"),
          (val_sub, ":cur_loot_slot", slot_party_looted_item_1),
          (val_add, ":cur_loot_slot", slot_party_looted_item_1_modifier),
          (party_set_slot, ":enemy_party_no", ":cur_loot_slot", ":item_modifier"),
          (val_sub, ":cur_loot_slot", slot_party_looted_item_1_modifier),
          (val_add, ":cur_loot_slot", 1),
          (val_mod, ":cur_loot_slot", num_party_loot_slots),
          (party_set_slot, ":enemy_party_no", slot_party_next_looted_item_slot, ":cur_loot_slot"),
        (try_end),
      (try_end),
      (store_troop_gold, ":cur_gold", "trp_player"),
      (store_div, ":max_lost", ":cur_gold", 5),
      (store_div, ":min_lost", ":cur_gold", 10),
      (store_random_in_range, ":lost_gold", ":min_lost", ":max_lost"),
	  ##diplomacy start+
	  (try_begin),
		#This does nothing unless the option is enabled.
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_MEDIUM),
		#add extra gold from enemy's looting skill
		(gt, ":enemy_party_no", 0),
		(party_get_skill_level, reg0, ":enemy_party_no", "skl_looting"),
		(val_clamp, reg0, 0, 11),#allow range +0 to +10
		(val_add, reg0, 10),
		(val_mul, ":lost_gold", reg0),
		(val_div, ":lost_gold", 10),
		#Add any gold from items not looted.
		(val_add, ":lost_gold", ":extra_gold"),
		#gold looted can't exceed player's actual gold
		(val_min, ":lost_gold", ":cur_gold"),
		(val_max, ":lost_gold", 0),
      (try_end),
	  #diplomacy end+
      (troop_remove_gold, "trp_player", ":lost_gold"),
	  ##diplomacy start+
	  (try_begin),
	    #add looted gold to the enemy, if he's a valid hero
		(is_between, ":party_leader", heroes_begin, heroes_end),
		(troop_is_hero, ":party_leader"),
		(neq, ":party_leader", "trp_player"),
		(neq, ":party_leader", "trp_kingdom_heroes_including_player_begin"),
		(ge, ":lost_gold", 1),
		#(call_script, "script_troop_add_gold", ":party_leader", ":lost_gold"),#add looted gold to enemy
		(troop_get_slot, reg0, ":party_leader", slot_troop_wealth),
		(val_add, reg0, ":lost_gold"),
		(val_max, reg0, 0),
		(troop_set_slot, ":party_leader", slot_troop_wealth, reg0),#add looted gold to enemy
	  (try_end),
	  (assign, reg0, ":save_reg0"),#revert register
	  ##diplomacy end+
      ]),


  #script_party_calculate_loot:
  # INPUT:
  # param1: Party-id
  # Returns num looted items in reg0
  ("party_calculate_loot",
    [
      (store_script_param_1, ":enemy_party"), #Enemy Party_id

      (call_script, "script_calculate_main_party_shares"),
      (assign, ":num_player_party_shares", reg0),

      (try_for_range, ":i_loot", 0, num_party_loot_slots),
        (store_add, ":cur_loot_slot", ":i_loot", slot_party_looted_item_1),
        (party_get_slot, ":item_no", "$g_enemy_party", ":cur_loot_slot"),
        (gt, ":item_no", 0),
        (party_set_slot, "$g_enemy_party", ":cur_loot_slot", 0),
        (val_sub, ":cur_loot_slot", slot_party_looted_item_1),
        (val_add, ":cur_loot_slot", slot_party_looted_item_1_modifier),
        (party_get_slot, ":item_modifier", "$g_enemy_party", ":cur_loot_slot"),
        (troop_add_item, "trp_temp_troop", ":item_no", ":item_modifier"),
      (try_end),
      (party_set_slot, "$g_enemy_party", slot_party_next_looted_item_slot, 0),

      (assign, ":num_looted_items",0),
      (try_begin),
        (this_or_next|party_slot_eq, "$g_enemy_party", slot_party_type, spt_kingdom_caravan),
        (this_or_next|party_slot_eq, "$g_enemy_party", slot_party_type, spt_bandit_lair),
        (party_slot_eq, "$g_enemy_party", slot_party_type, spt_village_farmer),
        (store_mul, ":plunder_amount", player_loot_share, 30),
        (val_mul, ":plunder_amount", "$g_strength_contribution_of_player"),
        (val_div, ":plunder_amount", 100),
        (val_div, ":plunder_amount", ":num_player_party_shares"),
        (try_begin),
          (party_slot_eq, "$g_enemy_party", slot_party_type, spt_kingdom_caravan),
          (reset_item_probabilities, 100),
          (assign, ":range_min", trade_goods_begin),
          (assign, ":range_max", trade_goods_end),
        (else_try),
          (party_slot_eq, "$g_enemy_party", slot_party_type, spt_bandit_lair),
          (val_div, ":plunder_amount", 2),
          (reset_item_probabilities, 1),
          (assign, ":range_min", food_begin),
          (assign, ":range_max", food_end),
        (else_try),
          (val_div, ":plunder_amount", 5),
          (reset_item_probabilities, 1),
          (assign, ":range_min", food_begin),
          (assign, ":range_max", food_end),
        (try_end),
        (store_sub, ":item_to_price_slot", slot_town_trade_good_prices_begin, trade_goods_begin),
        (try_for_range, ":cur_goods", ":range_min", ":range_max"),
          (try_begin),
            (neg|party_slot_eq, "$g_enemy_party", slot_party_type, spt_bandit_lair),
            (store_add, ":cur_price_slot", ":cur_goods", ":item_to_price_slot"),
            (party_get_slot, ":cur_price", "$g_enemy_party", ":cur_price_slot"),
          (else_try),
            (assign, ":cur_price", maximum_price_factor),
            (val_add, ":cur_price", average_price_factor),
            (val_div, ":cur_price", 3),
          (try_end),

          (assign, ":cur_probability", 100),
          (val_mul, ":cur_probability", average_price_factor),
          (val_div, ":cur_probability", ":cur_price"),
          (assign, reg0, ":cur_probability"),
          (set_item_probability_in_merchandise, ":cur_goods", ":cur_probability"),
        (try_end),
        (troop_add_merchandise, "trp_temp_troop", itp_type_goods, ":plunder_amount"),
        (val_add, ":num_looted_items", ":plunder_amount"),
      (try_end),

      #Now loot the defeated party
      (store_mul, ":loot_probability", player_loot_share, 3),
      (val_mul, ":loot_probability", "$g_strength_contribution_of_player"),
      (party_get_skill_level, ":player_party_looting", "p_main_party", "skl_looting"),
      (val_add, ":player_party_looting", 10),
      (val_mul, ":loot_probability", ":player_party_looting"),
      (val_div, ":loot_probability", 10),
      (val_div, ":loot_probability", ":num_player_party_shares"),

      (party_get_num_companion_stacks, ":num_stacks",":enemy_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":enemy_party",":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (party_stack_get_size, ":stack_size",":enemy_party",":i_stack"),
        (try_for_range, ":unused", 0, ":stack_size"),
          (troop_loot_troop, "trp_temp_troop", ":stack_troop", ":loot_probability"),
        (try_end),
      (try_end),

      #(troop_get_inventory_capacity, ":inv_cap", "trp_temp_troop"),
      #(try_for_range, ":i_slot", 0, ":inv_cap"),
      #  (troop_get_inventory_slot, ":item_id", "trp_temp_troop", ":i_slot"),
      #  (is_between, ":item_id", horses_begin, horses_end),
      #  (troop_set_inventory_slot, "trp_temp_troop", ":i_slot", -1),
      #(try_end),

      (troop_get_inventory_capacity, ":inv_cap", "trp_temp_troop"),
      (try_for_range, ":i_slot", 0, ":inv_cap"),
        (troop_get_inventory_slot, ":item_id", "trp_temp_troop", ":i_slot"),
        (ge, ":item_id", 0),
        (val_add, ":num_looted_items", 1),
      (try_end),

      (assign, reg0, ":num_looted_items"),
  ]),

  #script_calculate_main_party_shares:
  # INPUT:
  # Returns number of player party shares in reg0
  ("calculate_main_party_shares",
    [
      (assign, ":num_player_party_shares", player_loot_share),
      # Add shares for player's party
      (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
      (try_for_range, ":i_stack", 1, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", "p_main_party", ":i_stack"),
        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size","p_main_party",":i_stack"),
          (val_add, ":num_player_party_shares", ":stack_size"),
        (else_try),
          (val_add, ":num_player_party_shares", hero_loot_share),
        (try_end),
      (try_end),

      (assign, reg0, ":num_player_party_shares"),
  ]),

  #script_party_give_xp_and_gold:
  # INPUT:
  # param1: destroyed Party-id
  # calculates and gives player paty's share of gold and xp.

  ("party_give_xp_and_gold",
    [
      (store_script_param_1, ":enemy_party"), #Party_id

      (call_script, "script_calculate_main_party_shares"),
      (assign, ":num_player_party_shares", reg0),

      (assign, ":total_gain", 0),
      (party_get_num_companion_stacks, ":num_stacks",":enemy_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id,     ":stack_troop",":enemy_party",":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (party_stack_get_size, ":stack_size",":enemy_party",":i_stack"),
        (store_character_level, ":level", ":stack_troop"),
        (store_add, ":gain", ":level", 10),
        (val_mul, ":gain", ":gain"),
        (val_div, ":gain", 10),
        (store_mul, ":stack_gain", ":gain", ":stack_size"),
        (val_add, ":total_gain", ":stack_gain"),
      (try_end),

      (val_mul, ":total_gain", "$g_strength_contribution_of_player"),
      (val_div, ":total_gain", 100),

      (val_min, ":total_gain", 40000), #eliminate negative results

      (assign, ":player_party_xp_gain", ":total_gain"),

      (store_random_in_range, ":r", 50, 100),
      (val_mul, ":player_party_xp_gain", ":r"),
      (val_div, ":player_party_xp_gain", 100),

      (party_add_xp, "p_main_party", ":player_party_xp_gain"),

      (store_mul, ":player_gold_gain", ":total_gain", player_loot_share),
      (val_min, ":player_gold_gain", 60000), #eliminate negative results
      (store_random_in_range, ":r", 50, 100),
      (val_mul, ":player_gold_gain", ":r"),
      (val_div, ":player_gold_gain", 100),
      (val_div, ":player_gold_gain", ":num_player_party_shares"),

      #add gold now
      (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (call_script, "script_troop_add_gold", ":stack_troop", ":player_gold_gain"),
        (try_end),
      (try_end),
  ]),


  #script_setup_troop_meeting:
  # INPUT:
  # param1: troop_id with which meeting will be made.
  # param2: troop_dna (optional)

  ("setup_troop_meeting",
    [
      (store_script_param_1, ":meeting_troop"),
      (store_script_param_2, ":troop_dna"),
      (call_script, "script_get_meeting_scene"),
      (assign, ":meeting_scene", reg0),
      (modify_visitors_at_site,":meeting_scene"),
      (reset_visitors),
      (set_visitor,0,"trp_player"),
	  (try_begin),
		(gt, ":troop_dna", -1),
        (troop_set_slot, "trp_temp_array_c", 17, ":troop_dna"),
        (set_visitor,17,":meeting_troop",":troop_dna"),
	  (else_try),
        (set_visitor,17,":meeting_troop"),
	  (try_end),
      (set_jump_mission,"mt_conversation_encounter"),
      (jump_to_scene,":meeting_scene"),
      (change_screen_map_conversation, ":meeting_troop"),
  ]),

  #script_setup_party_meeting:
  # INPUT:
  # param1: Party-id with which meeting will be made.

  ("setup_party_meeting",
    [
      (store_script_param_1, ":meeting_party"),
      (try_begin),
        (lt, "$g_encountered_party_relation", 0), #hostile
#        (call_script, "script_music_set_situation_with_culture", mtf_sit_encounter_hostile),
      (try_end),
      (call_script, "script_get_meeting_scene"), (assign, ":meeting_scene", reg0),
      (modify_visitors_at_site,":meeting_scene"),(reset_visitors),
      (set_visitor,0,"trp_player"),
      (party_stack_get_troop_id, ":meeting_troop",":meeting_party",0),
      (party_stack_get_troop_dna,":troop_dna",":meeting_party",0),
      (set_visitor,17,":meeting_troop",":troop_dna"),
      (set_jump_mission,"mt_conversation_encounter"),
      (jump_to_scene,":meeting_scene"),
      (change_screen_map_conversation, ":meeting_troop"),
  ]),

  #script_get_meeting_scene:
  # INPUT: none
  # OUTPUT: reg0 contain suitable scene_no

  ("get_meeting_scene",
    [
      (party_get_current_terrain, ":terrain_type", "p_main_party"),
      (assign, ":scene_to_use", "scn_random_scene"),
      (try_begin),
        (eq, ":terrain_type", rt_steppe),
        (assign, ":scene_to_use", "scn_meeting_scene_steppe"),
      (else_try),
        (eq, ":terrain_type", rt_plain),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (else_try),
        (eq, ":terrain_type", rt_snow),
        (assign, ":scene_to_use", "scn_meeting_scene_snow"),
      (else_try),
        (eq, ":terrain_type", rt_desert),
        (assign, ":scene_to_use", "scn_meeting_scene_desert"),
      (else_try),
        (eq, ":terrain_type", rt_steppe_forest),
        (assign, ":scene_to_use", "scn_meeting_scene_steppe"),
      (else_try),
        (eq, ":terrain_type", rt_forest),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (else_try),
        (eq, ":terrain_type", rt_snow_forest),
        (assign, ":scene_to_use", "scn_meeting_scene_snow"),
      (else_try),
        (eq, ":terrain_type", rt_desert_forest),
        (assign, ":scene_to_use", "scn_meeting_scene_desert"),
      (else_try),
        (this_or_next|eq, ":terrain_type", rt_river),
        (eq, ":terrain_type", rt_water),
        (assign, ":scene_to_use", "scn_sea_boarding_a_a"),

        (party_get_slot, ":ship_type", "$g_encountered_party", slot_party_ship_type),
        (try_begin),
          (eq, ":ship_type", 1),
          (assign, ":scene_to_use", "scn_sea_boarding_a_a"),
        (else_try),
          (eq, ":ship_type", 2),
          (assign, ":scene_to_use", "scn_sea_boarding_b_b"),
        (else_try),
          (eq, ":ship_type", 3),
          (assign, ":scene_to_use", "scn_sea_boarding_c_c"),
        (else_try),
          (eq, ":ship_type", 4),
          (assign, ":scene_to_use", "scn_sea_boarding_d_d"),
        (try_end),

      (else_try),
        (assign, ":scene_to_use", "scn_meeting_scene_plain"),
      (try_end),
      (assign, reg0, ":scene_to_use"),
  ]),

  #script_party_remove_all_companions:
  # INPUT:
  # param1: Party-id from which  companions will be removed.
  # "$g_move_heroes" : controls if heroes will also be removed.

  ("party_remove_all_companions",
    [
      (store_script_param_1, ":party"), #Source Party_id
      (party_get_num_companion_stacks, ":num_companion_stacks",":party"),
      (try_for_range_backwards, ":stack_no", 0, ":num_companion_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party",":stack_no"),

        (party_stack_get_size, ":stack_size", ":party", ":stack_no"),

        (try_begin),
		##diplomacy start+
		  #To avoid problems with temporarily-rejoined promoted companions and ladies
		  #suddenly forgetting that they're lords, check this.
			#If the troop is a companion or a kingdom lady...
			(this_or_next|is_between, ":stack_troop", companions_begin, companions_end),
				(is_between, ":stack_troop", kingdom_ladies_begin, kingdom_ladies_end),
			#...but has since become a lord
			(this_or_next|troop_slot_eq, ":stack_troop", slot_troop_playerparty_history, dplmc_pp_history_granted_fief),
			(this_or_next|troop_slot_eq, ":stack_troop", slot_troop_playerparty_history, dplmc_pp_history_lord_rejoined),
				(troop_slot_eq, ":stack_troop", slot_troop_occupation, slto_kingdom_hero),
			#...and the troop would be removed
			(this_or_next|eq, "$g_move_heroes", 1),
				(eq, ":party", "p_main_party"),
			#Then set up the troop as if it was a lord that was just defeated but escaped
			(troop_set_slot, ":stack_troop", slot_troop_occupation, slto_kingdom_hero),
			(troop_set_slot, ":stack_troop", slot_troop_leaded_party, -1),
			(troop_set_slot, ":stack_troop", slot_troop_prisoner_of_party, -1),
			(troop_set_slot, ":stack_troop", slot_troop_cur_center, -1),
			(party_remove_members, ":party", ":stack_troop", ":stack_size"),
		#Fall through to standard behavior:
		(else_try),
	    ##diplomacy end+
          (troop_is_hero, ":stack_troop"),
          (neg|is_between, ":stack_troop", pretenders_begin, pretenders_end),
          #SB : insert fix for wife as companion, do not let her get imprisoned because dialogues aren't fun to debug
          (neg|troop_slot_eq, "trp_player", slot_troop_spouse, ":stack_troop"),
          (neq, ":stack_troop", "trp_player"),
          (eq, "$g_prison_heroes", 1),
          (eq, ":party", "p_main_party"),
          (store_random_in_range, ":succeed_escaping", 0, 2),
          (neq, ":succeed_escaping", 0), #50% chance companion stays with us.
          (troop_set_health, ":stack_troop", 100), #heal before leaving
          (store_faction_of_party, ":enemy_faction", "$g_enemy_party"),
          (assign, ":minimum_distance", 99999),
          (assign, ":prison_center", -1),
          (try_for_range, ":center", walled_centers_begin, walled_centers_end),
            (store_faction_of_party, ":center_faction", ":center"),
            (eq, ":center_faction", ":enemy_faction"),
            (store_distance_to_party_from_party, ":dist", ":center", "p_main_party"),
            (lt, ":dist", ":minimum_distance"),
            (assign, ":minimum_distance", ":dist"),
            (assign, ":prison_center", ":center"),
          (try_end),
          (assign, reg1, ":prison_center"),
          #(display_message, "@{!}DEBUG : prison center is {reg1}"),
          (try_begin),
            (ge, ":prison_center", 0),
            (store_random_in_range, ":succeed_escaping", 0, 4),
            (neq, ":succeed_escaping", 0), #25% chance companion escapes to a tavern.
            (party_add_prisoners, ":prison_center", ":stack_troop", ":stack_size"),
            (troop_set_slot, ":stack_troop", slot_troop_prisoner_of_party, ":prison_center"),
            (troop_set_slot, ":stack_troop", slot_troop_playerparty_history, pp_history_scattered),
            (troop_set_slot, ":stack_troop", slot_troop_turned_down_twice, 0),
            (troop_set_slot, ":stack_troop", slot_troop_occupation, 0),
            (party_remove_members, ":party", ":stack_troop", ":stack_size"),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (str_store_party_name, s1, ":prison_center"),
              (display_message, "str_your_hero_prisoned_at_s1"),
            (try_end),
          (else_try),
            #bandits or deserters won and captured companion. So place it randomly in a town's tavern.
            (assign, ":end_condition", 1000),
            (try_for_range, ":unused", 0, ":end_condition"),
              (store_random_in_range, ":town_no", towns_begin, towns_end),
			  ##diplomacy start+
			  #OLD (NATIVE) VERSION:
			  #(neg|troop_slot_eq, ":stack_troop", slot_troop_home, ":town_no"),
              #(neg|troop_slot_eq, ":stack_troop", slot_troop_first_encountered, ":town_no"),
			  #
			  #NEW (DIPLOMACY+) VERSION:
			  #If the player owns the town, the companion is no longer in "never return" mode.
			  (party_get_slot, ":town_lord", ":town_no", slot_town_lord),
			  (this_or_next|eq, ":town_lord", "trp_player"),
			  (this_or_next|troop_slot_eq, "trp_player", slot_troop_spouse, ":town_lord"),
				(neg|troop_slot_eq, ":stack_troop", slot_troop_home, ":town_no"),
              (this_or_next|eq, ":town_lord", "trp_player"),
			  (this_or_next|troop_slot_eq, "trp_player", slot_troop_spouse, ":town_lord"),
			     (neg|troop_slot_eq, ":stack_troop", slot_troop_first_encountered, ":town_no"),
			  ##diplomacy end+
              (assign, ":end_condition", -1),
            (try_end),
            (troop_set_slot, ":stack_troop", slot_troop_cur_center, ":town_no"),
            (troop_set_slot, ":stack_troop", slot_troop_playerparty_history, pp_history_scattered),
            (troop_set_slot, ":stack_troop", slot_troop_turned_down_twice, 0),
            (troop_set_slot, ":stack_troop", slot_troop_occupation, 0),
            (party_remove_members, ":party", ":stack_troop", ":stack_size"),
            (try_begin),
              (eq, "$cheat_mode", 1),
              (str_store_troop_name, 4, ":stack_troop"),
              (str_store_party_name, 5, ":town_no"),
              (display_message, "@{!}{s4} is sent to {s5} after defeat"),
            (try_end),
          (try_end),
        (else_try),
          (this_or_next|neg|troop_is_hero, ":stack_troop"),
          (eq, "$g_move_heroes", 1),
          (party_remove_members, ":party", ":stack_troop", ":stack_size"),
        (try_end),
      (try_end),
  ]),

  #script_party_remove_all_prisoners:
  # INPUT:
  # param1: Party-id from which  prisoners will be removed.
  # "$g_move_heroes" : controls if heroes will also be removed.

  ("party_remove_all_prisoners",
    [
      (store_script_param_1, ":party"), #Source Party_id
      (party_get_num_prisoner_stacks, ":num_prisoner_stacks",":party"),
      (try_for_range_backwards, ":stack_no", 0, ":num_prisoner_stacks"),
        (party_prisoner_stack_get_troop_id, ":stack_troop",":party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_prisoner_stack_get_size, ":stack_size",":party",":stack_no"),
        (party_remove_prisoners, ":party", ":stack_troop", ":stack_size"),
      (try_end),
  ]),

  #script_party_add_party_companions:
  # INPUT:
  # param1: Party-id to add the second part
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.

  ("party_add_party_companions",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_companion_stacks, ":num_stacks",":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":source_party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_members, ":target_party", ":stack_troop", ":stack_size"),
        (party_stack_get_num_wounded, ":num_wounded", ":source_party", ":stack_no"),
        (party_wound_members, ":target_party", ":stack_troop", ":num_wounded"),
      (try_end),
  ]),

  #script_party_add_party_prisoners:
  # INPUT:
  # param1: Party-id to add the second party
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.

  ("party_add_party_prisoners",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_prisoner_stacks, ":num_stacks",":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_prisoner_stack_get_troop_id, ":stack_troop",":source_party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_prisoner_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_members, ":target_party", ":stack_troop", ":stack_size"),
      (try_end),
  ]),

  #script_party_prisoners_add_party_companions:
  # INPUT:
  # param1: Party-id to add the second part
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.

  ("party_prisoners_add_party_companions",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_companion_stacks, ":num_stacks",":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":source_party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_prisoners, ":target_party", ":stack_troop", ":stack_size"),
      (try_end),
  ]),

  #script_party_prisoners_add_party_prisoners:
  # INPUT:
  # param1: Party-id to add the second part
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.

  ("party_prisoners_add_party_prisoners",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_prisoner_stacks, ":num_stacks",":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_prisoner_stack_get_troop_id, ":stack_troop",":source_party",":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        (party_prisoner_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_prisoners, ":target_party", ":stack_troop", ":stack_size"),
      (try_end),
  ]),

  # script_party_add_party:
  # INPUT:
  # param1: Party-id to add the second part
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.

  ("party_add_party",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (call_script, "script_party_add_party_companions",          ":target_party", ":source_party"),
      (call_script, "script_party_prisoners_add_party_prisoners", ":target_party", ":source_party"),
  ]),


  #script_party_copy:
  # INPUT:
  # param1: Party-id to copy the second party
  # param2: Party-id which will be copied to the first one.

  ("party_copy",
    [
      (assign, "$g_move_heroes", 1),
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_clear, ":target_party"),
      (call_script, "script_party_add_party", ":target_party", ":source_party"),
  ]),


  #script_clear_party_group:
  # INPUT:
  # param1: Party-id of the root of the group.
  # This script will clear the root party and all parties attached to it recursively.

  ("clear_party_group",
    [
      (store_script_param_1, ":root_party"),

      (party_clear, ":root_party"),
      (party_get_num_attached_parties, ":num_attached_parties", ":root_party"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":root_party", ":attached_party_rank"),
        (call_script, "script_clear_party_group", ":attached_party"),
      (try_end),
  ]),


  #script_party_add_wounded_members_as_prisoners:
  # INPUT:
  # param1: Party-id to add the second party
  # param2: Party-id which will be added to the first one.
  # "$g_move_heroes" : controls if heroes will also be added.

  ("party_add_wounded_members_as_prisoners",
    [
      (store_script_param_1, ":target_party"), #Target Party_id
      (store_script_param_2, ":source_party"), #Source Party_id
      (party_get_num_companion_stacks, ":num_stacks", ":source_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
        (party_stack_get_num_wounded, ":num_wounded", ":source_party", ":stack_no"),
        (ge, ":num_wounded", 1),
        (party_stack_get_troop_id, ":stack_troop", ":source_party", ":stack_no"),
        (this_or_next|neg|troop_is_hero, ":stack_troop"),
        (eq, "$g_move_heroes", 1),
        #(party_prisoner_stack_get_size, ":stack_size",":source_party",":stack_no"),
        (party_add_prisoners, ":target_party", ":stack_troop", ":num_wounded"),
      (try_end),
  ]),


  #script_get_nonempty_party_in_group:
  # INPUT:
  # param1: Party-id of the root of the group.
  # OUTPUT: reg0: nonempy party-id

  ("get_nonempty_party_in_group",
    [
      (store_script_param_1, ":party_no"),
      (party_get_num_companion_stacks, ":num_companion_stacks", ":party_no"),
      (try_begin),
        (gt, ":num_companion_stacks", 0),
        (assign, reg0, ":party_no"),
      (else_try),
        (assign, reg0, -1),

        (party_get_num_attached_parties, ":num_attached_parties", ":party_no"),
        (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
          (lt, reg0, 0),
          (party_get_attached_party_with_rank, ":attached_party", ":party_no", ":attached_party_rank"),
          (call_script, "script_get_nonempty_party_in_group", ":attached_party"),
        (try_end),
      (try_end),
  ]),

  #script_collect_prisoners_from_empty_parties:
  # INPUT:
  # param1: Party-id of the root of the group.
  # param2: Party to collect prisoners in.
  # make sure collection party is cleared before calling this.

  ("collect_prisoners_from_empty_parties",
    [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":collection_party"),

      (party_get_num_companions, ":num_companions", ":party_no"),
      (try_begin),
        (eq, ":num_companions", 0), #party is empty (has no companions). Collect its prisoners.
        (party_get_num_prisoner_stacks, ":num_stacks",":party_no"),
        (try_for_range, ":stack_no", 0, ":num_stacks"),
          (party_prisoner_stack_get_troop_id, ":stack_troop", ":party_no", ":stack_no"),
          (troop_is_hero, ":stack_troop"),
          (party_add_members, ":collection_party", ":stack_troop", 1),
        (try_end),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":party_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":party_no", ":attached_party_rank"),
        (call_script, "script_collect_prisoners_from_empty_parties", ":attached_party", ":collection_party"),
      (try_end),
  ]),

  #script_change_party_morale:
  # INPUT: party_no, morale_gained
  # OUTPUT: none

  ("change_party_morale",
   [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":morale_dif"),

      (party_get_morale, ":cur_morale", ":party_no"),
      (store_add, ":new_morale", ":cur_morale", ":morale_dif"),
      (val_clamp, ":new_morale", 0, 100),
      (party_set_morale, ":party_no", ":new_morale"),
      (str_store_party_name, s1, ":party_no"),

      (try_begin),
        (lt, ":new_morale", ":cur_morale"),
        (store_sub, reg1, ":cur_morale", ":new_morale"),
      (else_try),
        (gt, ":new_morale", ":cur_morale"),
        (store_sub, reg1, ":new_morale", ":cur_morale"),
      (try_end),
  ]),

  #script_count_casualties_and_adjust_morale:
  # INPUT: none
  # OUTPUT: none

  ("count_casualties_and_adjust_morale",
   [
    (call_script, "script_calculate_main_party_shares"),
    (assign, ":num_player_party_shares", reg0),

    (assign, ":our_loss_score", 0),
    (party_get_num_companion_stacks, ":num_stacks","p_player_casualties"),
    (try_for_range, ":i_stack", 0, ":num_stacks"),
      (party_stack_get_troop_id, ":stack_troop", "p_player_casualties", ":i_stack"),
      (party_stack_get_size, ":stack_size", "p_player_casualties", ":i_stack"),

      (party_stack_get_num_wounded, ":num_wounded", "p_player_casualties", ":i_stack"),
      (store_mul, ":stack_size_mul_2", ":stack_size", 2),
      ##diplomacy start+ Fix what appears to be a mistake in Native
      #(store_sub, ":stack_size_mul_2_sub_wounded", ":num_wounded"),##OLD
      (store_sub, ":stack_size_mul_2_sub_wounded", ":stack_size_mul_2", ":num_wounded"),##NEW
      ##diplomacy end+

      (store_character_level, ":level", ":stack_troop"),
      (store_add, ":gain", ":level", 3),

      #if died/wounded troop is player troop then give its level +30 while calculating troop die effect on morale
      (try_begin),
        (eq, ":stack_troop", "trp_player"),
        (val_add, ":level", 75),
      (else_try),
        (troop_is_hero, ":stack_troop"),
        (val_add, ":level", 50),
      (try_end),

      (val_mul, ":gain", ":gain"),
      (val_div, ":gain", 10),
      (assign, reg0, ":gain"),
      (val_mul, ":gain", ":stack_size"),

      (try_begin),
        (neg|troop_is_hero, ":stack_troop"),
        (val_mul, ":gain", ":stack_size_mul_2_sub_wounded"),
        (val_div, ":gain", ":stack_size_mul_2"),
      (try_end),

      (try_begin),
        (eq, "$cheat_mode", 1),
        (assign, reg1, ":stack_size"),
        (assign, reg2, ":gain"),
        (display_message, "str_our_per_person__reg0_num_people__reg1_total_gain__reg2"),
      (try_end),
      (val_add, ":our_loss_score", ":gain"),
    (try_end),

    (assign, ":died_enemy_population", 0),
    (assign, ":enemy_loss_score", 0),
    (party_get_num_companion_stacks, ":num_stacks","p_enemy_casualties"),
    (try_for_range, ":i_stack", 0, ":num_stacks"),
      (party_stack_get_troop_id, ":stack_troop", "p_enemy_casualties", ":i_stack"),
      (party_stack_get_size, ":stack_size", "p_enemy_casualties", ":i_stack"),

      (party_stack_get_num_wounded, ":num_wounded", "p_enemy_casualties", ":i_stack"),
      (store_mul, ":stack_size_mul_2", ":stack_size", 2),
      (store_sub, ":stack_size_mul_2_sub_wounded", ":stack_size_mul_2", ":num_wounded"),

      (store_character_level, ":level", ":stack_troop"),
      (store_add, ":gain", ":level", 3),

      #if troop is hero give extra +15 level while calculating troop die effect on morale
      (try_begin),
        (troop_is_hero, ":stack_troop"),
        (val_add, ":level", 50),
      (try_end),

      (val_mul, ":gain", ":gain"),
      (val_div, ":gain", 10),
      (assign, reg0, ":gain"),
      (val_mul, ":gain", ":stack_size"),

      (try_begin),
        (neg|troop_is_hero, ":stack_troop"),
        (val_mul, ":gain", ":stack_size_mul_2_sub_wounded"),
        (val_div, ":gain", ":stack_size_mul_2"),
      (try_end),

      (try_begin),
        (eq, "$cheat_mode", 1),
        (assign, reg1, ":stack_size"),
        (assign, reg2, ":gain"),
        (display_message, "str_ene_per_person__reg0_num_people__reg1_total_gain__reg2"),
      (try_end),
      (val_add, ":enemy_loss_score", ":gain"),
      (val_add, ":died_enemy_population", ":stack_size"),
    (try_end),

    (assign, ":ally_loss_score", 0),
    (try_begin),
      (eq, "$any_allies_at_the_last_battle", 1),
      (party_get_num_companion_stacks, ":num_stacks","p_ally_casualties"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", "p_ally_casualties", ":i_stack"),
        (party_stack_get_size, ":stack_size", "p_ally_casualties", ":i_stack"),

        (party_stack_get_num_wounded, ":num_wounded", "p_ally_casualties", ":i_stack"),
        (store_mul, ":stack_size_mul_2", ":stack_size", 2),
        ##diplomacy start+ Fix what appears to be a mistake in Native
        #(store_sub, ":stack_size_mul_2_sub_wounded", ":num_wounded"),##OLD
        (store_sub, ":stack_size_mul_2_sub_wounded", ":stack_size_mul_2", ":num_wounded"),##NEW
        ##diplomacy end+

        (store_character_level, ":level", ":stack_troop"),
        (store_add, ":gain", ":level", 3),

        #if troop is hero give extra +15 level while calculating troop die effect on morale
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (val_add, ":level", 50),
        (try_end),

        (val_mul, ":gain", ":gain"),
        (val_div, ":gain", 10),
        (assign, reg0, ":gain"),
        (val_mul, ":gain", ":stack_size"),

        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (val_mul, ":gain", ":stack_size_mul_2_sub_wounded"),
          (val_div, ":gain", ":stack_size_mul_2"),
        (try_end),

        (try_begin),
          (eq, "$cheat_mode", 1),
          (assign, reg1, ":stack_size"),
          (assign, reg2, ":gain"),
          (display_message, "str_all_per_person__reg0_num_people__reg1_total_gain__reg2"),
        (try_end),
        (val_add, ":ally_loss_score", ":gain"),
      (try_end),
    (try_end),

    (store_add, ":our_losses", ":our_loss_score", ":ally_loss_score"),
    (assign, ":enemy_losses", ":enemy_loss_score"),
    (val_mul, ":our_losses", 100),

    (try_begin),
      (eq, "$cheat_mode", 1),
      (assign, reg0, ":enemy_losses"),
      (display_message, "@{!}DEBUGS : enemy_loses : {reg0}"),
    (try_end),

    (try_begin),
      (gt, ":enemy_losses", 0),
      (store_div, ":loss_ratio", ":our_losses", ":enemy_losses"),
    (else_try),
      (assign, ":loss_ratio", 1000),
    (try_end),

    (try_begin),
      (eq, "$cheat_mode", 1),
      (assign, reg1, ":loss_ratio"),
      (display_message, "str_loss_ratio_is_reg1"),
    (try_end),

    (try_begin),
      (neg|is_between, "$g_enemy_party", centers_begin, centers_end),
      (store_sub, ":total_gain", 60, ":loss_ratio"),
    (else_try),
      (store_sub, ":total_gain", 100, ":loss_ratio"),
    (try_end),

    (try_begin),
      (lt, ":total_gain", 0),
      (val_div, ":total_gain", 2),
    (try_end),

    (try_begin),
      (eq, "$cheat_mode", 1),
      (assign, reg0, ":total_gain"),
      (display_message, "@{!}DEBUGS1 : total_gain : {reg0}"),
    (try_end),

    (val_max, ":total_gain", -60), #total gain changes between -60(1.8+ loss ratio) and 60(0 loss ratio). We assumed average loss ratio is 0.6
    (val_mul, ":total_gain", ":enemy_losses"),
    (val_div, ":total_gain", 100),

    (store_mul, ":total_enemy_morale_gain", ":total_gain", -1), #enemies get totally negative of the morale we get
    (val_mul, ":total_gain", "$g_strength_contribution_of_player"),
    (val_div, ":total_gain", 100),

    (try_begin),
      (eq, "$cheat_mode", 1),
      (assign, reg0, ":total_gain"),
      (display_message, "@{!}DEBUGS2 : total_gain : {reg0}"),
    (try_end),

    (try_begin),
      (party_is_active, "$g_enemy_party"), #change enemy morale if and only if there is a valid enemy party

      #main enemy party
      (assign, ":total_enemy_population", 0),
      (val_add, ":total_enemy_population", 10), #every part effect total population by number of agents they have plus 10
      (party_get_num_companion_stacks, ":num_stacks", "$g_enemy_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", "$g_enemy_party", ":i_stack"),
        (party_stack_get_size, ":stack_size", "$g_enemy_party", ":i_stack"),
        (val_add, ":total_enemy_population", ":stack_size"),
      (try_end),
      (assign, ":main_enemy_party_population", ":total_enemy_population"),

      #enemy attachers
      (party_get_num_attached_parties, ":num_attached_parties", "$g_enemy_party"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (val_add, ":total_enemy_population", 10), #every part effect total population by number of agents they have plus 10
        (party_get_attached_party_with_rank, ":attached_party", "$g_enemy_party", ":attached_party_rank"),
        (party_get_num_companion_stacks, ":num_stacks", ":attached_party"),
        (try_for_range, ":i_stack", 0, ":num_stacks"),
          (party_stack_get_troop_id, ":stack_troop", ":attached_party", ":i_stack"),
          (party_stack_get_size, ":stack_size", ":attached_party", ":i_stack"),
          (val_add, ":total_enemy_population", ":stack_size"),
        (try_end),
      (try_end),

      #(assign, reg3, ":total_enemy_population"),
      #(assign, reg4, ":died_enemy_population"),
      #(store_sub, ":remaining_enemy_population", ":total_enemy_population", ":died_enemy_population"),
      #(val_add, ":remaining_enemy_population", 10),
      #(assign, reg5, ":remaining_enemy_population"),
      #(display_message, "@total : {reg3}, died : {reg4}, remaining : {reg5}"),

      #remaining enemy population has 10+remaining soldiers in enemy party
      (assign, ":remaining_enemy_population", ":total_enemy_population"),

      (assign, reg5, ":remaining_enemy_population"),
      (assign, reg6, ":total_enemy_morale_gain"),

      (set_fixed_point_multiplier, 100),
      (val_mul, ":remaining_enemy_population", 100),
      (store_sqrt, ":sqrt_remaining_enemy_population", ":remaining_enemy_population"),
      (val_div, ":sqrt_remaining_enemy_population", 100),
      (val_div, ":total_enemy_morale_gain", ":sqrt_remaining_enemy_population"),
      (val_div, ":total_enemy_morale_gain", 4),

      (try_begin),
        (eq, "$cheat_mode", 1),
        (assign, reg7, ":total_enemy_morale_gain"),
        (display_message, "str_total_enemy_morale_gain__reg6_last_total_enemy_morale_gain__reg7_remaining_enemy_population__reg5"),
      (try_end),

      (store_mul, ":party_morale_gain", ":total_enemy_morale_gain", ":main_enemy_party_population"),
      (val_div, ":party_morale_gain", ":total_enemy_population"),

      (try_begin),
        (party_is_active, "$g_enemy_party"),

        (call_script, "script_change_party_morale", "$g_enemy_party", ":party_morale_gain"),

        (party_get_num_attached_parties, ":num_attached_parties", "$g_enemy_party"),
        (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
          (party_get_attached_party_with_rank, ":attached_party", "$g_enemy_party", ":attached_party_rank"),
          (party_get_num_companion_stacks, ":num_stacks", ":attached_party"),
          (assign, ":party_population", 0),
          (try_for_range, ":i_stack", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":stack_troop", ":attached_party", ":i_stack"),
            (party_stack_get_size, ":stack_size", ":attached_party", ":i_stack"),
            (val_add, ":party_population", ":stack_size"),
          (try_end),
          #(store_div, ":party_ratio", ":total_enemy_population_multiplied_by_100", ":party_population"), #party ratio changes between 0..100, shows population ratio of that party among all enemy parties
          (store_mul, ":party_morale_gain", ":total_enemy_morale_gain", ":party_population"),
          (val_div, ":party_morale_gain", ":total_enemy_population"),
          (call_script, "script_change_party_morale", ":attached_party", ":party_morale_gain"),
        (try_end),
      (try_end),
    (try_end),

    #Add morale
    (assign, ":morale_gain", ":total_gain"),
    (val_div, ":morale_gain", ":num_player_party_shares"),#if there are lots of soldiers in my party there will be less morale increase.

    (try_begin),
      (eq, "$cheat_mode", 1),
      (assign, reg0, ":num_player_party_shares"),
      (assign, reg1, ":total_gain"),
      (display_message, "@{!}DEBUGS3 : num_player_party_shares:{reg0}, total_gain:{reg1}"),
    (try_end),

    (call_script, "script_change_player_party_morale", ":morale_gain"),

    (store_mul, ":killed_enemies_by_our_soldiers", ":died_enemy_population", "$g_strength_contribution_of_player"),
    (store_div, ":faction_morale_change", ":killed_enemies_by_our_soldiers", 8), #each 8 killed agent with any faction decreases morale of troops belong to that faction in our party by 1.
    (try_begin),
      (gt, ":faction_morale_change", 2000),
      (assign, ":faction_morale_change", 2000),
    (try_end),

    (try_begin), #here we give positive morale to our troops of with same faction of ally party with 2/3x multipication.
      (ge, "$g_ally_party", 0),

      (store_div, ":ally_faction_morale_change", ":faction_morale_change", 3), #2/3x multipication (less than normal)
      (val_mul, ":ally_faction_morale_change", 2),
      (store_faction_of_party, ":ally_faction", "$g_ally_party"),
      (call_script, "script_change_faction_troop_morale", ":ally_faction", ":faction_morale_change", 0),
      # (faction_get_slot, ":faction_morale", ":ally_faction",  slot_faction_morale_of_player_troops),
      # (val_add, ":faction_morale", ":ally_faction_morale_change"),
      # (faction_set_slot, ":ally_faction",  slot_faction_morale_of_player_troops, ":faction_morale"),
    (try_end),

    (try_begin), #here we give positive morale to our troops of owner of rescued village's faction after saving village from bandits by x3 bonus.
      (neg|party_is_active, "$g_enemy_party"),
      (ge, "$current_town", 0),

      (val_mul, ":faction_morale_change", 2), #2x bonus (more than normal)
      (store_faction_of_party, ":ally_faction", "$current_town"),
      #SB : script call
      (call_script, "script_change_faction_troop_morale", ":ally_faction", ":faction_morale_change", 1),  #SB : script call
      # (faction_get_slot, ":faction_morale", ":ally_faction",  slot_faction_morale_of_player_troops),
      # (val_add, ":faction_morale", ":faction_morale_change"),
      # (faction_set_slot, ":ally_faction",  slot_faction_morale_of_player_troops, ":faction_morale"),
    (else_try),
      (party_is_active, "$g_enemy_party"),
      (assign, ":currently_in_rebellion", 0),
      (try_begin),
        (eq, "$players_kingdom", "fac_player_supporters_faction"),
        (neg|faction_slot_eq, "fac_player_supporters_faction", slot_faction_leader, "trp_player"),
        (assign, ":currently_in_rebellion", 1),
      (try_end),
      (eq, ":currently_in_rebellion", 0),

      (store_div, ":faction_morale_change", ":faction_morale_change", 3), #2/3x multipication (less than normal)
      (val_mul, ":faction_morale_change", 2),
      (store_faction_of_party, ":enemy_faction", "$g_enemy_party"),
      (call_script, "script_change_faction_troop_morale", ":enemy_faction", ":faction_morale_change", 0), #SB : script call
      # (faction_get_slot, ":faction_morale", ":enemy_faction",  slot_faction_morale_of_player_troops),
      # (val_sub, ":faction_morale", ":faction_morale_change"),
      # (faction_set_slot, ":enemy_faction",  slot_faction_morale_of_player_troops, ":faction_morale"),
    (try_end),

  ]),

  #script_print_casualties_to_s0:
  # INPUT:
  # param1: Party_id, param2: 0 = use new line, 1 = use comma

  #OUTPUT:
  # string register 0.

  ("print_casualties_to_s0",
    [(store_script_param, ":party_no", 1),
     (store_script_param, ":use_comma", 2),
     (str_clear, s0),
     (assign, ":total_reported", 0),
     (assign, ":total_wounded", 0),
     (assign, ":total_killed", 0),
     (assign, ":total_routed", 0),
     (party_get_num_companion_stacks, ":num_stacks",":party_no"),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop_id", ":party_no", ":i_stack"),
       (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
       (party_stack_get_num_wounded, ":num_wounded", ":party_no", ":i_stack"),
       #get number of routed agent numbers
       (try_begin),
         (this_or_next|eq, ":party_no", "p_main_party"),
         (eq, ":party_no", "p_player_casualties"),
         (troop_get_slot, ":num_routed", ":stack_troop_id", slot_troop_player_routed_agents),
         (troop_set_slot, ":stack_troop_id", slot_troop_player_routed_agents, 0),
       (else_try),
         (party_get_attached_to, ":attached_to", ":party_no"),
         (this_or_next|eq, ":party_no", "p_ally_casualties"),
         (ge, ":attached_to", 0),
         (this_or_next|eq, ":party_no", "p_ally_casualties"),
         (eq, ":attached_to", "p_main_party"),
         (troop_get_slot, ":num_routed", ":stack_troop_id", slot_troop_ally_routed_agents),
         (troop_set_slot, ":stack_troop_id", slot_troop_ally_routed_agents, 0),
       (else_try),
         (troop_get_slot, ":num_routed", ":stack_troop_id", slot_troop_enemy_routed_agents),
         (troop_set_slot, ":stack_troop_id", slot_troop_enemy_routed_agents, 0),
       (try_end),
       (store_sub, ":num_killed", ":stack_size", ":num_wounded"),
       (val_sub, ":num_killed", ":num_routed"),
       (val_add, ":total_killed", ":num_killed"),
       (val_add, ":total_wounded", ":num_wounded"),
       (val_add, ":total_routed", ":num_routed"),
       (try_begin),
         (this_or_next|gt, ":num_killed", 0),
         (this_or_next|gt, ":num_wounded", 0),
         (gt, ":num_routed", 0),
         (store_add, reg3, ":num_killed", ":num_wounded"),
         (store_add, reg3, reg3, ":num_routed"),
         (str_store_troop_name_by_count, s1, ":stack_troop_id", reg3),
         (try_begin),
           (troop_is_hero, ":stack_troop_id"),
           (assign, reg3, 0),
         (try_end),
         (try_begin), #there are people who killed, wounded and routed.
           (gt, ":num_killed", 0),
           (gt, ":num_wounded", 0),
           (gt, ":num_routed", 0),
           (assign, reg4, ":num_killed"),
           (assign, reg5, ":num_wounded"),
           (assign, reg6, ":num_routed"),
           (str_store_string, s2, "str_reg4_killed_reg5_wounded_reg6_routed"),
         (else_try), #there are people who killed and routed.
           (gt, ":num_killed", 0),
           (gt, ":num_routed", 0),
           (assign, reg4, ":num_killed"),
           (assign, reg5, ":num_routed"),
           (str_store_string, s2, "str_reg4_killed_reg5_routed"),
         (else_try), #there are people who killed and wounded.
           (gt, ":num_killed", 0),
           (gt, ":num_wounded", 0),
           (assign, reg4, ":num_killed"),
           (assign, reg5, ":num_wounded"),
           (str_store_string, s2, "str_reg4_killed_reg5_wounded"),
         (else_try), #there are people who wounded and routed.
           (gt, ":num_wounded", 0),
           (gt, ":num_routed", 0),
           (assign, reg4, ":num_wounded"),
           (assign, reg5, ":num_routed"),
           (str_store_string, s2, "str_reg4_wounded_reg5_routed"),
         (else_try), #there are people who only killed.
           (gt, ":num_killed", 0),
           (assign, reg1, ":num_killed"),
           (str_store_string, s3, "@killed"),
           (str_store_string, s2, "str_reg1_blank_s3"),
         (else_try), #there are people who only wounded.
           (gt, ":num_wounded", 0),
           (assign, reg1, ":num_wounded"),
           (str_store_string, s3, "@wounded"),
           (str_store_string, s2, "str_reg1_blank_s3"),
         (else_try), #there are people who only routed.
           (assign, reg1, ":num_routed"),
           (str_store_string, s3, "str_routed"),
           (str_store_string, s2, "str_reg1_blank_s3"),
         (try_end),
         (try_begin),
           (eq, ":use_comma", 1),
           (try_begin),
             (eq, ":total_reported", 0),
             (str_store_string, s0, "@{!}{reg3?{reg3}:} {s1} ({s2})"),
           (else_try),
             (str_store_string, s0, "@{!}{s0}, {reg3?{reg3}:} {s1} ({s2})"),
           (try_end),
         (else_try),
           (str_store_string, s0, "@{!}{s0}^{reg3?{reg3}:} {s1} ({s2})"),
         (try_end),
         (val_add, ":total_reported", 1),
       (try_end),
     (try_end),
     (try_begin),
       (this_or_next|gt, ":total_killed", 0),
       (this_or_next|gt, ":total_wounded", 0),
       (gt, ":total_routed", 0),
       (store_add, ":total_agents", ":total_killed", ":total_wounded"),
       (val_add, ":total_agents", ":total_routed"),
       (assign, reg3, ":total_agents"),
       (try_begin),
         (gt, ":total_killed", 0),
         (gt, ":total_wounded", 0),
         (gt, ":total_routed", 0),
         (assign, reg4, ":total_killed"),
         (assign, reg5, ":total_wounded"),
         (assign, reg6, ":total_routed"),
         (str_store_string, s2, "str_reg4_killed_reg5_wounded_reg6_routed"),
       (else_try),
         (gt, ":total_killed", 0),
         (gt, ":total_routed", 0),
         (assign, reg4, ":total_killed"),
         (assign, reg5, ":total_routed"),
         (str_store_string, s2, "str_reg4_killed_reg5_routed"),
       (else_try),
         (gt, ":total_killed", 0),
         (gt, ":total_wounded", 0),
         (assign, reg4, ":total_killed"),
         (assign, reg5, ":total_wounded"),
         (str_store_string, s2, "str_reg4_killed_reg5_wounded"),
       (else_try),
         (gt, ":total_wounded", 0),
         (gt, ":total_routed", 0),
         (assign, reg4, ":total_wounded"),
         (assign, reg5, ":total_routed"),
         (str_store_string, s2, "str_reg4_wounded_reg5_routed"),
       (else_try),
         (gt, ":total_killed", 0),
         (str_store_string, s2, "@killed"),
       (else_try),
         (gt, ":total_wounded", 0),
         (str_store_string, s2, "@wounded"),
       (else_try),
         (str_store_string, s2, "str_routed"),
       (else_try),
       (try_end),
       (str_store_string, s0, "@{s0}^TOTAL: {reg3} ({s2})"),
     (else_try),
       (try_begin),
         (eq, ":use_comma", 1),
         (str_store_string, s0, "@None"),
       (else_try),
         (str_store_string, s0, "@^None"),
       (try_end),
     (try_end),
  ]),

  #script_write_fit_party_members_to_stack_selection
  # INPUT:
  # param1: party_no, exclude_leader
  #OUTPUT:
  # trp_stack_selection_amounts slots (slot 0 = number of stacks, 1 = number of men fit, 2..n = stack sizes (fit))
  # trp_stack_selection_ids slots (2..n = stack troops)
  ("write_fit_party_members_to_stack_selection",
   [
     (store_script_param, ":party_no", 1),
     (store_script_param, ":exclude_leader", 2),
     (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
     (assign, ":slot_index", 2),
     (assign, ":total_fit", 0),
     (try_for_range, ":stack_index", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop", ":party_no", ":stack_index"),
       (assign, ":num_fit", 0),
       (try_begin),
         (troop_is_hero, ":stack_troop"),
         (try_begin),
           (neg|troop_is_wounded, ":stack_troop"),
           (this_or_next|eq, ":exclude_leader", 0),
           (neq, ":stack_index", 0),
           (assign, ":num_fit",1),
         (try_end),
       (else_try),
         (party_stack_get_size, ":num_fit", ":party_no", ":stack_index"),
         (party_stack_get_num_wounded, ":num_wounded", ":party_no", ":stack_index"),
         (val_sub, ":num_fit", ":num_wounded"),
       (try_end),
       (try_begin),
         (gt, ":num_fit", 0),
         (troop_set_slot, "trp_stack_selection_amounts", ":slot_index", ":num_fit"),
         (troop_set_slot, "trp_stack_selection_ids", ":slot_index", ":stack_troop"),
         (val_add, ":slot_index", 1),
       (try_end),
       (val_add, ":total_fit", ":num_fit"),
     (try_end),
     (val_sub, ":slot_index", 2),
     (troop_set_slot, "trp_stack_selection_amounts", 0, ":slot_index"),
     (troop_set_slot, "trp_stack_selection_amounts", 1, ":total_fit"),
    ]),

  #script_remove_fit_party_member_from_stack_selection
  # INPUT:
  # param1: slot_index
  #OUTPUT:
  # reg0 = troop_no
  # trp_stack_selection_amounts slots (slot 0 = number of stacks, 1 = number of men fit, 2..n = stack sizes (fit))
  # trp_stack_selection_ids slots (2..n = stack troops)
  ("remove_fit_party_member_from_stack_selection",
   [
     (store_script_param, ":slot_index", 1),
     (val_add, ":slot_index", 2),
     (troop_get_slot, ":amount", "trp_stack_selection_amounts", ":slot_index"),
     (troop_get_slot, ":troop_no", "trp_stack_selection_ids", ":slot_index"),
     (val_sub, ":amount", 1),
     (troop_set_slot, "trp_stack_selection_amounts", ":slot_index", ":amount"),
     (troop_get_slot, ":total_amount", "trp_stack_selection_amounts", 1),
     (val_sub, ":total_amount", 1),
     (troop_set_slot, "trp_stack_selection_amounts", 1, ":total_amount"),
     (try_begin),
       (le, ":amount", 0),
       (troop_get_slot, ":num_slots", "trp_stack_selection_amounts", 0),
       (store_add, ":end_cond", ":num_slots", 2),
       (store_add, ":begin_cond", ":slot_index", 1),
       (try_for_range, ":index", ":begin_cond", ":end_cond"),
         (store_sub, ":prev_index", ":index", 1),
         (troop_get_slot, ":value", "trp_stack_selection_amounts", ":index"),
         (troop_set_slot, "trp_stack_selection_amounts", ":prev_index", ":value"),
         (troop_get_slot, ":value", "trp_stack_selection_ids", ":index"),
         (troop_set_slot, "trp_stack_selection_ids", ":prev_index", ":value"),
       (try_end),
       (val_sub, ":num_slots", 1),
       (troop_set_slot, "trp_stack_selection_amounts", 0, ":num_slots"),
     (try_end),
     (assign, reg0, ":troop_no"),
    ]),

  #script_remove_random_fit_party_member_from_stack_selection
  # INPUT:
  # none
  #OUTPUT:
  # reg0 = troop_no
  # trp_stack_selection_amounts slots (slot 0 = number of stacks, 1 = number of men fit, 2..n = stack sizes (fit))
  # trp_stack_selection_ids slots (2..n = stack troops)
  ("remove_random_fit_party_member_from_stack_selection",
   [
     (troop_get_slot, ":total_amount", "trp_stack_selection_amounts", 1),
     (store_random_in_range, ":random_troop", 0, ":total_amount"),
     (troop_get_slot, ":num_slots", "trp_stack_selection_amounts", 0),
     (store_add, ":end_cond", ":num_slots", 2),
     (try_for_range, ":index", 2, ":end_cond"),
       (troop_get_slot, ":amount", "trp_stack_selection_amounts", ":index"),
       (val_sub, ":random_troop", ":amount"),
       (lt, ":random_troop", 0),
       (assign, ":end_cond", 0),
       (store_sub, ":slot_index", ":index", 2),
     (try_end),
     (call_script, "script_remove_fit_party_member_from_stack_selection", ":slot_index"),
    ]),


  #script_add_routed_party
  #INPUT: none
  #OUTPUT: none
  ("add_routed_party",
   [
     (party_get_num_companion_stacks, ":num_stacks", "p_routed_enemies"), #question, I changed (total_enemy_casualties) with (p_routed_enemies) because this is not prisoner in p_routed_enemies party.
     (assign, ":num_regulars", 0),
     (assign, ":deleted_stacks", 0),
     (try_for_range, ":stack_no", 0, ":num_stacks"),
       (store_sub, ":difference", ":num_stacks", ":stack_no"),
       (ge, ":difference", ":deleted_stacks"),
       (store_sub, ":stack_no_minus_deleted", ":stack_no", ":deleted_stacks"),
       (party_stack_get_troop_id, ":stack_troop", "p_routed_enemies", ":stack_no_minus_deleted"),
       (try_begin),
         (troop_is_hero, ":stack_troop"),
         (party_stack_get_size, ":stack_size", "p_routed_enemies", ":stack_no_minus_deleted"),
         (party_remove_members, "p_routed_enemies", ":stack_troop", 1),
         (try_begin),
           (le, ":stack_size", 1),
           (val_add, ":deleted_stacks", 1), #if deleted hero is the only one in his troop, now we have one less stacks
         (try_end),
       (else_try),
         (val_add, ":num_regulars", 1),
       (try_end),
     (try_end),

     #add new party to map if there is at least one routed agent. (new party name : routed_party, template : routed_warriors)
     (try_begin),
       (ge, ":num_regulars", 1),

       (set_spawn_radius, 2),
       (spawn_around_party, "p_main_party", "pt_routed_warriors"),
       (assign, ":routed_party", reg0),
       # SB : white flag
       (party_set_banner_icon, ":routed_party", "icon_white_flag"),
       (party_set_slot, ":routed_party", slot_party_commander_party, -1), #we need this because 0 is player's party!

       (assign, ":max_routed_agents", 0),
       (assign, ":routed_party_faction", "fac_neutral"),
       (try_for_range, ":cur_faction", npc_kingdoms_begin, npc_kingdoms_end),
         (faction_get_slot, ":num_routed_agents_in_this_faction", ":cur_faction", slot_faction_num_routed_agents),
         (gt, ":num_routed_agents_in_this_faction", ":max_routed_agents"),
         (assign, ":max_routed_agents", ":num_routed_agents_in_this_faction"),
         (assign, ":routed_party_faction", ":cur_faction"),
       (try_end),

       (party_set_faction, ":routed_party", ":routed_party_faction"),

       (party_set_ai_behavior, ":routed_party", ai_bhvr_travel_to_party),

       (assign, ":minimum_distance", 1000000),
       #SB : get rid of useless range
       (store_random_in_range, ":nearest_ally_city", walled_centers_begin, walled_centers_end),
       (try_for_range, ":party_no", walled_centers_begin, walled_centers_end),
         # (party_is_active, ":party_no"),
         # (party_get_slot, ":cur_party_type", ":party_no", slot_party_type),
         # (this_or_next|eq, ":cur_party_type", spt_town),
         # (eq, ":cur_party_type", spt_castle),
         (store_faction_of_party, ":cur_faction", ":party_no"),
         (this_or_next|eq, ":routed_party_faction", "fac_neutral"),
         (eq, ":cur_faction", ":routed_party_faction"),
         (party_get_position, pos1, ":party_no"),
         (store_distance_to_party_from_party, ":dist", ":party_no", "p_main_party"),
         (try_begin),
           (lt, ":dist", ":minimum_distance"),
           (assign, ":minimum_distance", ":dist"),
           (assign, ":nearest_ally_city", ":party_no"),
         (try_end),
       (try_end),

       (party_get_position, pos1, "p_main_party"), #store position information of main party in pos1
       (party_get_position, pos2, ":nearest_ally_city"), #store position information of target city in pos2

       (assign, ":minimum_distance", 1000000),
       (try_for_range, ":unused", 0, 10),
         (map_get_random_position_around_position, pos3, pos1, 2), #store position of found random position (possible placing position for new routed party) around battle position in pos3
         (get_distance_between_positions, ":dist", pos2, pos3), #store distance between found position and target city in ":dist".
         (try_begin),
           (lt, ":dist", ":minimum_distance"),
           (assign, ":minimum_distance", ":dist"),
           (copy_position, pos63, pos3),
         (try_end),
       (end_try),

       (party_set_position, ":routed_party", pos63),

       (party_set_ai_object, ":routed_party", ":nearest_ally_city"),
       (party_set_flags, ":routed_party", pf_default_behavior, 1),
       #SB : add extra slot to actually merge with garrison
       (party_set_slot, ":routed_party", slot_party_type, spt_reinforcement),

       #adding party members of p_routed_enemies to routed_party
       (party_clear, ":routed_party"),
       (party_get_num_companion_stacks, ":num_stacks", "p_routed_enemies"), #question, I changed (total_enemy_casualties) with (p_routed_enemies) because this is not prisoner in p_routed_enemies party.
       (try_for_range, ":stack_no", 0, ":num_stacks"),
         (party_stack_get_troop_id, ":stack_troop", "p_routed_enemies", ":stack_no"),
         (try_begin),
           (neg|troop_is_hero, ":stack_troop"), #do not add routed heroes to (new created) routed party for now.

           (party_stack_get_size, ":stack_size", "p_routed_enemies", ":stack_no"),
           (party_add_members, ":routed_party", ":stack_troop", ":stack_size"),
         (try_end),
       (try_end),
     (try_end),
    ]), #ozan


  #script_cf_training_ground_sub_routine_1_for_melee_details
  # INPUT:
  # value
  #OUTPUT:
  # none
  ("cf_training_ground_sub_routine_1_for_melee_details",
   [
     (store_script_param, ":value", 1),
     (ge, "$temp_3", ":value"),
     (val_add, ":value", 1),
     (troop_get_slot, ":troop_id", "trp_stack_selection_ids", ":value"),
     (str_store_troop_name, s0, ":troop_id"),
     ]),

  #script_training_ground_sub_routine_2_for_melee_details
  # INPUT:
  # value
  #OUTPUT:
  # none
  ("training_ground_sub_routine_2_for_melee_details",
   [
     (store_script_param, ":value", 1),
     (val_sub, ":value", 1),
     (try_begin),
       (lt, ":value", 0),
       (call_script, "script_remove_random_fit_party_member_from_stack_selection"),
     (else_try),
       (call_script, "script_remove_fit_party_member_from_stack_selection", ":value"),
     (try_end),
     (assign, ":troop_id", reg0),
     (store_sub, ":slot_index", "$temp_2", 1),
     (troop_set_slot, "trp_temp_array_a", ":slot_index", ":troop_id"),
     (try_begin),
       (eq, "$temp", "$temp_2"),
       (call_script, "script_start_training_at_training_ground", -1, "$temp"),
     (else_try),
       (val_add, "$temp_2", 1),
       (jump_to_menu, "mnu_training_ground_selection_details_melee_2"),
     (try_end),
     ]),

  #script_cf_training_ground_sub_routine_for_training_result
  # INPUT:
  # arg1: troop_id, arg2: stack_no, arg3: troop_count, arg4: xp_ratio_to_add
  #OUTPUT:
  # none
  ("cf_training_ground_sub_routine_for_training_result",
   [
     (store_script_param, ":troop_id", 1),
     (store_script_param, ":stack_no", 2),
     (store_script_param, ":amount", 3),
     (store_script_param, ":xp_ratio_to_add", 4),

     (store_character_level, ":level", ":troop_id"),
     (store_add, ":level_added", ":level", 5),
     (store_mul, ":min_hardness", ":level_added", 3),
     (val_min, ":min_hardness", 100),
     (store_sub, ":hardness_dif", ":min_hardness", "$g_training_ground_training_hardness"),
     (val_max, ":hardness_dif", 0),
     (store_sub, ":hardness_dif", 100, ":hardness_dif"),
     (val_mul, ":hardness_dif", ":hardness_dif"),
     (val_div, ":hardness_dif", 10), # value over 1000
##     (assign, reg0, ":hardness_dif"),
##     (display_message, "@Hardness difference: {reg0}/1000"),
     (store_mul, ":xp_ratio_to_add_for_stack", ":xp_ratio_to_add", ":hardness_dif"),
     (val_div, ":xp_ratio_to_add_for_stack", 1000),
     (try_begin),
       (eq, ":troop_id", "trp_player"),
       (val_mul, ":xp_ratio_to_add_for_stack", 1),
     (else_try),
       (try_begin),
         (eq, "$g_mt_mode", ctm_melee),
         (try_begin),
           (this_or_next|troop_is_guarantee_ranged, ":troop_id"),
           (troop_is_guarantee_horse, ":troop_id"),
           (val_div, ":xp_ratio_to_add_for_stack", 4),
         (try_end),
       (else_try),
         (eq, "$g_mt_mode", ctm_mounted),
         (try_begin),
           (neg|troop_is_guarantee_horse, ":troop_id"),
           (assign, ":xp_ratio_to_add_for_stack", 0),
         (try_end),
       (else_try),
         (neg|troop_is_guarantee_ranged, ":troop_id"),
         (assign, ":xp_ratio_to_add_for_stack", 0),
       (try_end),
     (try_end),
     (val_add,  ":level", 1),
     (store_mul, ":xp_to_add", 100, ":level"),
     (val_mul, ":xp_to_add", ":amount"),
     (val_div, ":xp_to_add", 20),
     (val_mul, ":xp_to_add", ":xp_ratio_to_add_for_stack"),
     (val_div, ":xp_to_add", 1000),
     (store_mul, ":max_xp_to_add", ":xp_to_add", 3),
     (val_div, ":max_xp_to_add", 2),
     (store_div, ":min_xp_to_add", ":xp_to_add", 2),
     (store_random_in_range, ":random_xp_to_add", ":min_xp_to_add", ":max_xp_to_add"),
     (gt, ":random_xp_to_add", 0),
     (try_begin),
       (troop_is_hero, ":troop_id"),
       (add_xp_to_troop, ":random_xp_to_add", ":troop_id"),
       (store_div, ":proficiency_to_add", ":random_xp_to_add", 50),
       (try_begin),
         (gt, ":proficiency_to_add", 0),
         (troop_raise_proficiency, ":troop_id", "$g_training_ground_used_weapon_proficiency", ":proficiency_to_add"),
       (try_end),
     (else_try),
       (party_add_xp_to_stack, "p_main_party", ":stack_no", ":random_xp_to_add"),
     (try_end),
     (assign, reg0, ":random_xp_to_add"),
     ]),


##  #script_cf_print_troop_name_with_stack_index_to_s0
##  # INPUT:
##  # param1: stack_index
##
##  #OUTPUT:
##  # string register 0.
##  ("cf_print_troop_name_with_stack_index_to_s0",
##   [
##     (store_script_param_1, ":stack_index"),
##     (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
##     (lt, ":stack_index", ":num_stacks"),
##     (party_stack_get_troop_id, ":stack_troop", "p_main_party", ":stack_index"),
##     (str_store_troop_name, s0, ":stack_troop"),
##    ]),

  #script_print_troop_owned_centers_in_numbers_to_s0
  # INPUT:
  # param1: troop_no
  #OUTPUT:
  # string register 0.
  ("print_troop_owned_centers_in_numbers_to_s0",
   [
     (store_script_param_1, ":troop_no"),
     (str_store_string, s0, "@nothing"),
     (assign, ":owned_towns", 0),
     (assign, ":owned_castles", 0),
     (assign, ":owned_villages", 0),
     (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
       (party_slot_eq, ":cur_center", slot_town_lord, ":troop_no"),
       (try_begin),
         (party_slot_eq, ":cur_center", slot_party_type, spt_town),
         (val_add, ":owned_towns", 1),
       (else_try),
         (party_slot_eq, ":cur_center", slot_party_type, spt_castle),
         (val_add, ":owned_castles", 1),
       (else_try),
         (val_add, ":owned_villages", 1),
       (try_end),
     (try_end),
     (assign, ":num_types", 0),
     (try_begin),
       (gt, ":owned_villages", 0),
       (assign, reg0, ":owned_villages"),
       (store_sub, reg1, reg0, 1),
       (str_store_string, s0, "@{reg0} village{reg1?s:}"),
       (val_add, ":num_types", 1),
     (try_end),
     (try_begin),
       (gt, ":owned_castles", 0),
       (assign, reg0, ":owned_castles"),
       (store_sub, reg1, reg0, 1),
       (try_begin),
         (eq, ":num_types", 0),
         (str_store_string, s0, "@{reg0} castle{reg1?s:}"),
       (else_try),
         (str_store_string, s0, "@{reg0} castle{reg1?s:} and {s0}"),
       (try_end),
       (val_add, ":num_types", 1),
     (try_end),
     (try_begin),
       (gt, ":owned_towns", 0),
       (assign, reg0, ":owned_towns"),
       (store_sub, reg1, reg0, 1),
       (try_begin),
         (eq, ":num_types", 0),
         (str_store_string, s0, "@{reg0} town{reg1?s:}"),
       (else_try),
         (eq, ":num_types", 1),
         (str_store_string, s0, "@{reg0} town{reg1?s:} and {s0}"),
       (else_try),
         (str_store_string, s0, "@{reg0} town{reg1?s:}, {s0}"),
       (try_end),
     (try_end),
     (store_add, reg0, ":owned_villages", ":owned_castles"),
     (val_add, reg0, ":owned_towns"),
     ]),

  #script_get_random_melee_training_weapon
  # INPUT: none
  # OUTPUT: reg0 = weapon_1, reg1 = weapon_2
  ("get_random_melee_training_weapon",
   [
     (assign, ":weapon_1", -1),
     (assign, ":weapon_2", -1),
     (store_random_in_range, ":random_no", 0, 3),
     (try_begin),
       (eq, ":random_no", 0),
       (assign, ":weapon_1", "itm_practice_staff"),
     (else_try),
       (eq, ":random_no", 1),
       (assign, ":weapon_1", "itm_practice_sword"),
       (assign, ":weapon_2", "itm_practice_shield"),
     (else_try),
       (assign, ":weapon_1", "itm_heavy_practice_sword"),
     (try_end),
     (assign, reg0, ":weapon_1"),
     (assign, reg1, ":weapon_2"),
     ]),

  #script_start_training_at_training_ground
  # INPUT:
  # param1: training_weapon_type, param2: training_param
  ("start_training_at_training_ground",
   [
     # (val_add, "$g_training_ground_training_count", 1),
     (store_script_param, ":mission_weapon_type", 1),
     (store_script_param, ":training_param", 2),

     (set_jump_mission, "mt_training_ground_training"),
     #SB : increment sparring count
     (party_get_slot, ":count", "$g_encountered_party", slot_grounds_count),
     (party_get_slot, ":trainer_troop", "$g_encountered_party", slot_grounds_trainer),
     (val_add, ":count", 1),
     (party_set_slot, "$g_encountered_party", slot_grounds_count, ":count"),


     (assign, ":training_default_weapon_1", -1),
     (assign, ":training_default_weapon_2", -1),
     (assign, ":training_default_weapon_3", -1),
     (assign, "$scene_num_total_gourds_destroyed", 0),
     (try_begin),
       (eq, ":mission_weapon_type", itp_type_bow),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_archery),
       (assign, ":training_default_weapon_1", "itm_practice_bow"),
       (try_begin),
         (eq, "$g_mt_mode", ctm_mounted),
         (assign, ":training_default_weapon_2", "itm_practice_arrows_100_amount"),
       (else_try),
         (assign, ":training_default_weapon_2", "itm_practice_arrows_10_amount"),
       (try_end),
     (else_try),
       (eq, ":mission_weapon_type", itp_type_crossbow),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_crossbow),
       (assign, ":training_default_weapon_1", "itm_practice_crossbow"),
       (assign, ":training_default_weapon_2", "itm_practice_bolts_9_amount"),
     (else_try),
       (eq, ":mission_weapon_type", itp_type_thrown),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_throwing),
       (try_begin),
         (eq, "$g_mt_mode", ctm_mounted),
         (assign, ":training_default_weapon_2", "itm_practice_throwing_daggers_100_amount"),
       (else_try),
         (assign, ":training_default_weapon_2", "itm_practice_throwing_daggers"),
       (try_end),
     (else_try),
       (eq, ":mission_weapon_type", itp_type_one_handed_wpn),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_one_handed_weapon),
       (assign, ":training_default_weapon_1", "itm_practice_sword"),
     (else_try),
       (eq, ":mission_weapon_type", itp_type_polearm),
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_polearm),
       (assign, ":training_default_weapon_1", "itm_practice_lance"),
     (else_try),
       #weapon_type comes as -1 when melee training is selected
       (assign, "$g_training_ground_used_weapon_proficiency", wpt_one_handed_weapon),
       # (call_script, "script_get_random_melee_training_weapon"),
       (try_begin),
         (gt, ":trainer_troop", 0),
         (troop_slot_ge, ":trainer_troop", slot_troop_trainer_training_difficulty, 4),
         (call_script, "script_get_proficient_melee_training_weapon", "$g_player_troop"),
         (try_begin), #sword and board
           (eq, reg0, "itm_practice_sword"),
           (assign, reg1, "itm_practice_shield"),
         (try_end),
       (else_try),
         (call_script, "script_get_random_melee_training_weapon"),
       (try_end),
       (assign, ":training_default_weapon_1", reg0),
       (assign, ":training_default_weapon_2", reg1),
     (try_end),

##     (assign, "$g_training_ground_training_troop_stack_index", ":stack_index"),
     (try_begin),
       (eq, "$g_mt_mode", ctm_mounted),
       (assign, ":training_default_weapon_3", "itm_practice_horse"),
       #SB : use slot
       (party_get_slot, "$g_training_ground_training_scene", "$g_encountered_party", slot_grounds_track),
     (else_try),
       #SB : use slot
       (party_get_slot, "$g_training_ground_training_scene", "$g_encountered_party", slot_grounds_melee),
       # (store_add, "$g_training_ground_training_scene", "scn_training_ground_ranged_melee_1", "$g_encountered_party"),
       # (val_sub, "$g_training_ground_training_scene", training_grounds_begin),
     (try_end),

     (modify_visitors_at_site, "$g_training_ground_training_scene"),
     (reset_visitors),
     (set_visitor, 0, "trp_player"),

     (assign, ":selected_weapon", -1),
     (try_for_range, ":cur_slot", ek_item_0, ek_head),#equipment slots
       (troop_get_inventory_slot, ":cur_item", "trp_player", ":cur_slot"),
       (ge, ":cur_item", 0),
       (item_get_type, ":item_type", ":cur_item"),
       (try_begin),
         (eq, ":item_type", ":mission_weapon_type"),
         (eq, ":selected_weapon", -1),
         (assign, ":selected_weapon", ":cur_item"),
       (try_end),
     (try_end),
     (mission_tpl_entry_clear_override_items, "mt_training_ground_training", 0),
     (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, "itm_practice_boots"),
     (try_begin),
       (ge, ":training_default_weapon_1", 0),
       (try_begin),
         (ge, ":selected_weapon", 0),
         (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, ":selected_weapon"),
       (else_try),
         (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, ":training_default_weapon_1"),
       (try_end),
     (try_end),
     (try_begin),
       (ge, ":training_default_weapon_2", 0),
       (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, ":training_default_weapon_2"),
     (try_end),
     (try_begin),
       (ge, ":training_default_weapon_3", 0),
       (mission_tpl_entry_add_override_item, "mt_training_ground_training", 0, ":training_default_weapon_3"),
     (try_end),

     (assign, ":cur_visitor_point", 5),
     (troop_get_slot, ":num_fit", "trp_stack_selection_amounts", 1),
     (store_add, ":end_cond", 5, ":num_fit"),
     (val_min, ":end_cond", 13),
     (try_for_range, ":cur_visitor_point", 5, ":end_cond"),
       (call_script, "script_remove_random_fit_party_member_from_stack_selection"),
       (set_visitor, ":cur_visitor_point", reg0),
       (val_add, ":cur_visitor_point", 1),
     (try_end),
     (try_begin),
       (eq, "$g_mt_mode", ctm_melee),
       (assign, ":total_difficulty", 0),
       (assign, ":cur_entry_point", 1),
       (try_for_range, ":i", 0, ":training_param"),
         (troop_get_slot, ":cur_troop", "trp_temp_array_a", ":i"),
         # (store_add, ":cur_entry_point", ":i", 1),
         (set_visitor, ":cur_entry_point", ":cur_troop"),
         (mission_tpl_entry_clear_override_items, "mt_training_ground_training", ":cur_entry_point"),
         (mission_tpl_entry_add_override_item, "mt_training_ground_training", ":cur_entry_point", "itm_practice_boots"),
         (call_script, "script_get_random_melee_training_weapon"),
         (mission_tpl_entry_add_override_item, "mt_training_ground_training", ":cur_entry_point", reg0),
         (try_begin),
           (ge, reg1, 0),
           (mission_tpl_entry_add_override_item, "mt_training_ground_training", ":cur_entry_point", reg1),
         (try_end),
         (val_add, ":cur_entry_point", 1),
         (store_character_level, ":cur_troop_level", ":cur_troop"),
         (val_add, ":cur_troop_level", 10),
         (val_mul, ":cur_troop_level", ":cur_troop_level"),
         (val_add, ":total_difficulty", ":cur_troop_level"),
       (try_end),

       (assign, "$g_training_ground_training_num_enemies", ":training_param"),
       (assign, "$g_training_ground_training_hardness",  ":total_difficulty"),
       (store_add, ":number_multiplier", "$g_training_ground_training_num_enemies", 4),
       (val_mul, "$g_training_ground_training_hardness", ":number_multiplier"),
       (val_div, "$g_training_ground_training_hardness", 2400),
       #SB : store by count
       # (str_store_string, s0, "@Your opponents are ready for the fight."),
     (else_try),
       (eq, "$g_mt_mode", ctm_mounted),
       (try_begin),
         (eq, ":mission_weapon_type", itp_type_bow),
         (assign, "$g_training_ground_training_hardness", 350),
         (assign, "$g_training_ground_training_num_gourds_to_destroy", 30),
       (else_try),
         (eq, ":mission_weapon_type", itp_type_thrown),
         (assign, "$g_training_ground_training_hardness", 400),
         (assign, "$g_training_ground_training_num_gourds_to_destroy", 30),
       (else_try),
         (eq, ":mission_weapon_type", itp_type_one_handed_wpn),
         (assign, "$g_training_ground_training_hardness", 200),
         (assign, "$g_training_ground_training_num_gourds_to_destroy", 45),
       (else_try),
         (eq, ":mission_weapon_type", itp_type_polearm),
         (assign, "$g_training_ground_training_hardness", 280),
         (assign, "$g_training_ground_training_num_gourds_to_destroy", 35),
       (try_end),
       # (str_store_string, s0, "@Try to destroy as many targets as you can. You have two and a half minutes to clear the track."),
     (else_try),
       (eq, "$g_mt_mode", ctm_ranged),
       (store_mul, "$g_training_ground_ranged_distance", ":training_param", 100),
       (assign, ":hardness_modifier", ":training_param"),
       (val_mul, ":hardness_modifier", ":hardness_modifier"),
       (try_begin),
         (eq, ":mission_weapon_type", itp_type_bow),
         (val_mul, ":hardness_modifier", 3),
         (val_div, ":hardness_modifier", 2),
       (else_try),
         (eq, ":mission_weapon_type", itp_type_thrown),
         (val_mul, ":hardness_modifier", 5),
         (val_div, ":hardness_modifier", 2),
         (val_mul, ":hardness_modifier", ":training_param"),
         (val_div, ":hardness_modifier", 2),
       (try_end),
       (store_mul, "$g_training_ground_training_hardness", 100, ":hardness_modifier"),
       (val_div, "$g_training_ground_training_hardness", 6000),
       # (str_store_string, s0, "@Stay behind the line on the ground and shoot the targets. Try not to waste any shots."),
     (try_end),
     (jump_to_menu, "mnu_training_ground_description"),
     ]),


  #script_print_party_to_s0:
  # INPUT:
  # param1: Party-id

  #OUTPUT:
  # string register 0.

  ##  ("print_party_to_s0",
  ##    [
  ##      (store_script_param_1, ":party"), #Party_id
  ##      (party_get_num_companion_stacks, ":num_stacks",":party"),
  ##      (str_store_string, s50, "str_dplmc_none"),
  ##      (try_for_range, ":i_stack", 0, ":num_stacks"),
  ##        (party_stack_get_troop_id,     ":stack_troop",":party",":i_stack"),
  ##        (party_stack_get_size,         ":stack_size",":party",":i_stack"),
  ##        (str_store_troop_name_by_count, s61, ":stack_troop", ":stack_size"),
  ##        (try_begin),
  ##          (troop_is_hero, ":stack_troop"),
  ##          (str_store_string_reg, s51, s61),
  ##        (else_try),
  ##          (assign, reg60, ":stack_size"),
  ##          (str_store_string, s63, "str_reg60_s61"),
  ##        (try_end),
  ##        (try_begin),
  ##          (eq, ":i_stack", 0),
  ##          (str_store_string_reg, s50, s51),
  ##        (else_try),
  ##          (str_store_string, s50, "str_s50_comma_s51"),
  ##        (try_end),
  ##      (try_end),
  ##      (str_store_string_reg, s0, s50),
  ##  ]),



  #script_party_count_fit_regulars:
  # Returns the number of unwounded regular companions in a party
  # INPUT:
  # param1: Party-id

  ("party_count_fit_regulars",
    [
      (store_script_param_1, ":party"), #Party_id
      (party_get_num_companion_stacks, ":num_stacks", ":party"),
      (assign, reg0, 0),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop", ":party", ":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (party_stack_get_size, ":stack_size",":party",":i_stack"),
        (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
        (val_sub, ":stack_size", ":num_wounded"),
        (val_add, reg0, ":stack_size"),
      (try_end),
  ]),


  #script_party_count_fit_for_battle:
  # Returns the number of unwounded companions in a party
  # INPUT:
  # param1: Party-id
  # OUTPUT: reg0 = result
  ("party_count_fit_for_battle",
    [
      (store_script_param_1, ":party"), #Party_id
      (party_get_num_companion_stacks, ":num_stacks",":party"),
      (assign, reg0, 0),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party",":i_stack"),
        (assign, ":num_fit",0),
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (try_begin),
            (neg|troop_is_wounded, ":stack_troop"),
            (assign, ":num_fit", 1),
          (try_end),
        (else_try),
          (party_stack_get_size, ":num_fit",":party",":i_stack"),
          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
          (val_sub, ":num_fit", ":num_wounded"),
        (try_end),
        (val_add, reg0, ":num_fit"),
      (try_end),
  ]),


  #script_party_count_members_with_full_health
  # Returns the number of unwounded regulars, and heroes other than player with 100% hitpoints in a party
  # INPUT:
  # param1: Party-id
  # OUTPUT: reg0 = result
  ("party_count_members_with_full_health",
    [
      (store_script_param_1, ":party"), #Party_id
      (party_get_num_companion_stacks, ":num_stacks",":party"),
      (assign, reg0, 0),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party",":i_stack"),
        (neq, ":stack_troop", "trp_player"),
        (assign, ":num_fit",0),
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (store_troop_health, ":troop_hp", ":stack_troop"),
          (try_begin),
            (ge, ":troop_hp", 80),
            (assign, ":num_fit",1),
          (try_end),
        (else_try),
          (party_stack_get_size, ":num_fit",":party",":i_stack"),
          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
          (val_sub, ":num_fit", ":num_wounded"),
          (val_max, ":num_fit", 0),
        (try_end),
        (val_add, reg0, ":num_fit"),
      (try_end),
  ]),


  ##  ("get_fit_stack_with_rank",
  ##    [
  ##      (store_script_param_1, ":party"), #Party_id
  ##      (store_script_param_2, ":rank"), #Rank
  ##      (party_get_num_companion_stacks, ":num_stacks",":party"),
  ##      (assign, reg0, -1),
  ##      (assign, ":num_total", 0),
  ##      (try_for_range, ":i_stack", 0, ":num_stacks"),
  ##        (eq, reg(0), -1), #continue only if we haven't found the result yet.
  ##        (party_stack_get_troop_id,     ":stack_troop",":party",":i_stack"),
  ##        (assign, ":num_fit",0),
  ##        (try_begin),
  ##          (troop_is_hero, ":stack_troop"),
  ##          (store_troop_health, ":troop_hp", ":stack_troop"),
  ##          (try_begin),
  ##            (ge,  ":troop_hp", 20),
  ##            (assign, ":num_fit",1),
  ##          (try_end),
  ##        (else_try),
  ##          (party_stack_get_size,         ":num_fit",":party",":i_stack"),
  ##          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
  ##          (val_sub, ":num_fit", ":num_wounded"),
  ##        (try_end),
  ##        (val_add, ":num_total", ":num_fit"),
  ##        (try_begin),
  ##          (lt, ":rank", ":num_total"),
  ##          (assign, reg(0), ":i_stack"),
  ##        (try_end),
  ##      (try_end),
  ##  ]),

  #script_get_stack_with_rank:
  # Returns the stack no, containing unwounded regular companions with rank rank.
  # INPUT:
  # param1: Party-id
  # param2: rank

  ("get_stack_with_rank",
    [
      (store_script_param_1, ":party"), #Party_id
      (store_script_param_2, ":rank"), #Rank
      (party_get_num_companion_stacks, ":num_stacks",":party"),
      (assign, reg(0), -1),
      (assign, ":num_total", 0),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (eq, reg(0), -1), #continue only if we haven't found the result yet.
        (party_stack_get_troop_id,     ":stack_troop",":party",":i_stack"),
        (neg|troop_is_hero, ":stack_troop"),
        (party_stack_get_size,         ":stack_size",":party",":i_stack"),
        (party_stack_get_num_wounded,  ":num_wounded",":party",":i_stack"),
        (val_sub, ":stack_size", ":num_wounded"),
        (val_add, ":num_total", ":stack_size"),
        (try_begin),
          (lt, ":rank", ":num_total"),
          (assign, reg(0), ":i_stack"),
        (try_end),
      (try_end),
  ]),

  #script_inflict_casualties_to_party:
  # INPUT:
  # param1: Party-id
  # param2: number of rounds

  #OUTPUT:
  # This script doesn't return a value but populates the parties p_temp_wounded and p_temp_killed with the wounded and killed.
  #Example:
  #  (script_inflict_casualties_to_party, "_p_main_party" ,50),
  #  Simulate 50 rounds of casualties to main_party.

  ("inflict_casualties_to_party",
    [
      (party_clear, "p_temp_casualties"),
      (store_script_param_1, ":party"), #Party_id
      (call_script, "script_party_count_fit_regulars", ":party"),
      (assign, ":num_fit", reg(0)), #reg(47) = number of fit regulars.
      (store_script_param_2, ":num_attack_rounds"), #number of attacks
      (try_for_range, ":unused", 0, ":num_attack_rounds"),
        (gt, ":num_fit", 0),
        (store_random_in_range, ":attacked_troop_rank", 0 , ":num_fit"), #attack troop with rank reg(46)
        (assign, reg1, ":attacked_troop_rank"),
        (call_script, "script_get_stack_with_rank", ":party", ":attacked_troop_rank"),
        (assign, ":attacked_stack", reg(0)), #reg(53) = stack no to attack.
        (party_stack_get_troop_id,     ":attacked_troop",":party",":attacked_stack"),
        (store_character_level, ":troop_toughness", ":attacked_troop"),
        (val_add, ":troop_toughness", 5),  #troop-toughness = level + 5
        (assign, ":casualty_chance", 10000),
        (val_div, ":casualty_chance", ":troop_toughness"), #dying chance
        (try_begin),
          (store_random_in_range, ":rand_num", 0 ,10000),
          (lt, ":rand_num", ":casualty_chance"), #check chance to be a casualty
          (store_random_in_range, ":rand_num2", 0, 2), #check if this troop will be wounded or killed
          (try_begin),
            (troop_is_hero,":attacked_troop"), #currently troop can't be a hero, but no harm in keeping this.
            (store_troop_health, ":troop_hp",":attacked_troop"),
            (val_sub, ":troop_hp", 45),
            (val_max, ":troop_hp", 1),
            (troop_set_health, ":attacked_troop", ":troop_hp"),
          (else_try),
            (lt, ":rand_num2", 1), #wounded
            (party_add_members, "p_temp_casualties", ":attacked_troop", 1),
            (party_wound_members, "p_temp_casualties", ":attacked_troop", 1),
            (party_wound_members, ":party", ":attacked_troop", 1),
          (else_try), #killed
            (party_add_members, "p_temp_casualties", ":attacked_troop", 1),
            (party_remove_members, ":party", ":attacked_troop", 1),
          (try_end),
          (val_sub, ":num_fit", 1), #adjust number of fit regulars.
        (try_end),
      (try_end),
  ]),


  #script_move_members_with_ratio:
  # INPUT:
  # param1: Source Party-id
  # param2: Target Party-id
  # pin_number = ratio of members to move, multiplied by 1000

  #OUTPUT:
  # This script doesn't return a value but moves some of the members of source party to target party according to the given ratio.
  ("move_members_with_ratio",
    [
      (store_script_param_1, ":source_party"), #Source Party_id
      (store_script_param_2, ":target_party"), #Target Party_id
      (party_get_num_prisoner_stacks, ":num_stacks",":source_party"),
      (try_for_range_backwards, ":stack_no", 0, ":num_stacks"),
        (party_prisoner_stack_get_troop_id,     ":stack_troop",":source_party",":stack_no"),
        (party_prisoner_stack_get_size,    ":stack_size",":source_party",":stack_no"),
        (store_mul, ":number_to_move",":stack_size","$pin_number"),
        (val_div, ":number_to_move", 1000),
        (party_remove_prisoners, ":source_party", ":stack_troop", ":number_to_move"),
        (assign, ":number_moved", reg0),
        (party_add_prisoners, ":target_party", ":stack_troop", ":number_moved"),
      (try_end),
      (party_get_num_companion_stacks, ":num_stacks",":source_party"),
      (try_for_range_backwards, ":stack_no", 0, ":num_stacks"),
        (party_stack_get_troop_id,     ":stack_troop",":source_party",":stack_no"),
        (party_stack_get_size,    ":stack_size",":source_party",":stack_no"),
        (store_mul, ":number_to_move",":stack_size","$pin_number"),
        (val_div, ":number_to_move", 1000),
        (party_remove_members, ":source_party", ":stack_troop", ":number_to_move"),
        (assign, ":number_moved", reg0),
        (party_add_members, ":target_party", ":stack_troop", ":number_moved"),
      (try_end),
  ]),


  # script_count_parties_of_faction_and_party_type:
  # counts number of active parties with a template and faction.
  # Input: arg1 = faction_no, arg2 = party_type
  # Output: reg0 = count

  ("count_parties_of_faction_and_party_type",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":party_type"),
      (assign, reg0, 0),
      (try_for_parties, ":party_no"),
        (party_is_active, ":party_no"),
        (party_get_slot, ":cur_party_type", ":party_no", slot_party_type),
        (store_faction_of_party, ":cur_faction", ":party_no"),
        (eq, ":cur_party_type", ":party_type"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, reg0, 1),
      (try_end),
  ]),

# script_faction_get_number_of_armies
# Input: arg1 = faction_no
# Output: reg0 = number_of_armies
  ("faction_get_number_of_armies",
   [
      (store_script_param_1, ":faction_no"),
      (assign, ":num_armies", 0),
      ##diplomacy start+ support for promoted kingdom ladies
      (try_for_range, ":troop_no", heroes_begin, heroes_end),#<- changed from active_npcs to heroes
      ##diplomacy end+
		(troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
    	(store_troop_faction, ":hero_faction_no", ":troop_no"),
        (eq, ":hero_faction_no", ":faction_no"),
        (troop_get_slot, ":hero_party", ":troop_no", slot_troop_leaded_party),
        (ge, ":hero_party", 0),
        (party_is_active, ":hero_party"),
        (call_script, "script_party_count_fit_regulars", ":hero_party"),
        (assign, ":party_size", reg0),
        (call_script, "script_party_get_ideal_size", ":hero_party"),
        (assign, ":ideal_size", reg0),
        (val_mul, ":ideal_size", 60),
        (val_div, ":ideal_size", 100),
        (gt, ":party_size", ":ideal_size"),
        (val_add, ":num_armies", 1),
      (try_end),
      (assign, reg0, ":num_armies"),
    ]),


# script_faction_recalculate_strength
# Input: arg1 = faction_no
# Output: reg0 = strength
  ("faction_recalculate_strength",
   [
      (store_script_param_1, ":faction_no"),

      (call_script, "script_faction_get_number_of_armies", ":faction_no"),
      (assign, ":num_armies", reg0),
      (assign, ":num_castles", 0),
      (assign, ":num_towns", 0),

      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_faction_of_party, ":center_faction", ":center_no"),
        (eq, ":center_faction", ":faction_no"),
        (try_begin),
          (party_slot_eq, ":center_no", slot_party_type, spt_castle),
          (val_add, ":num_castles", 1),
        (else_try),
          (party_slot_eq, ":center_no", slot_party_type, spt_town),
          (val_add, ":num_towns", 1),
        (try_end),
      (try_end),

      (faction_set_slot, ":faction_no", slot_faction_num_armies, ":num_armies"),
      (faction_set_slot, ":faction_no", slot_faction_num_castles, ":num_castles"),
      (faction_set_slot, ":faction_no", slot_faction_num_towns, ":num_towns"),

    ]),

  #script_select_random_town:
  # This script selects a random town in range [towns_begin, towns_end)
  # INPUTS:
  # none

  #OUTPUT:
  # reg0: id of the selected random town
##  ("select_random_town",
##    [
##      (assign, ":num_towns", towns_end),
##      (val_sub,":num_towns", towns_begin),
##      (store_random, ":random_town", ":num_towns"),
##      (val_add,":random_town", towns_begin),
##      (assign, reg0, ":random_town"),
##  ]),

#  ("select_random_spawn_point",
#    [
#      (assign, reg(20), spawn_points_end),
#      (val_sub,reg(20), spawn_points_begin),
#      (store_random, reg(21), reg(20)),
#      (val_add,reg(21), spawn_points_begin),
#      (assign, "$pout_town", reg(21)),
# ]),

  #script_cf_select_random_town_with_faction:
  # This script selects a random town in range [towns_begin, towns_end)
  # such that faction of the town is equal to given_faction
  # INPUT:
  # arg1 = faction_no

  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no
  ("cf_select_random_town_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      # First count num matching spawn points
      (assign, ":no_towns", 0),
      (try_for_range,":cur_town", towns_begin, towns_end),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_towns", 1),
      (try_end),
      (gt, ":no_towns", 0), #Fail if there are no towns
      (store_random_in_range, ":random_town", 0, ":no_towns"),
      (assign, ":no_towns", 0),
      (try_for_range,":cur_town", towns_begin, towns_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_towns", 1),
        (gt, ":no_towns", ":random_town"),
        (assign, ":result", ":cur_town"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

  #script_cf_select_random_village_with_faction:
  # This script selects a random village in range [villages_begin, villages_end)
  # such that faction of the village is equal to given_faction
  # INPUT:
  # arg1 = faction_no

  #OUTPUT:
  # This script may return false if there is no matching village.
  # reg0 = village_no
  ("cf_select_random_village_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      # First count num matching spawn points
      (assign, ":no_villages", 0),
      (try_for_range,":cur_village", villages_begin, villages_end),
        (store_faction_of_party, ":cur_faction", ":cur_village"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_villages", 1),
      (try_end),
      (gt, ":no_villages", 0), #Fail if there are no villages
      (store_random_in_range, ":random_village", 0, ":no_villages"),
      (assign, ":no_villages", 0),
      (try_for_range,":cur_village", villages_begin, villages_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_village"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_villages", 1),
        (gt, ":no_villages", ":random_village"),
        (assign, ":result", ":cur_village"),
      (try_end),
      (assign, reg0, ":result"),
  ]),


  #script_cf_select_random_walled_center_with_faction:
  # This script selects a random center in range [centers_begin, centers_end)
  # such that faction of the town is equal to given_faction
  # INPUT:
  # arg1 = faction_no
  # arg2 = preferred_center_no

  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no (Can fail)
  ("cf_select_random_walled_center_with_faction",
    [
      (store_script_param, ":faction_no", 1),
      (store_script_param, ":preferred_center_no", 2),
      (assign, ":result", -1),
      # First count num matching spawn points
      (assign, ":no_centers", 0),
      (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (val_add, ":no_centers", 1),
        (eq, ":cur_center", ":preferred_center_no"),
        (val_add, ":no_centers", 99),
      (try_end),
      (gt, ":no_centers", 0), #Fail if there are no centers
      (store_random_in_range, ":random_center", 0, ":no_centers"),
      (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (val_sub, ":random_center", 1),
        (try_begin),
          (eq, ":cur_center", ":preferred_center_no"),
          (val_sub, ":random_center", 99),
        (try_end),
        (lt, ":random_center", 0),
        (assign, ":result", ":cur_center"),
      (try_end),
      (assign, reg0, ":result"),
  ]),


  #script_cf_select_random_walled_center_with_faction_and_owner_priority_no_siege:
  # INPUT:
  # arg1 = faction_no
  # arg2 = owner_troop_no
  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = center_no (Can fail)
  ("cf_select_random_walled_center_with_faction_and_owner_priority_no_siege",
    [
      (store_script_param, ":faction_no", 1),
      (store_script_param, ":troop_no", 2),
      (assign, ":result", -1),
      (assign, ":no_centers", 0),

      #SB : faction active conditional
      (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
      (call_script, "script_lord_get_home_center", ":troop_no"),
      (assign, ":home_center", reg0),

      (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (party_slot_eq, ":cur_center", slot_center_is_besieged_by, -1),
        (val_add, ":no_centers", 1),

        #(party_slot_eq, ":cur_center", slot_town_lord, ":troop_no"),
        (eq, ":home_center", ":cur_center"), #I changed it with above line, now if lord is owner of any village its bound walled center is counted as 1000. Better this way. ozan-18.01.09

        (val_add, ":no_centers", 1000),
      (try_end),

      #if no center is available count all centers not besieged do not care its faction.
      (try_begin),
        (le, ":no_centers", 0),
        (ge, "$g_dplmc_lord_recycling", DPLMC_LORD_RECYCLING_ENABLE),
        (assign, "$g_there_is_no_avaliable_centers", 1),

        (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
          #SB : probably original faction
          (party_slot_eq, ":cur_center", slot_center_original_faction, ":faction_no"),
          (party_slot_eq, ":cur_center", slot_center_is_besieged_by, -1),
          (val_add, ":no_centers", 1),
        (try_end),
      (else_try),
        (assign, "$g_there_is_no_avaliable_centers", 0),
      (try_end),

      # (faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader), #SB : only one check
      (this_or_next|eq, "$g_there_is_no_avaliable_centers", 0),
      (neg|faction_slot_eq, ":faction_no", slot_faction_leader, ":troop_no"), #faction leaders cannot spawn if they have no centers.

      (store_random_in_range, ":random_center", 0, ":no_centers"),
      (try_for_range,":cur_center", walled_centers_begin, walled_centers_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (this_or_next|eq, "$g_there_is_no_avaliable_centers", 1),
        (eq, ":cur_faction", ":faction_no"),
        (party_slot_eq, ":cur_center", slot_center_is_besieged_by, -1),
        (val_sub, ":random_center", 1),
        (try_begin),
          #(party_slot_eq, ":cur_center", slot_town_lord, ":troop_no"),
          (eq, ":home_center", ":cur_center"), #I changed it with above line, now if lord is owner of any village its bound walled center is counted as 1000. Better this way. ozan-18.01.09
          (eq, "$g_there_is_no_avaliable_centers", 0),

          (val_sub, ":random_center", 1000),
        (try_end),
        (lt, ":random_center", 0),
        (assign, ":result", ":cur_center"),
      (try_end),
      (assign, reg0, ":result"),
  ]),


  #script_cf_select_random_walled_center_with_faction_and_less_strength_priority:
  # This script selects a random center in range [centers_begin, centers_end)
  # such that faction of the town is equal to given_faction
  # INPUT:
  # arg1 = faction_no
  # arg2 = preferred_center_no

  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no (Can fail)
  ("cf_select_random_walled_center_with_faction_and_less_strength_priority",
    [
      (store_script_param, ":faction_no", 1),
      (store_script_param, ":preferred_center_no", 2),
      (assign, ":result", -1),
      # First count num matching spawn points
      (assign, ":no_centers", 0),
      (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (party_slot_eq, ":cur_center", slot_center_is_besieged_by, -1),
        (val_add, ":no_centers", 1),
        (try_begin),
          (eq, ":cur_center", ":preferred_center_no"),
          (val_add, ":no_centers", 99),
        (try_end),
##        (call_script, "script_party_calculate_regular_strength", ":cur_center"),
##        (assign, ":strength", reg0),
##        (lt, ":strength", 80),
##        (store_sub, ":strength", 100, ":strength"),
##        (val_div, ":strength", 20),
##        (val_add, ":no_centers", ":strength"),
      (try_end),
      (gt, ":no_centers", 0), #Fail if there are no centers
      (store_random_in_range, ":random_center", 0, ":no_centers"),
      (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (eq, ":cur_faction", ":faction_no"),
        (party_slot_eq, ":cur_center", slot_center_is_besieged_by, -1),
        (val_sub, ":random_center", 1),
        (try_begin),
          (eq, ":cur_center", ":preferred_center_no"),
          (val_sub, ":random_center", 99),
        (try_end),
##        (try_begin),
##          (call_script, "script_party_calculate_regular_strength", ":cur_center"),
##          (assign, ":strength", reg0),
##          (lt, ":strength", 80),
##          (store_sub, ":strength", 100, ":strength"),
##          (val_div, ":strength", 20),
##          (val_sub, ":random_center", ":strength"),
##        (try_end),
        (lt, ":random_center", 0),
        (assign, ":result", ":cur_center"),
      (try_end),
      (assign, reg0, ":result"),
  ]),


  #script_cf_select_random_town_at_peace_with_faction:
  # This script selects a random town in range [towns_begin, towns_end)
  # such that faction of the town is friendly to given_faction
  # INPUT:
  # arg1 = faction_no

  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no
  ("cf_select_random_town_at_peace_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      # First count num matching towns
      (assign, ":no_towns", 0),
      (try_for_range,":cur_town", towns_begin, towns_end),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (store_relation,":reln", ":cur_faction", ":faction_no"),
        (ge, ":reln", 0),
        (val_add, ":no_towns", 1),
      (try_end),
      (gt, ":no_towns", 0), #Fail if there are no towns
      (store_random_in_range, ":random_town", 0, ":no_towns"),
      (assign, ":no_towns", 0),
      (try_for_range,":cur_town", towns_begin, towns_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (store_relation,":reln", ":cur_faction", ":faction_no"),
        (ge, ":reln", 0),
        (val_add, ":no_towns", 1),
        (gt, ":no_towns", ":random_town"),
        (assign, ":result", ":cur_town"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

  #script_cf_select_random_town_at_peace_with_faction_in_trade_route
  # INPUT:
  # arg1 = town_no
  # arg2 = faction_no

  #OUTPUT:
  # This script may return false if there is no matching town.
  # reg0 = town_no
  ("cf_select_random_town_at_peace_with_faction_in_trade_route",
    [
      (store_script_param, ":town_no", 1),
      (store_script_param, ":faction_no", 2),
      (assign, ":result", -1),
      (assign, ":no_towns", 0),
      (try_for_range, ":cur_slot", slot_town_trade_routes_begin, slot_town_trade_routes_end),
        (party_get_slot, ":cur_town", ":town_no", ":cur_slot"),
        (gt, ":cur_town", 0),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (store_relation, ":reln", ":cur_faction", ":faction_no"),
        (ge, ":reln", 0),
        (val_add, ":no_towns", 1),
      (try_end),
      (gt, ":no_towns", 0), #Fail if there are no towns
      (store_random_in_range, ":random_town", 0, ":no_towns"),
      (try_for_range, ":cur_slot", slot_town_trade_routes_begin, slot_town_trade_routes_end),
        (eq, ":result", -1),
        (party_get_slot, ":cur_town", ":town_no", ":cur_slot"),
        (gt, ":cur_town", 0),
        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (store_relation, ":reln", ":cur_faction", ":faction_no"),
        (ge, ":reln", 0),
        (val_sub, ":random_town", 1),
        (lt, ":random_town", 0),
        (assign, ":result", ":cur_town"),
      (try_end),
      (assign, reg0, ":result"),
  ]),



	#the following is a very simple adjustment - it measures the difference in prices between two towns
	#all goods are weighted equally except for luxuries
	#it does not take into account the prices of the goods, nor cargo capacity
	#to do that properly, a merchant would have to virtually fill his baggage, slot by slot, for each town
	#i also found that one needed to introduce demand inelasticity -- prices should vary a lot for grain,  relatively little for iron
    ##diplomacy start+
	#
    #Added a third parameter, the caravan party, for use in distance calculations and perhaps
	#other things in the future.  This may be -1, in which case the script attempts to find a
	#general answer without referring to any specific attributes.  It may also be a town,
	#in which case its position is used for distance calculations.
	##diplomacy end+
	("cf_select_most_profitable_town_at_peace_with_faction_in_trade_route",
    [
      (store_script_param, ":town_no", 1),
      (store_script_param, ":faction_no", 2),
	  ##diplomacy start+
	  (store_script_param, ":perspective_party", 3),
	  ##diplomacy end+

      (assign, ":result", -1),
	  (assign, ":best_town_score", 0),
      (store_sub, ":item_to_price_slot", slot_town_trade_good_prices_begin, trade_goods_begin),

	  ##diplomacy start+
	  # If economics changes are enabled, the caravan may also take into account the distance
	  # to the destination or bias towards towns of its town faction.
	  (store_random_in_range, ":consider_distance", 0, 2),
	  (store_random_in_range, ":faction_bias", 0, 2),
	  (try_begin),
		(lt, ":perspective_party", 0),
		(assign, ":perspective_party", ":town_no"),
	  (try_end),
      ##diplomacy end+

      (try_for_range, ":cur_slot", slot_town_trade_routes_begin, slot_town_trade_routes_end),
        (party_get_slot, ":cur_town", ":town_no", ":cur_slot"),
        (gt, ":cur_town", 0),

        (store_faction_of_party, ":cur_faction", ":cur_town"),
        (store_relation, ":reln", ":cur_faction", ":faction_no"),
        (ge, ":reln", 0),

		(assign, ":cur_town_score", 0),
		(try_for_range, ":cur_goods", trade_goods_begin, trade_goods_end),
			(neq, ":cur_goods", "itm_butter"), #Don't count perishables
			(neq, ":cur_goods", "itm_cattle_meat"),
			(neq, ":cur_goods", "itm_chicken"),
			(neq, ":cur_goods", "itm_pork"),

            (store_add, ":cur_goods_price_slot", ":cur_goods", ":item_to_price_slot"),
			(party_get_slot, ":origin_price", ":town_no", ":cur_goods_price_slot"),
			(party_get_slot, ":destination_price", ":cur_town", ":cur_goods_price_slot"),

			(gt, ":destination_price", ":origin_price"),
			(store_sub, ":price_dif", ":destination_price", ":origin_price"),

			(try_begin), #weight luxury goods double
				(this_or_next|eq, ":cur_goods", "itm_spice"),
					(eq, ":cur_goods", "itm_velvet"),
				(val_mul, ":price_dif", 2),
			(try_end),
			(val_add, ":cur_town_score", ":price_dif"),
		(try_end),

##		(try_begin),
##			(eq, "$cheat_mode", 1),
##			(str_store_party_name, s10, ":town_no"),
##			(str_store_party_name, s11, ":cur_town"),
##			(assign, reg3, ":cur_town_score"),
##			(display_message, "str_caravan_in_s10_considers_s11_total_price_dif_=_reg3"),
##		(try_end),

        ##diplomacy start+
		(try_begin),
			#Economic changes must be enabled, or the player must have decided
			#to use mercantilism settings (which expresses a desire to see changes
			#related to that setting applied), or a trade treaty must be in effect.
			(this_or_next|neg|faction_slot_eq, "fac_player_supporters_faction", dplmc_slot_faction_mercantilism, 0),
			(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
			#Take into account distance, or treat factions preferentially
			(try_begin),
				#Bias towards own faction
				(ge, ":faction_bias", 1),
				(neq, ":faction_no", ":cur_faction"),

				##The penalty is based on the source faction's mercantilism rating, as well as
				##the other faction's mercantilism rating.
				(faction_get_slot, ":source_mercantilism", ":faction_no", dplmc_slot_faction_mercantilism),
				(val_clamp, ":source_mercantilism", -3, 4),
				(faction_get_slot, ":dest_mercantilism", ":cur_faction", dplmc_slot_faction_mercantilism),
				(val_clamp, ":dest_mercantilism", -3, 4),
				##Default (if both factions have mercantilism 0) is a 6% reduction.  Possible range is 0% (least) to 12% (most).
				(store_sub, ":percent", 94, ":source_mercantilism"),
				(val_sub, ":percent", ":dest_mercantilism"),

				(val_mul, ":cur_town_score", ":percent"),
				(val_add, ":cur_town_score", 50),
				(val_div, ":cur_town_score", 100),
			(try_end),
			(try_begin),
				(ge, ":consider_distance", 1),#consider distance
				(store_distance_to_party_from_party, ":dist", ":perspective_party",":cur_town"),
				#Avoid asymptotic effects and undue weighting.
				#Further explanation: What we really care about is time, not distance.
				#It will take time to buy and sell once reaching our destination: halving
				#the distance doesn't double the expected profit per month.
				(val_max, ":dist", 0),
				(val_add, ":dist", 12),
				#Avoid possible problems trying to compare distant towns
				(val_mul, ":cur_town_score", 100),
				(val_div, ":cur_town_score", ":dist"),
			(try_end),
		(try_end),
		##diplomacy end+

		(gt, ":cur_town_score", ":best_town_score"),
		(assign, ":best_town_score", ":cur_town_score"),
		(assign, ":result", ":cur_town"),

	  (try_end),

      (gt, ":result", -1), #Fail if there are no towns

      (assign, reg0, ":result"),

#	  (store_current_hours, ":hour"),
#	  (party_set_slot, ":result", slot_town_caravan_last_visit, ":hour"),

##	  (try_begin),
##		(eq, "$cheat_mode", 1),
##	    (assign, reg3, ":best_town_score"),
##	    (str_store_party_name, s3, ":town_no"),
##	    (str_store_party_name, s4, ":result"),
##	    (display_message, "str_test__caravan_in_s3_selects_for_s4_trade_score_reg3"),
##	  (try_end),

  ]),


  ##  ("cf_select_faction_spawn_point",
  ##    [
  ##      # First count num matching spawn points
  ##      (assign, reg(24), 0),
  ##      (try_for_range,reg(25), spawn_points_begin, spawn_points_end),
  ##        (store_faction_of_party, reg(23), reg(25)),
  ##        (eq, reg(23), "$pin_faction"),
  ##        (val_add, reg(24), 1),
  ##      (end_try,0),
  ##      # reg4 now holds num towns of this faction.
  ##      (gt, reg(24), 0), #Fail if there are no towns
  ##      (store_random, reg(26), reg(24)),
  ##
  ##      (assign, reg(24), 0), # reg24 = num points of this faction.
  ##      (try_for_range,reg(25), spawn_points_begin, spawn_points_end),
  ##        (store_faction_of_party, reg(23), reg(25)),
  ##        (eq, reg(23), "$pin_faction"),
  ##        (try_begin,0),
  ##          (eq, reg(24), reg(26)),
  ##          (assign, "$pout_town", reg(25)), # result is this town
  ##        (end_try,0),
  ##        (val_add, reg(24), 1),
  ##      (end_try,0),
  ##  ]),


  #script_spawn_party_at_random_town:
  # This script selects a random town in range [towns_begin, towns_end)
  # such that faction of the town is equal to given_faction
  # and spawns a new party there.
  # INPUT:
  # $pin_faction: given_faction
  # $pin_party_template: given_party_template

  #OUTPUT:
  # This script may return false if party cannot be spawned.
  # $pout_party: id of the spawned party
  ##  ("spawn_party_at_random_town",
  ##    [
  ##      (call_script,"script_select_random_spawn_point"),
  ##      (set_spawn_radius,1),
  ##      (spawn_around_party,"$pout_town","$pin_party_template"),
  ##      (assign, "$pout_party", reg(0)),
  ##  ]),

  #script_cf_spawn_party_at_faction_town:
  # This script selects a random town in range [towns_begin, towns_end)
  # such that faction of the town is equal to given_faction
  # and spawns a new party there.
  # INPUT:
  # $pin_faction: given_faction
  # $pin_party_template: given_party_template

  #OUTPUT:
  # This script may return false if party cannot be spawned.
  # $pout_party: id of the spawned party
  ##  ("cf_spawn_party_at_faction_town",
  ##    [
  ##      (call_script,"script_cf_select_faction_spawn_point"),
  ##      (set_spawn_radius,1),
  ##      (spawn_around_party,"$pout_town","$pin_party_template"),
  ##      (assign, "$pout_party", reg(0)),
  ##  ]),

  #script_spawn_party_at_random_town_if_below_limit:
  # This script checks if number of parties
  # of specified template is less than limit,
  # If so, it selects a random town in range [towns_begin, towns_end)
  # and spawns a new party there.
  # INPUT:
  # $pin_party_template: given_party_template
  # $pin_limit: limit value

  #OUTPUT:
  # $pout_party: id of the spawned party
  # $pout_town: id of the selected faction town
  # Note:
  # This script may return false if number of parties
  # of specified template is greater or equal to limit,
  # or if party cannot be spawned.
##  ("cf_spawn_party_at_random_town_if_below_limit",
##    [
##      (store_num_parties_of_template, reg(22), "$pin_party_template"),
##      (lt,reg(22),"$pin_limit"), #check if we are below limit.
##      (call_script,"script_select_random_spawn_point"),
##      (set_spawn_radius,1),
##      (spawn_around_party,"$pout_town","$pin_party_template"),
##      (assign, "$pout_party", reg(0)),
##  ]),

  ##  #script_spawn_party_at_faction_town_if_below_limit:
  ##  # This script checks if number of parties
  ##  # of specified template is less than limit,
  ##  # If so, it selects a random town in range [towns_begin, towns_end)
  ##  # such that faction of the town is equal to given_faction
  ##  # and spawns a new party there.
  ##  # INPUT:
  ##  # $pin_faction: given_faction
  ##  # $pin_party_template: given_party_template
  ##  # $pin_limit: limit value
  ##
  ##  #OUTPUT:
  ##  # $pout_party: id of the spawned party
  ##  # $pout_town: id of the selected faction town
  ##  # Note:
  ##  # This script may return false if number of parties
  ##  # of specified template is greater or equal to limit,
  ##  # or if party cannot be spawned.
  ##  ("cf_spawn_party_at_faction_town_if_below_limit",
  ##    [
  ##      (store_num_parties_of_template, reg(22), "$pin_party_template"),
  ##      (lt,reg(22),"$pin_limit"), #check if we are below limit.
  ##      (call_script,"script_cf_select_faction_spawn_point"),
  ##      (set_spawn_radius,1),
  ##      (spawn_around_party,"$pout_town","$pin_party_template"),
  ##      (assign, "$pout_party", reg(0)),
  ##  ]),

  # script_shuffle_troop_slots:
  # Shuffles a range of slots of a given troop.
  # Used for exploiting a troop as an array.
  # Input: arg1 = troop_no, arg2 = slot_begin, arg3 = slot_end
  ("shuffle_troop_slots",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":slots_begin", 2),
      (store_script_param, ":slots_end", 3),
      (try_for_range, ":cur_slot_no", ":slots_begin", ":slots_end"),
        (store_random_in_range, ":random_slot_no", ":slots_begin", ":slots_end"), #reg(58) = random slot. Now exchange slots reg(57) and reg(58)
        (troop_get_slot, ":cur_slot_value", ":troop_no", ":cur_slot_no"), #temporarily store the value in slot reg(57) in reg(59)
        (troop_get_slot, ":random_slot_value", ":troop_no", ":random_slot_no"), #temporarily store the value in slot reg(58) in reg(60)
        (troop_set_slot, ":troop_no", ":cur_slot_no", ":random_slot_value"), # Now exchange the two...
        (troop_set_slot, ":troop_no", ":random_slot_no", ":cur_slot_value"),
      (try_end),
  ]),


  # script_get_quest - combines old get_random_quest with new get_dynamic_quest

  # Input: arg1 = troop_no (of the troop in conversation), arg2 = min_importance (of the quest)
  # Output: reg0 = quest_no (the slots of the quest will be filled after calling this script)
  ("get_quest",
    [
      (store_script_param_1, ":giver_troop"),

      (store_character_level, ":player_level", "trp_player"),
      (store_troop_faction, ":giver_faction_no", ":giver_troop"),

      (troop_get_slot, ":giver_party_no", ":giver_troop", slot_troop_leaded_party),
      (troop_get_slot, ":giver_reputation", ":giver_troop", slot_lord_reputation_type),

      (assign, ":giver_center_no", -1),
      (try_begin),
        (gt, ":giver_party_no", 0),
        (party_get_attached_to, ":giver_center_no", ":giver_party_no"),
      (else_try),
        (is_between, "$g_encountered_party", centers_begin, centers_end),
        (assign, ":giver_center_no", "$g_encountered_party"),
      (try_end),

	  ##diplomacy start+
	  (call_script, "script_troop_get_player_relation", ":giver_troop"),
	  (assign, ":giver_relation", reg0),
	  (store_relation, ":giver_faction_relation", ":giver_faction_no", "fac_player_faction"),
	  #Assign some variables used later (mostly in lord checks) to re-enable
	  #quests which are usually disabled once the player has received homage.
	  (assign, ":is_close", 0),
	  (assign, ":nominal_superior", 0),
	  (try_begin),
		#is valid hero:
		(is_between, ":giver_troop", heroes_begin, heroes_end),
		(troop_slot_ge, ":giver_troop", slot_troop_occupation, slto_inactive + 1),
		(neg|troop_slot_ge, ":giver_troop", slot_troop_occupation, slto_retirement),

		#is close:
		(try_begin),
			#affiliates, and spouse
			(call_script, "script_dplmc_is_affiliated_family_member", ":giver_troop"),
			(this_or_next|ge, reg0, 1),
				(troop_slot_eq, "trp_player", slot_troop_spouse, ":giver_troop"),
			(assign, ":is_close", 1),
		(else_try),
			(ge, ":giver_faction_relation", 0),
			(ge, ":giver_relation", 50),
			(try_begin),
				(this_or_next|is_between, ":giver_troop", companions_begin, companions_end),
					(is_between, ":giver_troop", pretenders_begin, pretenders_end),
				(this_or_next|troop_slot_eq, ":giver_troop", slot_troop_occupation, slto_kingdom_hero),
					(troop_slot_eq, ":giver_troop", slot_troop_occupation, slto_player_companion),
				(neg|troop_slot_eq, ":giver_troop", slot_troop_playerparty_history, dplmc_pp_history_nonplayer_entry),
				(assign, ":is_close", 1),
			(else_try),
				#(call_script, "script_troop_get_family_relation_to_troop", ":giver_troop", "trp_player"),
				(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":giver_troop", "trp_player"),
				(ge, reg0, 2),
				(assign, ":is_close", 1),
			(try_end),
		(try_end),

		#is nominally the social superior of the player (or even if not the superior,
		#is allowed to give the player orders in at least one context)
		(try_begin),
			#quest giver is faction leader or marshall, or player's father or mother
			(this_or_next|troop_slot_eq, "trp_player", slot_troop_father, ":giver_troop"),
			(this_or_next|troop_slot_eq, "trp_player", slot_troop_mother, ":giver_troop"),
			(this_or_next|faction_slot_eq, ":giver_faction_no", slot_faction_leader, ":giver_troop"),
				(faction_slot_eq, ":giver_faction_no", slot_faction_marshall, ":giver_troop"),
			(assign, ":nominal_superior", 1),
		(else_try),
			#player has less than 3/4 of the quest giver's renown
			(troop_get_slot, reg0, ":giver_troop", slot_troop_renown),
			(val_mul, reg0, 3),
			(val_div, reg0, 4),
			(neg|troop_slot_ge, "trp_player", slot_troop_renown, reg0),
			(assign, ":nominal_superior", 1),
		(else_try),
			#quest giver is player's father-in-law or mother-in-law
			(troop_get_slot, ":player_spouse", "trp_player", slot_troop_spouse),
			(is_between, ":player_spouse", heroes_begin, heroes_end),
			(this_or_next|troop_slot_eq, ":player_spouse", slot_troop_father, ":giver_troop"),
				(troop_slot_eq, ":player_spouse", slot_troop_mother, ":giver_troop"),
			(assign, ":nominal_superior", 1),
		(try_end),
	  (try_end),
	  ##diplomacy end+

      (try_begin),
        (troop_slot_eq, ":giver_troop", slot_troop_occupation, slto_kingdom_hero),
        (try_begin),
          (ge, "$g_talk_troop_faction_relation", 0),
          (assign, ":quests_begin", lord_quests_begin),
          (assign, ":quests_end", lord_quests_end),
          (assign, ":quests_begin_2", lord_quests_begin_2),
          (assign, ":quests_end_2", lord_quests_end_2),
        (else_try),
          (assign, ":quests_begin", enemy_lord_quests_begin),
          (assign, ":quests_end", enemy_lord_quests_end),
          (assign, ":quests_begin_2", 0),
          (assign, ":quests_end_2", 0),
        (try_end),
      (else_try),
        (is_between, ":giver_troop", village_elders_begin, village_elders_end),
        (assign, ":quests_begin", village_elder_quests_begin),
        (assign, ":quests_end", village_elder_quests_end),
        (assign, ":quests_begin_2", village_elder_quests_begin_2),
        (assign, ":quests_end_2", village_elder_quests_end_2),
      (else_try),
        (is_between, ":giver_troop", mayors_begin, mayors_end),
        (assign, ":quests_begin", mayor_quests_begin),
        (assign, ":quests_end", mayor_quests_end),
        (assign, ":quests_begin_2", mayor_quests_begin_2),
        (assign, ":quests_end_2", mayor_quests_end_2),
      (else_try),
        (assign, ":quests_begin", lady_quests_begin),
        (assign, ":quests_end", lady_quests_end),
        (assign, ":quests_begin_2", lady_quests_begin_2),
        (assign, ":quests_end_2", lady_quests_end_2),
      (try_end),

      (assign, ":result", -1),
	  (assign, ":quest_target_troop", -1),
	  (assign, ":quest_target_center", -1),
	  (assign, ":quest_target_faction", -1),
	  (assign, ":quest_object_faction", -1),
	  (assign, ":quest_object_troop", -1),
	  (assign, ":quest_object_center", -1),
	  (assign, ":quest_target_party", -1),
	  (assign, ":quest_target_party_template", -1),
	  (assign, ":quest_target_amount", -1),
	  (assign, ":quest_target_dna", -1),
	  (assign, ":quest_target_item", -1),
	  (assign, ":quest_importance", 1),
	  (assign, ":quest_xp_reward", 0),
	  (assign, ":quest_gold_reward", 0),
	  (assign, ":quest_convince_value", 0),
	  (assign, ":quest_expiration_days", 0),
	  (assign, ":quest_dont_give_again_period", 0),

	  (try_begin), #get dynamic quest is a separate script, so that we can scan a number of different troops at once for it
	   	(call_script, "script_get_dynamic_quest", "$g_talk_troop"),

	    (assign, ":result", reg0),
	    (assign, ":relevant_troop", reg1),
	    (assign, ":relevant_party", reg2),
	    (assign, ":relevant_faction", reg3),

	    #GUILDMASTER QUESTS
	    (try_begin),
			(eq, ":result", "qst_track_down_bandits"),
			(assign, ":quest_target_party", ":relevant_party"),
			(assign ,":quest_expiration_days", 60),
			(assign, ":quest_xp_reward", 1000),
			(assign, ":quest_gold_reward", 1000),

		(else_try),
			(eq, ":result", "qst_retaliate_for_border_incident"),
			(assign, ":quest_target_troop", ":relevant_troop"),
			(assign, ":quest_target_faction", ":relevant_faction"),

			(assign ,":quest_expiration_days", 30),
			(assign, ":quest_xp_reward", 1000),
			(assign, ":quest_gold_reward", 1000),

		#KINGDOM LORD QUESTS
		(else_try),
	        (eq, ":result", "qst_cause_provocation"),
			(assign, ":quest_target_faction", ":relevant_faction"),
	        (assign, ":quest_expiration_days", 30),
	        (assign, ":quest_dont_give_again_period", 100),
			(assign, ":quest_xp_reward", 1000),
			(assign, ":quest_gold_reward", 1000),

	    (else_try),
			(eq, ":result", "qst_destroy_bandit_lair"),
			(assign, ":quest_target_party", ":relevant_party"),
			(assign ,":quest_expiration_days", 60),
			(assign, ":quest_xp_reward", 3000),
			(assign, ":quest_gold_reward", 1500),

		#KINGDOM LADY OR KINGDOM HERO QUESTS
		(else_try),
			(eq, ":result", "qst_rescue_prisoner"),
			(assign, ":quest_target_troop", ":relevant_troop"),
			(assign, ":quest_target_center", ":relevant_party"),

			(assign, ":quest_expiration_days", 30),
			(assign, ":quest_dont_give_again_period", 5),
			(assign, ":quest_importance", 2),
			(assign, ":quest_xp_reward", 1500),
			(assign, ":quest_gold_reward", 2000), #actual reward in dialogues
            (store_character_level, ":quest_convince_value", ":quest_target_troop"),
			(val_mul, ":quest_convince_value", 65), #SB : we normalize this to match the gold reward for ~level 30 lords
            (call_script, "script_calculate_ransom_amount_for_troop", ":quest_target_troop"), #SB: calculate a set amount
            (assign, ":quest_target_amount", reg0),
		(try_end),
	  (try_end),

	  #no dynamic quest available
	  (try_begin),
		(eq, ":result", -1),

	    (try_for_range, ":unused", 0, 20), #Repeat trial twenty times
	        (eq, ":result", -1),
	        (assign, ":quest_target_troop", -1),
	        (assign, ":quest_target_center", -1),
	        (assign, ":quest_target_faction", -1),
	        (assign, ":quest_object_faction", -1),
	        (assign, ":quest_object_troop", -1),
	        (assign, ":quest_object_center", -1),
	        (assign, ":quest_target_party", -1),
	        (assign, ":quest_target_party_template", -1),
	        (assign, ":quest_target_amount", -1),
	        (assign, ":quest_target_dna", -1),
	        (assign, ":quest_target_item", -1),
	        (assign, ":quest_importance", 1),
	        (assign, ":quest_xp_reward", 0),
	        (assign, ":quest_gold_reward", 0),
	        (assign, ":quest_convince_value", 0),
	        (assign, ":quest_expiration_days", 0),
	        (assign, ":quest_dont_give_again_period", 0),

            (store_sub, ":num_possible_old_quests", ":quests_end", ":quests_begin"),
            (store_sub, ":num_possible_new_quests", ":quests_end_2", ":quests_begin_2"),
            (store_add, ":num_possible_total_quests", ":num_possible_old_quests", ":num_possible_new_quests"),

            (store_random_in_range, ":quest_no", 0, ":num_possible_total_quests"),
            (try_begin),
              (lt, ":quest_no", ":num_possible_old_quests"),
              (store_random_in_range, ":quest_no", ":quests_begin", ":quests_end"),
            (else_try),
              (store_random_in_range, ":quest_no", ":quests_begin_2", ":quests_end_2"),
            (try_end),

	        (neg|check_quest_active,":quest_no"),
	        (neg|quest_slot_ge, ":quest_no", slot_quest_dont_give_again_remaining_days, 1),
	        (try_begin),
	          # Village Elder quests
	          (eq, ":quest_no", "qst_deliver_grain"),
	          (try_begin),
	            (is_between, ":giver_center_no", villages_begin, villages_end),
	            #The quest giver is the village elder
	            (call_script, "script_get_troop_item_amount", ":giver_troop", "itm_grain"),
	            (eq, reg0, 0),
	            (neg|party_slot_ge, ":giver_center_no", slot_town_prosperity, 40),
	            (assign, ":quest_target_center", ":giver_center_no"),
	            (store_random_in_range, ":quest_target_amount", 4, 8),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 20),
	            (assign, ":result", ":quest_no"),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_deliver_cattle"),
	          (try_begin),
	            (is_between, ":giver_center_no", villages_begin, villages_end),
	            #The quest giver is the village elder
	            (party_get_slot, ":num_cattle", ":giver_center_no", slot_village_number_of_cattle),
	            (lt, ":num_cattle", 50),
	            (assign, ":quest_target_center", ":giver_center_no"),
	            (store_random_in_range, ":quest_target_amount", 5, 10),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 20),
	            (assign, ":result", ":quest_no"),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_train_peasants_against_bandits"),
	          (try_begin),
	            (is_between, ":giver_center_no", villages_begin, villages_end),
	            #The quest giver is the village elder
	            (store_skill_level, ":player_trainer", "skl_trainer", "trp_player"),
	            (gt, ":player_trainer", 0),
	            (store_random_in_range, ":quest_target_amount", 5, 8),
                #SB : add condition to have at least this many farmers remaining to show up
                (party_count_members_of_type, ":num_villagers", ":giver_center_no", "trp_farmer"), #disallow peasant woman
                (gt, ":num_villagers", ":quest_target_amount"), #+1 for village elder
	            (assign, ":quest_target_center", ":giver_center_no"),
	            (assign, ":quest_expiration_days", 20),
	            (assign, ":quest_dont_give_again_period", 40),
	            (assign, ":result", ":quest_no"),
	          (try_end),
	        (else_try),
	          # Mayor quests
	          (eq, ":quest_no", "qst_escort_merchant_caravan"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_random_party_in_range, ":quest_target_center", towns_begin, towns_end),
	          (store_distance_to_party_from_party, ":dist", ":giver_center_no",":quest_target_center"),
	          (assign, ":quest_gold_reward", ":dist"),
	          (val_add, ":quest_gold_reward", 25),
	          (val_mul, ":quest_gold_reward", 25),
	          (val_div, ":quest_gold_reward", 20),
	          (store_random_in_range, ":quest_target_amount", 6, 12),
	          # (assign, "$escort_merchant_caravan_mode", 0), #SB : useless global, use quest slots if necessary
	          (assign, ":result", ":quest_no"),
	        (else_try),
              (eq, ":quest_no", "qst_deliver_wine"),
              (is_between, ":giver_center_no", centers_begin, centers_end),
              (store_random_party_in_range, ":quest_target_center", towns_begin, towns_end),
              (store_random_in_range, ":random_no", 0, 2),
              #SB : add chance of random food product
              (try_begin),
                (eq, ":random_no", 0), #as before, but skip the need for a quest variant
                (store_random_in_range, ":quest_target_item", "itm_wine", food_begin),
              (else_try),
                (store_random_in_range, ":quest_target_item", food_begin, food_end),
              (try_end),
              (store_random_in_range, ":quest_target_amount", 6, 12),
              (store_distance_to_party_from_party, ":dist", ":giver_center_no",":quest_target_center"),

              #SB : also, instead of emptying target center of merchandise, pick one that's actually missing food
              (assign, ":quest_gold_reward", ":dist"),
              (val_add, ":quest_gold_reward", 2),
              (assign, ":multiplier", 5),
              (val_add, ":multiplier", ":quest_target_amount"),
              (val_mul, ":quest_gold_reward", ":multiplier"),
              (val_div, ":quest_gold_reward", 100),
              (val_mul, ":quest_gold_reward", 10),
              (item_get_max_ammo, ":max_amount", ":quest_target_item"),

              (store_item_value,"$qst_deliver_wine_debt",":quest_target_item"),
              (val_mul,"$qst_deliver_wine_debt",":quest_target_amount"),
              (val_mul,"$qst_deliver_wine_debt", 6),
              (val_div,"$qst_deliver_wine_debt", 5),

              (val_mul, ":quest_target_amount", ":max_amount"), #store actual quantity

              (assign, ":quest_expiration_days", 7), #SB : probably calculate distance for possible spoilage?
              (assign, ":quest_dont_give_again_period", 20),
              (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_troublesome_bandits"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_character_level, ":quest_gold_reward", "trp_player"),
	          (val_add, ":quest_gold_reward", 20),
	          (val_mul, ":quest_gold_reward", 35),
	          (val_div, ":quest_gold_reward",100),
	          (val_mul, ":quest_gold_reward", 10),
	          (assign, ":quest_expiration_days", 30),
	          (assign, ":quest_dont_give_again_period", 30),
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_kidnapped_girl"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_random_in_range, ":quest_target_center", villages_begin, villages_end),
	          (store_character_level, ":quest_target_amount"),
	          (val_add, ":quest_target_amount", 15),
	          (store_distance_to_party_from_party, ":dist", ":giver_center_no", ":quest_target_center"),
	          (val_add, ":dist", 15),
	          (val_mul, ":dist", 2),
	          (val_mul, ":quest_target_amount", ":dist"),
	          (val_div, ":quest_target_amount",100),
	          (val_mul, ":quest_target_amount",10),
	          (assign, ":quest_gold_reward", ":quest_target_amount"),
	          (val_div, ":quest_gold_reward", 40),
	          (val_mul, ":quest_gold_reward", 10),
              (assign, ":quest_expiration_days", 15),
	          (assign, ":quest_dont_give_again_period", 30),
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_move_cattle_herd"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (call_script, "script_cf_select_random_town_at_peace_with_faction", ":giver_faction_no"),
	          (neq, ":giver_center_no", reg0),
	          (assign, ":quest_target_center", reg0),
	          (store_distance_to_party_from_party, ":dist",":giver_center_no",":quest_target_center"),
	          (assign, ":quest_gold_reward", ":dist"),
	          (val_add, ":quest_gold_reward", 25),
	          (val_mul, ":quest_gold_reward", 50),
	          (val_div, ":quest_gold_reward", 20),
	          (assign, ":quest_expiration_days", 30),
	          (assign, ":quest_dont_give_again_period", 20),
	          (assign, ":result", ":quest_no"),
	        (else_try),
	          (eq, ":quest_no", "qst_persuade_lords_to_make_peace"),
	          (is_between, ":giver_center_no", centers_begin, centers_end),
	          (store_faction_of_party, ":cur_object_faction", ":giver_center_no"),
	          (call_script, "script_cf_faction_get_random_enemy_faction", ":cur_object_faction"),
	          (assign, ":cur_target_faction", reg0),
	          (call_script, "script_cf_get_random_lord_except_king_with_faction", ":cur_object_faction"),
	          (assign, ":cur_object_troop", reg0),
			  ##diplomacy start+
			  #may also be anyone with tmt_aristocrat > 0
			  (call_script, "script_dplmc_get_troop_morality_value", ":cur_object_troop", tmt_aristocratic),
			  (this_or_next|ge, reg0, 1),
			  ##diplomacy+
			  (this_or_next|troop_slot_eq, ":cur_object_troop", slot_lord_reputation_type, lrep_quarrelsome),
			  (this_or_next|troop_slot_eq, ":cur_object_troop", slot_lord_reputation_type, lrep_selfrighteous),
			  (this_or_next|troop_slot_eq, ":cur_object_troop", slot_lord_reputation_type, lrep_martial),
				(troop_slot_eq, ":cur_object_troop", slot_lord_reputation_type, lrep_debauched),

	          (call_script, "script_cf_get_random_lord_except_king_with_faction", ":cur_target_faction"),
	          (assign, ":quest_target_troop", reg0),
			  ##diplomacy start+
			  #may also be anyone with tmt_aristocrat > 0
			  (call_script, "script_dplmc_get_troop_morality_value", ":quest_target_troop", tmt_aristocratic),
			  (this_or_next|ge, reg0, 1),
			  ##diplomacy+
			  (this_or_next|troop_slot_eq, ":quest_target_troop", slot_lord_reputation_type, lrep_quarrelsome),
			  (this_or_next|troop_slot_eq, ":quest_target_troop", slot_lord_reputation_type, lrep_selfrighteous),
			  (this_or_next|troop_slot_eq, ":quest_target_troop", slot_lord_reputation_type, lrep_martial),
			  (troop_slot_eq, ":quest_target_troop", slot_lord_reputation_type, lrep_debauched),

	          (assign, ":quest_object_troop", ":cur_object_troop"),
	          (assign, ":quest_target_faction", ":cur_target_faction"),
	          (assign, ":quest_object_faction", ":cur_object_faction"),
	          (assign, ":quest_gold_reward", 12000),
	          (assign, ":quest_convince_value", 7000),
	          (assign, ":quest_expiration_days", 30),
	          (assign, ":quest_dont_give_again_period", 100),
	          (assign, ":result", ":quest_no"),
	        (else_try),
              (eq, ":quest_no", "qst_deal_with_looters"),
                  ##diplomacy start+
                  #re-enable looters quest at all levels for variety
              #(is_between, ":player_level", 0, 15),
                  ##diplomacy end+
              (is_between, ":giver_center_no", centers_begin, centers_end),
              (store_faction_of_party, ":cur_object_faction", ":giver_center_no"),
              (store_num_parties_destroyed_by_player, ":num_looters_destroyed", "pt_looters"),
              (party_template_set_slot,"pt_looters",slot_party_template_num_killed,":num_looters_destroyed"),
              (quest_set_slot,":quest_no",slot_quest_current_state,0),
              (quest_set_slot,":quest_no",slot_quest_target_party_template,"pt_looters"),
              (assign, ":quest_gold_reward", 500),
              (assign, ":quest_xp_reward", 500),
              (assign, ":quest_expiration_days", 20),
              (assign, ":quest_dont_give_again_period", 30),
          ##diplomacy start+
              (try_begin),
              #don't give full quest reward if outside the normal level range
                 (ge, ":player_level", 15),
                 (store_sub, ":quest_xp_award", ":player_level", 14),
                 (val_mul, ":quest_xp_award", -10),
                 (val_add, ":quest_xp_award", 500),
                 (val_max, ":quest_xp_award", 100),#XP drops by 10 per level over limit, until level 40
                 #To avoid being pestered with trivia, increase :quest_dont_give_again_period with the player's level
                 (store_add, ":quest_dont_give_again_period", ":player_level", 16),
              (try_end),
              ##diplomacy end+
              (assign, ":result", ":quest_no"),
            (else_try),
              (eq, ":quest_no", "qst_deal_with_night_bandits"),
                  ##diplomacy start+
                  #re-enable quest at all levels for variety
              #(is_between, ":player_level", 0, 15),
                  ##diplomacy end+
              (is_between, ":giver_center_no", centers_begin, centers_end),
              (party_slot_ge, ":giver_center_no", slot_center_has_bandits, 1),
              (assign, ":quest_target_center", ":giver_center_no"),
              (assign, ":quest_expiration_days", 4),
              (assign, ":quest_dont_give_again_period", 15),
              ##diplomacy start+
              (try_begin),
               #To avoid being pestered with trivia, increase :quest_dont_give_again_period with the player's level
                 (ge, ":player_level", 15),
                 (store_add, ":quest_dont_give_again_period", ":player_level", 1),
              (try_end),
              ##diplomacy end+
              (assign, ":result", ":quest_no"),
            (else_try),
              # Lady quests
              (eq, ":quest_no", "qst_rescue_lord_by_replace"),
              #(eq, 1, 0), dckplmc test
              (try_begin),
                (ge, "$g_talk_troop_faction_relation", 0),
                    ##diplomacy start+
                    #if this quest is not disabled, remove the upper level limit to increase play variety
                #(is_between, ":player_level", 5, 25),
                    (ge, ":player_level", 5),
                    ##diplomacy end+

                (assign, ":prisoner_relative", -1),

                (try_begin),
                  (troop_get_slot, ":cur_target_troop", ":giver_troop", slot_troop_father), #get giver_troop's father
                  (gt, ":cur_target_troop", 0), #if giver_troop has a father as a troop in game
                  (troop_slot_ge, ":cur_target_troop", slot_troop_prisoner_of_party, 0), #if giver_troop's father is in a prison
                  (assign, ":prisoner_relative", ":cur_target_troop"),
                (try_end),

                (try_begin),
                  (eq, ":prisoner_relative", -1), #if giver_troop has no father or giver_troop's father is not in prison.
                  (troop_get_slot, ":cur_target_troop", ":giver_troop", slot_troop_spouse), #get giver_troop's spouse
                  (gt, ":cur_target_troop", 0), #if giver_troop has a spouse as a troop in game
                  (troop_slot_ge, ":cur_target_troop", slot_troop_prisoner_of_party, 0), #if giver_troop's spouse is in a prison
                  (assign, ":prisoner_relative", ":cur_target_troop"),
                (try_end),

                (try_begin),
                  (eq, ":prisoner_relative", -1), #if ((giver_troop has no father) or (giver_troop's father is not in prison)) and ((giver_troop has no spouse) or (giver_troop's spouse is not in prison)).
                  (troop_get_slot, ":cur_target_troop", ":giver_troop", slot_troop_guardian), #get giver_troop's spouse
                  (gt, ":cur_target_troop", 0), #if giver_troop has a guardian as a troop in game
                  (troop_slot_ge, ":cur_target_troop", slot_troop_prisoner_of_party, 0), #if giver_troop's guardian is in a prison
                  (assign, ":prisoner_relative", ":cur_target_troop"),
                (try_end),

                (try_begin),
                  (eq, "$cheat_mode", 1),
                  (assign, reg0, ":prisoner_relative"),
                  (display_message, "str_prisoner_relative_is_reg0"),
                (try_end),

                (gt, ":prisoner_relative", -1),
                #(changed 2) no need to this anymore (troop_slot_ge, ":prisoner_relative", slot_troop_prisoner_of_party, 0),
                (call_script, "script_search_troop_prisoner_of_party", ":prisoner_relative"),
                (assign, ":cur_target_center", reg0),

                #(changed 3) no need to check only towns anymore (is_between, ":cur_target_center", towns_begin, towns_end),#Skip if he is not in a town
                (is_between, ":cur_target_center", walled_centers_begin, walled_centers_end), #Skip if he is not in a walled center

                (assign, ":quest_target_center", ":cur_target_center"),
                (assign, ":quest_target_troop", ":prisoner_relative"),
                (assign, ":quest_expiration_days", 30),
                (assign, ":quest_dont_give_again_period", 73),
                (assign, ":result", ":quest_no"),
              (try_end),
            (else_try),
	          (eq, ":quest_no", "qst_deliver_message_to_prisoner_lord"),

			  ##diplomacy start+ enable this quest even when a vassal from an affiliated family member
			  ##...or from a faction leader, a faction marshall, or your spouse
			  (this_or_next|ge, ":is_close", 1),
			  (this_or_next|ge, ":nominal_superior", 1),
			  ##diplomacy end+
			  (eq, "$player_has_homage", 0),

	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
				##diplomacy start+
				#Remove the upper level limit to increase play variety
	            #(is_between, ":player_level", 5, 25),
				(ge, ":player_level", 5),
				##diplomacy end+
	            (troop_get_slot, ":cur_target_troop", ":giver_troop", slot_troop_father),
	            (try_begin),
	              (eq, ":cur_target_troop", 0),
	              (troop_get_slot, ":cur_target_troop", ":giver_troop", slot_troop_spouse),
	            (try_end),
	            #(troop_slot_eq, ":cur_target_troop", slot_troop_is_prisoner, 1),#Skip if the lady's father/husband is not in prison
				(gt, ":cur_target_troop", -1),
	            (troop_slot_ge, ":cur_target_troop", slot_troop_prisoner_of_party, 0),
	            (call_script, "script_search_troop_prisoner_of_party", ":cur_target_troop"),
	            (assign, ":cur_target_center", reg0),
	            (is_between, ":cur_target_center", towns_begin, towns_end),#Skip if he is not in a town
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 30),
	            (assign, ":result", ":quest_no"),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_duel_for_lady"),

	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (ge, ":player_level", 10),

                (troop_get_slot, ":giver_husband", ":giver_troop", slot_troop_spouse), #dckplmc - lady has no enemies
	            #(call_script, "script_cf_troop_get_random_enemy_troop_with_occupation", ":giver_troop", slto_kingdom_hero),#Can fail
	            (call_script, "script_cf_troop_get_random_enemy_troop_with_occupation", ":giver_husband", slto_kingdom_hero),#Can fail
	            (assign, ":cur_target_troop", reg0),

	            (neg|troop_slot_eq, ":giver_troop", slot_troop_spouse, ":cur_target_troop"), #must not be in the family
	            (neg|troop_slot_eq, ":giver_troop", slot_troop_father, ":cur_target_troop"),
	            (neg|troop_slot_ge, ":cur_target_troop", slot_troop_prisoner_of_party, 0),
	            (troop_slot_ge, ":cur_target_troop", slot_troop_leaded_party, 0),

                ##diplomacy start+ add benefactor ~ goodnatured/upstanding equivalence
                (neg|troop_slot_eq, ":cur_target_troop", slot_lord_reputation_type, lrep_benefactor),
                #also disable challenging conventional & moralist ladies
                (neg|troop_slot_eq, ":cur_target_troop", slot_lord_reputation_type, lrep_conventional),
                (neg|troop_slot_eq, ":cur_target_troop", slot_lord_reputation_type, lrep_moralist),
                #diplomacy end+
	            (neg|troop_slot_eq, ":cur_target_troop", slot_lord_reputation_type, lrep_goodnatured),
	            (neg|troop_slot_eq, ":cur_target_troop", slot_lord_reputation_type, lrep_upstanding),
	            (neg|troop_slot_eq, ":cur_target_troop", slot_lord_reputation_type, lrep_martial),

	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 50),
	            (assign, ":result", ":quest_no"),
	          (try_end),
	          # Enemy Lord Quests
	        (else_try),
              (eq, ":quest_no", "qst_lend_surgeon"),
              (try_begin),
                (eq, "$g_defending_against_siege", 0),#Skip if the center is under siege (because of resting)
                ##diplomacy start+
                #also disable for roguish lords with negative tmt_humanitarian ratings
                (call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
                (this_or_next|neq, ":giver_reputation", lrep_roguish),
                    (lt, reg0, 0),
            #Disable for anyone with a negative tmt_egalitarian rating, as this would be out of character.
                (call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_egalitarian),
                (ge, reg0, 0),
                ##diplomacy end+
                (neq, ":giver_reputation", lrep_quarrelsome),
                (neq, ":giver_reputation", lrep_debauched),
                (assign, ":max_surgery_level", 0),
                (assign, ":best_surgeon", -1),
                (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
                (try_for_range, ":i_stack", 1, ":num_stacks"),
                  (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
                  (troop_is_hero, ":stack_troop"),
                  #SB : has to be companion, otherwise pretender/wife gets called
                  (is_between, ":stack_troop", companions_begin, companions_end),
                  (store_skill_level, ":cur_surgery_skill", skl_surgery, ":stack_troop"),
                  (gt, ":cur_surgery_skill", ":max_surgery_level"),
                  (assign, ":max_surgery_level", ":cur_surgery_skill"),
                  (assign, ":best_surgeon", ":stack_troop"),
                (try_end),

                (store_character_level, ":cur_level", "trp_player"),
                (assign, ":required_skill", 5),
                (val_div, ":cur_level", 10),
                (val_add, ":required_skill", ":cur_level"),
                (ge, ":max_surgery_level", ":required_skill"), #Skip if party skill level is less than the required value

                (assign, ":quest_object_troop", ":best_surgeon"),
                (assign, ":quest_importance", 1),
                #SB : this seems extremely low for cost of surgery, give at least 50 gold
                (store_mul, ":quest_xp_reward", ":max_surgery_level", 10), #slightly better
                (assign, ":quest_gold_reward", ":quest_xp_reward"),
                (assign, ":quest_dont_give_again_period", 50),
                (assign, ":result", ":quest_no"),
              (try_end),
              # Lord Quests
            (else_try),
	          (eq, ":quest_no", "qst_meet_spy_in_enemy_town"),
			  ##diplomacy start+ enable this quest even when a vassal from an affiliated family member
			  #...or from a faction leader, a faction marshall, or your spouse
			  (this_or_next|ge, ":is_close", 1),
			  (this_or_next|ge, ":nominal_superior", 1),
			  ##diplomacy end+
			  (eq, "$player_has_homage", 0),

	          (try_begin),
	            (eq, "$players_kingdom", ":giver_faction_no"),
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (neq, ":giver_reputation", lrep_martial),

	            (call_script, "script_troop_get_player_relation", ":giver_troop"),
	            (assign, ":giver_relation", reg0),
	            (gt, ":giver_relation", 3),
	            (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),
	            (assign, ":enemy_faction", reg0),
	            (store_relation, ":reln", ":enemy_faction", "fac_player_supporters_faction"),
	            (lt, ":reln", 0),
	            (call_script, "script_cf_select_random_town_with_faction", ":enemy_faction"),
	            (assign, ":cur_target_center", reg0),
	            #Just to make sure that there is a free walker
	            (call_script, "script_cf_center_get_free_walker", ":cur_target_center"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (store_random_in_range, ":quest_target_amount", secret_signs_begin, secret_signs_end),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_gold_reward", 500),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 50),
	            (quest_set_slot, "qst_meet_spy_in_enemy_town", slot_quest_gold_reward, 500),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_raid_caravan_to_start_war"),
			  (eq, 1, 0), #disable this as a random quest

	          (try_begin),
	            (eq, "$players_kingdom", ":giver_faction_no"),
                ##diplomacy start+
				#no lords who are opposed to raiding will suggest this, even if they match
				#one of the listed personalities.
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
				(lt, reg0, 1),
				#roguish lords can give this quest unless they're opposed to raiding
	            (this_or_next|eq, ":giver_reputation", lrep_roguish),
                ##diplomacy end+
	            (this_or_next|eq, ":giver_reputation", lrep_cunning),
	            (this_or_next|eq, ":giver_reputation", lrep_quarrelsome),
	            (             eq, ":giver_reputation", lrep_debauched),
	            (gt, ":player_level", 10),
				(eq, 1, 0), #disable this as a random quest

	            (neg|faction_slot_eq, ":giver_faction_no", slot_faction_leader, ":giver_troop"),#Can not take the quest from the king
	            (call_script, "script_cf_faction_get_random_friendly_faction", ":giver_faction_no"),#Can fail
	            (assign, ":quest_target_faction", reg0),
	            (store_troop_faction, ":quest_object_faction", ":giver_troop"),
	            (assign, ":quest_target_party_template", "pt_kingdom_caravan_party"),
	            (assign, ":quest_target_amount", 2),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 100),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_deliver_message"),
			  ##diplomacy start+ enable this quest even when a vassal from an affiliated family member
			  #...or from a faction leader, a faction marshall, or your spouse
			  (this_or_next|ge, ":is_close", 1),
			  (this_or_next|ge, ":nominal_superior", 1),
			  ##diplomacy end+
			  (eq, "$player_has_homage", 0),

	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
				##diplomacy start+
				#increase the level/renown range validity of this quest
	            #(lt, ":player_level", 20),
			    #(neg|troop_slot_ge, "trp_player", slot_troop_renown, 125),
				(store_character_level, reg0, ":giver_troop"),
				(val_max, reg0, 20),#20 or quest-giver's level, whichever is greater
				(lt, ":player_level", reg0),
				(troop_get_slot, reg0, ":giver_troop", slot_troop_renown),
				(val_div, reg0, 2),
				(val_max, reg0, 125),#125 or 50% of quest-giver's renown, whichever is greater
				##diplomacy end+
	            (call_script, "script_cf_get_random_lord_in_a_center_with_faction", ":giver_faction_no"),#Can fail
	            (assign, ":cur_target_troop", reg0),
	            (neq, ":cur_target_troop", ":giver_troop"),#Skip himself
	            (call_script, "script_get_troop_attached_party", ":cur_target_troop"),
	            (assign, ":cur_target_center", reg0),#cur_target_center will definitely be a valid center
	            (neq,":giver_center_no", ":cur_target_center"),#Skip current center

	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_xp_reward", 30),
	            (assign, ":quest_gold_reward", 40),
	            (assign, ":quest_dont_give_again_period", 10),
				##diplomacy start+
				(try_begin),
					(this_or_next|troop_slot_ge, "trp_player", slot_troop_renown, 125),
						(ge, ":player_level", 20),
					(assign, ":quest_dont_give_again_period", ":player_level"),
					(val_clamp, ":quest_dont_give_again_period", 10, 61),
				(try_end),
				##diplomacy end+

	            (assign, ":result", ":quest_no"),

	            (assign, ":quest_expiration_days", 30),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_escort_lady"),
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (ge, ":player_level", 10),

				(ge, ":giver_troop", 0), #skip troops without fathers in range

				(assign, ":cur_object_troop", -1),
                (try_for_range, ":lady", kingdom_ladies_begin, kingdom_ladies_end),
				  (troop_slot_eq, ":lady", slot_troop_father, ":giver_troop"),
				  (assign, ":cur_object_troop", ":lady"),
				(try_end),

				(ge, ":cur_object_troop", 0),

				(troop_get_slot, ":giver_troop_confirm", ":cur_object_troop", slot_troop_father),  # just to make sure
				(eq, ":giver_troop", ":giver_troop_confirm"), # just to make sure

	            (store_random_in_range, ":random_no", 0, 2),
	            (try_begin),
	              (eq, ":random_no", 0),
	              (troop_get_slot, ":cur_object_troop_2", ":giver_troop", slot_troop_spouse),
				  (is_between, ":cur_object_troop_2", kingdom_ladies_begin, kingdom_ladies_end),
				  (troop_get_slot, ":giver_troop_confirm", ":cur_object_troop_2", slot_troop_spouse),  # just to make sure
				  (eq, ":giver_troop", ":giver_troop_confirm"), # just to make sure
	              (assign, ":cur_object_troop", ":cur_object_troop_2"),
	            (try_end),
	            (gt, ":cur_object_troop", 0),#Skip lords without a lady
				##diplomacy start+ use a script for gender
	            #(troop_get_type, ":cur_troop_gender", ":cur_object_troop"),
				(call_script, "script_dplmc_store_troop_is_female", ":cur_object_troop"),
				(assign, ":cur_troop_gender", reg0),
	            #(eq, ":cur_troop_gender", 1),#Skip if it is not female
				(neq, ":cur_troop_gender", 0),
				##diplomacy end+
	            (gt, ":giver_center_no", 0),#Skip if lord is outside the center
	            (troop_slot_eq, ":cur_object_troop", slot_troop_cur_center, ":giver_center_no"),#Skip if the lady is not at the same center
	            (call_script, "script_cf_select_random_town_with_faction", ":giver_faction_no"),#Can fail
	            (assign, ":cur_target_center", reg0),
	            (neq, ":cur_target_center", ":giver_center_no"),
	            (hero_can_join),#Skip if player has no available slots

	            (assign, ":quest_object_troop", ":cur_object_troop"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_expiration_days", 20),
	            (assign, ":quest_dont_give_again_period", 30),
	            (assign, ":result", ":quest_no"),
	          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_hunt_down_raiders"),
##          (try_begin),
##            (gt, ":player_level", 10),
##            (faction_slot_eq, ":giver_faction_no", slot_faction_leader, ":giver_troop"),
##            (call_script, "script_cf_select_random_town_with_faction", ":giver_faction_no"),#Can fail
##            (assign, ":cur_object_center", reg0),
##            (neq, ":cur_object_center", ":giver_center_no"),#Skip current center
##            (call_script, "script_get_random_enemy_center", ":giver_party_no"),
##            (assign, ":cur_target_center", reg0),
##            (ge, ":cur_target_center", 0),
##            (store_faction_of_party, ":cur_target_faction", ":cur_target_center"),
##            (is_between,  ":cur_target_faction", kingdoms_begin, kingdoms_end),
##
##            (assign, ":quest_object_center", ":cur_object_center"),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 1500),
##            (assign, ":quest_gold_reward", 1000),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_bring_back_deserters"),
##          (try_begin),
##            (gt, ":player_level", 5),
##            (faction_get_slot, ":cur_target_party_template", ":giver_faction_no", slot_faction_deserter_party_template),
##            (faction_get_slot, ":cur_target_troop", ":giver_faction_no", slot_faction_deserter_troop),
##            (gt, ":cur_target_party_template", 0),#Skip factions with no deserter party templates
##            (store_num_parties_of_template, ":num_deserters", ":cur_target_party_template"),
##            (ge, ":num_deserters", 2),#Skip if there are less than 2 active deserter parties
##
##            (assign, ":quest_target_troop", ":cur_target_troop"),
##            (assign, ":quest_target_party_template", ":cur_target_party_template"),
##            (assign, ":quest_target_amount", 5),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 500),
##            (assign, ":quest_gold_reward", 300),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_deliver_supply_to_center_under_siege"),
##          (try_begin),
##            (gt, ":player_level", 10),
##            (gt, ":giver_center_no", 0),#Skip if lord is outside the center
##            (call_script, "script_cf_get_random_siege_location_with_faction", ":giver_faction_no"),#Can fail
##            (assign, ":quest_target_center", reg0),
##            (assign, ":quest_target_amount", 10),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 500),
##            (assign, ":quest_gold_reward", 300),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_rescue_lady_under_siege"),
##          (try_begin),
##            (gt, ":player_level", 15),
##            (troop_get_slot, ":cur_object_troop", ":giver_troop", slot_troop_daughter),
##            (store_random_in_range, ":random_no", 0, 2),
##            (try_begin),
##              (this_or_next|eq,  ":cur_object_troop", 0),
##              (eq, ":random_no", 0),
##              (troop_get_slot, ":cur_object_troop_2", ":giver_troop", slot_troop_spouse),
##              (gt, ":cur_object_troop_2", 0),
##              (assign, ":cur_object_troop", ":cur_object_troop_2"),
##            (try_end),
##            (gt, ":cur_object_troop", 0),#Skip lords without a lady
##            (troop_get_type, ":cur_troop_gender", ":cur_object_troop"),
##            (eq, ":cur_troop_gender", 1),#Skip if lady is not female
##            (troop_get_slot, ":cur_target_center", ":cur_object_troop", slot_troop_cur_center),
##            (is_between, ":cur_target_center", centers_begin, centers_end),#Skip if she is not in a center
##            (neq,":giver_center_no", ":cur_target_center"),#Skip current center
##            (call_script, "script_cf_get_random_siege_location_with_faction", ":giver_faction_no"),#Can fail
##            (assign, ":cur_target_center", reg0),
##            (troop_set_slot, ":cur_object_troop", slot_troop_cur_center, ":cur_target_center"),#Move lady to the siege location
##            (assign, ":quest_object_troop", ":cur_object_troop"),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":quest_target_troop", ":giver_troop"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 200),
##            (assign, ":quest_gold_reward", 750),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_deliver_message_to_lover"),
##          (try_begin),
##            (is_between, ":player_level", 5, 30),
##            (troop_get_slot, ":cur_target_troop", ":giver_troop", slot_troop_lover),
##            (gt, ":cur_target_troop", 0),#Skip lords without a lover
##            (troop_get_slot, ":cur_target_center", ":cur_target_troop", slot_troop_cur_center),
##            (is_between, ":cur_target_center", centers_begin, centers_end),#Skip if she is not in a center
##            (neq,":giver_center_no", ":cur_target_center"),#Skip current center
##            (assign, ":quest_target_troop", ":cur_target_troop"),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":result", ":quest_no"),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_bring_reinforcements_to_siege"),
##          (try_begin),
##            (gt, ":player_level", 10),
##            (call_script, "script_cf_get_random_siege_location_with_attacker_faction", ":giver_faction_no"),#Can fail
##            (assign, ":cur_target_center", reg0),
##            (store_random_in_range, ":random_no", 5, 11),
##            (troops_can_join, ":random_no"),#Skip if the player doesn't have enough room
##            (call_script, "script_cf_get_number_of_random_troops_from_party", ":giver_party_no", ":random_no"),#Can fail
##            (assign, ":cur_object_troop", reg0),
##            (party_get_battle_opponent, ":cur_target_party", ":cur_target_center"),
##            (party_get_num_companion_stacks, ":num_stacks", ":cur_target_party"),
##            (gt, ":num_stacks", 0),#Skip if the besieger party has no troops
##            (party_stack_get_troop_id, ":cur_target_troop", ":cur_target_party", 0),
##            (troop_is_hero, ":cur_target_troop"),#Skip if the besieger party has no heroes
##            (neq, ":cur_target_troop", ":giver_troop"),#Skip if the quest giver is the same troop
##            (assign, ":quest_target_troop", ":cur_target_troop"),
##            (assign, ":quest_object_troop", ":cur_object_troop"),
##            (assign, ":quest_target_party", ":cur_target_party"),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":quest_target_amount", ":random_no"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 400),
##            (assign, ":quest_gold_reward", 200),
##            (assign, ":result", ":quest_no"),
##          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_deliver_message_to_enemy_lord"),
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
				##diplomacy start+
				#remove upper level limit to increase play variety
	            #(is_between, ":player_level", 5,25),
				(ge, ":player_level", 5),
				##diplomacy end+
	            (call_script, "script_cf_get_random_lord_from_another_faction_in_a_center", ":giver_faction_no"),#Can fail
	            (assign, ":cur_target_troop", reg0),
	            (call_script, "script_get_troop_attached_party", ":cur_target_troop"),
	            (assign, ":quest_target_center", reg0),#quest_target_center will definitely be a valid center
	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_importance", 1),
	            (assign, ":quest_xp_reward", 200),
				##diplomacy start+
				#decrease XP reward as you exceed the maximum level
				(try_begin),
					(ge, ":player_level", 26),
					(store_sub, ":quest_xp_reward", 25, ":player_level"),
					(val_add, ":quest_xp_reward", 200),
					(val_max, ":quest_xp_reward", 50),#minus 10 xp for every level above 25, to a minimum of 50 XP at level 40
				(try_end),
				##diplomacy end+
	            (assign, ":quest_gold_reward", 0),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 40),
	          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_bring_prisoners_to_enemy"),
##          (try_begin),
##            (gt, ":player_level", 10),
##            (is_between, ":giver_center_no", centers_begin, centers_end),#Skip if the quest giver is not at a center
##            (store_random_in_range, ":random_no", 5, 11),
##            (troops_can_join_as_prisoner, ":random_no"),#Skip if the player doesn't have enough room
##            (call_script, "script_get_random_enemy_town", ":giver_center_no"),
##            (assign, ":cur_target_center", reg0),
##            (ge, ":cur_target_center", 0),#Skip if there are no enemy towns
##            (store_faction_of_party, ":cur_target_faction", ":cur_target_center"),
##            (faction_get_slot, ":cur_object_troop", ":cur_target_faction", slot_faction_tier_5_troop),
##            (assign, ":quest_target_center", ":cur_target_center"),
##            (assign, ":quest_object_troop", ":cur_object_troop"),
##            (assign, ":quest_target_amount", ":random_no"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 300),
##            (assign, ":quest_gold_reward", 200),
##            (assign, ":result", ":quest_no"),
##          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_deal_with_bandits_at_lords_village"),
	          (try_begin),
			    ##diplomacy start+
				#Does not have negative "tmt_humanitarian" rating
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
				(ge, reg0, 0),
				##diplomacy end+
	            (neq, ":giver_reputation", lrep_debauched),
	            (neq, ":giver_reputation", lrep_quarrelsome),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (assign, ":end_cond", villages_end),
	            (assign, ":cur_target_center", -1),
	            (try_for_range, ":cur_village", villages_begin, ":end_cond"),
	              (party_slot_eq, ":cur_village", slot_town_lord, ":giver_troop"),
                  #SB : fix this to ge
	              (party_slot_ge, ":cur_village", slot_village_infested_by_bandits, 1),
	              (party_slot_eq, ":cur_village", slot_village_state, svs_normal),
	              (assign, ":cur_target_center", ":cur_village"),
	              (assign, ":end_cond", 0),
	            (try_end),
	            (ge, ":cur_target_center", 0),
	            (neg|check_quest_active, "qst_eliminate_bandits_infesting_village"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30),
                #SB : do quest rewards here instead of upon completion
                (store_character_level, ":quest_gold_reward", "trp_player"),
                (val_mul, ":quest_gold_reward", 20),
                (val_add, ":quest_gold_reward", 300),
                (assign, ":quest_xp_reward", 350),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_raise_troops"),
	          (try_begin),
	            (neq, ":giver_reputation", lrep_martial),
				##diplomacy start+
				#RE-ENABLE for player's faction
	            #(neq, ":giver_faction_no", "fac_player_supporters_faction"), #we need tier_1_troop a valid value
				(assign, ":faction_for_troop", ":giver_faction_no"),
				(try_begin),
					(eq, ":giver_faction_no", "fac_player_supporters_faction"),
					(assign, ":faction_for_troop", "$g_player_culture"),
					(neg|is_between, ":faction_for_troop", npc_kingdoms_begin, npc_kingdoms_end),
					(troop_get_slot, ":faction_for_troop", ":giver_troop", slot_troop_original_faction),
				(try_end),
				(is_between, ":faction_for_troop", npc_kingdoms_begin, npc_kingdoms_end), #we need tier_1_troop a valid value
				##diplomacy end+
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (store_character_level, ":cur_level", "trp_player"),
	            (gt, ":cur_level", 5),
	            (troop_slot_ge, "trp_player", slot_troop_renown, 100),

	            (store_random_in_range, ":quest_target_amount", 5, 8),
	            (party_get_free_companions_capacity, ":free_capacity", "p_main_party"),
	            (le, ":quest_target_amount", ":free_capacity"),
	            (faction_get_slot, ":quest_object_troop", ":giver_faction_no", slot_faction_tier_1_troop),
	            (store_random_in_range, ":level_up", 20, 40),
	            (val_add, ":level_up", ":cur_level"),
	            (val_div, ":level_up", 10),

	            (store_mul, ":quest_gold_reward", ":quest_target_amount", 10),

	            (assign, ":quest_target_troop", ":quest_object_troop"),

	            (try_for_range, ":unused", 0, ":level_up"),
	              (troop_get_upgrade_troop, ":level_up_troop", ":quest_target_troop", 0),
	              (gt, ":level_up_troop", 0),
	              (assign, ":quest_target_troop", ":level_up_troop"),
				  ##diplomacy start+ Fix what appears to be a native bug,
	              #(val_mul, ":quest_gold_reward", ":quest_gold_reward", 7),
	              #(val_div, ":quest_gold_reward", ":quest_gold_reward", 4),
				  (val_mul, ":quest_gold_reward", 7),
				  (val_div, ":quest_gold_reward", 4),
				  ##diplomacy end+
	            (try_end),

	            (assign, ":quest_xp_reward", ":quest_gold_reward"),
	            (val_mul, ":quest_xp_reward", 3),
	            (val_div, ":quest_xp_reward", 10),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 120),
	            (assign, ":quest_dont_give_again_period", 15),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_collect_taxes"),
			  ##diplomacy start+ enable this quest even when a vassal,
   			  #if the quest giver is an affiliated family member
			  #...or from the faction leader, the faction marshall, or your spouse
			  (this_or_next|ge, ":is_close", 1),
			  (this_or_next|ge, ":nominal_superior", 1),
			  ##diplomacy end+
			  (eq, "$player_has_homage", 0),

	          (try_begin),
                ##diplomacy start+ benefactor lords do not give tax-collection quest because good-natured/upstanding do not
	            (neq, ":giver_reputation", lrep_benefactor),
				#neither do certain lady personalities either (only ambitious do)
				(neg|is_between, ":giver_reputation", lrep_conventional, lrep_ambitious),
				(neq, ":giver_reputation", lrep_moralist),
                ##diplomacy end+
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (neq, ":giver_reputation", lrep_upstanding),
	            (ge, "$g_talk_troop_faction_relation", 0),
				#SB : we've modified this script call with additional parameter
	            (call_script, "script_cf_troop_get_random_leaded_town_or_village_except_center", ":giver_troop", ":giver_center_no", svs_normal),
	            (assign, ":quest_target_center", reg0),
	            (assign, ":quest_importance", 1),
	            (assign, ":quest_gold_reward", 0),
	            (assign, ":quest_xp_reward", 100),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 50),
	            (assign, ":quest_dont_give_again_period", 20),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_hunt_down_fugitive"),
	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
                #SB : change conditions to prevent selecting a village that's being raided or infested by bandits
                ## although at higher levels we can make it so that the "kinsmen" are bandits
                (assign, ":cur_target_center", -1),
	            (try_for_range, ":unused_2", 0, 10),
	              (call_script, "script_cf_select_random_village_with_faction", ":giver_faction_no"),
                  (call_script, "script_cf_village_normal_cond", reg0),
                  (assign, ":cur_target_center", reg0),
	            (try_end),
                (neq, ":cur_target_center", -1),
	            # (call_script, "script_cf_select_random_village_with_faction", ":giver_faction_no"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (store_random_in_range, ":quest_target_dna", 0, 1000000),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 30),
	          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_capture_messenger"),
##          (try_begin),
##            (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),
##            (assign, ":cur_target_faction", reg0),
##            (faction_get_slot, ":cur_target_troop", ":cur_target_faction", slot_faction_messenger_troop),
##            (gt, ":cur_target_troop", 0),#Checking the validiy of cur_target_troop
##            (store_num_parties_destroyed_by_player, ":quest_target_amount", "pt_messenger_party"),
##
##            (assign, ":quest_target_troop", ":cur_target_troop"),
##            (assign, ":quest_target_party_template", ":cur_target_party_template"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 700),
##            (assign, ":quest_gold_reward", 400),
##            (assign, ":result", ":quest_no"),
##          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_kill_local_merchant"),
			  ##diplomacy start+ enable this quest even when a vassal from an affiliated family member or your spouse
			  (this_or_next|ge, ":is_close", 1),
			  ##diplomacy end+
			  (eq, "$player_has_homage", 0),

	          (try_begin),
                ##diplomacy start+
				#Lords who dislike breaking deals do not give this quest
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_honest),
				(lt, reg0, 1),
				#Roguish lords can give the Kill Local Merchant quest, unless they dislike murder.
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
	            (this_or_next|neq, ":giver_reputation", lrep_roguish),
					(lt, reg0, 1),
				#Ambitious ladies can give this quest
				(this_or_next|eq, ":giver_reputation", lrep_ambitious),
				(this_or_next|eq, ":giver_reputation", lrep_roguish),
                ##diplomacy end+
	            (this_or_next|eq, ":giver_reputation", lrep_quarrelsome),
	            (this_or_next|eq, ":giver_reputation", lrep_cunning),
	            (             eq, ":giver_reputation", lrep_debauched),
	            (neg|faction_slot_eq, ":giver_faction_no", slot_faction_leader, ":giver_troop"),#Can not take the quest from the king
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (gt, ":player_level", 5),
	            (is_between, ":giver_center_no", towns_begin, towns_end),
	            (assign, ":quest_importance", 1),
	            (assign, ":quest_xp_reward", 300),
	            (assign, ":quest_gold_reward", 1000),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 10),
	            (assign, ":quest_dont_give_again_period", 30),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_bring_back_runaway_serfs"),
	          (try_begin),
                ##diplomacy start+
				#companions who have compassion for commoners do not give the Runaway Serfs quest
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
				(lt, reg0, 1),
				#neither do Benefactor lords
	            (neq, ":giver_reputation", lrep_benefactor),
				#neither do most lady personalities (only ambitious do)
				(neg|is_between, ":giver_reputation", lrep_conventional, lrep_ambitious),
				(neq, ":giver_reputation", lrep_moralist),
                ##diplomacy end+
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (neq, ":giver_reputation", lrep_upstanding),
	            (ge, "$g_talk_troop_faction_relation", 0),
	            (ge, ":player_level", 5),
	            (gt, ":giver_center_no", 0),#Skip if lord is outside the center
	            (eq, "$g_defending_against_siege", 0),#Skip if the center is under siege (because of resting)

	            (assign, ":cur_object_center", -1),
	            (try_for_range, ":cur_village", villages_begin, villages_end),
	              (party_slot_eq, ":cur_village", slot_town_lord, ":giver_troop"),
	              (store_distance_to_party_from_party, ":dist", ":cur_village", ":giver_center_no"),
	              (lt, ":dist", 25),
	              (assign, ":cur_object_center", ":cur_village"),
	            (try_end),
	            (ge, ":cur_object_center", 0),#Skip if the quest giver is not the owner of any villages around the center
	            (call_script, "script_cf_select_random_town_with_faction", ":giver_faction_no"),
	            (assign, ":cur_target_center", reg0),
	            (neq, ":cur_target_center", ":giver_center_no"),#Skip current center
	            (store_distance_to_party_from_party, ":dist", ":cur_target_center", ":giver_center_no"),
	            (ge, ":dist", 20),
	            (assign, ":quest_target_party_template", "pt_runaway_serfs"),
	            (assign, ":quest_object_center", ":cur_object_center"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_importance", 1),
	            (assign, ":quest_xp_reward", 200),
	            (assign, ":quest_gold_reward", 150),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 20),
	            (assign, "$qst_bring_back_runaway_serfs_num_parties_returned", 0),
	            (assign, "$qst_bring_back_runaway_serfs_num_parties_fleed", 0),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_follow_spy"),
			  ##diplomacy start+ enable this quest even when a vassal from an affiliated family member or your spouse
			  #or a nominal superior
			  (this_or_next|ge, ":is_close", 1),
			  (this_or_next|ge, ":nominal_superior", 1),
			  ##diplomacy end+
			  (eq, "$player_has_homage", 0),

	          (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
				##diplomacy start+
				#Ladies other than the ambitious do not give this quest
                                (this_or_next|lt, reg0, 0),
				(this_or_next|eq, ":giver_reputation", lrep_ambitious),
                                (neg|is_between, ":giver_reputation", lrep_conventional, lrep_moralist + 1),
                                #As the "success" dialogue refers to torture, humanitarians do not either
                                (call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
                                (lt, reg0, 1),
                                #This is more open to interpretation, but I will also bar custodians from
										  #this, unless they have a negative tmt_humanitarian score.
                                (this_or_next|lt, reg0, 0),
                                   (neq, ":giver_reputation", lrep_custodian),
                                (neq, ":giver_reputation", lrep_benefactor),
				##diplomacy end+
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (party_get_skill_level, ":tracking_skill", "p_main_party", "skl_tracking"),
	            (ge, ":tracking_skill", 2),
	            (ge, ":player_level", 10),
	            (eq, "$g_defending_against_siege", 0), #Skip if the center is under siege (because of resting)
	            (gt, ":giver_party_no", 0), #Skip if the quest giver doesn't have a party
	            (gt, ":giver_center_no", 0), #skip if the quest giver is not in a center
	            (party_slot_eq, "$g_encountered_party", slot_party_type, spt_town), #skip if we are not in a town.
	            (party_get_position, pos2, "p_main_party"),
	            (assign, ":min_distance", 99999),
                    (assign, ":cur_object_center", -1),
	            (try_for_range, ":unused_2", 0, 10),
	              (call_script, "script_cf_get_random_enemy_center", ":giver_party_no"),
	              (assign, ":random_object_center", reg0),
	              (party_get_position, pos3, ":random_object_center"),
	              (map_get_random_position_around_position, pos4, pos3, 6),
	              (get_distance_between_positions, ":cur_distance", pos2, pos4),
	              (lt, ":cur_distance", ":min_distance"),
	              (assign, ":min_distance", ":cur_distance"),
	              (assign, ":cur_object_center", ":random_object_center"),
	              (copy_position, pos63, pos4), #Do not change pos63 until quest is accepted
	            (try_end),
	            (gt, ":cur_object_center", 0), #Skip if there are no enemy centers

	            (assign, ":quest_object_center", ":cur_object_center"),
	            (assign, ":quest_dont_give_again_period", 50),
	            (assign, ":result", ":quest_no"),
	            (assign, "$qst_follow_spy_run_away", 0),
	            (assign, "$qst_follow_spy_meeting_state", 0),
	            (assign, "$qst_follow_spy_meeting_counter", 0),
	            (assign, "$qst_follow_spy_spy_back_in_town", 0),
	            (assign, "$qst_follow_spy_partner_back_in_town", 0),
	            (assign, "$qst_follow_spy_no_active_parties", 0),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_capture_enemy_hero"),
	          (try_begin),
	            (eq, "$players_kingdom", ":giver_faction_no"),
				##diplomacy start+
				(this_or_next|ge, ":is_close", 1),
			    (this_or_next|ge, ":nominal_superior", 1),
				##diplomacy end+
	            (neg|faction_slot_eq, "$players_kingdom", slot_faction_marshall, "trp_player"),
	            (ge, ":player_level", 15),
	            (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),#Can fail
	            (assign, ":quest_target_faction", reg0),
	            (assign, ":quest_expiration_days", 30),
                ##diplomacy start+ change from 80 to 30
	            (assign, ":quest_dont_give_again_period", 30),#was 80
                ##diplomacy end+
	            (assign, ":quest_gold_reward", 2000),
	            (assign, ":result", ":quest_no"),
	          (try_end),
            (else_try),
              (eq, ":quest_no", "qst_lend_companion"),
              (try_begin),
                (ge, "$g_talk_troop_faction_relation", 0),
                (assign, ":total_heroes", 0),
                (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
                #SB : pre-process
                (try_for_range, ":troop_no", companions_begin, companions_end),
                  (troop_set_slot, ":troop_no", dplmc_slot_troop_temp_slot, 0),
                (try_end),
                (try_for_range, ":i_stack", 0, ":num_stacks"),
                  (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
                  (troop_is_hero, ":stack_troop"),
                  (is_between, ":stack_troop", companions_begin, companions_end),
                  (store_character_level, ":stack_level", ":stack_troop"),
                  (ge, ":stack_level", 15),
                  (assign, ":is_quest_hero", 0),
                  (try_for_range, ":i_quest", 0, all_quests_end),
                    (check_quest_active, ":i_quest"),
                    (this_or_next|quest_slot_eq, ":i_quest", slot_quest_target_troop, ":stack_troop"),
                    (quest_slot_eq, ":i_quest", slot_quest_object_troop, ":stack_troop"),
                    (assign, ":is_quest_hero", 1),
                  (try_end),
                  (eq, ":is_quest_hero", 0),
                  (val_add, ":total_heroes", 1),
                  (troop_set_slot, ":stack_troop", dplmc_slot_troop_temp_slot, 1), #SB : set flag here
                (try_end),
                (gt, ":total_heroes", 0),#Skip if party has no eligible heroes
                (store_random_in_range, ":random_hero", 0, ":total_heroes"),
                (assign, ":total_heroes", 0),
                (assign, ":cur_target_troop", -1),
                (try_for_range, ":stack_troop", companions_begin, companions_end),
                  (eq, ":cur_target_troop", -1),
                  # (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
                  # (troop_is_hero, ":stack_troop"),
                  # (is_between, ":stack_troop", companions_begin, companions_end),
                  # # (neq, ":stack_troop", "trp_player"), #SB : useless check
                  # (store_character_level, ":stack_level", ":stack_troop"),
                  # (ge, ":stack_level", 15),
                  # (assign, ":is_quest_hero", 0),
                  # (try_for_range, ":i_quest", 0, all_quests_end),
                    # (check_quest_active, ":i_quest"),
                    # (this_or_next|quest_slot_eq, ":i_quest", slot_quest_target_troop, ":stack_troop"),
                    # (quest_slot_eq, ":i_quest", slot_quest_object_troop, ":stack_troop"),
                    # (assign, ":is_quest_hero", 1),
                  # (try_end),
                  # (eq, ":is_quest_hero", 0),
                  #SB : check flag here
                  (troop_slot_eq, ":stack_troop", dplmc_slot_troop_temp_slot, 1),
                  (val_add, ":total_heroes", 1),
                  (gt, ":total_heroes", ":random_hero"),
                  (assign, ":cur_target_troop", ":stack_troop"),
                (try_end),
                (is_between, ":cur_target_troop", companions_begin, companions_end),

                (assign, ":quest_target_troop", ":cur_target_troop"),
                (store_current_day, ":quest_target_amount"),
                (val_add, ":quest_target_amount", 8),

                (assign, ":quest_importance", 1),
                #SB : scale reward by level
                (store_character_level, ":stack_level", ":quest_target_troop"),
                (store_mul, ":quest_xp_reward", ":stack_level", 20), #base level of 15
                # (assign, ":quest_xp_reward", 300),
                # (assign, ":quest_gold_reward", 400),
                (store_add, ":quest_gold_reward", ":quest_xp_reward", 100),
                (assign, ":result", ":quest_no"),
                (assign, ":quest_dont_give_again_period", 30),
              (try_end),
            (else_try),
              (eq, ":quest_no", "qst_collect_debt"),
              #(eq, 1, 0), #disable this quest pending talk with armagan
              #re-enabled, dckplmc
              (try_begin),
	            (ge, "$g_talk_troop_faction_relation", 0),
	          # Find a vassal (within the same kingdom?)
	            (call_script, "script_cf_get_random_lord_in_a_center_with_faction", ":giver_faction_no"),#Can fail
	            (assign, ":quest_target_troop", reg0),
	            (neq, ":quest_target_troop", ":giver_troop"),#Skip himself
	            (call_script, "script_get_troop_attached_party", ":quest_target_troop"),
	            (assign, ":quest_target_center", reg0),#cur_target_center will definitely be a valid center
	            (neq,":giver_center_no", ":quest_target_center"),#Skip current center

	            (assign, ":quest_xp_reward", 30),
	            (assign, ":quest_gold_reward", 40),
	            (assign, ":result", ":quest_no"),
	            (store_random_in_range, ":quest_target_amount", 6, 9),
	            (val_mul, ":quest_target_amount", 500),
	            (store_div, ":quest_convince_value", ":quest_target_amount", 5),
	            (assign, ":quest_expiration_days", 90),
	            (assign, ":quest_dont_give_again_period", 20),
	          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_capture_conspirators"),
##          (try_begin),
##            (eq, 1,0), #TODO: disable this for now
##            (ge, ":player_level", 10),
##            (is_between, ":giver_center_no", towns_begin, towns_end),#Skip if quest giver's center is not a town
##            (party_slot_eq, ":giver_center_no", slot_town_lord, ":giver_troop"),#Skip if the current center is not ruled by the quest giver
##            (call_script, "script_cf_get_random_kingdom_hero", ":giver_faction_no"),#Can fail
##
##            (assign, ":quest_target_troop", reg0),
##            (assign, ":quest_target_center", ":giver_center_no"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 10),
##            (assign, ":quest_gold_reward", 10),
##            (assign, ":result", ":quest_no"),
##            (store_character_level, ":cur_level"),
##            (val_div, ":cur_level", 5),
##            (val_max, ":cur_level", 3),
##            (store_add, ":max_parties", 4, ":cur_level"),
##            (store_random_in_range, "$qst_capture_conspirators_num_parties_to_spawn", 4, ":max_parties"),
##            (assign, "$qst_capture_conspirators_num_troops_to_capture", 0),
##            (assign, "$qst_capture_conspirators_num_parties_spawned", 0),
##            (assign, "$qst_capture_conspirators_leave_meeting_counter", 0),
##            (assign, "$qst_capture_conspirators_party_1", 0),
##            (assign, "$qst_capture_conspirators_party_2", 0),
##            (assign, "$qst_capture_conspirators_party_3", 0),
##            (assign, "$qst_capture_conspirators_party_4", 0),
##            (assign, "$qst_capture_conspirators_party_5", 0),
##            (assign, "$qst_capture_conspirators_party_6", 0),
##            (assign, "$qst_capture_conspirators_party_7", 0),
##          (try_end),
##        (else_try),
##          (eq, ":quest_no", "qst_defend_nobles_against_peasants"),
##          (try_begin),
##            (eq, 1,0), #TODO: disable this for now
##            (ge, ":player_level", 10),
##            (is_between, ":giver_center_no", towns_begin, towns_end),#Skip if quest giver's center is not a town
##            (party_slot_eq, ":giver_center_no", slot_town_lord, ":giver_troop"),#Skip if the current center is not ruled by the quest giver
##
##            (assign, ":quest_target_center", ":giver_center_no"),
##            (assign, ":quest_importance", 1),
##            (assign, ":quest_xp_reward", 10),
##            (assign, ":quest_gold_reward", 10),
##            (assign, ":result", ":quest_no"),
##            (store_character_level, ":cur_level"),
##            (val_div, ":cur_level", 5),
##            (val_max, ":cur_level", 4),
##            (store_add, ":max_parties", 4, ":cur_level"),
##            (store_random_in_range, "$qst_defend_nobles_against_peasants_num_peasant_parties_to_spawn", 4, ":cur_level"),
##            (store_random_in_range, "$qst_defend_nobles_against_peasants_num_noble_parties_to_spawn", 4, ":cur_level"),
##            (assign, "$qst_defend_nobles_against_peasants_num_nobles_to_save", 0),
##            (assign, "$qst_defend_nobles_against_peasants_num_nobles_saved", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_1", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_2", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_3", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_4", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_5", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_6", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_7", 0),
##            (assign, "$qst_defend_nobles_against_peasants_peasant_party_8", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_1", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_2", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_3", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_4", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_5", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_6", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_7", 0),
##            (assign, "$qst_defend_nobles_against_peasants_noble_party_8", 0),
##          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_incriminate_loyal_commander"),
			  ##diplomacy start+ enable this quest even when a vassal from an affiliated family member
			  (this_or_next|ge, ":is_close", 1),
			  ##diplomacy end+
			  (eq, "$player_has_homage", 0),

	          (try_begin),
                ##diplomacy start+ benefactors & moralists will not give this quest
	            (neq, ":giver_reputation", lrep_benefactor),
	            (neq, ":giver_reputation", lrep_moralist),
				#neither will most lady personalities (only ambitious do)
				(neg|is_between, ":giver_reputation", lrep_conventional, lrep_ambitious),
				(neq, ":giver_reputation", lrep_moralist),
				#neither will lords who dislike mistreating their own men, or who
				#are forthright in their dealings
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_egalitarian),
				(lt, reg0, 1),
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_honest),
				(lt, reg0, 1),
				#neither will other lords who dislike murder
				(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
				(lt, reg0, 1),
                ##diplomacy end+
	            (neq, ":giver_reputation", lrep_upstanding),
	            (neq, ":giver_reputation", lrep_goodnatured),
	            (eq, "$players_kingdom", ":giver_faction_no"),
	            (ge, ":player_level", 10),
	            (faction_slot_eq, ":giver_faction_no", slot_faction_leader, ":giver_troop"),
	            (assign, ":try_times", 1),
	            (assign, ":found", 0),
	            (try_for_range, ":unused", 0, ":try_times"),
	              (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),#Can fail
	              (assign, ":cur_target_faction", reg0),

	              (faction_get_slot, ":cur_target_troop", ":cur_target_faction", slot_faction_leader),
	              (assign, ":num_centerless_heroes", 0),
	              ##diplomacy start+ add support for promoted ladies
	              (try_for_range, ":cur_kingdom_hero", heroes_begin, heroes_end),#<- changed active_npcs to heroes
	              ##diplomacy end+
	                (troop_slot_eq, ":cur_kingdom_hero", slot_troop_occupation, slto_kingdom_hero),
	                #(troop_slot_eq, ":cur_kingdom_hero", slot_troop_is_prisoner, 0),
	                (neg|troop_slot_ge, ":cur_kingdom_hero", slot_troop_prisoner_of_party, 0),
	                (neq, ":cur_target_troop", ":cur_kingdom_hero"),
	                (store_troop_faction, ":cur_kingdom_hero_faction", ":cur_kingdom_hero"),
	                (eq, ":cur_target_faction", ":cur_kingdom_hero_faction"),
##                (call_script, "script_get_number_of_hero_centers", ":cur_kingdom_hero"),
##                (eq, reg0, 0),
	                (val_add, ":num_centerless_heroes", 1),
	              (try_end),
	              (gt, ":num_centerless_heroes", 0),
	              (assign, ":cur_object_troop", -1),
	              (store_random_in_range, ":random_kingdom_hero", 0, ":num_centerless_heroes"),
	              ##diplomacy start+ add support for promoted ladies
	              (try_for_range, ":cur_kingdom_hero", heroes_begin, heroes_end),#<- changed active_npcs to heroes
	              ##diplomacy end+
	                (eq, ":cur_object_troop", -1),
	                (troop_slot_eq, ":cur_kingdom_hero", slot_troop_occupation, slto_kingdom_hero),
	                (neq, ":cur_target_troop", ":cur_kingdom_hero"),
	                (store_troop_faction, ":cur_kingdom_hero_faction", ":cur_kingdom_hero"),
	                (eq, ":cur_target_faction", ":cur_kingdom_hero_faction"),
##                (call_script, "script_get_number_of_hero_centers", ":cur_kingdom_hero"),
##                (eq, reg0, 0),
	                (val_sub, ":random_kingdom_hero", 1),
	                (lt, ":random_kingdom_hero", 0),
	                (assign, ":cur_object_troop", ":cur_kingdom_hero"),
	              (try_end),

	              (assign, ":cur_target_center", -1),
	              (call_script, "script_get_troop_attached_party", ":cur_target_troop"),
	              (is_between, reg0, towns_begin, towns_end),
	              (party_slot_eq, reg0, slot_town_lord, ":cur_target_troop"),
	              (assign, ":cur_target_center", reg0),

	              (assign, ":try_times", -1),#Exit the second loop
	              (assign, ":found", 1),
	            (try_end),
	            (eq, ":found", 1),

	            (assign, "$incriminate_quest_sacrificed_troop", 0),

	            (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
	            (try_for_range, ":i_stack", 1, ":num_stacks"),
	              (eq ,"$incriminate_quest_sacrificed_troop", 0),
	              (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
	              (neg|troop_is_hero, ":stack_troop"),
	              (store_character_level, ":stack_troop_level", ":stack_troop"),
	              (ge, ":stack_troop_level", 25), #this is "top tier"
	              (assign, "$incriminate_quest_sacrificed_troop", ":stack_troop"),
	            (try_end),
	            (gt, "$incriminate_quest_sacrificed_troop", 0),

	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_object_troop", ":cur_object_troop"),
	            (assign, ":quest_target_center", ":cur_target_center"),
	            (assign, ":quest_target_faction", ":cur_target_faction"),

	            (assign, ":quest_importance", 1),
	            (assign, ":quest_xp_reward", 700),
	            (assign, ":quest_gold_reward", 1000),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 30),
	            (assign, ":quest_dont_give_again_period", 180),
	          (try_end),
	        (else_try),
	          (eq, ":quest_no", "qst_capture_prisoners"),
			  ##diplomacy start+ enable this quest even when a vassal from an affiliated family member
			  (this_or_next|ge, ":is_close", 1),
			  (this_or_next|ge, ":nominal_superior", 1),
			  ##diplomacy end+
			  (eq, "$player_has_homage", 0),

	          (try_begin),
	            (eq, "$players_kingdom", ":giver_faction_no"),

	            # (store_add, ":max_tier_no", slot_faction_tier_5_troop, 1),
                #SB : makes sure the giver doesn't already have these as prisoners when offering
                (assign, ":cond", 20),
                (assign, ":cur_target_faction", -1),
                (assign, ":party_no", -1),
                (try_begin), #store prisoner count
                  (is_between, ":giver_center_no", walled_centers_begin, walled_centers_end),
                  (party_slot_eq, ":giver_center_no", slot_town_lord, ":giver_troop"),
                  (assign, ":party_no", ":giver_center_no"),
                (else_try), #technically we should store both, but while in center prisoners are dropped off
                  (party_is_active, ":giver_party_no"),
                  (assign, ":party_no", ":giver_party_no"),
                (try_end),
                # (gt, ":party_no", 0),
                (try_for_range, ":unused", 0, ":cond"),
	              (call_script, "script_cf_faction_get_random_enemy_faction", ":giver_faction_no"),#Can fail
	              (assign, ":cur_target_faction", reg0),
	              (store_random_in_range, ":random_tier_no", slot_faction_tier_2_troop, slot_faction_tier_5_troop + 1),
	              (faction_get_slot, ":cur_target_troop", ":cur_target_faction", ":random_tier_no"),
	              (gt, ":cur_target_troop", 0),
	              (store_random_in_range, ":quest_target_amount", 3, 7),
                  (try_begin),
                    (gt, ":party_no", 0),
                    (party_count_prisoners_of_type, ":count", ":party_no", ":cur_target_troop"),
                    (val_sub, ":quest_target_amount", ":count"),
                  (try_end),
                  (gt, ":quest_target_amount", 1), #too minor to give a quest for 1 soldier
                  (assign, ":cond", 0),
                (try_end),
                (eq, ":cond", 0),
	            (assign, ":quest_target_troop", ":cur_target_troop"),
	            (assign, ":quest_target_faction", ":cur_target_faction"),
	            (assign, ":quest_importance", 1),
	            (store_character_level, ":quest_gold_reward", ":cur_target_troop"),
	            (val_add, ":quest_gold_reward", 5),
	            (val_mul, ":quest_gold_reward", ":quest_gold_reward"),
	            (val_div, ":quest_gold_reward", 5),
	            (val_mul, ":quest_gold_reward", ":quest_target_amount"),
	            (assign, ":quest_xp_reward", ":quest_gold_reward"),
	            (assign, ":result", ":quest_no"),
	            (assign, ":quest_expiration_days", 90),
	            (assign, ":quest_dont_give_again_period", 20),
	          (try_end),
	        (try_end),
		(try_end),
	  (try_end),
	  #end of quest finding


      (try_begin),
        (neq, ":result", -1),

        (try_begin),
          (party_is_active, ":quest_target_center"),
          (store_faction_of_party, ":quest_target_faction", ":quest_target_center"),
        (try_end),

        (quest_set_slot, ":result", slot_quest_target_troop, ":quest_target_troop"),
        (quest_set_slot, ":result", slot_quest_target_center, ":quest_target_center"),
        (quest_set_slot, ":result", slot_quest_object_troop, ":quest_object_troop"),
        (quest_set_slot, ":result", slot_quest_target_faction, ":quest_target_faction"),
        (quest_set_slot, ":result", slot_quest_object_faction, ":quest_object_faction"),
        (quest_set_slot, ":result", slot_quest_object_center, ":quest_object_center"),
        (quest_set_slot, ":result", slot_quest_target_party, ":quest_target_party"),
        (quest_set_slot, ":result", slot_quest_target_party_template, ":quest_target_party_template"),
        (quest_set_slot, ":result", slot_quest_target_amount, ":quest_target_amount"),
        (quest_set_slot, ":result", slot_quest_importance, ":quest_importance"),
        (quest_set_slot, ":result", slot_quest_xp_reward, ":quest_xp_reward"),
        (quest_set_slot, ":result", slot_quest_gold_reward, ":quest_gold_reward"),
        (quest_set_slot, ":result", slot_quest_convince_value, ":quest_convince_value"),
        (quest_set_slot, ":result", slot_quest_expiration_days, ":quest_expiration_days"),
        (quest_set_slot, ":result", slot_quest_dont_give_again_period, ":quest_dont_give_again_period"),
        (quest_set_slot, ":result", slot_quest_current_state, 0),
        (quest_set_slot, ":result", slot_quest_giver_troop, ":giver_troop"),
        (quest_set_slot, ":result", slot_quest_giver_center, ":giver_center_no"),
        (quest_set_slot, ":result", slot_quest_target_dna, ":quest_target_dna"),
        (quest_set_slot, ":result", slot_quest_target_item, ":quest_target_item"),
      (try_end),

      (assign, reg0, ":result"),
  ]),

  ("get_dynamic_quest",
  #Dynamic quests are rarer, more important quests
  #this is a separate script from get_quest, so that tavern keepers can scan all NPCs for quests
    [
    (store_script_param_1, ":giver_troop"),

	(assign, ":result", -1),
	(assign, ":relevant_troop", -1),
	(assign, ":relevant_party", -1),
	(assign, ":relevant_faction", -1),

	(try_begin),
		##diplomacy start+
		##OLD:
		#(eq, ":giver_troop", -1),
		##NEW:
		(lt, ":giver_troop", 0),
		##diplomacy end+
	(else_try),
		#1 rescue prisoner
		(neg|check_quest_active, "qst_rescue_prisoner"),
		(this_or_next|troop_slot_eq, ":giver_troop", slot_troop_occupation, slto_kingdom_hero),
			(troop_slot_eq, ":giver_troop", slot_troop_occupation, slto_kingdom_lady),

		(assign, ":target_troop", -1),
		##diplomacy start+ add support for promoted ladies
		#(try_for_range, ":possible_prisoner", active_npcs_begin, active_npcs_end),
		(try_for_range, ":possible_prisoner", heroes_begin, heroes_end),
			(this_or_next|troop_slot_eq, ":possible_prisoner", slot_troop_occupation, slto_kingdom_hero),
				(is_between, ":possible_prisoner", active_npcs_begin, active_npcs_end),
		##diplomacy end+
			(troop_get_slot, ":captor_location", ":possible_prisoner", slot_troop_prisoner_of_party),
			(is_between, ":captor_location", walled_centers_begin, walled_centers_end),
			(store_troop_faction, ":giver_troop_faction_no", ":giver_troop"),
			(store_faction_of_party, ":captor_location_faction_no", ":captor_location"),
			(store_relation, ":giver_captor_relation", ":giver_troop_faction_no", ":captor_location_faction_no"),
			(lt, ":giver_captor_relation", 0),

			(call_script, "script_troop_get_family_relation_to_troop", ":giver_troop", ":possible_prisoner"),
			##diplomacy start+
			#If optional behavior changes are enabled, allow this for more relatives.
			#(In-laws, uncles, nieces.)
		   (try_begin),
			   (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
				(ge, reg0, 4),
				(val_max, reg0, 10),
			(else_try),
			#If the characters are related to each other, and both are
			#affiliated with the player, consider them to be close enough.
				 (ge, reg0, 1),
				 (lt, reg0, 10),
				 (call_script, "script_dplmc_is_affiliated_family_member", ":giver_troop"),
				 (ge, reg0, 1),
				 (call_script, "script_dplmc_is_affiliated_family_member", ":possible_prisoner"),
				 (ge, reg0, 1),
				 (assign, reg0, 10),
			(try_end),
			##diplomacy end+
			(ge, reg0, 10),

			(assign, ":offered_parole", 0),
			(try_begin),
				(call_script, "script_cf_prisoner_offered_parole", ":possible_prisoner"),
				(assign, ":offered_parole", 1),
			(try_end),
			(eq, ":offered_parole", 0),

			(neg|party_slot_eq, ":captor_location", slot_town_lord, "trp_player"),

			(assign, ":target_troop", ":possible_prisoner"),
			(assign, ":target_party", ":captor_location"),
		(try_end),

		(gt, ":target_troop", -1),
		(assign, ":result", "qst_rescue_prisoner"),
		(assign, ":relevant_troop", ":target_troop"),
		(assign, ":relevant_party", ":target_party"),

	(else_try),
		#2 retaliate for border incident
		(is_between, ":giver_troop", mayors_begin, mayors_end),
		(store_faction_of_troop, ":giver_faction", ":giver_troop"),

		(neg|check_quest_active, "qst_retaliate_for_border_incident"),
		(quest_slot_eq, "qst_retaliate_for_border_incident", slot_quest_dont_give_again_remaining_days, 0),
		(assign, ":target_leader", 0),

		(try_for_range, ":kingdom", "fac_kingdom_1", kingdoms_end),
			(call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":giver_faction", ":kingdom"),
			(assign, ":diplomatic_status", reg0),
			(eq, ":diplomatic_status", -1),
			(assign, ":duration", reg1),
			(ge, ":duration", 10),

			##diplomacy start+ add support for promoted kingdom ladies
			#(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
			(try_for_range, ":lord", heroes_begin, heroes_end),
				(this_or_next|is_between, ":lord", active_npcs_begin, active_npcs_end),
					(troop_slot_eq, ":lord", slot_troop_occupation, slto_kingdom_hero),
			##diplomacy end+
				(store_faction_of_troop, ":lord_faction", ":lord"),
				(eq, ":lord_faction", ":kingdom"),

				(troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_debauched),

				(assign, ":target_leader", ":lord"),
				(assign, ":target_faction", ":kingdom"),
			(try_end),
		(try_end),
		##diplomacy start+ add support for promoted kingdom ladies
		#(is_between, ":target_leader", active_npcs_begin, active_npcs_end),
		(is_between, ":target_leader", heroes_begin, heroes_end),
		##diplomacy end+

		(assign, ":result", "qst_retaliate_for_border_incident"),
		(assign, ":relevant_troop", ":target_leader"),
		(assign, ":relevant_faction", ":target_faction"),
	(else_try), #Find bandit hideout
		(troop_slot_eq, ":giver_troop", slot_troop_occupation, slto_kingdom_hero),
		(neg|check_quest_active, "qst_destroy_bandit_lair"),
		(quest_slot_eq, "qst_destroy_bandit_lair", slot_quest_dont_give_again_remaining_days, 0),

#		(display_message, "@Checking for bandit lair quest"),

		(assign, ":lair_found", -1),

		(try_for_range, ":bandit_template", bandit_party_templates_begin, bandit_party_templates_end), #SB : template range
			(party_template_get_slot, ":bandit_lair", ":bandit_template", slot_party_template_lair_party),

			#No party is active because bandit lairs are removed as soon as they are attacked, by the player -- but can only be removed by the player. This will reset bandit lair to zero
			(gt, ":bandit_lair", "p_spawn_points_end"),

			(assign, ":closest_town", -1),
			(assign, ":score_to_beat", 99999),

			(try_for_range, ":town_no", towns_begin, towns_end),
				(store_distance_to_party_from_party, ":distance", ":bandit_lair", ":town_no"),
				(lt, ":distance", ":score_to_beat"),
				(assign, ":closest_town", ":town_no"),
				(assign, ":score_to_beat", ":distance"),
			(try_end),

			#(str_store_party_name, s7, ":closest_town"),
			#(party_get_slot, ":closest_town_lord", ":closest_town", slot_town_lord),
			#(str_store_troop_name, s8, ":closest_town_lord"),

			(party_slot_eq, ":closest_town", slot_town_lord, ":giver_troop"),
			(assign, ":lair_found", ":bandit_lair"),
		(try_end),

		(gt, ":lair_found", "p_spawn_points_end"),

		(assign ,":result", "qst_destroy_bandit_lair"),
		(assign, ":relevant_party", ":lair_found"),
	(else_try),  #3 - bounty on bandit party
		(is_between, ":giver_troop", mayors_begin, mayors_end),
		(neg|check_quest_active, "qst_track_down_bandits"),
		(quest_slot_eq, "qst_track_down_bandits", slot_quest_dont_give_again_remaining_days, 0),

		(assign, ":cur_town", -1),
		(try_for_range, ":town", towns_begin, towns_end),
			(party_slot_eq, ":town", slot_town_elder, ":giver_troop"),
			(assign, ":cur_town", ":town"),
		(try_end),
		(gt, ":cur_town", -1),

		(call_script, "script_merchant_road_info_to_s42", ":cur_town"),
		(assign, ":bandit_party_found", reg0),
		(party_is_active, ":bandit_party_found"),
		(gt, ":bandit_party_found", 0),

        (try_begin),
            (eq, "$cheat_mode", 1),
            (display_message, "str_traveller_attack_found"),
        (try_end),

		(assign ,":result", "qst_track_down_bandits"),
		(assign, ":relevant_party", ":bandit_party_found"),
	(else_try),  #raid a caravan to start war
		##diplomacy start+
        #SB : quest not already active
        (neg|check_quest_active, "qst_cause_provocation"),
	    ##Roguish and tmt_humanitarian < 0 also should qualify.
		(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
		(assign, ":humanitarian_value", reg0),
		(lt, ":humanitarian_value", 1),
		(assign, reg0, 0),#<-- satisfies requirement
		(try_begin),
			#Originally, only lrep_debauched qualified
			(troop_slot_eq, ":giver_troop", slot_lord_reputation_type, lrep_debauched),
			(assign, reg0, 1),
		(else_try),
			#Roguish qualifies for anti-humanitarians
			(troop_slot_eq, ":giver_troop", slot_lord_reputation_type, lrep_roguish),
			(lt, ":humanitarian_value", 1),
			(assign, reg0, 1),
		(try_end),
		(eq, reg0, 1),
		##diplomacy end+
		(store_faction_of_troop, ":giver_troop_faction", ":giver_troop"),

		(assign, ":junior_debauched_lord_in_faction", -1),
      ##diplomacy start+
		#Add support for promoted kingdom ladies
		#(try_for_range, ":lord_in_faction", active_npcs_begin, active_npcs_end),
		(try_for_range, ":lord_in_faction", heroes_begin, heroes_end),
			(this_or_next|is_between, ":lord_in_faction", active_npcs_begin, active_npcs_end),
				(troop_slot_eq, ":lord_in_faction", slot_troop_occupation, slto_kingdom_hero),
			(call_script, "script_dplmc_get_troop_morality_value", ":giver_troop", tmt_humanitarian),
			(assign, ":other_humanitarian", reg0),
			(lt, ":other_humanitarian", 1),
			(assign, reg0, 0),#<-- satisfies personality requirement
			(try_begin),
				#originally just debauched lords
				(troop_slot_eq, ":lord_in_faction", slot_lord_reputation_type, lrep_debauched),
				(assign, reg0, 1),
			(else_try),
				#roguish qualifies for anti-humanitarians
				(troop_slot_eq, ":giver_troop", slot_lord_reputation_type, lrep_roguish),
				(lt, ":humanitarian_value", 1),
				(assign, reg0, 1),
			(try_end),
			(eq, reg0, 1),
	  ##diplomacy end+
			(store_faction_of_troop, ":debauched_lord_faction", ":lord_in_faction"),
			(eq, ":debauched_lord_faction", ":giver_troop_faction"),
			(assign, ":junior_debauched_lord_in_faction", ":lord_in_faction"),
		(try_end),
		(eq, ":giver_troop", ":junior_debauched_lord_in_faction"),

		(assign, ":faction_to_attack", -1),
		(assign, ":faction_to_attack_score", -1),

	    (try_for_range, ":faction_candidate", kingdoms_begin, kingdoms_end),
			(neq, ":faction_candidate", ":giver_troop_faction"),
			(faction_slot_eq, ":faction_candidate", slot_faction_state, sfs_active),
			(neq, ":faction_candidate", "$players_kingdom"),

			(store_relation, ":relation", ":faction_candidate", ":giver_troop_faction"),

			(store_add, ":provocation_slot", ":giver_troop_faction", slot_faction_provocation_days_with_factions_begin),
			(val_sub, ":provocation_slot", kingdoms_begin),
			(faction_get_slot, ":provocation_days", ":faction_candidate", ":provocation_slot"),

			(ge, ":relation", 0), #disqualifies if the faction is already at war
			(le, ":provocation_days", 0), #disqualifies if the faction has already provoked someone

			(store_random_in_range, ":faction_candidate_score", 0, 100),
			#add in scores - no truce?
#				(store_add, ":truce_slot", ":giver_troop_faction", slot_faction_truce_days_with_factions_begin),
#				(store_add, ":provocation_slot", ":giver_troop_faction", slot_faction_provocation_days_with_factions_begin),
#				(val_sub, ":truce_slot", kingdoms_begin),
#				(val_sub, ":provocation_slot", kingdoms_begin),
#				(faction_slot_eq, ":faction_candidate", ":provocation_slot", 0),
#				(try_begin),
#					(faction_slot_ge, ":faction_candidate", ":truce_slot", 1),
#					(val_sub, ":faction_to_attack_temp_score", 1),
#				(try_end),

			(gt, ":faction_candidate_score", ":faction_to_attack_score"),
				(assign, ":faction_to_attack", ":faction_candidate"),
			(assign, ":faction_to_attack_score", ":faction_candidate_score"),
	    (try_end),

		(is_between, ":faction_to_attack", kingdoms_begin, kingdoms_end),

		(assign ,":result", "qst_cause_provocation"),
		(assign, ":relevant_faction", ":faction_to_attack"),

	(try_end),

    (assign, reg0, ":result"),
    (assign, reg1, ":relevant_troop"),
    (assign, reg2, ":relevant_party"),
    (assign, reg3, ":relevant_faction"),

    ]),

  ("get_political_quest",
  #Political quests are given by the player's political "coach" -- ie, a spouse or the minister -- to improve standing in the faction
  [
	(store_script_param, ":giver_troop", 1),

	(assign, ":result", -1),
	(assign, ":quest_target_troop", -1),
	(assign, ":quest_object_troop", -1),
	(assign, ":quest_dont_give_again_period", 7), #one week on average



	(try_begin), #this for kingdom hero, "we have a mutual enemy"
		(neg|check_quest_active, "qst_denounce_lord"),
		(try_begin),
			(ge, "$cheat_mode", 1),
			(quest_get_slot, reg4, "qst_denounce_lord", slot_quest_dont_give_again_remaining_days),
			(display_message, "@{!}DEBUG -- Checking for denounce lord, eligible in {reg4} days"),
		(try_end),

		(neg|quest_slot_ge, "qst_denounce_lord", slot_quest_dont_give_again_remaining_days, 1),
		(neq, ":giver_troop", "$g_player_minister"),
		(neg|troop_slot_eq, "trp_player", slot_troop_spouse, ":giver_troop"),
		(neg|faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),


#		(neg|troop_slot_eq, "$g_talk_troop", slot_lord_reputation_type, lrep_martial),
		(neg|troop_slot_eq, "$g_talk_troop", slot_lord_reputation_type, lrep_quarrelsome),
		(neg|troop_slot_eq, "$g_talk_troop", slot_lord_reputation_type, lrep_goodnatured),

#		(neg|troop_slot_ge, "trp_player", slot_troop_controversy, 10),


		(assign, ":target_lord", -1),
		(assign, ":score_to_beat", 1),

		##diplomacy start+ support promoted ladies
		#(try_for_range, ":potential_target", active_npcs_begin, active_npcs_end),
		(try_for_range, ":potential_target", heroes_begin, heroes_end),
		   (this_or_next|is_between, ":potential_target", active_npcs_begin, active_npcs_end),
			   (troop_slot_eq, ":potential_target", slot_troop_occupation, slto_kingdom_hero),
            (neg|troop_slot_ge, ":potential_target", slot_troop_occupation, slto_retirement),
            ##diplomacy end+
			(store_faction_of_troop, ":potential_target_faction", ":potential_target"),
			(eq, ":potential_target_faction", "$players_kingdom"),
			(neq, ":potential_target", ":giver_troop"),
			(neg|faction_slot_eq, ":potential_target_faction", slot_faction_leader, ":potential_target"),

			#cannot denounce if you also have an intrigue against lord active
			(this_or_next|neg|check_quest_active, "qst_intrigue_against_lord"),
				(neg|quest_slot_eq, "qst_intrigue_against_lord", slot_quest_target_troop, ":potential_target"),

			(call_script, "script_troop_get_relation_with_troop", ":potential_target", ":giver_troop"),
			(assign, ":relation_with_giver_troop", reg0),
			(lt, ":relation_with_giver_troop", ":score_to_beat"),

			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- Rival found in {s4}"),
			(try_end),

			(try_begin),
				(troop_slot_eq, "$g_talk_troop", slot_lord_reputation_type, lrep_debauched),
				(assign, ":max_rel_w_player", 15),
			(else_try),
				##diplomacy start+
				(this_or_next|troop_slot_eq, "$g_talk_troop", slot_lord_reputation_type, lrep_ambitious),
				##diplomacy end+
				(troop_slot_eq, "$g_talk_troop", slot_lord_reputation_type, lrep_quarrelsome),
				(assign, ":max_rel_w_player", 10),
			(else_try),
				(assign, ":max_rel_w_player", 5),
			(try_end),

			(call_script, "script_troop_get_relation_with_troop", ":potential_target", "trp_player"),
			(assign, ":relation_with_player", reg0),
			(lt, ":relation_with_player", ":max_rel_w_player"),

			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- {s4} is not close friend of player"),
			(try_end),

			(assign, ":enemies_in_faction", 0),
			##diplomacy start+ support promoted ladies
			#(try_for_range, ":other_lord", active_npcs_begin, active_npcs_end),
			(try_for_range, ":other_lord", heroes_begin, heroes_end),
			   (this_or_next|is_between, ":other_lord", active_npcs_begin, active_npcs_end),
				   (troop_slot_eq, ":other_lord", slot_troop_occupation, slto_kingdom_hero),
            #do not scheme regarding dead/exiled lords
                (neg|troop_slot_ge, ":other_lord", slot_troop_occupation, slto_retirement),
                ##diplomacy end+
				(store_faction_of_troop, ":other_lord_faction", ":other_lord"),
				(eq, ":other_lord_faction", "$players_kingdom"),
				(call_script, "script_troop_get_relation_with_troop", ":potential_target", ":other_lord"),
				(lt, reg0, 0),
				(val_add, ":enemies_in_faction", 1),
			(try_end),

			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(assign, reg3, ":enemies_in_faction"),
				(display_message, "@{!}DEBUG -- {s4} has {reg3} rivals"),
			(try_end),

			(this_or_next|ge, ":enemies_in_faction", 3),
				(ge, "$cheat_mode", 1),

			(assign, ":score_to_beat", ":relation_with_giver_troop"),
			(assign, ":target_lord", ":potential_target"),
		(try_end),

		##diplomacy start+ support promoted ladies
		#(is_between, ":target_lord", active_npcs_begin, active_npcs_end),
		(is_between, ":target_lord", heroes_begin, heroes_end),
		##diplomacy end+

		(assign, ":result", "qst_denounce_lord"),
		(assign, ":quest_target_troop", ":target_lord"),

	(else_try),
		(neg|check_quest_active, "qst_intrigue_against_lord"),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(quest_get_slot, reg4, "qst_intrigue_against_lord", slot_quest_dont_give_again_remaining_days),
			(display_message, "@{!}DEBUG -- Checking for intrigue, eligible in {reg4} days"),
		(try_end),

		(neg|quest_slot_ge, "qst_intrigue_against_lord", slot_quest_dont_give_again_remaining_days, 1),



		(neq, ":giver_troop", "$g_player_minister"),
		(neg|troop_slot_eq, "trp_player", slot_troop_spouse, ":giver_troop"),
		(neg|faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- Trying for intrigue against lord"),
		(try_end),


		(assign, ":target_lord", -1),
		(assign, ":score_to_beat", 10),

		##diplomacy start+ Support promoted kingdom ladies
		#(try_for_range, ":potential_target", active_npcs_begin, active_npcs_end),
		(try_for_range, ":potential_target", heroes_begin, heroes_end),
		    (this_or_next|is_between, ":potential_target", active_npcs_begin, active_npcs_end),
		    (troop_slot_eq, ":potential_target", slot_troop_occupation, slto_kingdom_hero),
           #do not scheme regarding dead/exiled lords
            (neg|troop_slot_ge, ":potential_target", slot_troop_occupation, slto_retirement),
            ##diplomacy end+
			(store_faction_of_troop, ":potential_target_faction", ":potential_target"),
			(eq, ":potential_target_faction", "$players_kingdom"),
			(neq, ":potential_target", ":giver_troop"),
			(neg|faction_slot_eq, ":potential_target_faction", slot_faction_leader, ":potential_target"),


			(this_or_next|neg|check_quest_active, "qst_denounce_lord"),
				(neg|quest_slot_eq, "qst_denounce_lord", slot_quest_target_troop, ":potential_target"),

			(faction_get_slot, ":faction_liege", "$players_kingdom", slot_faction_leader),
			(call_script, "script_troop_get_relation_with_troop", ":potential_target", ":faction_liege"),
			(assign, ":relation_with_liege", reg0),
			(lt, ":relation_with_liege", ":score_to_beat"),

			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- {s4} has sufficiently low relation with liege"),
			(try_end),


			(call_script, "script_troop_get_relation_with_troop", ":potential_target", ":giver_troop"),
			(assign, ":relation_with_giver_troop", reg0),
			(lt, ":relation_with_giver_troop", 0),

			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- {s4} has sufficiently low relation with giver troop"),
			(try_end),


			(call_script, "script_troop_get_relation_with_troop", ":potential_target", "trp_player"),
			(assign, ":relation_with_player", reg0),
			(lt, ":relation_with_player", 0),

			(str_store_troop_name, s4, ":potential_target"),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(display_message, "@{!}DEBUG -- {s4} has sufficiently low relation with player"),
			(try_end),

			(assign, ":score_to_beat", ":relation_with_liege"),
			(assign, ":target_lord", ":potential_target"),
		(try_end),

		##diplomacy start+ support promoted ladies
		#(is_between, ":target_lord", active_npcs_begin, active_npcs_end),
		(is_between, ":target_lord", heroes_begin, heroes_end),
		##diplomacy end+

		(assign, ":result", "qst_intrigue_against_lord"),
		(assign, ":quest_target_troop", ":target_lord"),


	(else_try),
		#Resolve dispute, if there is a good chance of achieving the result
		(try_begin),
			(ge, "$cheat_mode", 1),
			(quest_get_slot, reg4, "qst_resolve_dispute", slot_quest_dont_give_again_remaining_days),
			(display_message, "@{!}DEBUG -- Checking for resolve dispute, eligible in {reg4} days"),
		(try_end),

		(neg|quest_slot_ge, "qst_resolve_dispute", slot_quest_dont_give_again_remaining_days, 1),


		##diplomacy start+
		#Add additional relative options
		##(call_script, "script_troop_get_family_relation_to_troop", "trp_player", ":giver_troop"),
		(call_script, "script_dplmc_troop_get_family_relation_to_troop", "trp_player", ":giver_troop"),
		(this_or_next|ge, reg0, 4),
		##diplomacy end+
		(this_or_next|troop_slot_eq, "trp_player", slot_troop_spouse, "$g_talk_troop"),
			(eq, "$g_talk_troop", "$g_player_minister"),

		(assign, ":target_lord", -1),
		(assign, ":object_lord", -1),
		(assign, ":best_chance_of_success", 20),

      ##diplomacy start+ support promoted ladies
		#(try_for_range, ":lord_1", active_npcs_begin, active_npcs_end),
      (try_for_range, ":lord_1", heroes_begin, heroes_end),
		   (this_or_next|is_between, ":lord_1", active_npcs_begin, active_npcs_end),
			   (troop_slot_eq, ":lord_1", slot_troop_occupation, slto_kingdom_hero),
         #do not use dead/exiled lords
            (neg|troop_slot_ge, ":lord_1", slot_troop_occupation, slto_retirement),
            ##diplomacy end+
			(store_faction_of_troop, ":lord_1_faction", ":lord_1"),
			(eq, ":lord_1_faction", "$players_kingdom"),
			(neq, ":lord_1", "$g_talk_troop"),

	      ##diplomacy start+ support promoted ladies
			#(try_for_range, ":lord_2", active_npcs_begin, active_npcs_end),
			(try_for_range, ":lord_2", heroes_begin, heroes_end),
			   (this_or_next|is_between, ":lord_2", active_npcs_begin, active_npcs_end),
				   (troop_slot_eq, ":lord_2", slot_troop_occupation, slto_kingdom_hero),
			   #do not use dead/exiled lords
                (neg|troop_slot_ge, ":lord_2", slot_troop_occupation, slto_retirement),
                ##diplomacy end+
				(store_faction_of_troop, ":lord_2_faction", ":lord_2"),
				(eq, ":lord_2_faction", "$players_kingdom"),

				(neq, ":lord_1", ":lord_2"),
				(neq, ":lord_2", "$g_talk_troop"),

				(call_script, "script_troop_get_relation_with_troop", ":lord_1", ":lord_2"),
				(assign, ":lord_1_relation_with_lord_2", reg0),
				(lt, ":lord_1_relation_with_lord_2", -5),

				(call_script, "script_troop_get_relation_with_troop", ":lord_1", "trp_player"),
				(assign, ":relation_with_lord_1", reg0),

				(call_script, "script_troop_get_relation_with_troop", ":lord_2", "trp_player"),
				(assign, ":relation_with_lord_2", reg0),

				(gt, ":relation_with_lord_1", 0),
				(gt, ":relation_with_lord_2", 0),

				(store_mul, ":chance_of_success", ":relation_with_lord_1", ":relation_with_lord_2"),


				(gt, ":chance_of_success", ":best_chance_of_success"),
				(assign, ":best_chance_of_success", ":chance_of_success"),
				(assign, ":target_lord", ":lord_1"),
				(assign, ":object_lord", ":lord_2"),
			(try_end),
		(try_end),

		##diplomacy start+ support promoted ladies
		#(is_between, ":target_lord", active_npcs_begin, active_npcs_end),
		(is_between, ":target_lord", heroes_begin, heroes_end),
		##diplomacy end+

		(assign, ":result", "qst_resolve_dispute"),
		(assign, ":quest_target_troop", ":target_lord"),
		(assign, ":quest_object_troop", ":object_lord"),

	(else_try),
		(try_begin),
			(ge, "$cheat_mode", 1),
			(quest_get_slot, reg4, "qst_offer_gift", slot_quest_dont_give_again_remaining_days),
			(display_message, "@{!}DEBUG -- Checking for offer gift, eligible in {reg4} days"),
		(try_end),

		##diplomacy start+ conventional ladies have a quicker "reset" time on this quest
		(neg|quest_slot_ge, "qst_offer_gift", slot_quest_dont_give_again_remaining_days, 4),
        (this_or_next|troop_slot_eq, ":giver_troop", slot_lord_reputation_type, lrep_conventional),
		##diplomacy end+
		(neg|quest_slot_ge, "qst_offer_gift", slot_quest_dont_give_again_remaining_days, 1),

		(assign, ":relative_found", -1),
		(assign, ":score_to_beat", 5),
		##diplomacy start+
		#Slightly expand the range of potential targets if changes are enabled
		(try_begin),
         (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		   (assign, ":score_to_beat", 4),
		   (troop_slot_eq, ":giver_troop", slot_lord_reputation_type, lrep_conventional),
		   (assign, ":score_to_beat", 3),
	   (try_end),
		##diplomacy end+

		##diplomacy start+
		#(try_for_range, ":potential_relative", active_npcs_begin, active_npcs_end),
		#Add support for promoted ladies (TODO: add a variant for ordinary ladies as well)
		(try_for_range, ":potential_relative", heroes_begin, heroes_end),
			#do not use dead/exiled lords
			(this_or_next|is_between, ":potential_relative", active_npcs_begin, active_npcs_end),
				(troop_slot_eq, ":potential_relative", slot_troop_occupation, slto_kingdom_hero),
         (neg|troop_slot_ge, ":potential_relative", slot_troop_occupation, slto_retirement),
        ##diplomacy end+
			(store_faction_of_troop, ":relative_faction", ":potential_relative"),
			(eq, ":relative_faction", "$players_kingdom"),
			(neq, ":potential_relative", ":giver_troop"),
			(neg|faction_slot_eq, ":relative_faction", slot_faction_leader, ":potential_relative"),

			(call_script, "script_troop_get_family_relation_to_troop", ":giver_troop", ":potential_relative"),
			(assign, ":family_relation", reg0),
			(ge, ":family_relation", ":score_to_beat"),

			(store_sub, ":min_relation_w_player", 0, ":family_relation"),

			(call_script, "script_troop_get_relation_with_troop", "trp_player", ":potential_relative"),
			(assign, ":relation_with_player", reg0),
			(is_between, ":relation_with_player", ":min_relation_w_player", 0),

			(assign, ":score_to_beat", ":family_relation"),
			(assign, ":relative_found", ":potential_relative"),

		(try_end),

		(is_between, ":relative_found", active_npcs_begin, active_npcs_end),

		(assign, ":result", "qst_offer_gift"),
		(assign, ":quest_target_troop", ":relative_found"),
	(try_end),


	(try_begin),
		(gt, ":result", -1),
		(quest_set_slot, ":result", slot_quest_target_troop, ":quest_target_troop"),
		(quest_set_slot, ":result", slot_quest_target_troop, ":quest_object_troop"),

		(quest_set_slot, ":result", slot_quest_giver_troop, ":giver_troop"),
        (quest_set_slot, ":result", slot_quest_dont_give_again_period, ":quest_dont_give_again_period"),
    (try_end),

    (assign, reg0, ":result"),
    (assign, reg1, ":quest_target_troop"),
    (assign, reg2, ":quest_object_troop"),

  ]),


  ("npc_find_quest_for_player_to_s11",
  [
  (store_script_param, ":faction", 1),

  (assign, ":quest_giver_found", -1),
  (try_for_range, ":quest_giver", active_npcs_begin, mayors_end),
    (eq, ":quest_giver_found", -1),

	(neg|troop_slot_eq, "trp_player", slot_troop_spouse, ":quest_giver"),

	(gt, ":quest_giver", "$g_troop_list_no"),

	(assign, "$g_troop_list_no", ":quest_giver"),

	(this_or_next|troop_slot_eq, ":quest_giver", slot_troop_occupation, slto_kingdom_hero),
		(is_between, ":quest_giver", mayors_begin, mayors_end),

	(neg|troop_slot_ge, ":quest_giver", slot_troop_prisoner_of_party, centers_begin),

	(try_begin),
		(is_between, ":quest_giver", mayors_begin, mayors_end),
		(assign, ":quest_giver_faction", -1),
		(try_for_range,":town", towns_begin, towns_end),
			(party_slot_eq, ":town", slot_town_elder, ":quest_giver"),
			(store_faction_of_party, ":quest_giver_faction", ":town"),
		(try_end),
	(else_try),
		(store_faction_of_troop, ":quest_giver_faction", ":quest_giver"),
	(try_end),
	(eq, ":faction", ":quest_giver_faction"),

	(call_script, "script_get_dynamic_quest", ":quest_giver"),
    (gt, reg0, -1),

    (assign, ":quest_giver_found", ":quest_giver"),
	(try_begin),
          (eq, "$cheat_mode", 1),
	  (str_store_troop_name, s4, ":quest_giver_found"),
	  (display_message, "str_test_diagnostic_quest_found_for_s4"),
        (try_end),

  (try_end),

  (assign, reg0, ":quest_giver_found"),

    ]),



  # script_cf_get_random_enemy_center_within_range
  # Input: arg1 = party_no, arg2 = range (in kms)
  # Output: reg0 = center_no
  ("cf_get_random_enemy_center_within_range",
    [
      (store_script_param, ":party_no", 1),
      (store_script_param, ":range", 2),

      (assign, ":num_centers", 0),
      (store_faction_of_party, ":faction_no", ":party_no"),
      (try_for_range, ":cur_center", centers_begin, centers_end),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (lt, ":cur_relation", 0),
        (store_distance_to_party_from_party, ":dist", ":party_no", ":cur_center"),
        (le, ":dist", ":range"),
        (val_add, ":num_centers", 1),
      (try_end),
      (gt, ":num_centers", 0),
      (store_random_in_range, ":random_center", 0, ":num_centers"),
      (assign, ":end_cond", centers_end),
      (try_for_range, ":cur_center", centers_begin, ":end_cond"),
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (lt, ":cur_relation", 0),
        (store_distance_to_party_from_party, ":dist", ":party_no", ":cur_center"),
        (le, ":dist", ":range"),
        (val_sub, ":random_center", 1),
        (lt, ":random_center", 0),
        (assign, ":result", ":cur_center"),
        (assign, ":end_cond", 0),#break
      (try_end),
      (assign, reg0, ":result"),
  ]),

  # script_cf_faction_get_random_enemy_faction
  # Input: arg1 = faction_no
  # Output: reg0 = faction_no (Can fail)
  ("cf_faction_get_random_enemy_faction",
    [
      (store_script_param_1, ":faction_no"),

      (assign, ":result", -1),
      (assign, ":count_factions", 0),
      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":cur_faction", slot_faction_state, sfs_active),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (le, ":cur_relation", -1),
        (val_add, ":count_factions", 1),
      (try_end),
      (store_random_in_range,":random_faction",0,":count_factions"),
      (assign, ":count_factions", 0),
      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (eq, ":result", -1),
        (faction_slot_eq, ":cur_faction", slot_faction_state, sfs_active),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (le, ":cur_relation", -1),
        (val_add, ":count_factions", 1),
        (gt, ":count_factions", ":random_faction"),
        (assign, ":result", ":cur_faction"),
      (try_end),

      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),

  # script_cf_faction_get_random_friendly_faction
  # Input: arg1 = faction_no
  # Output: reg0 = faction_no (Can fail)
  ("cf_faction_get_random_friendly_faction",
    [
      (store_script_param_1, ":faction_no"),

      (assign, ":result", -1),
      (assign, ":count_factions", 0),
      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":cur_faction", slot_faction_state, sfs_active),
        (neq, ":cur_faction", ":faction_no"),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (ge, ":cur_relation", 0),
        (val_add, ":count_factions", 1),
      (try_end),
      (store_random_in_range,":random_faction",0,":count_factions"),
      (assign, ":count_factions", 0),
      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (eq, ":result", -1),
        (faction_slot_eq, ":cur_faction", slot_faction_state, sfs_active),
        (neq, ":cur_faction", ":faction_no"),
        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
        (ge, ":cur_relation", 0),
        (val_add, ":count_factions", 1),
        (gt, ":count_factions", ":random_faction"),
        (assign, ":result", ":cur_faction"),
      (try_end),

      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),

  # script_cf_troop_get_random_enemy_troop_with_occupation
  # Input: arg1 = troop_no,
  # Output: reg0 = enemy_troop_no (Can fail)
  ("cf_troop_get_random_enemy_troop_with_occupation",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":occupation"),

      (assign, ":result", -1),
      (assign, ":count_enemies", 0),
      (try_for_range, ":enemy_troop_no", active_npcs_begin, active_npcs_end),
        (troop_slot_eq, ":enemy_troop_no", slot_troop_occupation, ":occupation"),
        (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":enemy_troop_no"),
        (lt, reg0, -10),
        (val_add, ":count_enemies", 1),
      (try_end),

      (gt, ":count_enemies", 0),
      (store_random_in_range,":random_enemy",0,":count_enemies"),

      (assign, ":count_enemies", 0),
      (try_for_range, ":enemy_troop_no", active_npcs_begin, active_npcs_end),
        (troop_slot_eq, ":enemy_troop_no", slot_troop_occupation, ":occupation"),
        (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":enemy_troop_no"),
        (lt, reg0, -10),
        (val_add, ":count_enemies", 1),
        (eq, ":random_enemy", ":count_enemies"),
        (assign, ":result", ":enemy_troop_no"),
      (try_end),

      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),


##  # script_cf_troop_get_random_enemy_troop_as_a_town_lord
##  # Input: arg1 = troop_no
##  # Output: reg0 = enemy_troop_no (Can fail)
##  ("cf_troop_get_random_enemy_troop_as_a_town_lord",
##    [
##      (store_script_param_1, ":troop_no"),
##
##      (assign, ":result", -1),
##      (assign, ":count_enemies", 0),
##      (try_for_range, ":cur_slot", slot_troop_enemies_begin, slot_troop_enemies_end),
##        (troop_get_slot, ":cur_enemy", ":troop_no", ":cur_slot"),
##        (gt, ":cur_enemy", 0),
##        (troop_slot_eq, ":cur_enemy", slot_troop_occupation, slto_kingdom_hero),
##        (call_script, "script_get_number_of_hero_centers", ":cur_enemy"),
##        (gt, reg0, 0),
##        (val_add, ":count_enemies", 1),
##      (try_end),
##      (store_random_in_range,":random_enemy",0,":count_enemies"),
##      (assign, ":count_enemies", 0),
##      (try_for_range, ":cur_slot", slot_troop_enemies_begin, slot_troop_enemies_end),
##        (eq, ":result", -1),
##        (troop_get_slot, ":cur_enemy", ":troop_no", ":cur_slot"),
##        (gt, ":cur_enemy", 0),
##        (troop_slot_eq, ":cur_enemy", slot_troop_occupation, slto_kingdom_hero),
##        (call_script, "script_get_number_of_hero_centers", ":cur_enemy"),
##        (gt, reg0, 0),
##        (val_add, ":count_enemies", 1),
##        (gt, ":count_enemies", ":random_enemy"),
##        (assign, ":result", ":cur_enemy"),
##      (try_end),
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),


  ##  # script_cf_get_random_enemy_with_valid_slot
  ##  # Input: arg1 = faction_no, arg2 = slot_no
  ##  # Output: reg0 = faction_no (Can fail)
  ##  ("cf_get_random_enemy_with_valid_slot",
  ##    [
  ##      (store_script_param_1, ":faction_no"),
  ##      (store_script_param_2, ":slot_no"),
  ##
  ##      (assign, ":result", -1),
  ##      (assign, ":count_factions", 0),
  ##      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
  ##        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
  ##        (le, ":cur_relation", -10),
  ##        (faction_get_slot, ":cur_value", ":cur_faction", ":slot_no"),
  ##        (gt, ":cur_value", 0),#Checking validity
  ##        (val_add, ":count_factions", 1),
  ##      (try_end),
  ##      (store_random_in_range,":random_faction",0,":count_factions"),
  ##      (assign, ":count_factions", 0),
  ##      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
  ##        (eq, ":result", -1),
  ##        (store_relation, ":cur_relation", ":faction_no", ":cur_faction"),
  ##        (le, ":cur_relation", -10),
  ##        (faction_get_slot, ":cur_value", ":cur_faction", ":slot_no"),
  ##        (gt, ":cur_value", 0),#Checking validity
  ##        (val_add, ":count_factions", 1),
  ##        (gt, ":count_factions", ":random_faction"),
  ##        (assign, ":result", ":cur_faction"),
  ##      (try_end),
  ##
  ##      (neq, ":result", -1),
  ##      (assign, reg0, ":result"),
  ##  ]),


##  # script_cf_get_random_kingdom_hero
##  # Input: arg1 = faction_no
##  # Output: reg0 = troop_no (Can fail)
##  ("cf_get_random_kingdom_hero",
##    [
##      (store_script_param_1, ":faction_no"),
##      (assign, ":count_heroes", 0),
##      (try_for_range, ":center_no", centers_begin, centers_end),
##        (store_faction_of_party, ":cur_faction", ":center_no"),
##        (eq, ":cur_faction", ":faction_no"),
##        (party_get_slot, ":cur_lord", ":center_no", slot_town_lord),
##        (is_between, ":cur_lord", heroes_begin, heroes_end),
##        (val_add, ":count_heroes", 1),
##      (try_end),
##      (store_random_in_range, ":random_hero", 0, ":count_heroes"),
##      (assign, ":result", -1),
##      (assign, ":count_heroes", 0),
##      (try_for_range, ":center_no", centers_begin, centers_end),
##        (eq, ":result", -1),
##        (store_faction_of_party, ":cur_faction", ":center_no"),
##        (eq, ":cur_faction", ":faction_no"),
##        (party_get_slot, ":cur_lord", ":center_no", slot_town_lord),
##        (is_between, ":cur_lord", heroes_begin, heroes_end),
##        (val_add, ":count_heroes", 1),
##        (lt, ":random_hero", ":count_heroes"),
##        (assign, ":result", ":cur_lord"),
##      (try_end),
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),


# script_cf_get_random_kingdom_hero_as_lover - removed



##  # script_cf_get_random_siege_location_with_faction
##  # Input: arg1 = faction_no
##  # Output: reg0 = center_no, Can Fail!
##  ("cf_get_random_siege_location_with_faction",
##    [
##      (store_script_param_1, ":faction_no"),
##      (assign, ":result", -1),
##      (assign, ":count_sieges", 0),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (party_get_battle_opponent, ":besieger_party", ":center_no"),
##        (gt, ":besieger_party", 0),
##        (store_faction_of_party, ":cur_faction_no", ":center_no"),
##        (eq, ":cur_faction_no", ":faction_no"),
##        (val_add, ":count_sieges", 1),
##      (try_end),
##      (store_random_in_range,":random_center",0,":count_sieges"),
##      (assign, ":count_sieges", 0),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (eq, ":result", -1),
##        (party_get_battle_opponent, ":besieger_party", ":center_no"),
##        (gt, ":besieger_party", 0),
##        (store_faction_of_party, ":cur_faction_no", ":center_no"),
##        (eq, ":cur_faction_no", ":faction_no"),
##        (val_add, ":count_sieges", 1),
##        (gt, ":count_sieges", ":random_center"),
##        (assign, ":result", ":center_no"),
##      (try_end),
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),

##  # script_cf_get_random_siege_location_with_attacker_faction
##  # Input: arg1 = faction_no
##  # Output: reg0 = center_no, Can Fail!
##  ("cf_get_random_siege_location_with_attacker_faction",
##    [
##      (store_script_param_1, ":faction_no"),
##      (assign, ":result", -1),
##      (assign, ":count_sieges", 0),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (party_get_battle_opponent, ":besieger_party", ":center_no"),
##        (gt, ":besieger_party", 0),
##        (store_faction_of_party, ":cur_faction_no", ":besieger_party"),
##        (eq, ":cur_faction_no", ":faction_no"),
##        (val_add, ":count_sieges", 1),
##      (try_end),
##      (store_random_in_range,":random_center",0,":count_sieges"),
##      (assign, ":count_sieges", 0),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (eq, ":result", -1),
##        (party_get_battle_opponent, ":besieger_party", ":center_no"),
##        (gt, ":besieger_party", 0),
##        (store_faction_of_party, ":cur_faction_no", ":besieger_party"),
##        (eq, ":cur_faction_no", ":faction_no"),
##        (val_add, ":count_sieges", 1),
##        (gt, ":count_sieges", ":random_center"),
##        (assign, ":result", ":center_no"),
##      (try_end),
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),



##  # script_cf_get_number_of_random_troops_from_party
##  # Input: arg1 = party_no, arg2 = number of troops to remove
##  # Output: reg0 = troop_no, Can fail if there are no slots having the required number of units!
##  ("cf_get_number_of_random_troops_from_party",
##    [
##      (store_script_param_1, ":party_no"),
##      (store_script_param_2, ":no_to_remove"),
##
##      (assign, ":result", -1),
##      (assign, ":count_stacks", 0),
##
##      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
##      (try_for_range, ":i_stack", 0, ":num_stacks"),
##        (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
##        (party_stack_get_num_wounded, ":num_wounded",":party_no",":i_stack"),
##        (val_sub, ":stack_size", ":num_wounded"),
##        (ge, ":stack_size", ":no_to_remove"),
##        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
##        (neg|troop_is_hero, ":stack_troop"),
##        (val_add, ":count_stacks", 1),
##      (try_end),
##      (store_random_in_range,":random_stack",0,":count_stacks"),
##      (assign, ":count_stacks", 0),
##      (try_for_range, ":i_stack", 0, ":num_stacks"),
##        (eq, ":result", -1),
##        (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
##        (party_stack_get_num_wounded, ":num_wounded",":party_no",":i_stack"),
##        (val_sub, ":stack_size", ":num_wounded"),
##        (ge, ":stack_size", ":no_to_remove"),
##        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
##        (neg|troop_is_hero, ":stack_troop"),
##        (val_add, ":count_stacks", 1),
##        (gt, ":count_stacks", ":random_stack"),
##        (assign, ":result", ":stack_troop"),
##      (try_end),
##
##      (neq, ":result", -1),
##      (assign, reg0, ":result"),
##  ]),




  # script_cf_get_random_lord_in_a_center_with_faction
  # Input: arg1 = faction_no
  # Output: reg0 = troop_no, Can Fail!
  ("cf_get_random_lord_in_a_center_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (eq, ":faction_no", ":lord_faction_no"),
        (troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", slot_troop_is_prisoner, 0),
        (neg|troop_slot_ge, ":lord_no", slot_troop_prisoner_of_party, 0),
        (troop_get_slot, ":lord_party", ":lord_no", slot_troop_leaded_party),
        (ge, ":lord_party", 0),
        (party_get_attached_to, ":lord_attachment", ":lord_party"),
        (is_between, ":lord_attachment", centers_begin, centers_end), #is troop in a center?
        (val_add, ":count_lords", 1),
      (try_end),
      (store_random_in_range, ":random_lord", 0, ":count_lords"),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (eq, ":result", -1),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (eq, ":faction_no", ":lord_faction_no"),
        (troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", slot_troop_is_prisoner, 0),
        (neg|troop_slot_ge, ":lord_no", slot_troop_prisoner_of_party, 0),
        (troop_get_slot, ":lord_party", ":lord_no", slot_troop_leaded_party),
        (ge, ":lord_party", 0),
        (party_get_attached_to, ":lord_attachment", ":lord_party"),
        (is_between, ":lord_attachment", centers_begin, centers_end), #is troop in a center?
        (val_add, ":count_lords", 1),
        (lt, ":random_lord", ":count_lords"),
        (assign, ":result", ":lord_no"),
      (try_end),
      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),

  # script_cf_get_random_lord_except_king_with_faction
  # Input: arg1 = faction_no
  # Output: reg0 = troop_no, Can Fail!
  ("cf_get_random_lord_except_king_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (eq, ":faction_no", ":lord_faction_no"),
        (neg|faction_slot_eq, ":faction_no", slot_faction_leader, ":lord_no"),
        (troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", slot_troop_is_prisoner, 0),
        (neg|troop_slot_ge, ":lord_no", slot_troop_prisoner_of_party, 0),
        (troop_get_slot, ":lord_party", ":lord_no", slot_troop_leaded_party),
        (ge, ":lord_party", 0),
        (val_add, ":count_lords", 1),
      (try_end),
      (store_random_in_range, ":random_lord", 0, ":count_lords"),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (eq, ":result", -1),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (eq, ":faction_no", ":lord_faction_no"),
        (neg|faction_slot_eq, ":faction_no", slot_faction_leader, ":lord_no"),
        (troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", slot_troop_is_prisoner, 0),
        (neg|troop_slot_ge, ":lord_no", slot_troop_prisoner_of_party, 0),
        (troop_get_slot, ":lord_party", ":lord_no", slot_troop_leaded_party),
        (ge, ":lord_party", 0),
        (val_add, ":count_lords", 1),
        (lt, ":random_lord", ":count_lords"),
        (assign, ":result", ":lord_no"),
      (try_end),
      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),


  # script_cf_get_random_lord_from_another_faction_in_a_center
  # Input: arg1 = faction_no
  # Output: reg0 = troop_no, Can Fail!
  ("cf_get_random_lord_from_another_faction_in_a_center",
    [
      (store_script_param_1, ":faction_no"),
      (assign, ":result", -1),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (neq, ":lord_faction_no", ":faction_no"),
        (store_relation, ":our_relation", ":lord_faction_no", "fac_player_supporters_faction"),
        (store_relation, ":lord_relation", ":lord_faction_no", ":faction_no"),
        (lt, ":lord_relation", 0),
        (ge, ":our_relation", 0),
        (troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", slot_troop_is_prisoner, 0),
        (neg|troop_slot_ge, ":lord_no", slot_troop_prisoner_of_party, 0),
        (troop_get_slot, ":lord_party", ":lord_no", slot_troop_leaded_party),
        (ge, ":lord_party", 0),
        (party_get_attached_to, ":lord_attachment", ":lord_party"),
        (is_between, ":lord_attachment", centers_begin, centers_end), #is troop in a center?
        (val_add, ":count_lords", 1),
      (try_end),
      (store_random_in_range, ":random_lord", 0, ":count_lords"),
      (assign, ":count_lords", 0),
      (try_for_range, ":lord_no", heroes_begin, heroes_end),
        (eq, ":result", -1),
        (store_troop_faction, ":lord_faction_no", ":lord_no"),
        (neq, ":lord_faction_no", ":faction_no"),
        (store_relation, ":our_relation", ":lord_faction_no", "fac_player_supporters_faction"),
        (store_relation, ":lord_relation", ":lord_faction_no", ":faction_no"),
        (lt, ":lord_relation", 0),
        (ge, ":our_relation", 0),
        (troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
        #(troop_slot_eq, ":lord_no", slot_troop_is_prisoner, 0),
        (neg|troop_slot_ge, ":lord_no", slot_troop_prisoner_of_party, 0),
        (troop_get_slot, ":lord_party", ":lord_no", slot_troop_leaded_party),
        (ge, ":lord_party", 0),
        (party_get_attached_to, ":lord_attachment", ":lord_party"),
        (is_between, ":lord_attachment", centers_begin, centers_end), #is troop in a center?
        (val_add, ":count_lords", 1),
        (lt, ":random_lord", ":count_lords"),
        (assign, ":result", ":lord_no"),
      (try_end),
      (neq, ":result", -1),
      (assign, reg0, ":result"),
  ]),

  # script_get_closest_walled_center
  # Input: arg1 = party_no
  # Output: reg0 = center_no (closest)
  ("get_closest_walled_center",
    [
      (store_script_param_1, ":party_no"),
      (assign, ":min_distance", 9999999),
      (assign, reg0, -1),
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (store_distance_to_party_from_party, ":party_distance", ":party_no", ":center_no"),
        (lt, ":party_distance", ":min_distance"),
        (assign, ":min_distance", ":party_distance"),
        (assign, reg0, ":center_no"),
      (try_end),
  ]),

  # script_get_closest_center
  # Input: arg1 = party_no
  # Output: reg0 = center_no (closest)
  ("get_closest_center",
    [
      (store_script_param_1, ":party_no"),
      (assign, ":min_distance", 9999999),
      (assign, reg0, -1),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_distance_to_party_from_party, ":party_distance", ":party_no", ":center_no"),
        (lt, ":party_distance", ":min_distance"),
        (assign, ":min_distance", ":party_distance"),
        (assign, reg0, ":center_no"),
      (try_end),
  ]),


  # script_get_closest_center_of_faction
  # Input: arg1 = party_no, arg2 = kingdom_no
  # Output: reg0 = center_no (closest)
  ("get_closest_center_of_faction",
    [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":kingdom_no"),
      (assign, ":min_distance", 99999),
      (assign, ":result", -1),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_faction_of_party, ":faction_no", ":center_no"),
        (eq, ":faction_no", ":kingdom_no"),
        (store_distance_to_party_from_party, ":party_distance", ":party_no", ":center_no"),
        (lt, ":party_distance", ":min_distance"),
        (assign, ":min_distance", ":party_distance"),
        (assign, ":result", ":center_no"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

  # script_get_closest_walled_center_of_faction
  # Input: arg1 = party_no, arg2 = kingdom_no
  # Output: reg0 = center_no (closest)
  ("get_closest_walled_center_of_faction",
    [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":kingdom_no"),
      (assign, ":min_distance", 99999),
      (assign, ":result", -1),
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":faction_no", ":center_no"),
        (eq, ":faction_no", ":kingdom_no"),
        (store_distance_to_party_from_party, ":party_distance", ":party_no", ":center_no"),
        (lt, ":party_distance", ":min_distance"),
        (assign, ":min_distance", ":party_distance"),
        (assign, ":result", ":center_no"),
      (try_end),
      (assign, reg0, ":result"),
  ]),


##  # script_get_closest_town_of_faction
##  # Input: arg1 = party_no, arg2 = kingdom_no
##  # Output: reg0 = center_no (closest)
##  ("get_closest_town_of_faction",
##    [
##      (store_script_param_1, ":party_no"),
##      (store_script_param_2, ":kingdom_no"),
##      (assign, ":min_distance", 9999999),
##      (assign, ":result", -1),
##      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
##        (store_faction_of_party, ":faction_no", ":center_no"),
##        (eq, ":faction_no", ":kingdom_no"),
##        (party_slot_eq, ":center_no", slot_party_type, spt_town),
##        (store_distance_to_party_from_party, ":party_distance", ":party_no", ":center_no"),
##        (lt, ":party_distance", ":min_distance"),
##        (assign, ":min_distance", ":party_distance"),
##        (assign, ":result", ":center_no"),
##      (try_end),
##      (assign, reg0, ":result"),
##  ]),


  # script_let_nearby_parties_join_current_battle
  # Input: arg1 = besiege_mode, arg2 = dont_add_friends_other_than_accompanying
  # Output: none
  ("let_nearby_parties_join_current_battle",
    [
      (store_script_param, ":besiege_mode", 1),
      (store_script_param, ":dont_add_friends_other_than_accompanying", 2),

      (store_character_level, ":player_level", "trp_player"),
      (try_for_parties, ":party_no"),
        (party_is_active, ":party_no"),
        (party_get_battle_opponent, ":opponent",":party_no"),
        (lt, ":opponent", 0), #party is not itself involved in a battle
        (party_get_attached_to, ":attached_to",":party_no"),
        (lt, ":attached_to", 0), #party is not attached to another party
        (get_party_ai_behavior, ":behavior", ":party_no"),
        (neq, ":behavior", ai_bhvr_in_town),

        (party_stack_get_troop_id, ":stack_troop", ":party_no", 0),
        (party_get_template_id,":template_id",":party_no"),
        #SB : exclude certain templates, quest, prisoners/routers
        (neq, ":template_id", "pt_troublesome_bandits"),
        (neq, ":template_id", "pt_bandits_awaiting_ransom"),
        (neq, ":template_id", "pt_rescued_prisoners"),
        (neq, ":template_id", "pt_routed_warriors"),

        (try_begin),
          (this_or_next|is_between, ":stack_troop", "trp_looter", bandits_end),
          (is_between, ":template_id", bandit_party_templates_begin, bandit_party_templates_end), #SB : template range
          (assign, ":is_bandit", 1),
        (else_try),
          (assign, ":is_bandit", 0),
        (try_end),
        (game_get_reduce_campaign_ai, ":join_sub"), #easier = smaller distance bandits
        (try_begin),#Native behaviour
          (eq, "$g_dplmc_terrain_advantage", DPLMC_TERRAIN_ADVANTAGE_DISABLE),
          (try_begin),
            (eq, ":is_bandit", 1),
            (assign, ":join_distance", 5), #day/not bandit
            (try_begin),
              (is_currently_night),
              (assign, ":join_distance", 3), #nigh/not bandit
            (try_end),
          (else_try),
            (assign, ":join_distance", 3), #day/bandit
            (try_begin),
              (is_currently_night),
              (assign, ":join_distance", 2), #night/bandit
            (try_end),
          (try_end),
        (else_try), #SB : new distance calculation, based on spotting
          (party_get_skill_level, ":join_distance", ":party_no", "skl_spotting"), #Native lords have none
          (val_div, ":join_distance", 3),
          (val_add, ":join_distance", 4), #from 4 to 7
          (try_begin), #global night deduction
            (is_currently_night),
            (val_sub, ":join_distance", 2), #night/not bandit
          (try_end),
          (try_begin),
            (eq, ":is_bandit", 1),
            (val_sub, ":join_distance", 1), #day/bandit, value of 3
            (val_sub, ":join_distance", ":join_sub"), #can reduce it down to 1 on easy mode
            (is_currently_night), #night/bandit
            (val_add, ":join_distance", 1), #less sharp penalty, value of 2
          (try_end),
          #booster to patrols etc. that makes up for new base of 4
          (try_begin),
            (eq, ":template_id", "pt_patrol_party"),
            (val_add, ":join_distance", 1), #always true
            (try_begin),
              (get_party_ai_object, ":obj", ":party_no"),#just in case
              (eq, ":behavior", ai_bhvr_escort_party),
              (eq, ":obj", "p_main_party"),
              (val_add, ":join_distance", ":join_sub"),#they stray off easily
            (try_end),
          # (else_try), #other behaviour score
            # (eq, ":behavior", ai_bhvr_avoid_party), #fleeing
            # (val_sub, ":join_distance", 1),
          (else_try), #representing preparedness to join battle
            (this_or_next|eq, ":behavior", ai_bhvr_patrol_party),
            (this_or_next|eq, ":behavior", ai_bhvr_patrol_location),
            (eq, ":behavior", ai_bhvr_escort_party),
            (val_add, ":join_distance", 1),
          (try_end),
        (try_end),


		# #Quest bandits do not join battle
		# (this_or_next|neg|check_quest_active, "qst_track_down_bandits"),
			# (neg|quest_slot_eq, "qst_track_down_bandits", slot_quest_target_party, ":party_no"),
		# (this_or_next|neg|check_quest_active, "qst_troublesome_bandits"),
			# (neg|quest_slot_eq, "qst_troublesome_bandits", slot_quest_target_party, ":party_no"),



        (store_distance_to_party_from_party, ":distance", ":party_no", "p_main_party"),
        (lt, ":distance", ":join_distance"),

        (store_faction_of_party, ":faction_no", ":party_no"),
        (store_faction_of_party, ":enemy_faction", "$g_enemy_party"),
        (try_begin),
          (eq, ":faction_no", "fac_player_supporters_faction"),
          (assign, ":reln_with_player", 100),
        (else_try),
          (store_relation, ":reln_with_player", ":faction_no", "fac_player_supporters_faction"),
        (try_end),
        (try_begin),
          (eq, ":faction_no", ":enemy_faction"),
          (assign, ":reln_with_enemy", 100),
        (else_try),
          (store_relation, ":reln_with_enemy", ":faction_no", ":enemy_faction"),
        (try_end),

        (assign, ":enemy_side", 1),
        (try_begin),
          (neq, "$g_enemy_party", "$g_encountered_party"),
          (assign, ":enemy_side", 2),
        (try_end),

        (try_begin),
          (eq, ":besiege_mode", 0),
          (lt, ":reln_with_player", 0),
          (gt, ":reln_with_enemy", 0),
          ##zerilius changes begin
          ##wrong use of operation (native bug)
          #(party_get_slot, ":party_type", ":party_no"),
          (party_get_slot, ":party_type", ":party_no", slot_party_type),
          ##zerilius changes end

          (assign, ":enemy_is_bandit_party_and_level_is_greater_than_6", 0),
          (try_begin), #SB : is_bandit
            # (party_stack_get_troop_id, ":stack_troop", ":party_no", 0),
            # (is_between, ":stack_troop", "trp_looter", "trp_black_khergit_horseman"),
            (eq, ":is_bandit", 1),
            (gt, ":player_level", 6),
            (assign, ":enemy_is_bandit_party_and_level_is_greater_than_6", 1),
          (try_end),

          (this_or_next|eq, ":party_type", spt_kingdom_hero_party),
          (eq, ":enemy_is_bandit_party_and_level_is_greater_than_6", 1),

          (get_party_ai_behavior, ":ai_bhvr", ":party_no"),
          (neq, ":ai_bhvr", ai_bhvr_avoid_party),
          (party_quick_attach_to_current_battle, ":party_no", ":enemy_side"), #attach as enemy
          (str_store_party_name, s1, ":party_no"),
          #SB : colorize
          (display_message, "str_s1_joined_battle_enemy", message_negative),
        (else_try),
          (try_begin),
            (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
            (party_slot_eq, ":party_no", slot_party_ai_object, "trp_player"),
            (assign, ":party_is_accompanying_player", 1),
          (else_try),
            (assign, ":party_is_accompanying_player", 0),
          (try_end),

          (this_or_next|eq, ":dont_add_friends_other_than_accompanying", 0),
          (eq, ":party_is_accompanying_player", 1),
          (gt, ":reln_with_player", 0),
          (lt, ":reln_with_enemy", 0),

          (assign, ":following_player", 0),
          (try_begin),
            (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
            (party_slot_eq, ":party_no", slot_party_ai_object, "p_main_party"),
            (assign, ":following_player", 1),
          (try_end),

          (assign, ":do_join", 1),
          (try_begin),
            (eq, ":besiege_mode", 1),
            (eq, ":following_player", 0),
            (assign, ":do_join", 0),
            (eq, ":faction_no", "$players_kingdom"),
            (faction_slot_eq, "$players_kingdom", slot_faction_marshall, "trp_player"),
            (assign, ":do_join", 1),
          (try_end),
          (eq, ":do_join", 1),

          ##zerilius changes begin
          ##wrong use of operation (native bug)
          #(party_get_slot, ":party_type", ":party_no"),
          (party_get_slot, ":party_type", ":party_no", slot_party_type),
          ##zerilius changes end
          (this_or_next|eq, ":party_type", spt_kingdom_hero_party), #dckplmc
          (eq, ":template_id", "pt_hero_party"),
          (party_stack_get_troop_id, ":leader", ":party_no", 0),
          #(troop_get_slot, ":player_relation", ":leader", slot_troop_player_relation),
          (call_script, "script_troop_get_player_relation", ":leader"),
          (assign, ":player_relation", reg0),

          (assign, ":join_even_you_do_not_like_player", 0),
          (try_begin),
            (faction_slot_eq, "$players_kingdom", slot_faction_marshall, "trp_player"), #new added, if player is marshal and if he is accompanying then join battle even lord do not like player
            (eq, ":following_player", 1),
            (assign, ":join_even_you_do_not_like_player", 1),
          ##diplomacy start+
	  #Affiliates will assist the player.
	   (else_try),
             (lt, ":player_relation", 0),
	     (call_script, "script_dplmc_is_affiliated_family_member", ":leader"),
	     (val_max, ":player_relation", reg0),
          ##diplomacy end+
          (try_end),

          (this_or_next|ge, ":player_relation", 0),
          (eq, ":join_even_you_do_not_like_player", 1),

          (party_quick_attach_to_current_battle, ":party_no", 0), #attach as friend
          (str_store_party_name, s1, ":party_no"),
          # ## SB : colorize
          # (faction_get_color, ":color", ":faction_no"),
          (display_message, "str_s1_joined_battle_friend", message_positive),

          (troop_get_slot, ":limit", "$g_player_troop", slot_troop_renown),
          (val_sub, ":limit", dplmc_command_renown_limit),
          (game_get_reduce_campaign_ai, ":bonus"),
          (val_mul, ":bonus", "$player_right_to_rule"),
          (val_add, ":limit", ":bonus"),

          (assign, ":continue", -1), #by default, not under command

          (try_begin), #under command if marshal
            (eq, ":faction_no", "$players_kingdom"),
            (troop_slot_eq, ":leader", slot_troop_occupation, slto_kingdom_hero),
            (try_begin), #as marshal
               # (is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
               # (faction_slot_eq, "$players_kingdom", slot_faction_marshall, "trp_player"),
               # (assign, ":continue", 0),
            # (else_try), #as ruler/pretender marshal
               # (faction_slot_eq, ":party_faction", slot_faction_state, sfs_active),
               (call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", ":faction_no"),
               (ge, reg0, DPLMC_FACTION_STANDING_MARSHALL),

               (display_message, "@marshall {reg0}"),
               # (this_or_next|faction_slot_eq, ":party_faction", slot_faction_marshall, "trp_player"),
               # (faction_slot_eq, ":party_faction", slot_faction_leader, "$g_player_troop"),
               (assign, ":continue", 0),
            (try_end),
            (eq, ":continue", -1), #If still not satisfied, check other conditions
          (else_try), #or high enough renown
            (troop_slot_eq, ":leader", slot_troop_occupation, slto_kingdom_hero),
            (troop_get_slot, ":renown", ":leader", slot_troop_renown),
            (call_script, "script_troop_get_relation_with_troop", ":leader", "$g_player_troop"),
            (val_sub, ":renown", reg0), #higher relation means less renown needed.
            (le, ":renown", ":limit"),

            (assign, ":continue", 0),
          (else_try), #straggler parties - patrols, caravans, etc.
            (neg|is_between, ":leader", active_npcs_begin, active_npcs_end),

            (assign, ":continue", 0),
          (try_end),
          (party_set_slot, ":party_no", slot_party_temp_slot_1, ":continue"),
          (try_begin),
            (ge, "$cheat_mode", 1),
            (assign, reg0, ":continue"),
            # (str_store_party_name, s0, ":party_no"),
            (str_store_party_name, s0, ":party_no"),
            (faction_get_color, ":color", ":faction_no"),
            (display_message, "@{s0} will {reg0?not :}be under your command", ":color"),
          (try_end),

        (try_end),
      (try_end),
  ]),

  # script_party_wound_all_members_aux
  # Input: arg1 = party_no
  ("party_wound_all_members_aux",
    [
      (store_script_param_1, ":party_no"),

      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
          (party_wound_members, ":party_no", ":stack_troop", ":stack_size"),
        (else_try),
          (troop_set_health, ":stack_troop", 0),
        (try_end),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":party_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":party_no", ":attached_party_rank"),
        (call_script, "script_party_wound_all_members_aux", ":attached_party"),
      (try_end),
  ]),

  # script_party_wound_all_members
  # Input: arg1 = party_no
  ("party_wound_all_members",
    [
      (store_script_param_1, ":party_no"),

      (call_script, "script_party_wound_all_members_aux", ":party_no"),
  ]),



  # script_calculate_battle_advantage
  # Output: reg0 = battle advantage
  ("calculate_battle_advantage",
    [
      (call_script, "script_party_count_fit_for_battle", "p_collective_friends"),
      (assign, ":friend_count", reg(0)),

      (party_get_skill_level, ":player_party_tactics",  "p_main_party", skl_tactics),
      (party_get_skill_level, ":ally_party_tactics",  "p_collective_friends", skl_tactics),
      (val_max, ":player_party_tactics", ":ally_party_tactics"),

      (call_script, "script_party_count_fit_for_battle", "p_collective_enemy"),
      (assign, ":enemy_count", reg(0)),

      (party_get_skill_level, ":enemy_party_tactics",  "p_collective_enemy", skl_tactics),

      (val_add, ":friend_count", 1),
      (val_add, ":enemy_count", 1),

      (try_begin),
        (ge, ":friend_count", ":enemy_count"),
        (val_mul, ":friend_count", 100),
        (store_div, ":ratio", ":friend_count", ":enemy_count"),
        (store_sub, ":raw_advantage", ":ratio", 100),
      (else_try),
        (val_mul, ":enemy_count", 100),
        (store_div, ":ratio", ":enemy_count", ":friend_count"),
        (store_sub, ":raw_advantage", 100, ":ratio"),
      (try_end),
      (val_mul, ":raw_advantage", 2),

      (val_mul, ":player_party_tactics", 30),
      (val_mul, ":enemy_party_tactics", 30),
      (val_add, ":raw_advantage", ":player_party_tactics"),
      (val_sub, ":raw_advantage", ":enemy_party_tactics"),
      (val_div, ":raw_advantage", 100),


      (assign, reg0, ":raw_advantage"),
      (display_message, "@Battle Advantage = {reg0}.", 0xFFFFFFFF),
  ]),


  # script_cf_check_enemies_nearby
  # Input: none
  # Output: none, fails when enemies are nearby
  ("cf_check_enemies_nearby",
    [
      (get_player_agent_no, ":player_agent"),
      (agent_is_alive, ":player_agent"),
      (agent_get_position, pos1, ":player_agent"),
      (assign, ":result", 0),
      (set_fixed_point_multiplier, 100),
      (try_for_agents,":cur_agent"),
        (neq, ":cur_agent", ":player_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (neg|agent_is_ally, ":cur_agent"),
        (agent_get_position, pos2, ":cur_agent"),
        (get_distance_between_positions, ":cur_distance", pos1, pos2),
        (le, ":cur_distance", 1500), #15 meters
        (assign, ":result", 1),
      (try_end),
      (eq, ":result", 0),
  ]),

  # script_get_heroes_attached_to_center_aux
  # For internal use only
  ("get_heroes_attached_to_center_aux",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_get_num_companion_stacks, ":num_stacks",":center_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":center_no",":i_stack"),
        (troop_is_hero, ":stack_troop"),
        (party_add_members, ":party_no_to_collect_heroes", ":stack_troop", 1),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":center_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":center_no", ":attached_party_rank"),
        (call_script, "script_get_heroes_attached_to_center_aux", ":attached_party", ":party_no_to_collect_heroes"),
      (try_end),
  ]),

  # script_get_heroes_attached_to_center
  # Input: arg1 = center_no, arg2 = party_no_to_collect_heroes
  # Output: none, adds heroes to the party_no_to_collect_heroes party
  ("get_heroes_attached_to_center",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_clear, ":party_no_to_collect_heroes"),
      (call_script, "script_get_heroes_attached_to_center_aux", ":center_no", ":party_no_to_collect_heroes"),

#rebellion changes begin -Arma
     (try_for_range, ":pretender", pretenders_begin, pretenders_end),
        (neq, ":pretender", "$supported_pretender"),
        (troop_slot_eq, ":pretender", slot_troop_cur_center, ":center_no"),
        (party_add_members, ":party_no_to_collect_heroes", ":pretender", 1),
     (try_end),

#     (try_for_range, ":rebel_faction", rebel_factions_begin, rebel_factions_end),
#        (faction_slot_eq, ":rebel_faction", slot_faction_state, sfs_inactive_rebellion),
#        (faction_slot_eq, ":rebel_faction", slot_faction_inactive_leader_location, ":center_no"),
#        (faction_get_slot, ":pretender", ":rebel_faction", slot_faction_leader),
#        (party_add_members, ":party_no_to_collect_heroes", ":pretender", 1),
#     (try_end),
#rebellion changes end


  ]),


  # script_get_heroes_attached_to_center_as_prisoner_aux
  # For internal use only
  ("get_heroes_attached_to_center_as_prisoner_aux",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_get_num_prisoner_stacks, ":num_stacks",":center_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_prisoner_stack_get_troop_id, ":stack_troop",":center_no",":i_stack"),
        (troop_is_hero, ":stack_troop"),
        (party_add_members, ":party_no_to_collect_heroes", ":stack_troop", 1),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":center_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":center_no", ":attached_party_rank"),
        (call_script, "script_get_heroes_attached_to_center_as_prisoner_aux", ":attached_party", ":party_no_to_collect_heroes"),
      (try_end),
  ]),


  # script_get_heroes_attached_to_center_as_prisoner
  # Input: arg1 = center_no, arg2 = party_no_to_collect_heroes
  # Output: none, adds heroes to the party_no_to_collect_heroes party
  ("get_heroes_attached_to_center_as_prisoner",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_clear, ":party_no_to_collect_heroes"),
      (call_script, "script_get_heroes_attached_to_center_as_prisoner_aux", ":center_no", ":party_no_to_collect_heroes"),
  ]),

##
##  # script_cf_get_party_leader
##  # Input: arg1 = party_no
##  # Output: reg0 = troop_no of the leader (Can fail)
##  ("cf_get_party_leader",
##    [
##      (store_script_param_1, ":party_no"),
##
##      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
##      (gt, ":num_stacks", 0),
##      (party_stack_get_troop_id, ":stack_troop", ":party_no", 0),
##      (troop_is_hero, ":stack_troop"),
##      (assign, reg0, ":stack_troop"),
##  ]),

  # script_give_center_to_faction
  # Input: arg1 = center_no, arg2 = faction
  ("give_center_to_faction",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":faction_no"),

      ##diplomacy begin
      (party_set_slot, ":center_no", dplmc_slot_center_taxation, 0),
      (try_begin),
        (party_slot_eq, ":center_no", slot_village_infested_by_bandits, "trp_peasant_woman"),
        (party_set_slot, ":center_no", slot_village_infested_by_bandits, 0),
      (try_end),
      (try_begin),
        (eq, "$g_constable_training_center", ":center_no"),
        (assign, "$g_constable_training_center", -1),
      (try_end),
      ##diplomacy end
      (try_begin),
        (eq, ":faction_no", "fac_player_supporters_faction"),
        (faction_get_slot, ":player_faction_king", "fac_player_supporters_faction", slot_faction_leader),
        (eq, ":player_faction_king", "trp_player"),

        (try_begin),
          (is_between, ":center_no", walled_centers_begin, walled_centers_end),
          (assign, ":number_of_walled_centers_players_kingdom_has", 1),
        (else_try),
          (assign, ":number_of_walled_centers_players_kingdom_has", 0),
        (try_end),

        (try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
          (store_faction_of_party, ":owner_faction_no", ":walled_center"),
          (eq, ":owner_faction_no", "fac_player_supporters_faction"),
          (val_add, ":number_of_walled_centers_players_kingdom_has", 1),
        (try_end),

        (ge, ":number_of_walled_centers_players_kingdom_has", 10),
        (unlock_achievement, ACHIEVEMENT_VICTUM_SEQUENS),
      (try_end),

      (try_begin),
        (check_quest_active, "qst_join_siege_with_army"),
        (quest_slot_eq, "qst_join_siege_with_army", slot_quest_target_center, ":center_no"),
        (call_script, "script_abort_quest", "qst_join_siege_with_army", 0),
        #Reactivating follow army quest
        (faction_get_slot, ":faction_marshall", "$players_kingdom", slot_faction_marshall),
        (str_store_troop_name_link, s9, ":faction_marshall"),
        (setup_quest_text, "qst_follow_army"),
        (str_store_string, s2, "@{s9} wants you to resume following his army until further notice."),
        (call_script, "script_start_quest", "qst_follow_army", ":faction_marshall"),
        (assign, "$g_player_follow_army_warnings", 0),
      (try_end),

      #(store_faction_of_party, ":old_faction", ":center_no"),
      (call_script, "script_give_center_to_faction_aux", ":center_no", ":faction_no"),
      (call_script, "script_update_village_market_towns"),

      (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
        (call_script, "script_faction_recalculate_strength", ":cur_faction"),
      (try_end),
      (assign, "$g_recalculate_ais", 1),

	  (try_begin),
        (eq, ":faction_no", "fac_player_supporters_faction"),
		(faction_slot_eq, "fac_player_supporters_faction", slot_faction_state, sfs_inactive),
		(call_script, "script_activate_player_faction", "trp_player"),
	  (try_end),

      #(call_script, "script_activate_deactivate_player_faction", ":old_faction"),
      #(try_begin),
      #(eq, ":faction_no", "fac_player_supporters_faction"),
      #(faction_slot_eq, "fac_player_supporters_faction", slot_faction_leader, "trp_player"),
      #(call_script, "script_give_center_to_lord", ":center_no", "trp_player", 0),

      #check with Armagan -- what is this here for?
      #(try_for_range, ":cur_village", villages_begin, villages_end),
      #(store_faction_of_party, ":cur_village_faction", ":cur_village"),
      #(eq, ":cur_village_faction", "fac_player_supporters_faction"),
      #(neg|party_slot_eq, ":cur_village", slot_town_lord, "trp_player"),
      #(call_script, "script_give_center_to_lord", ":cur_village", "trp_player", 0),
      #(try_end),
      #(try_end),
    ]),

  # script_give_center_to_faction_aux
  # Input: arg1 = center_no, arg2 = faction
  ("give_center_to_faction_aux",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":faction_no"),

      (store_faction_of_party, ":old_faction", ":center_no"),
      (party_set_faction, ":center_no", ":faction_no"),

      (try_begin),
        (party_slot_eq, ":center_no", slot_party_type, spt_village),
        (try_begin),
          (party_get_slot, ":farmer_party", ":center_no", slot_village_farmer_party),
          (gt, ":farmer_party", 0),
          (party_is_active, ":farmer_party"),
          (party_set_faction, ":farmer_party", ":faction_no"),
        (try_end),
        #SB : reinforcements becomes deserters
        (try_begin),
          (party_get_slot, ":reinf_party", ":center_no", slot_village_reinforcement_party),
          (gt, ":reinf_party", 0),
          (party_is_active, ":reinf_party"),
          (set_spawn_radius, 0),
          (spawn_around_party, ":reinf_party", "pt_deserters"),
          (assign, ":new_party", reg0),
          #apply move_members_with_ratio, party_inflict_attrition, party_inflict_casualties, etc based on center relations/prosperity
          (call_script, "script_party_add_party", ":new_party", ":reinf_party"),
          (party_set_slot, ":center_no", slot_village_reinforcement_party, -1),
          (party_set_ai_behavior, ":new_party", ai_bhvr_patrol_party),
          (party_set_ai_object, ":new_party", ":center_no"), #or its market town
          (party_set_ai_patrol_radius, ":new_party", 25),
          (remove_party, ":reinf_party"),
        (try_end),
      (try_end),

      (try_begin),
	    #This bit of seemingly redundant code (the neq condition) is designed to prevent a bug that occurs when a player first conquers a center -- apparently this script is called again AFTER it is handed to a lord
		#Without this line, then the player's dialog selection does not have any affect, because town_lord is set again to stl_unassigned after the player makes his or her choice
	    (neq, ":faction_no", ":old_faction"),
		##diplomacy start+
		(party_get_slot, ":old_ex_faction", ":center_no", slot_center_ex_faction),
		##diplomacy end+
        (party_set_slot, ":center_no", slot_center_ex_faction, ":old_faction"),
        (party_get_slot, ":old_town_lord", ":center_no", slot_town_lord),
		##diplomacy start+
		(store_current_hours, ":hours"),
		(party_get_slot, ":old_ex_lord", ":center_no", dplmc_slot_center_ex_lord),
		#(party_get_slot, ":old_last_transfer", ":center_no", dplmc_slot_center_last_transfer_time),
		(try_begin),
			#When a faction regains a lost fief, if the ex-lord is a member of that faction,
			#don't erase that information.
			(this_or_next|party_slot_eq, ":center_no", slot_center_original_faction, ":faction_no"),#Handle several rapid sequential transfers
				(eq, ":old_ex_faction", ":faction_no"),
			(is_between, ":old_ex_lord", heroes_begin, heroes_end),
			(store_faction_of_troop, ":old_ex_lord_faction", ":old_ex_lord"),
			(eq, ":old_ex_lord_faction", ":faction_no"),
		(else_try),
			#Otherwise, if the center had a lord before this transfer, set the
			#ex-lord to the lord losing this.
			(neq, ":old_town_lord", stl_unassigned),
			(ge, ":old_town_lord", 0),
			(this_or_next|ge, ":old_town_lord", 1),#Don't apply to the player at the start of the game
				(gt, ":hours", 0),

			#Don't apply to fiefs lost by the faction leader, except for his "home",
			#and any fiefs with him marked as the original lord.
			(call_script, "script_dplmc_get_troop_standing_in_faction", ":old_town_lord", ":old_faction"),
			(this_or_next|lt, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
			(this_or_next|troop_slot_eq, ":old_faction", slot_troop_home, ":center_no"),
				(party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":old_town_lord"),

			(party_set_slot, ":center_no", dplmc_slot_center_ex_lord, ":old_town_lord"),
		(try_end),
        (party_set_slot, ":center_no", dplmc_slot_center_last_transfer_time, ":hours"),
        (party_set_slot, ":center_no", slot_town_lord, stl_unassigned),
        (party_set_banner_icon, ":center_no", 0),#Removing banner
        (call_script, "script_update_faction_notes", ":old_faction"),
        #Invalidate old lord's cached center points
        (gt, ":old_town_lord", -1),
        (troop_set_slot, ":old_town_lord", dplmc_slot_troop_center_points_plus_one, 0),
      (try_end),

      (call_script, "script_update_faction_notes", ":faction_no"),
      (call_script, "script_update_center_notes", ":center_no"),

      (try_begin),
        (ge, ":old_town_lord", 0),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (call_script, "script_update_troop_notes", ":old_town_lord"),
      (try_end),

      (try_for_range, ":other_center", centers_begin, centers_end),
        (party_slot_eq, ":other_center", slot_village_bound_center, ":center_no"),
        ##diplomacy start+ Avoid infinite recursion even if some foolish modder (such as myself)
        #has set up bizarre cyclic dependencies
        (store_faction_of_party, ":other_center_faction", ":other_center"),
        ##The "this or next" is so that any weird uses of this function
        ##in Native (to change something to its own faction) will be
        ##replicated.  The reason this works is that all villages have
        ##higher ID numbers than castles or towns.
        (this_or_next|gt, ":other_center", ":center_no"),
        (neq, ":other_center_faction", ":old_faction"),
        ##diplomacy end+
        (call_script, "script_give_center_to_faction_aux", ":other_center", ":faction_no"),
      (try_end),
  ]),

  # script_change_troop_faction
  # Input: arg1 = troop_no, arg2 = faction
  ("change_troop_faction",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":faction_no"),
      (try_begin),
        #Reactivating inactive or defeated faction
        (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        (neg|faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
        (faction_set_slot, ":faction_no", slot_faction_state, sfs_active),
        #(call_script, "script_store_average_center_value_per_faction"),
      (try_end),

	  #Political ramifications
	  (store_faction_of_troop, ":orig_faction", ":troop_no"),
	  ##diplomacy start+ save these for reference
	  #(faction_get_slot, ":orig_faction_leader", ":orig_faction", slot_faction_leader),
	  (faction_get_slot, ":new_faction_leader", ":faction_no", slot_faction_leader),
	  (try_begin),
		  #Avoid letting heroes get stuck as slto_inactive if petitioners switch away from the player's faction
		  (eq, ":orig_faction", "fac_player_supporters_faction"),
	     (gt, ":troop_no", 0),
	     (troop_is_hero, ":troop_no"),
		  (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_inactive),
		  (this_or_next|is_between, ":troop_no", lords_begin, lords_end),
		  (this_or_next|is_between, ":troop_no", kings_begin, kings_end),
		  (this_or_next|is_between, ":troop_no", pretenders_begin, pretenders_end),
		  (this_or_next|troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_granted_fief),
		     (troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_lord_rejoined),
		  (troop_set_slot, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
	  (try_end),
	  ##diplomacy end+

	  #remove if he is marshal
	  (try_begin),
		(faction_slot_eq, ":orig_faction", slot_faction_marshall, ":troop_no"),
        (call_script, "script_check_and_finish_active_army_quests_for_faction", ":orig_faction"),

		#No current issue on the agenda
		(try_begin),
			(faction_slot_eq, ":orig_faction", slot_faction_political_issue, 0),

			(faction_set_slot, ":orig_faction", slot_faction_political_issue, 1), #Appointment of marshal
			(store_current_hours, ":hours"),
			(val_max, ":hours", 0),
			(faction_set_slot, ":orig_faction", slot_faction_political_issue_time, ":hours"), #Appointment of marshal
			##diplomacy start+ Reset political stance for kingdom ladies as well
			#(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),##OLD
			(try_for_range, ":active_npc", heroes_begin, heroes_end),##NEW
			##diplomacy end+
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":orig_faction"),
				(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
			(try_end),
			(try_begin),
				(eq, "$players_kingdom", ":orig_faction"),
				(troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),
			(try_end),
		(try_end),

        (try_begin),
		  (troop_get_slot, ":old_marshall_party", ":troop_no", slot_troop_leaded_party),
          (party_is_active, ":old_marshall_party"),
          (party_set_marshal, ":old_marshall_party", 0),
        (try_end),

		(faction_set_slot, ":orig_faction", slot_faction_marshall, -1),
	  (try_end),
	  #Removal as marshal ends

	  #Other political ramifications
	  (troop_set_slot, ":troop_no", slot_troop_stance_on_faction_issue, -1),
	  ##diplomacy start+ Support promoted kingdom ladies
	  #(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
	  (try_for_range, ":active_npc", heroes_begin, heroes_end),
	  ##diplomacy end+
		(troop_slot_eq, ":active_npc", slot_troop_stance_on_faction_issue, ":troop_no"),
		(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
	  (try_end),
	  #Political ramifications end


		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":troop_no"),
			(display_message, "@{!}DEBUG - {s4} faction changed in normal faction change"),
		(try_end),

      (troop_set_faction, ":troop_no", ":faction_no"),
	  ##diplomacy start+
	  ##Don't give lords amnesia about what the player said to recruit them.
	  ##OLD:
      #(troop_set_slot, ":troop_no", slot_troop_recruitment_random, 0),
      #(troop_set_slot, ":troop_no", slot_lord_recruitment_argument, 0),
      #(troop_set_slot, ":troop_no", slot_lord_recruitment_candidate, 0),
      #(troop_set_slot, ":troop_no", slot_troop_promised_fief, 0),
	  ##NEW
	  (try_begin),
		 (eq, ":troop_no", "trp_player"),
		 #Don't change of this for the player.
	  (else_try),
	    (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
		 (this_or_next|eq, ":faction_no", "fac_player_supporters_faction"),
			(eq, ":faction_no", "$players_kingdom"),
		 (ge, ":new_faction_leader", 0),
		 (this_or_next|eq, ":faction_no", "fac_player_supporters_faction"),
		 (this_or_next|eq, ":new_faction_leader", "trp_player"),
		 (this_or_next|troop_slot_eq, ":new_faction_leader", slot_troop_spouse, "trp_player"),
			(troop_slot_eq, "trp_player", slot_troop_spouse, ":new_faction_leader"),
		 #Joined faction that player is ruler or co-ruler of.  Don't forget
		 #any promises received.
		 (troop_set_slot, ":troop_no", slot_troop_recruitment_random, 0),
	  (else_try),
	     #Joined a new faction.  Previous promises moot.
		 (troop_set_slot, ":troop_no", slot_troop_recruitment_random, 0),
		 (troop_set_slot, ":troop_no", slot_lord_recruitment_argument, 0),
		 (troop_set_slot, ":troop_no", slot_lord_recruitment_candidate, 0),
		 (troop_set_slot, ":troop_no", slot_troop_promised_fief, 0),
	  (try_end),
	  ##diplomacy end+

      #Give new title
      # (call_script, "script_troop_set_title_according_to_faction", ":troop_no", ":faction_no"), moved down

      (try_begin),
        (this_or_next|eq, ":faction_no", "$players_kingdom"),
        (eq, ":faction_no", "fac_player_supporters_faction"),
        (call_script, "script_check_concilio_calradi_achievement"),
      (try_end),

	  #Takes walled centers and dependent villages with him
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
        (party_set_faction, ":center_no", ":faction_no"),
        (try_for_range, ":village_no", villages_begin, villages_end),
          (party_slot_eq, ":village_no", slot_village_bound_center, ":center_no"),
          (party_set_faction, ":village_no", ":faction_no"),
          (party_get_slot, ":farmer_party_no", ":village_no", slot_village_farmer_party),
          (try_begin),
            (gt, ":farmer_party_no", 0),
            (party_is_active, ":farmer_party_no"),
            (party_set_faction, ":farmer_party_no", ":faction_no"),
          (try_end),
          (try_begin),
            (party_get_slot, ":old_town_lord", ":village_no", slot_town_lord),
            (neq, ":old_town_lord", ":troop_no"),
            (party_set_slot, ":village_no", slot_town_lord, stl_unassigned),
            ##diplomacy start+ Invalidate old lord's cached center points
            (gt, ":old_town_lord", -1),
            (troop_set_slot, ":old_town_lord", dplmc_slot_troop_center_points_plus_one, 0),
            ##diplomacy end+
          (try_end),
        (try_end),
      (try_end),

	  #Dependant kingdom ladies switch faction
	  (try_for_range, ":kingdom_lady", kingdom_ladies_begin, kingdom_ladies_end),
		##diplomacy start+ This is required if kingdom ladies can be promoted to other roles
        (this_or_next|troop_slot_eq, ":kingdom_lady", slot_troop_occupation, 0),#for prisoners
		   (troop_slot_eq, ":kingdom_lady", slot_troop_occupation, slto_kingdom_lady),
		(store_faction_of_troop, reg0, ":kingdom_lady"),
		(this_or_next|eq, reg0, ":orig_faction"),
		(neg|faction_slot_eq, reg0, slot_faction_state, sfs_active),
		##diplomacy end+
		(call_script, "script_get_kingdom_lady_social_determinants", ":kingdom_lady"),
		(assign, ":closest_male_relative", reg0),
		(assign, ":new_center", reg1),

		(eq, ":closest_male_relative", ":troop_no"),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":kingdom_lady"),
			(display_message, "@{!}DEBUG - {s4} faction changed by guardian moving"),
		(try_end),

		(troop_set_faction, ":kingdom_lady", ":faction_no"),
        (call_script, "script_troop_set_title_according_to_faction", ":kingdom_lady", ":faction_no"),
		(troop_slot_eq, ":kingdom_lady", slot_troop_prisoner_of_party, -1),
		(troop_set_slot, ":kingdom_lady", slot_troop_cur_center, ":new_center"),
	  (try_end),

      #Give new title
      (call_script, "script_troop_set_title_according_to_faction", ":troop_no", ":faction_no"), #moved from top

	  #Remove his control over villages under another fortress
      (try_for_range, ":village_no", villages_begin, villages_end),
        (party_slot_eq, ":village_no", slot_town_lord, ":troop_no"),
        (store_faction_of_party, ":village_faction", ":village_no"),
        (try_begin),
          (neq, ":village_faction", ":faction_no"),
          (party_set_slot, ":village_no", slot_town_lord, stl_unassigned),
          ##diplomacy start+ invalidate cached center points
          (gt, ":old_town_lord", -1),
          (troop_set_slot, ":troop_no", dplmc_slot_troop_center_points_plus_one, 0),
          ##diplomacy end+
        (try_end),
      (try_end),

	  #Free prisoners
      (try_begin),
        (troop_get_slot, ":leaded_party", ":troop_no", slot_troop_leaded_party),
        (gt, ":leaded_party", 0),
        (party_set_faction, ":leaded_party", ":faction_no"),
        (party_get_num_prisoner_stacks, ":num_stacks", ":leaded_party"),
        (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
          (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":leaded_party", ":troop_iterator"),
          (store_troop_faction, ":cur_faction", ":cur_troop_id"),
          (troop_is_hero, ":cur_troop_id"),
          (eq, ":cur_faction", ":faction_no"),
          (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),
          (party_remove_prisoners, ":leaded_party", ":cur_troop_id", 1),
        (try_end),
      (try_end),

	  #Annull all quests of which the lord is giver
	  (try_for_range, ":quest", all_quests_begin, all_quests_end),
		(check_quest_active, ":quest"),
		(quest_slot_eq, ":quest", slot_quest_giver_troop, ":troop_no"),

		(str_store_troop_name, s4, ":troop_no"),
		(try_begin),
		  (eq, "$cheat_mode", 1),
  		  (display_message, "str_s4_changing_sides_aborts_quest"),
        (try_end),
		(call_script, "script_abort_quest", ":quest", 0),
	  (try_end),

	  #Boot all lords out of centers whose faction has changed
	  ##diplomacy start+ add check for promoted kingdom ladies
	  #(try_for_range, ":lord_to_move", active_npcs_begin, active_npcs_end),
	  (try_for_range, ":lord_to_move", heroes_begin, heroes_end),
		 (troop_slot_ge, ":lord_to_move", slot_troop_leaded_party, 1),
	  ##diplomacy end+
		(troop_get_slot, ":lord_led_party", ":lord_to_move", slot_troop_leaded_party),
	    (party_is_active, ":lord_led_party"),
		(party_get_attached_to, ":led_party_attached", ":lord_led_party"),
		(is_between, ":led_party_attached", walled_centers_begin, walled_centers_end),
		(store_faction_of_party, ":led_party_faction", ":lord_led_party"),
		(store_faction_of_party, ":attached_party_faction", ":led_party_attached"),
		(neq, ":led_party_faction", ":attached_party_faction"),

		(party_detach, ":lord_led_party"),
	  (try_end),

	  #Increase relation with lord in new faction by 5
	  #Or, if player kingdom, make inactive pending confirmation
	  (faction_get_slot, ":faction_liege", ":faction_no", slot_faction_leader),
	  (try_begin),
		(eq, ":faction_liege", "trp_player"),
		(neq, ":troop_no", "$g_talk_troop"),
	    (troop_set_slot, ":troop_no", slot_troop_occupation, slto_inactive), #POSSIBLE REASON 1
	  (else_try),
	   ##diplomacy start+ Add support for promoted ladies
		##OLD:
		#(is_between, ":faction_liege", active_npcs_begin, active_npcs_end),
		#(is_between, ":troop_no", active_npcs_begin, active_npcs_end),
		##NEW:
		(is_between, ":faction_liege", heroes_begin, heroes_end),
		(is_between, ":troop_no", heroes_begin, heroes_end),
		##diplomacy end+
		(call_script, "script_troop_change_relation_with_troop", ":faction_liege", ":troop_no", 5),
		(val_add, "$total_indictment_changes", 5),
	  (try_end),

	  #Break courtship relations
	  (try_begin),
	  	(troop_slot_ge, ":troop_no", slot_troop_spouse, 0),
		#Already married, do nothing
	  (else_try),
		(is_between, ":troop_no", active_npcs_begin, active_npcs_end),
		##diplomacy start+
		#Bug fix: don't do this for pretenders.
		(neg|is_between, ":troop_no", kings_begin, kings_end),
		(neg|is_between, ":troop_no", pretenders_begin, pretenders_end),
		##diplomacy end+
	    (try_for_range, ":love_interest_slot", slot_troop_love_interest_1, slot_troop_love_interests_end),
			(troop_get_slot, ":courted_lady", ":troop_no", ":love_interest_slot"),
            ##diplomacy start+ don't call this for bad values
            (is_between, ":courted_lady", kingdom_ladies_begin, kingdom_ladies_end),
            ##diplomacy end+
			(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":courted_lady", ":troop_no"),
	    (try_end),
		##diplomacy start+
		# Don't call this script for married troops / rulers
		#(call_script, "script_assign_troop_love_interests", ":troop_no"),
		(try_begin),
			(neg|troop_slot_ge, ":troop_no", slot_troop_spouse, 0),
			(neg|is_between, ":troop_no", kings_begin, kings_end),
			(neg|is_between, ":troop_no", pretenders_begin, pretenders_end),
			(call_script, "script_assign_troop_love_interests", ":troop_no"),
		(try_end),
		##diplomacy end+
	  (else_try),
		(is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
		(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(try_for_range, ":love_interest_slot", slot_troop_love_interest_1, slot_troop_love_interests_end),
				(troop_slot_eq, ":active_npc", ":love_interest_slot", ":troop_no"),
				(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":troop_no", ":active_npc"),
			(try_end),
		(try_end),
	  (try_end),

	  #Stop raidings/sieges of new faction's fief if there is any
	  (troop_get_slot, ":troop_party", ":troop_no", slot_troop_leaded_party),
	  (try_for_range, ":center_no", centers_begin, centers_end),
	    (party_slot_eq, ":center_no", slot_party_type, spt_village),
	    (party_get_slot, ":raided_by", ":center_no", slot_village_raided_by),
	    (eq, ":raided_by", ":troop_party"),
	    (party_set_slot, ":center_no", slot_village_raided_by, -1),
	    (try_begin),
	      (party_slot_eq, ":center_no", slot_village_state, svs_being_raided),
	      (party_set_slot, ":center_no", slot_village_state, svs_normal),
	      (party_set_extra_text, ":center_no", "str_empty_string"),
	    (try_end),
	  (else_try),
	    (party_get_slot, ":besieged_by", ":center_no", slot_center_is_besieged_by),
	    (eq, ":besieged_by", ":troop_party"),
	    (party_set_slot, ":center_no", slot_center_is_besieged_by, -1),
	    (try_begin),
	      (party_slot_eq, ":center_no", slot_village_state, svs_under_siege),
	      (party_set_slot, ":center_no", slot_village_state, svs_normal),
	      (party_set_extra_text, ":center_no", "str_empty_string"),
	    (try_end),
	  (try_end),

      (call_script, "script_update_all_notes"),

      (call_script, "script_update_village_market_towns"),
      (assign, "$g_recalculate_ais", 1),
      ]),

  # script_troop_set_title_according_to_faction
  # Input: arg1 = troop_no, arg2 = faction_no
  # EDITED FROM NATIVE TO ALLOW CUSTOM PLAYER KINGDOM TITLES
  ("troop_set_title_according_to_faction",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":faction_no", 2),
      ##diplomacy start+
      # OLD CODE:
      #(try_begin),
      #  (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
      #  (str_store_troop_name_plural, s0, ":troop_no"),
      #  (troop_get_type, ":gender", ":troop_no"),
      #  (store_sub, ":title_index", ":faction_no", kingdoms_begin),
      #  (try_begin),
      #    (eq, ":gender", 0), #male
      #    (val_add, ":title_index", kingdom_titles_male_begin),
      #  (else_try),
      #    (val_add, ":title_index", kingdom_titles_female_begin),
      #  (try_end),
      #  (str_store_string, s1, ":title_index"),
      #  (troop_set_name, ":troop_no", s1),
      #  (troop_get_slot, ":troop_party", ":troop_no", slot_troop_leaded_party),
      #  (gt, ":troop_party", 0),
      #  (str_store_troop_name, s5, ":troop_no"),
      #  (party_set_name, ":troop_party", "str_s5_s_party"),
      #(try_end),
      #
      # NEW CODE:
      (assign, ":save_reg0", 0),
      (assign, ":custom_name", 0),
      (try_begin),
	    #Don't do anything when given a bad value.
		 #
		 #We could restrict this further, checking whether the troop is a hero,
		 #or whether it's between heroes_begin and heroes_end, but there are
		 #legitimate reasons a coder may want to run this to get a temporary value,
		 #or use this with temporary heroes, or so forth.
		 #
		 #However, some things are unambiguously errors:
		 (this_or_next|lt, ":troop_no", 0),# At best, the rename operation would fail.
		 (this_or_next|eq, ":troop_no", "trp_heroes_end"),# This is used to store custom titles, so applying a title to this will mess them up.
		 (this_or_next|eq, ":troop_no", "trp_kingdom_heroes_including_player_begin"),#This could easily end up changed due to carelessness
		 #There is also no legitimate reason to try to give the titles to generic soldiers.
		 (is_between, ":troop_no", soldiers_begin, soldiers_end),
	  ##Custom player kingdom vassal titles, credit Caba`drin start
	  #(Updated 2011-04-24, to use Caba`drin's 2011-04-20 bug-fix and update)
	  # See http://forums.taleworlds.com/index.php/topic,148259.0.html
      (else_try),
		(call_script, "script_dplmc_store_troop_is_female", ":troop_no"),#<- dplmc+ altered
		(assign, ":troop_is_female", reg0),
		##Additional alteration start
		#All Rhodok benefactor / custodian NPCs insist on the name "Tribune"
		#Currently this is just Bunduk, but others could be added.
		(try_begin),
			(str_store_troop_name, s1, ":troop_no"),#s1 is overwritten below
			#For dialogue reasons, this should be enabled even when the player
			#is co-ruler of an NPC kingdom.
			(this_or_next|eq, ":faction_no", "fac_player_supporters_faction"),
				(eq, ":faction_no", "$players_kingdom"),
			(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_benefactor),
				(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_custodian),
			(troop_slot_eq, ":troop_no", slot_troop_original_faction, "fac_kingdom_5"),
			(assign, ":is_coruler", 0),
			(try_begin),
				(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
				(faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),
				(gt, ":faction_leader", -1),
				(this_or_next|eq, ":faction_leader", "trp_player"),
				(this_or_next|troop_slot_eq, "trp_player", slot_troop_spouse, ":faction_leader"),
					(troop_slot_eq, ":faction_leader", slot_troop_spouse, "trp_player"),
				(assign, ":is_coruler", 1),
			(try_end),
			(this_or_next|eq, ":is_coruler", 1),
				(eq, ":faction_no", "fac_player_supporters_faction"),
			(str_store_string, s0, "@Tribune"),
			(str_store_troop_name_plural, s1, ":troop_no"),
			(str_store_string, s1, "str_s0_s1"),
		##Additional alteration end
		(else_try),
            (eq, ":faction_no", "fac_player_supporters_faction"),
            #(troop_get_type, ":gender", ":troop_no"),#<- dplmc+ altered (use script for gender instead)
            (try_begin),
              (eq, ":troop_is_female", 0), #male #<- dplmc+ altered
              (troop_slot_eq, "trp_heroes_end", 0, 1),
              (str_store_troop_name, s0, "trp_heroes_end"),
              (str_store_troop_name_plural, s1, ":troop_no"),
              (str_store_string, s1, "str_s0_s1"),
              (assign, ":custom_name", 1),
            (else_try),
              (eq, ":troop_is_female", 1), #slot 0 is potentially unassigned, 'Countess Alayen'
              (troop_slot_eq, "trp_heroes_end", 1, 1),

              #unmarried ladies should retain title
              (assign, ":continue", 0),
              (try_begin),
                  (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
                  (this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
                  (troop_slot_ge, ":troop_no", slot_troop_spouse, 0),
                  (assign, ":continue", 1),
              (else_try),
                  (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
                  (assign, ":continue", 1),
              (try_end),
              (eq, ":continue", 1),

              (str_store_troop_name_plural, s0, "trp_heroes_end"),
              (str_store_troop_name_plural, s1, ":troop_no"),
              (str_store_string, s1, "str_s0_s1"),
              (assign, ":custom_name", 1),
            (try_end),
            (eq, ":custom_name", 1), #So if it fails, will rename normally
        (else_try),
            (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
            (faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),
            ##Additional section begin: add support for player kingdom culture
            (try_begin),
                (eq, ":faction_no", "fac_player_supporters_faction"),
                (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
                (assign, ":faction_no", "$g_player_culture"),#<- Use title from culture if one is set, and not using custom titles
            (try_end),
            ##Additional section end
            (str_store_troop_name_plural, s0, ":troop_no"),
            #(troop_get_type, ":gender", ":troop_no"),#<- dplmc+ altered
            (store_sub, ":title_index", ":faction_no", kingdoms_begin),
            (try_begin),
                (this_or_next|eq, ":troop_no", ":faction_leader"),
                (troop_slot_eq, ":troop_no", slot_troop_spouse, ":faction_leader"), #wife is now queen/khatun/sultana
                (try_begin),
                    (eq, ":troop_is_female", 0),
                    (val_add, ":title_index", "str_faction_leader_title_male_player"),
                (else_try),
                    (val_add, ":title_index", "str_faction_leader_title_female_player"),
                (try_end),
            (else_try),
                (try_begin),
                  (eq, ":troop_is_female", 0), #<- dplmc+ altered
                  (val_add, ":title_index", kingdom_titles_male_begin),
                (else_try),
                  (try_begin),
                      (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
                      (this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
                      (troop_slot_ge, ":troop_no", slot_troop_spouse, 0),
                      (val_add, ":title_index", kingdom_titles_female_begin),
                  (else_try),
                      (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
                      (val_add, ":title_index", kingdom_titles_female_begin),
                  (else_try),
                      (assign, ":title_index", kingdom_titles_female_begin), #unmarried or unlanded ladies should just be Lady
                  (try_end),
                (try_end),
            (try_end),
            (str_store_string, s1, ":title_index"),
        (try_end),
        (troop_set_name, ":troop_no", s1),
        (troop_get_slot, ":troop_party", ":troop_no", slot_troop_leaded_party),
        (gt, ":troop_party", 0),
        (str_store_troop_name, s5, ":troop_no"),
        (party_set_name, ":troop_party", "str_s5_s_party"),
      (try_end),
      ##Custom player kingdom vassal titles, credit Caba'drin end
      (assign, reg0, ":save_reg0"),
      ##diplomacy end+
      ]),
  # script_give_center_to_lord
  # Input: arg1 = center_no, arg2 = lord_troop, arg3 = add_garrison_to_center
  ("give_center_to_lord",
    [
      (store_script_param, ":center_no", 1),
      (store_script_param, ":lord_troop_id", 2), #-1 only in the case of a player deferring ownership of a center
      (store_script_param, ":add_garrison", 3),
      ##diplomacy begin
      (party_set_slot, ":center_no", dplmc_slot_center_taxation, 0),
      (try_begin),
        (party_slot_eq, ":center_no", slot_village_infested_by_bandits, "trp_peasant_woman"),
        (party_set_slot, ":center_no", slot_village_infested_by_bandits, 0),
      (try_end),
      ##diplomacy end

      ##diplomacy start+
      #For relation changes below, store all heroes' center points and closest fiefs.
      (call_script, "script_dplmc_prepare_hero_center_points_ignoring_center", ":center_no"),

      #(assign, ":player_declines_honor", 0),
      #(try_begin),
      #	  (gt, "$g_dont_give_fief_to_player_days", 1),
      #	  (assign, ":player_declines_honor", 1),
      #(try_end),
      ##diplomacy end+

      (try_begin),
      ##diplomacy start+ notable events like this should be logged by default
        (store_current_hours, ":hours"),
        (ge, ":hours", 1),#Don't spam the game log during world setup
        (ge, ":lord_troop_id", 0),
        (str_store_party_name_link, s4, ":center_no"),
        (str_store_troop_name_link, s5, ":lord_troop_id"),
        (store_troop_faction, ":msg_faction_no", ":lord_troop_id"),
        (faction_get_color, ":color", ":msg_faction_no"), #SB : colorize
        (str_store_faction_name_link, s7, ":msg_faction_no"),
        (try_begin),
           (faction_slot_eq, ":msg_faction_no", slot_faction_leader, ":lord_troop_id"),
           (display_log_message, "@{s5} of the {s7} has taken ownership of {s4}.", ":color"),
        (else_try),
           (display_log_message, "@{s4} has been awarded to {s5} of the {s7}.", ":color"),
        (try_end),
      (else_try),
	  ##diplomacy end+
	   (eq, "$cheat_mode", 1),
		(ge, ":lord_troop_id", 0),
		(str_store_party_name, s4, ":center_no"),
		(str_store_troop_name, s5, ":lord_troop_id"),
		(display_message, "@{!}DEBUG -- {s4} awarded to {s5}"),
	  (try_end),

	  (try_begin),
	    (eq, ":lord_troop_id", "trp_player"),
	    (unlock_achievement, ACHIEVEMENT_ROYALITY_PAYMENT),

	    (assign, ":number_of_fiefs_player_have", 1),
	    (try_for_range, ":cur_center", centers_begin, centers_end),
	      (neq, ":cur_center", ":center_no"),
	      (party_slot_eq, ":cur_center", slot_town_lord, "trp_player"),
	      (val_add, ":number_of_fiefs_player_have", 1),
	    (try_end),

	    (ge, ":number_of_fiefs_player_have", 5),
	    (unlock_achievement, ACHIEVEMENT_MEDIEVAL_EMLAK),
	  (try_end),

      (party_get_slot, ":old_lord_troop_id", ":center_no", slot_town_lord),

	  (try_begin), #This script is ONLY called with lord_troop_id = -1 when it is the player faction
	  ##diplomacy start+
	  #The player can now also be co-ruler of a NPC kingdom.
         (eq, ":lord_troop_id", -1),

		 (is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
		 (faction_get_slot, ":players_kingdom_liege", "$players_kingdom", slot_faction_leader),
		 (gt, ":players_kingdom_liege", -1),
		 (this_or_next|eq, ":players_kingdom_liege", "trp_player"),
		 (this_or_next|troop_slot_eq, ":players_kingdom_liege", slot_troop_spouse, "trp_player"),
			(troop_slot_eq, "trp_player", slot_troop_spouse, ":players_kingdom_liege"),

		(assign, ":lord_troop_faction", "$players_kingdom"),
		(party_set_banner_icon, ":center_no", 0),#Removing banner
	  (else_try),
	  ##diplomacy end+
	    (eq, ":lord_troop_id", -1),
	    (assign, ":lord_troop_faction", "fac_player_supporters_faction"),
        (party_set_banner_icon, ":center_no", 0),#Removing banner

      (else_try),
	    (eq, ":lord_troop_id", "trp_player"),
	    (assign, ":lord_troop_faction", "$players_kingdom"), #was changed on Apr 27 from fac_plyr_sup_fac

      (else_try),
		(store_troop_faction, ":lord_troop_faction", ":lord_troop_id"),
	  (try_end),
	  (faction_get_slot, ":faction_leader", ":lord_troop_faction", slot_faction_leader),

	  (try_begin),
	    (eq, ":faction_leader", "trp_player"),

        (try_begin),
            (troop_get_type, ":is_female", "trp_player"),
            (eq, ":is_female", 1),
            (unlock_achievement, ACHIEVEMENT_QUEEN),
        (try_end),
	  (try_end),

	  (try_begin),
		(eq, ":faction_leader", ":old_lord_troop_id"),
		(call_script, "script_add_log_entry", logent_liege_grants_fief_to_vassal, ":faction_leader", ":center_no", ":lord_troop_id", ":lord_troop_faction"),
        (troop_set_slot, ":lord_troop_id", slot_troop_promised_fief, 0),
	  (try_end),

      (try_begin),
	    (eq, ":lord_troop_id", -1), #Lord troop ID -1 is only used when a player is deferring assignment of a fief
        (party_set_faction, ":center_no", "$players_kingdom"),
	  (else_try),
        (eq, ":lord_troop_id", "trp_player"),
        (gt, "$players_kingdom", 0),
        (party_set_faction, ":center_no", "$players_kingdom"),
      (else_try),
        (eq, ":lord_troop_id", "trp_player"),
        (neg|is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
        (party_set_faction, ":center_no", "fac_player_supporters_faction"),
      (else_try),
        (party_set_faction, ":center_no", ":lord_troop_faction"),
      (try_end),
      (party_set_slot, ":center_no", slot_town_lord, ":lord_troop_id"),

      (try_begin),
        (party_slot_eq, ":center_no", slot_party_type, spt_village),
        (party_get_slot, ":farmer_party_no", ":center_no", slot_village_farmer_party),
        (gt, ":farmer_party_no", 0),
        (party_is_active, ":farmer_party_no"),
        (store_faction_of_party, ":center_faction", ":center_no"),
        (party_set_faction, ":farmer_party_no", ":center_faction"),
      (try_end),

    (try_begin),
        (this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_town),
			(party_slot_eq, ":center_no", slot_party_type, spt_castle),
		(gt, ":lord_troop_id", -1),

#normal_banner_begin
        (troop_get_slot, ":cur_banner", ":lord_troop_id", slot_troop_banner_scene_prop),
        (try_begin),
            (gt, ":cur_banner", 0),
            (val_sub, ":cur_banner", banner_scene_props_begin),
            (val_add, ":cur_banner", banner_map_icons_begin),
            (party_set_banner_icon, ":center_no", ":cur_banner"),
# custom_banner_begin
       (else_try),
           (eq, ":cur_banner", -1),
           (troop_get_slot, ":flag_icon", ":lord_troop_id", slot_troop_custom_banner_map_flag_type),

           # (assign, reg0, ":flag_icon"),
           # (str_store_troop_name, s5, ":lord_troop_id",),
           # (display_message, "@{s5} : {reg0}"),

           (ge, ":flag_icon", 0),
           (val_add, ":flag_icon", custom_banner_map_icons_begin),
           (party_set_banner_icon, ":center_no", ":flag_icon"),
       (try_end),

       (neq, ":lord_troop_id", "trp_player"),
       #free all captive ladies
       (try_for_range, ":lady", kingdom_ladies_begin, kingdom_ladies_end),
           (troop_get_slot, ":prisoner_of_party", ":lady", slot_troop_prisoner_of_party),
           (neg|troop_slot_eq, ":lady", slot_troop_occupation, slto_kingdom_hero),
           (eq, ":center_no", ":prisoner_of_party"),
           (call_script, "script_remove_troop_from_prison", ":lady"),
           (store_faction_of_troop, ":lady_faction", ":lady"),
           (store_faction_of_troop, ":release_faction", ":lord_troop_id"),
           (faction_get_color, ":lady_faction_color", ":lady_faction"),
           (str_store_troop_name_link, s1, ":lady"),
           (str_store_faction_name_link, s2, ":release_faction"),
           (str_store_faction_name_link, s3, ":lady_faction"),
           (display_log_message, "@{s1} of {s3} has been released from captivity by {s2}.", ":lady_faction_color"),
       (try_end),

    (try_end),

#    (try_begin),
#		(eq, 1, 0),
 #       (eq, ":lord_troop_id", "trp_player"),
 #       (neq, ":old_lord_troop_id", "trp_player"),
 #       (party_get_slot, ":center_relation", ":center_no", slot_center_player_relation),
 #       (is_between, ":center_relation", -4, 5),
 #       (call_script, "script_change_player_relation_with_center", ":center_no", 5),
 #       (gt, ":old_lord_troop_id", 0),
 #       (call_script, "script_change_player_relation_with_troop", ":old_lord_troop_id", -25),
 #   (try_end),
	(try_begin),
		(gt, ":lord_troop_id", -1),
		(call_script, "script_update_troop_notes", ":lord_troop_id"),
	(try_end),

    (call_script, "script_update_center_notes", ":center_no"),

    (try_begin),
      (gt, ":lord_troop_faction", 0),
      (call_script, "script_update_faction_notes", ":lord_troop_faction"),
    (try_end),

    (try_begin),
        (ge, ":old_lord_troop_id", 0),
        (call_script, "script_update_troop_notes", ":old_lord_troop_id"),
        (store_troop_faction, ":old_lord_troop_faction", ":old_lord_troop_id"),
        (call_script, "script_update_faction_notes", ":old_lord_troop_faction"),
    (try_end),

    (try_begin),
        (eq, ":add_garrison", 1),
        (this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_town),
			(party_slot_eq, ":center_no", slot_party_type, spt_castle),
        (assign, ":garrison_strength", 3),
        (try_begin),
          (party_slot_eq, ":center_no", slot_party_type, spt_town),
          (assign, ":garrison_strength", 9),
        (try_end),
        (try_for_range, ":unused", 0, ":garrison_strength"),
          (call_script, "script_cf_reinforce_party", ":center_no"),
        (try_end),
        ## ADD some XP initially
        (try_for_range, ":unused", 0, 7),
          (store_mul, ":xp_range_min", 150, ":garrison_strength"),
          (store_mul, ":xp_range_max", 200, ":garrison_strength"),
          (store_random_in_range, ":xp", ":xp_range_min", ":xp_range_max"),
          (party_upgrade_with_xp, ":center_no", ":xp", 0),
        (try_end),
    (try_end),

	(faction_get_slot, ":faction_leader", ":lord_troop_faction", slot_faction_leader),
	(store_current_hours, ":hours"),

	#the next block handles gratitude, objections and jealousies
	(try_begin),
	  	(gt, ":hours", 0),
		(gt, ":lord_troop_id", 0),

    	(call_script, "script_troop_change_relation_with_troop", ":lord_troop_id", ":faction_leader", 10),
		(val_add, "$total_promotion_changes", 10),

		#smaller factions are more dramatically influenced by internal jealousies
		#Disabled as of NOV 2010
#		(try_begin),
#			(neg|faction_slot_ge, ":lord_troop_faction", slot_faction_number_of_parties, 4),
#			(assign, ":faction_size_multiplier", 6),
#		(else_try),
#			(neg|faction_slot_ge, ":lord_troop_faction", slot_faction_number_of_parties, 8),
#			(assign, ":faction_size_multiplier", 5),
#		(else_try),
#			(neg|faction_slot_ge, ":lord_troop_faction", slot_faction_number_of_parties, 16),
#			(assign, ":faction_size_multiplier", 4),
#		(else_try),
#			(neg|faction_slot_ge, ":lord_troop_faction", slot_faction_number_of_parties, 32),
#			(assign, ":faction_size_multiplier", 3),
#		(else_try),
#			(assign, ":faction_size_multiplier", 2),
#		(try_end),

		#factional politics -- each lord in the faction adjusts his relation according to the relation with the lord receiving the faction
		##diplomacy start+ add support for kingdom ladies
		#(try_for_range, ":other_lord", active_npcs_begin, active_npcs_end),
		(try_for_range, ":other_lord", heroes_begin, heroes_end),
		##diplomacy end+
			(troop_slot_eq, ":other_lord", slot_troop_occupation, slto_kingdom_hero),
			(neq, ":other_lord", ":lord_troop_id"),

		    (store_troop_faction, ":other_troop_faction", ":other_lord"),
		    (eq, ":lord_troop_faction", ":other_troop_faction"),

		    (neq, ":other_lord", ":faction_leader"),

	        (call_script, "script_troop_get_relation_with_troop", ":other_lord", ":lord_troop_id"),
			(assign, ":relation_with_troop", reg0),

			#relation reduction = relation/10 minus 2. So,0 = -2, 8 = -1, 16+ = no change or bonus, 24+ gain one point
		    (store_div, ":relation_with_liege_change", ":relation_with_troop", 8), #changed from 16
		    (val_sub, ":relation_with_liege_change", 2),

		    (val_clamp, ":relation_with_liege_change", -5, 3),

			(try_begin),
				#upstanding and goodnatured lords will not lose relation unless they actively dislike the other lord
				(this_or_next|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_upstanding),
				 ##diplomacy start+ add companion/lady personality types
				 (this_or_next|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_benefactor),
				 (this_or_next|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_conventional),
				 (this_or_next|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_moralist),
				 (this_or_next|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_otherworldly),
				 ##diplomacy end+
					(troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_goodnatured),
				(ge, ":relation_with_troop", 0),
				(val_max, ":relation_with_liege_change", 0),
			(else_try),
				#penalty is increased for lords who have the more unpleasant reputation types
				(this_or_next|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_selfrighteous),
				(this_or_next|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_debauched),
					(troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_quarrelsome),
				(lt, ":relation_with_liege_change", 0),
				(val_mul, ":relation_with_liege_change", 3),
				(val_div, ":relation_with_liege_change", 2),
			(try_end),
			##diplomacy start+

			#TODO (idea for "high"): instead of being absolute, the sliding score system should be used.
			#(So you can use a score instead of using relations.)  The greater the
			#difference in score, the greater the relation loss -- so if the lord
			#was nearly indifferent between two candidates, the difference would be
			#lesser.
			(try_begin),
				(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
				(try_begin),
					#Optional change: Non-jerkish lords will not object to giving a village to
					#someone fiefless, unless they dislike him.
					(neg|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_debauched),
					(neg|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_selfrighteous),
					(neg|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_quarrelsome),
					(lt, ":relation_with_liege_change", 0),
					(is_between, ":center_no", villages_begin, villages_end),
					(troop_slot_eq, ":lord_troop_id", slot_troop_temp_slot, 0),
					(ge, ":relation_with_troop", 0),
					(val_max, ":relation_with_liege_change", 0),
				(try_end),
				(try_begin),
					#Optional change: because taking a penalty for 'thrashing' the same fief
					#back and forth is silly, if you're giving the fief back to the lord who
					#last had it, reduce any penalty.
					(lt, ":relation_with_liege_change", 0),
					(party_slot_eq, ":center_no", dplmc_slot_center_ex_lord, ":lord_troop_id"),
					(neq, ":lord_troop_id", 0),
					(val_add, ":relation_with_liege_change", 1),

					#If the other lord doesn't have any claim of his own on the center,
					#attenuate the penalty more.
					(lt, ":relation_with_liege_change", 0),
					(ge, ":relation_with_troop", 0),
					(neg|party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":other_lord"),
					(neg|troop_slot_eq, ":other_lord", slot_troop_home, ":center_no"),
					(this_or_next|neg|troop_slot_ge, ":other_lord", slot_troop_stance_on_faction_issue, 0),
						(neg|party_slot_eq, ":center_no", slot_center_last_taken_by_troop, ":other_lord"),
					(val_add, ":relation_with_liege_change", 1),
				(else_try),
					#Similar logic, but for "original lord" instead of most recent lord
					(lt, ":relation_with_liege_change", 0),
					(neg|party_slot_eq, ":center_no", dplmc_slot_center_ex_lord, ":lord_troop_id"),#don't apply this if the above "ex-center" check was applied
					(this_or_next|party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":lord_troop_id"),
						(troop_slot_eq, ":lord_troop_id", slot_troop_home, ":center_no"),

					#Only attenuate the panelty if the other lord doesn't have any claim of his own on the center
					(ge, ":relation_with_troop", 0),
					(neg|troop_slot_eq, ":other_lord", slot_troop_home, ":center_no"),
					(neg|party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":other_lord"),
					(neg|party_slot_eq, ":center_no", dplmc_slot_center_ex_lord, ":other_lord"),
					(this_or_next|neg|troop_slot_ge, ":other_lord", slot_troop_stance_on_faction_issue, 0),
						(neg|party_slot_eq, ":center_no", slot_center_last_taken_by_troop, ":other_lord"),

					(val_add, ":relation_with_liege_change", 1),
				(try_end),
				(try_begin),
					#On the minus side, lords whose homes and/or original fiefs are not
					#disposed according to their wishes are that much more cross.
					(lt, ":relation_with_liege_change", 1),
					(this_or_next|party_slot_eq, ":center_no", dplmc_slot_center_ex_lord, ":other_lord"),
					(this_or_next|party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":other_lord"),
					   (troop_slot_eq, ":other_lord", slot_troop_home, ":center_no"),
					(val_sub, ":relation_with_liege_change", 1),
				(else_try),
					#Optional change: martial lords are less displeased by awarding a fief to
					#the one who conquered it.
					(lt, ":relation_with_liege_change", 0),
					(party_slot_eq, ":center_no", slot_center_last_taken_by_troop, ":lord_troop_id"),
					(this_or_next|troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_upstanding),
					(troop_slot_eq, ":other_lord", slot_lord_reputation_type, lrep_martial),
					(val_add, ":relation_with_liege_change", 1),
				(try_end),
			(try_end),
			##diplomacy end+

		    (neq, ":relation_with_liege_change", 0),
			#removed Nov 2010
#		  	(val_mul, ":relation_reduction", ":faction_size_multiplier"),
#		  	(val_div, ":relation_reduction", 2),
			#removed Nov 2010

			(try_begin),
				(troop_slot_eq, ":other_lord", slot_troop_stance_on_faction_issue, ":lord_troop_id"),
				(val_add, ":relation_with_liege_change", 1),
				(val_max, ":relation_with_liege_change", 1),
			(try_end),

 	        (call_script, "script_troop_change_relation_with_troop", ":other_lord", ":faction_leader", ":relation_with_liege_change"),
			(val_add, "$total_promotion_changes", ":relation_with_liege_change"),

		    (try_begin),
				(this_or_next|le, ":relation_with_liege_change", -4), #Nov 2010 - changed from -8
				(this_or_next|troop_slot_eq, ":other_lord", slot_troop_promised_fief, 1), #1 is any fief
					(troop_slot_eq, ":other_lord", slot_troop_promised_fief, ":center_no"),
				(call_script, "script_add_log_entry", logent_troop_feels_cheated_by_troop_over_land, ":other_lord", ":center_no", ":lord_troop_id", ":lord_troop_faction"),
		    (try_end),

		(try_end),
	(try_end),

	##diplomacy start+ invalidate cached center points
	(try_begin),
		(neq, ":old_lord_troop_id", ":lord_troop_id"),
		(try_begin),
			(gt, ":old_lord_troop_id", -1),
			(troop_set_slot, ":old_lord_troop_id", dplmc_slot_troop_center_points_plus_one, 0),
		(try_end),
		(try_begin),
			(gt, ":lord_troop_id", -1),
			(troop_set_slot, ":lord_troop_id", dplmc_slot_troop_center_points_plus_one, 0),
		(try_end),
	(try_end),
	##diplomacy end+

	#Villages from another faction will also be transferred along with a fortress
    (try_begin),
		(is_between, ":center_no", walled_centers_begin, walled_centers_end),
        (try_for_range, ":cur_village", villages_begin, villages_end),
			(party_slot_eq, ":cur_village", slot_village_bound_center, ":center_no"),
			(store_faction_of_party, ":cur_village_faction", ":cur_village"),
			(neq, ":cur_village_faction", ":lord_troop_faction"),

			(call_script, "script_give_center_to_lord", ":cur_village", ":lord_troop_id", 0),
        (try_end),
    (try_end),
  ]),

##  # script_give_town_to_besiegers
##  # Input: arg1 = center_no, arg2 = besieger_party
##  ("give_town_to_besiegers",
##    [
##      (store_script_param_1, ":center_no"),
##      (store_script_param_2, ":besieger_party"),
##      (store_faction_of_party, ":besieger_faction", ":besieger_party"),
##
##      (try_begin),
##        (call_script, "script_cf_get_party_leader", ":besieger_party"),
##        (assign, ":new_leader", reg0),
##      (else_try),
##        (call_script, "script_select_kingdom_hero_for_new_center", ":besieger_faction"),
##        (assign, ":new_leader", reg0),
##      (try_end),
##
##      (call_script, "script_give_center_to_lord", ":center_no", ":new_leader"),
##
##      (try_for_parties, ":party_no"),
##        (get_party_ai_object, ":object", ":party_no"),
##        (get_party_ai_behavior, ":behavior", ":party_no"),
##        (eq, ":object", ":center_no"),
##        (this_or_next|eq, ":behavior", ai_bhvr_travel_to_party),
##        (eq, ":behavior", ai_bhvr_attack_party),
##        (party_set_ai_behavior, ":party_no", ai_bhvr_hold),
##        (party_set_slot, ":party_no", slot_party_ai_state, spai_undefined),
##        (party_set_flags, ":party_no", pf_default_behavior, 0),
##      (try_end),
##
##      #Staying at the center for a while
##      (party_set_ai_behavior, ":besieger_party", ai_bhvr_hold),
##      (party_set_slot, ":besieger_party", slot_party_ai_state, spai_undefined),
##      (party_set_flags, ":besieger_party", pf_default_behavior, 0),
##
##      (faction_get_slot, ":reinforcement_a", ":besieger_faction", slot_faction_reinforcements_a),
##      (faction_get_slot, ":reinforcement_b", ":besieger_faction", slot_faction_reinforcements_b),
##      (party_add_template, ":center_no", ":reinforcement_a"),
##      (party_add_template, ":center_no", ":reinforcement_b"),
##  ]),
##

  # script_get_number_of_hero_centers
  # Input: arg1 = troop_no
  # Output: reg0 = number of centers that are ruled by the hero
  ("get_number_of_hero_centers",
    [
      (store_script_param_1, ":troop_no"),
      (assign, ":result", 0),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
        (val_add, ":result", 1),
      (try_end),
      (assign, reg0, ":result"),
  ]),


  ##  # script_cf_get_new_center_leader_chance_for_troop
  ##  # Input: arg1 = troop_no
  ##  # Output: reg0 = chance of the troop to rule a new center
  ##  ("cf_get_new_center_leader_chance_for_troop",
  ##    [
  ##      (store_script_param_1, ":troop_no"),
  ##      (troop_get_slot, ":troop_rank", ":troop_no", slot_troop_kingdom_rank),
  ##      (try_begin),
  ##        (eq, ":troop_rank", 4),
  ##        (assign, ":troop_chance", 1000),
  ##      (else_try),
  ##        (eq, ":troop_rank", 3),
  ##        (assign, ":troop_chance", 800),
  ##      (else_try),
  ##        (eq, ":troop_rank", 2),
  ##        (assign, ":troop_chance", 400),
  ##      (else_try),
  ##        (eq, ":troop_rank", 1),
  ##        (assign, ":troop_chance", 100),
  ##      (else_try),
  ##        (assign, ":troop_chance", 10),
  ##      (try_end),
  ##
  ##      (call_script, "script_get_number_of_hero_centers", ":troop_no"),
  ##      (assign, ":number_of_hero_centers", reg0),
  ##      (try_begin),
  ##        (gt, ":number_of_hero_centers", 0),
  ##        (val_mul, ":number_of_hero_centers", 2),
  ##        (val_mul, ":number_of_hero_centers", ":number_of_hero_centers"),
  ##        (val_div, ":troop_chance", ":number_of_hero_centers"),
  ##      (try_end),
  ##      (assign, reg0, ":troop_chance"),
  ##      (eq, reg0, 0),
  ##      (assign, reg0, 1),
  ##  ]),


##  # script_select_kingdom_hero_for_new_center
##  # Input: arg1 = faction_no
##  # Output: reg0 = troop_no as the new leader
##  ("select_kingdom_hero_for_new_center",
##    [
##      (store_script_param_1, ":kingdom"),
##
##      (assign, ":min_num_centers", -1),
##      (assign, ":min_num_centers_troop", -1),
##
##      (try_for_range, ":troop_no", kingdom_heroes_begin, kingdom_heroes_end),
##        (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
##        (store_troop_faction, ":troop_faction", ":troop_no"),
##        (eq, ":troop_faction", ":kingdom"),
##        (call_script, "script_get_number_of_hero_centers", ":troop_no"),
##        (assign, ":num_centers", reg0),
##        (try_begin),
##          (lt, ":num_centers", ":min_num_centers"),
##          (assign, ":min_num_centers", ":num_centers"),
##          (assign, ":min_num_centers_troop", ":troop_no"),
##        (try_end),
##      (try_end),
##      (assign, reg0, ":min_num_centers_troop"),
##  ]),


  # script_cf_get_random_enemy_center
  # Input: arg1 = party_no
  # Output: reg0 = center_no
  ("cf_get_random_enemy_center",
    [
      (store_script_param_1, ":party_no"),

      (assign, ":result", -1),
      (assign, ":total_enemy_centers", 0),
      (store_faction_of_party, ":party_faction", ":party_no"),

      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_faction_of_party, ":center_faction", ":center_no"),
        (store_relation, ":party_relation", ":center_faction", ":party_faction"),
        (lt, ":party_relation", 0),
        (val_add, ":total_enemy_centers", 1),
      (try_end),

      (gt, ":total_enemy_centers", 0),
      (store_random_in_range, ":random_center", 0, ":total_enemy_centers"),
      (assign, ":total_enemy_centers", 0),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (eq, ":result", -1),
        (store_faction_of_party, ":center_faction", ":center_no"),
        (store_relation, ":party_relation", ":center_faction", ":party_faction"),
        (lt, ":party_relation", 0),
        (val_sub, ":random_center", 1),
        (lt, ":random_center", 0),
        (assign, ":result", ":center_no"),
      (try_end),
      (assign, reg0, ":result"),
  ]),


##  # script_get_random_enemy_town
##  # Input: arg1 = party_no
##  # Output: reg0 = center_no
##  ("get_random_enemy_town",
##    [
##      (store_script_param_1, ":party_no"),
##
##      (assign, ":result", -1),
##      (assign, ":total_enemy_centers", 0),
##      (store_faction_of_party, ":party_faction", ":party_no"),
##
##      (try_for_range, ":center_no", towns_begin, towns_end),
##        (store_faction_of_party, ":center_faction", ":center_no"),
##        (neq, ":center_faction", ":party_faction"),
##        (val_add, ":total_enemy_centers", 1),
##      (try_end),
##
##      (try_begin),
##        (eq, ":total_enemy_centers", 0),
##      (else_try),
##        (store_random_in_range, ":random_center", 0, ":total_enemy_centers"),
##        (assign, ":total_enemy_centers", 0),
##        (try_for_range, ":center_no", towns_begin, towns_end),
##          (eq, ":result", -1),
##          (store_faction_of_party, ":center_faction", ":center_no"),
##          (neq, ":center_faction", ":party_faction"),
##          (store_relation, ":party_relation", ":center_faction", ":party_faction"),
##          (le, ":party_relation", -10),
##          (val_add, ":total_enemy_centers", 1),
##          (lt, ":random_center", ":total_enemy_centers"),
##          (assign, ":result", ":center_no"),
##        (try_end),
##      (try_end),
##      (assign, reg0, ":result"),
##  ]),



  # script_find_travel_location
  # Input: arg1 = center_no
  # Output: reg0 = new_center_no (to travel within the same faction)
  ("find_travel_location",
    [
      (store_script_param_1, ":center_no"),
      (store_faction_of_party, ":faction_no", ":center_no"),
      (assign, ":total_weight", 0),
      (try_for_range, ":cur_center_no", centers_begin, centers_end),
        (neq, ":center_no", ":cur_center_no"),
        (store_faction_of_party, ":center_faction_no", ":cur_center_no"),
        (eq, ":faction_no", ":center_faction_no"),

        (store_distance_to_party_from_party, ":cur_distance", ":center_no", ":cur_center_no"),
        (val_add, ":cur_distance", 1),

        (assign, ":new_weight", 100000),
        (val_div, ":new_weight", ":cur_distance"),
        (val_add, ":total_weight", ":new_weight"),
      (try_end),

      (assign, reg0, -1),

      (try_begin),
        (eq, ":total_weight", 0),
      (else_try),
        (store_random_in_range, ":random_weight", 0 , ":total_weight"),
        (assign, ":total_weight", 0),
        (assign, ":done", 0),
        (try_for_range, ":cur_center_no", centers_begin, centers_end),
          (eq, ":done", 0),
          (neq, ":center_no", ":cur_center_no"),
          (store_faction_of_party, ":center_faction_no", ":cur_center_no"),
          (eq, ":faction_no", ":center_faction_no"),

          (store_distance_to_party_from_party, ":cur_distance", ":center_no", ":cur_center_no"),
          (val_add, ":cur_distance", 1),

          (assign, ":new_weight", 100000),
          (val_div, ":new_weight", ":cur_distance"),
          (val_add, ":total_weight", ":new_weight"),
          (lt, ":random_weight", ":total_weight"),
          (assign, reg0, ":cur_center_no"),
          (assign, ":done", 1),
        (try_end),
      (try_end),
  ]),


  # script_get_relation_between_parties
  # Input: arg1 = party_no_1, arg2 = party_no_2
  # Output: reg0 = relation between parties
  ("get_relation_between_parties",
    [
      (store_script_param_1, ":party_no_1"),
      (store_script_param_2, ":party_no_2"),

      (store_faction_of_party, ":party_no_1_faction", ":party_no_1"),
      (store_faction_of_party, ":party_no_2_faction", ":party_no_2"),
      (try_begin),
        (eq, ":party_no_1_faction", ":party_no_2_faction"),
        (assign, reg0, 100),
      (else_try),
        (store_relation, ":relation", ":party_no_1_faction", ":party_no_2_faction"),
        (assign, reg0, ":relation"),
      (try_end),
  ]),
  # script_calculate_weekly_party_wage
  # Input: arg1 = party_no
  # Output: reg0 = weekly wage
  ("calculate_weekly_party_wage",
    [
      (store_script_param_1, ":party_no"),

      (assign, ":result", 0),
      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
        (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
        (call_script, "script_npc_get_troop_wage", ":stack_troop", ":party_no"),
        (assign, ":cur_wage", reg0),
        (val_mul, ":cur_wage", ":stack_size"),
        (val_add, ":result", ":cur_wage"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

  # script_calculate_player_faction_wage
  # Input: arg1 = party_no
  # Output: reg0 = weekly wage
  ("calculate_player_faction_wage",
    [(assign, ":nongarrison_wages", 0),
     (assign, ":garrison_wages", 0),
     (try_for_parties, ":party_no"),
       (assign, ":garrison_troop", 0),
       (try_begin),
         (this_or_next|party_slot_eq, ":party_no", slot_party_type, spt_town),
         (party_slot_eq, ":party_no", slot_party_type, spt_castle),
         (party_slot_eq, ":party_no", slot_town_lord, "trp_player"),
         (assign, ":garrison_troop", 1),
       (try_end),
       (this_or_next|eq, ":party_no", "p_main_party"),
       (eq, ":garrison_troop", 1),
       (party_get_num_companion_stacks, ":num_stacks",":party_no"),
       (try_for_range, ":i_stack", 0, ":num_stacks"),
         (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
         (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
         (call_script, "script_game_get_troop_wage", ":stack_troop", ":party_no"),
         (assign, ":cur_wage", reg0),
         (val_mul, ":cur_wage", ":stack_size"),
         (try_begin),
           (eq, ":garrison_troop", 1),
           (val_add, ":garrison_wages", ":cur_wage"),
         (else_try),
           (val_add, ":nongarrison_wages", ":cur_wage"),
         (try_end),
       (try_end),
     (try_end),
     (val_div, ":garrison_wages", 2),#Half payment for garrisons
     (store_sub, ":total_payment", 14, "$g_cur_week_half_daily_wage_payments"), #between 0 and 7
     (val_mul, ":nongarrison_wages", ":total_payment"),
     (val_div, ":nongarrison_wages", 14),
     ##diplomacy start+ centralization affects this in the player's kingdom
###xxx TODO: This appears to be missing.
     ##diplomacy end+
     (store_add, reg0, ":nongarrison_wages", ":garrison_wages"),
    ]),

  # script_calculate_hero_weekly_net_income_and_add_to_wealth
  # Input: arg1 = troop_no
  # Output: none
  ("calculate_hero_weekly_net_income_and_add_to_wealth",
    [
      (store_script_param_1, ":troop_no"),

      (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
      (troop_get_slot, ":cur_wealth", ":troop_no", slot_troop_wealth),

      (assign, ":weekly_income", 750), #let every hero receive 750 denars by default

      (store_character_level, ":troop_level", ":troop_no"),
      (store_mul, ":level_income", ":troop_level", 10),
      (val_add, ":weekly_income", ":level_income"),

      (store_troop_faction,":faction_no", ":troop_no"),

	  ##diplomacy start+
	  #Bonus for marshall and/or faction leader (is 1000 in native)
	  (assign, ":leader_bonus_gold", 1000),
	  (assign, ":bonus_applied", 0),
	  (try_begin),
		   #OPTIONAL CHANGE (HIGH)
		   (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_HIGH),
 		   #Scale marshall and king bonus gold by number of remaining kingdoms,
           #so the total amount paid out remains the same even as kingdoms disappear.
           #This is only enabled if changes are on "HIGH".
           (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
           (store_sub, ":original_kingdoms", npc_kingdoms_end, npc_kingdoms_begin),#deliberately excludes player kingdom
           (ge, ":original_kingdoms", 2),
           (assign, ":current_kingdoms", 0),
           (try_for_range, ":other_fac", kingdoms_begin, kingdoms_end),#deliberately include player kingdom
             (faction_slot_eq, ":other_fac", slot_faction_state, sfs_active),
             (val_add, ":current_kingdoms", 1),
           (try_end),
           (ge, ":current_kingdoms", 1),
           (lt, ":current_kingdoms", ":original_kingdoms"),
           (val_mul, ":leader_bonus_gold", ":original_kingdoms"),
           (val_div, ":leader_bonus_gold", ":current_kingdoms"),
		   #Examples, assuming 6 starting kingdoms and no player kingdom:
		   #6 kingdoms: 1000 each, 1000 * 6 = 6000 total
		   #5 kingdoms: 1200 each, 1200 * 5 = 6000 total
		   #4 kingdoms: 1500 each, 1500 * 4 = 6000 total
		   #3 kingdoms: 2000 each, 2000 * 3 = 6000 total
		   #2 kingdoms: 3000 each, 3000 * 2 = 6000 total
		   #1 kingdom:  6000 each, 6000 * 1 = 6000 total
      (try_end),
	  ##diplomacy end+

      (try_begin), #check if troop is kingdom leader
        (faction_slot_eq, ":faction_no", slot_faction_leader, ":troop_no"),
        ##diplomacy start+
		#OLD BEHAVIOR:
        #(val_add, ":weekly_income", 1000),
		#NEW BEHAVIOR:
		(val_add, ":weekly_income", ":leader_bonus_gold"),
		(val_add, ":bonus_applied", 1),
        ##diplomacy end+
      (try_end),

      (try_begin), #check if troop is marshall
        (faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),
        ##diplomacy start+
		#OLD BEHAVIOR:
        #(val_add, ":weekly_income", 1000),
		#NEW BEHAVIOR:
	    (val_add, ":weekly_income", ":leader_bonus_gold"),
		(val_add, ":bonus_applied", 1),
        ##diplomacy end+
      (try_end),

	  ##diplomacy start+
	  (try_begin),
	  	  #OPTIONAL CHANGE (MEDIUM)
		  (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_MEDIUM),
		  #If the lord is the spouse of the faction leader and no better bonus
		  #applied, the lord gets half of the bonus if either (1) there is no
		  #marshall, or (2) the faction leader is the player.
		  (eq, ":bonus_applied", 0),
		  (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
  		  #Don't do the usual polygamy check: the bonus only applies to
		  #one of the spouses.
		  (faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),
		  (ge, ":faction_leader", 0),
		  (troop_slot_eq, ":faction_leader", slot_troop_spouse, ":troop_no"),
		  #Don't apply the bonus unless the faction leader bonus is going
		  #all/partially uncollected, or the marshal bonus is going uncollected.
		  (this_or_next|neg|faction_slot_ge, ":faction_no", slot_faction_marshall, 0),
			(eq, ":faction_leader", "trp_player"),
		  #Apply bonus
		  (val_add, ":bonus_applied", 1),
		  (store_div, reg0, ":leader_bonus_gold", 2),
		  (val_add, ":weekly_income", reg0),
	  (try_end),
	  ##diplomacy end+

      (assign, ":cur_weekly_wage", 0),
      (try_begin),
        (gt, ":party_no",0),
        (call_script, "script_calculate_weekly_party_wage", ":party_no"),
        (assign, ":cur_weekly_wage", reg0),
      (try_end),
      ##diplomacy start+
      (try_begin),
	     #take into account leader's leadership skill, like in CC
	     #economics changes must be enabled
         (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_HIGH),
         (store_skill_level, ":leadership_level", "skl_leadership", ":troop_no"),
         (val_clamp, ":leadership_level", 0, 11),
         (store_mul, ":leadership_bonus", 5, ":leadership_level"),
         (store_sub, ":leadership_factor", 100, ":leadership_bonus"),
         (val_mul, ":cur_weekly_wage", ":leadership_factor"),  #wage = wage * (100 - 5*leadership)/100
         (val_div, ":cur_weekly_wage", 100),
      (try_end),

	  #Store the change in income for use below
	  (store_sub, ":net_income", ":weekly_income", ":cur_weekly_wage"),
      ##diplomacy end+
      (val_sub, ":weekly_income", ":cur_weekly_wage"),

      (val_add, ":cur_wealth", ":weekly_income"),

	  (try_begin),
		(lt, ":cur_wealth", 0),
		(store_sub, ":percent_under", 0, ":cur_wealth"),
		(val_mul, ":percent_under", 100),
		(val_div, ":percent_under", ":cur_weekly_wage"),
		(val_div, ":percent_under", 5), #Max 20 percent
		##diplomacy start+
		#The above assumption could be violated if the lord entered this
		#script with a negative wealth.  Add a failsafe.
		(val_clamp, ":percent_under", 0, 21),
		##diplomacy end+
		(call_script, "script_party_inflict_attrition", ":party_no", ":percent_under", 1),
	  (try_end),

	  ##diplomacy start+
	  #Apply gold change
	  (try_begin),
	     #If the wealth change was positive, some of it may go to the lord's holdings.
	     (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_HIGH),
	     (ge, ":net_income", 1),
		 (call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", ":net_income", ":troop_no"),
	  (else_try),
	     #Fall through to old version:
		 #OLD VERSION:
         (val_max, ":cur_wealth", 0),
         (troop_set_slot, ":troop_no", slot_troop_wealth, ":cur_wealth"),
	  (try_end),
	  ##diplomacy end+
  ]),

  # script_cf_reinforce_party
  # Input: arg1 = party_no,
  # Output: none
  # Adds reinforcement to party according to its type and faction
  # Called from several places, simple_triggers for centers, script_hire_men_to_kingdom_hero_party for hero parties
  ("cf_reinforce_party",
    [
      (store_script_param_1, ":party_no"),

      (store_faction_of_party, ":party_faction", ":party_no"),
	  ##diplomacy start+ The party faction may be changed for culture, but we still need the original
	  (assign, ":real_party_faction", ":party_faction"),
	  ##diplomacy end+
      (party_get_slot, ":party_type",":party_no", slot_party_type),

#Rebellion changes begin:
      (try_begin),
        (eq, ":party_type", spt_kingdom_hero_party),
        (party_stack_get_troop_id, ":leader", ":party_no"),
        (troop_get_slot, ":party_faction",  ":leader", slot_troop_original_faction),
		##diplomacy start+ Use player culture for companions and spouse (and any hypothetical non-hero mercenaries)
		(eq, ":real_party_faction", "fac_player_supporters_faction"),
		(is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
		(this_or_next|is_between, ":leader", companions_begin, companions_end),
		(this_or_next|troop_slot_eq, "trp_player", slot_troop_spouse, ":leader"),
		   (neg|is_between, ":leader", heroes_begin, heroes_end),
		(assign, ":party_faction", "$g_player_culture"),
		##diplomacy end+
      (try_end),
#Rebellion changes end

      (try_begin),
      #SB : this block checks for town lords, which is invalid for kingdom parties
        (is_between, ":party_type", spt_castle, spt_village),
        (eq, ":party_faction", "fac_player_supporters_faction"),
        (party_get_slot, ":town_lord", ":party_no", slot_town_lord),
        (try_begin),
        ##diplomacy begin
          (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
          (assign, ":party_faction", "$g_player_culture"),

          # (try_begin), #debug
            # (eq, "$cheat_mode", 1),
            # (str_store_party_name, s11, ":party_no"),
            # (display_message, "@pt in {s11}"),
          # (try_end),

        (else_try),
        ##diplomacy end
          (gt, ":town_lord", 0),
          (troop_get_slot, ":party_faction", ":town_lord", slot_troop_original_faction),
          (gt, ":party_faction", 0), ## CC
        (else_try),
          (party_get_slot, ":party_faction", ":party_no", slot_center_original_faction),
        (try_end),
      (try_end),
	  ##diplomacy start+ Player culture cleanup (do this once here, instead of separately for each type)
	  (try_begin),
	     (gt, ":real_party_faction", "fac_commoners"),
	     (this_or_next|eq, ":real_party_faction", "fac_player_faction"),
	     (this_or_next|eq, ":real_party_faction", "fac_player_supporters_faction"),
		 (eq, ":real_party_faction", "$players_kingdom"),
		 (neg|is_between, ":party_faction", npc_kingdoms_begin, npc_kingdoms_end),
		 (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
		 (assign, ":party_faction", "$g_player_culture"),
	  (try_end),
	  ##diplomacy end+

      (faction_get_slot, ":party_template_a", ":party_faction", slot_faction_reinforcements_a),
      (faction_get_slot, ":party_template_b", ":party_faction", slot_faction_reinforcements_b),
      (faction_get_slot, ":party_template_c", ":party_faction", slot_faction_reinforcements_c),

      (assign, ":party_template", 0),
      (store_random_in_range, ":rand", 0, 100),
  	  ##diplomacy start+
	  #Implement "quality vs. quantity" in a way that is visible in player battles
	  #(previously, quantity increased party size, but quality only had an effect
	  #in autocalc battles)
	  (try_begin),
		(is_between, ":real_party_faction", kingdoms_begin, kingdoms_end),
		(faction_get_slot, ":dplmc_quality", ":real_party_faction", dplmc_slot_faction_quality),
		(val_clamp, ":dplmc_quality", -3, 4),
		(val_add, ":rand", ":dplmc_quality"),
		(val_clamp, ":rand", 0, 101),
	  (try_end),
	  ##diplomacy end+
      (try_begin),
        (this_or_next|eq, ":party_type", spt_town),
        (eq, ":party_type", spt_castle),  #CASTLE OR TOWN
        (try_begin),
          (lt, ":rand", 65),
          (assign, ":party_template", ":party_template_a"),
        (else_try),
          (assign, ":party_template", ":party_template_b"),
        (try_end),
      (else_try),
        (eq, ":party_type", spt_kingdom_hero_party),
        (try_begin),
          (lt, ":rand", 50),
          (assign, ":party_template", ":party_template_a"),
        (else_try),
          (lt, ":rand", 75),
          (assign, ":party_template", ":party_template_b"),
        (else_try),
          (assign, ":party_template", ":party_template_c"),
        (try_end),
      (else_try),
	  ##diplomacy start+ Reinforcements for patrols
	    (this_or_next|eq, ":party_type", spt_patrol),
	    (eq, ":party_type", spt_reinforcement), #SB : add more reinf if necessary
		(try_begin),
		   (lt, ":rand", 65),
		   (assign, ":party_template", ":party_template_a"),
		(else_try),
		   (assign, ":party_template", ":party_template_b"),
		(try_end),
	  ##diplomacy end+
      (try_end),

      (try_begin),
        (gt, ":party_template", 0),
        (party_add_template, ":party_no", ":party_template"),
      (try_end),
  ]),

  # script_hire_men_to_kingdom_hero_party
  # Input: arg1 = troop_no (hero of the party)
  # Output: none
  ("hire_men_to_kingdom_hero_party",
    [
      (store_script_param_1, ":troop_no"),

      (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
      (troop_get_slot, ":cur_wealth", ":troop_no", slot_troop_wealth),

      #while hiring reinforcements party leaders can only use 3/4 of their budget. This value is holding in ":hiring budget".
      (assign, ":hiring_budget", ":cur_wealth"),
      (val_mul, ":hiring_budget", 3),
      (val_div, ":hiring_budget", 4),

      (call_script, "script_party_get_ideal_size", ":party_no"),
      (assign, ":ideal_size", reg0),
      (store_mul, ":ideal_top_size", ":ideal_size", 3),
      (val_div, ":ideal_top_size", 2),

	  #(try_begin),
	  #	(ge, "$cheat_mode", 1),
      #  (str_store_troop_name, s7, ":troop_no"),
      #  (assign, reg9, ":cur_wealth"),
      #  (display_message, "@{!}DEBUGS : {s7} total budget is {reg9}"),
      #  (assign, reg6, ":ideal_size"),
      #  (assign, reg7, ":ideal_top_size"),
      #  (assign, reg8, ":hiring_budget"),
      #  (display_message, "str_debug__hiring_men_to_s7_ideal_size__reg6_ideal_top_size__reg7_hiring_budget__reg8"),
      #(try_end),

      (party_get_num_companions, ":party_size", ":party_no"),

      (store_faction_of_party, ":party_faction", ":party_no"),
      (try_begin),
        (this_or_next|eq, ":party_faction", "fac_player_supporters_faction"),
        (eq, ":party_faction", "$players_kingdom"),
        (assign, ":reinforcement_cost", reinforcement_cost_moderate),
      (else_try),
        (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
        (assign, ":reinforcement_cost", reinforcement_cost_moderate),
        (try_begin),
          (eq, ":reduce_campaign_ai", 0), #hard
          (assign, ":reinforcement_cost", reinforcement_cost_hard),
        (else_try),
          (eq, ":reduce_campaign_ai", 1), #moderate
          (assign, ":reinforcement_cost", reinforcement_cost_moderate),
        (else_try),
          (eq, ":reduce_campaign_ai", 2), #easy
          (assign, ":reinforcement_cost", reinforcement_cost_easy),
        (try_end),
      (try_end),

      (assign, ":num_rounds", 1),
      (try_for_range, ":unused", 0 , ":num_rounds"),
        (try_begin),
          (lt, ":party_size", ":ideal_size"),
          (gt, ":hiring_budget", ":reinforcement_cost"),
          (gt, ":party_no", 0),
          (call_script, "script_cf_reinforce_party", ":party_no"),
          (val_sub, ":cur_wealth", ":reinforcement_cost"),
          (troop_set_slot, ":troop_no", slot_troop_wealth, ":cur_wealth"),
        (else_try),
          (gt, ":party_size", ":ideal_top_size"),
          (store_troop_faction, ":troop_faction", ":troop_no"),
          (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
          (assign, ":total_regulars", 0),
          (assign, ":total_regular_levels", 0),
          (try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
            (neg|troop_is_hero, ":stack_troop"),
            (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
            (store_character_level, ":stack_level", ":stack_troop"),
            (store_troop_faction, ":stack_faction", ":stack_troop"),
            (try_begin),
              (eq, ":troop_faction", ":stack_faction"),
              (val_mul, ":stack_level", 3), #reducing the chance of the faction troops' removal
            (try_end),
            (val_mul, ":stack_level", ":stack_size"),
            (val_add, ":total_regulars", ":stack_size"),
            (val_add, ":total_regular_levels", ":stack_level"),
          (try_end),
          (gt, ":total_regulars", 0),
          (store_div, ":average_level", ":total_regular_levels", ":total_regulars"),
          (try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
            (neg|troop_is_hero, ":stack_troop"),
            (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
            (store_character_level, ":stack_level", ":stack_troop"),
            (store_troop_faction, ":stack_faction", ":stack_troop"),
            (try_begin),
              (eq, ":troop_faction", ":stack_faction"),
              (val_mul, ":stack_level", 3),
            (try_end),
            (store_sub, ":level_dif", ":average_level", ":stack_level"),
            (val_div, ":level_dif", 3),
            (store_add, ":prune_chance", 10, ":level_dif"),
            (gt, ":prune_chance", 0),
            (call_script, "script_get_percentage_with_randomized_round", ":stack_size", ":prune_chance"),
            (gt, reg0, 0),
            (party_remove_members, ":party_no", ":stack_troop", reg0),
          (try_end),
        (try_end),
      (try_end),
  ]),

  # script_get_percentage_with_randomized_round
  # Input: arg1 = value, arg2 = percentage
  # Output: none
  ("get_percentage_with_randomized_round",
    [
      (store_script_param, ":value", 1),
      (store_script_param, ":percentage", 2),

      (store_mul, ":result", ":value", ":percentage"),
      (val_div, ":result", 100),
      (store_mul, ":used_amount", ":result", 100),
      (val_div, ":used_amount", ":percentage"),
      (store_sub, ":left_amount", ":value", ":used_amount"),
      (try_begin),
        (gt, ":left_amount", 0),
        (store_mul, ":chance", ":left_amount", ":percentage"),
        (store_random_in_range, ":random_no", 0, 100),
        (lt, ":random_no", ":chance"),
        (val_add, ":result", 1),
      (try_end),
      (assign, reg0, ":result"),
      ]),

  # script_create_cattle_herd
  # Input: arg1 = center_no, arg2 = amount (0 = default)
  # Output: reg0 = party_no
  ("create_cattle_herd",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":amount"),

      (assign, ":herd_party", -1),
      (set_spawn_radius,1),

      (spawn_around_party,":center_no", "pt_cattle_herd"),
      (assign, ":herd_party", reg0),
      (party_get_position, pos1, ":center_no"),
      (call_script, "script_map_get_random_position_around_position_within_range", 1, 2),
      (party_set_position, ":herd_party", pos2),

      (party_set_slot, ":herd_party", slot_party_type, spt_cattle_herd),
      (party_set_slot, ":herd_party", slot_party_ai_state, spai_undefined),
      (party_set_ai_behavior, ":herd_party", ai_bhvr_hold),

      (party_set_slot, ":herd_party", slot_party_commander_party, -1), #we need this because 0 is player's party!

      (try_begin),
        (gt, ":amount", 0),
        (party_clear, ":herd_party"),
        (party_add_members, ":herd_party", "trp_cattle", ":amount"),
      (try_end),

      (assign, reg0, ":herd_party"),
  ]),

  #script_buy_cattle_from_village
  # Input: arg1 = village_no, arg2 = amount, arg3 = single_cost
  # Output: reg0 = party_no
  ("buy_cattle_from_village",
    [
      (store_script_param, ":village_no", 1),
      (store_script_param, ":amount", 2),
      (store_script_param, ":single_cost", 3),

      #Changing price of the cattle
      (try_for_range, ":unused", 0, ":amount"),
        (call_script, "script_game_event_buy_item", "itm_cattle_meat", 0),
        (call_script, "script_game_event_buy_item", "itm_cattle_meat", 0),
      (try_end),

      (party_get_slot, ":num_cattle", ":village_no", slot_village_number_of_cattle),
      (val_sub, ":num_cattle", ":amount"),
      (party_set_slot, ":village_no", slot_village_number_of_cattle, ":num_cattle"),
      (store_mul, ":cost", ":single_cost", ":amount"),
      (troop_remove_gold, "trp_player", ":cost"),
      #SB : add gold back to elder
      (try_begin),
        (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_MEDIUM),
        (party_get_slot, ":elder", ":village_no", slot_town_elder),
        (gt, ":elder", 0),
        (troop_add_gold, ":elder", ":cost"),
      (try_end),

      (assign, ":continue", 1),
      (try_for_parties, ":cur_party"),
        (eq, ":continue", 1),
        (party_slot_eq, ":cur_party", slot_party_type, spt_cattle_herd),
        (store_distance_to_party_from_party, ":dist", ":village_no", ":cur_party"),
        (lt, ":dist", 6),
        (assign, ":subcontinue", 1),
        (try_begin),
          (check_quest_active, "qst_move_cattle_herd"),
          (quest_slot_eq, "qst_move_cattle_herd", slot_quest_target_party, ":cur_party"),
          (assign, ":subcontinue", 0),
        (try_end),
        (eq, ":subcontinue", 1),
        (party_add_members, ":cur_party", "trp_cattle", ":amount"),
        (assign, ":continue", 0),
        (assign, reg0, ":cur_party"),
      (try_end),
      (try_begin),
        (eq, ":continue", 1),
        (call_script, "script_create_cattle_herd", ":village_no", ":amount"),
      (try_end),
  ]),

  #script_kill_cattle_from_herd
  # Input: arg1 = party_no, arg2 = amount
  # Output: none (fills trp_temp_troop's inventory)
  ("kill_cattle_from_herd",
    [
      (store_script_param_1, ":party_no"),
      (store_script_param_2, ":amount"),

      (troop_clear_inventory, "trp_temp_troop"),
      (store_mul, ":meat_amount", ":amount", 2),
      (troop_add_items, "trp_temp_troop", "itm_cattle_meat", ":meat_amount"),

      (troop_get_inventory_capacity, ":inv_size", "trp_temp_troop"),
      (try_for_range, ":i_slot", 0, ":inv_size"),
        (troop_get_inventory_slot, ":item_id", "trp_temp_troop", ":i_slot"),
        (eq, ":item_id", "itm_cattle_meat"),
        (troop_set_inventory_slot_modifier, "trp_temp_troop", ":i_slot", imod_fresh),
      (try_end),

      (party_get_num_companions, ":num_cattle", ":party_no"),
      (try_begin),
        (ge, ":amount", ":num_cattle"),
        (remove_party, ":party_no"),
      (else_try),
        (party_remove_members, ":party_no", "trp_cattle", ":amount"),
      (try_end),
      ]),

  # script_create_kingdom_hero_party
  # Input: arg1 = troop_no, arg2 = center_no
  # Output: $pout_party = party_no
  ("create_kingdom_hero_party",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":center_no", 2),

      (store_troop_faction, ":troop_faction_no", ":troop_no"),

      (assign, "$pout_party", -1),
      (try_begin),
        (eq, "$g_there_is_no_avaliable_centers", 0),
        (set_spawn_radius, 0),
      (else_try),
        (set_spawn_radius, 15),
      (try_end),
      (spawn_around_party, ":center_no", "pt_kingdom_hero_party"),

      (assign, "$pout_party", reg0),

      ###faction icons### dckplmc
      (try_begin),

        (assign, ":icon_faction", ":troop_faction_no"),

        (try_begin),
          (gt, ":troop_faction_no", "fac_commoners"),
          (this_or_next|eq, ":troop_faction_no", "fac_player_faction"),
          (this_or_next|eq, ":troop_faction_no", "fac_player_supporters_faction"),
          (eq, ":troop_faction_no", "$players_kingdom"),
          (neg|is_between, ":troop_faction_no", npc_kingdoms_begin, npc_kingdoms_end),
          (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
          (assign, ":icon_faction", "$g_player_culture"),
        (try_end),

          (is_between, ":icon_faction", npc_kingdoms_begin, kingdoms_end),
          (store_sub, ":fac_offset", ":icon_faction", npc_kingdoms_begin),
          (try_begin),
              (faction_slot_eq, ":icon_faction", slot_faction_leader, ":troop_no"),
              (store_add, ":icon", "icon_kingdom_1_king", ":fac_offset"),
              (party_set_icon, "$pout_party", ":icon"),
          (else_try),
              (store_add, ":icon", "icon_kingdom_1_lord", ":fac_offset"),
              (party_set_icon, "$pout_party", ":icon"),
          (try_end),
      (try_end),
      ###

      (party_set_faction, "$pout_party", ":troop_faction_no"),
      (party_set_slot, "$pout_party", slot_party_type, spt_kingdom_hero_party),
      (call_script, "script_party_set_ai_state", "$pout_party", spai_undefined, -1),
      (troop_set_slot, ":troop_no", slot_troop_leaded_party, "$pout_party"),
      (party_add_leader, "$pout_party", ":troop_no"),
      (str_store_troop_name, s5, ":troop_no"),
      (party_set_name, "$pout_party", "str_s5_s_party"),

      (party_set_slot, "$pout_party", slot_party_commander_party, -1), #we need this because 0 is player's party!

      #Setting the flag icon
      #normal_banner_begin
      (troop_get_slot, ":cur_banner", ":troop_no", slot_troop_banner_scene_prop),
      (try_begin),
        (gt, ":cur_banner", 0),
        (val_sub, ":cur_banner", banner_scene_props_begin),
        (val_add, ":cur_banner", banner_map_icons_begin),
        (party_set_banner_icon, "$pout_party", ":cur_banner"),
      (else_try),
      #custom_banner_begin
          (eq, ":cur_banner", -1),
          (troop_get_slot, ":flag_icon", ":troop_no", slot_troop_custom_banner_map_flag_type),
          (try_begin),
           (ge, ":flag_icon", 0),
           (val_add, ":flag_icon", custom_banner_map_icons_begin),
           (party_set_banner_icon, "$pout_party", ":flag_icon"),
          (try_end),
      (try_end),

      (try_begin),
        #because of below two lines, lords can only hire more than one party_template(stack) at game start once a time during all game.
        (troop_slot_eq, ":troop_no", slot_troop_spawned_before, 0),
        (troop_set_slot, ":troop_no", slot_troop_spawned_before, 1),
        (assign, ":num_tries", 20),
        (try_begin),
          (store_troop_faction, ":troop_kingdom", ":troop_no"),
          (faction_slot_eq, ":troop_kingdom", slot_faction_leader, ":troop_no"),
          (assign, ":num_tries", 50),
        (try_end),

        #(str_store_troop_name, s0, ":troop_no"),
        #(display_message, "{!}str_debug__hiring_men_to_party_for_s0"),

        (try_for_range, ":unused", 0, ":num_tries"),
          (call_script, "script_hire_men_to_kingdom_hero_party", ":troop_no"),
        (try_end),

        (assign, ":xp_rounds", 0),

        (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
        (try_begin),
          (this_or_next|eq, ":troop_faction_no", "$players_kingdom"),
          (eq, ":troop_faction_no", "fac_player_supporters_faction"),
          (assign, ":xp_rounds", 0),
        (else_try),
          (eq, ":reduce_campaign_ai", 0), #hard
          (assign, ":xp_rounds", 2),
        (else_try),
          (eq, ":reduce_campaign_ai", 1), #moderate
          (assign, ":xp_rounds", 1),
        (else_try),
          (eq, ":reduce_campaign_ai", 2), #easy
          (assign, ":xp_rounds", 0),
        (try_end),

        (troop_get_slot, ":renown", ":troop_no", slot_troop_renown),
        (store_div, ":renown_xp_rounds", ":renown", 100),
        (val_add, ":xp_rounds", ":renown_xp_rounds"),
        (try_for_range, ":unused", 0, ":xp_rounds"),
          (call_script, "script_upgrade_hero_party", "$pout_party", 4000),
        (try_end),
      (try_end),
  ]),

  # script_create_kingdom_party_if_below_limit
  # Input: arg1 = faction_no, arg2 = party_type (variables beginning with spt_)
  # Output: reg0 = party_no
  ("create_kingdom_party_if_below_limit",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":party_type"),

      (call_script, "script_count_parties_of_faction_and_party_type", ":faction_no", ":party_type"),
      (assign, ":party_count", reg0),

      (assign, ":party_count_limit", 0),

      (faction_get_slot, ":num_towns", ":faction_no", slot_faction_num_towns),

      (try_begin),
##        (eq, ":party_type", spt_forager),
##        (assign, ":party_count_limit", 1),
##      (else_try),
##        (eq, ":party_type", spt_scout),
##        (assign, ":party_count_limit", 1),
##      (else_try),
##        (eq, ":party_type", spt_patrol),
##        (assign, ":party_count_limit", 1),
##      (else_try),
##        (eq, ":party_type", spt_messenger),
##        (assign, ":party_count_limit", 1),
##      (else_try),
        (eq, ":party_type", spt_kingdom_caravan),
        (try_begin),
          (eq, ":num_towns", 0),
          (assign, ":party_count_limit", 0),
        (else_try),
          (eq, ":num_towns", 1),
          (assign, ":party_count_limit", 1),
        (else_try),
          (eq, ":num_towns", 2),
          (assign, ":party_count_limit", 3),
        (else_try),
          (assign, ":party_count_limit", 5),
        (try_end),
        ##diplomacy begin
          #overwriting party count limit MAX(2 * X - 1, 0)
        (store_mul, ":party_count_limit", ":num_towns", 2),
        (val_sub, ":party_count_limit", 1),
        (val_max, ":party_count_limit", 0),
        ##diplomacy end

##      (else_try),
##        (eq, ":party_type", spt_prisoner_train),
##        (assign, ":party_count_limit", 1),
      (try_end),

      (assign, reg0, -1),
      (try_begin),
        (lt, ":party_count", ":party_count_limit"),
        (call_script,"script_cf_create_kingdom_party", ":faction_no", ":party_type"),
      (try_end),
  ]),


  # script_cf_create_kingdom_party
  # Input: arg1 = faction_no, arg2 = party_type (variables beginning with spt_)
  # Output: reg0 = party_no
  ("cf_create_kingdom_party",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":party_type"),

      (str_store_faction_name, s7, ":faction_no"),
      (assign, ":party_name_str", "str_no_string"),

##      (faction_get_slot, ":reinforcements_a", ":faction_no", slot_faction_reinforcements_a),
      (faction_get_slot, ":reinforcements_b", ":faction_no", slot_faction_reinforcements_b),
##      (faction_get_slot, ":reinforcements_c", ":faction_no", slot_faction_reinforcements_c),

      (try_begin),
##        (eq, ":party_type", spt_forager),
##        (assign, ":party_template", "pt_forager_party"),
#        (assign, ":party_name_str", "str_s7_foragers"),
##      (else_try),
##        (eq, ":party_type", spt_scout),
##        (assign, ":party_template", "pt_scout_party"),
#        (assign, ":party_name_str", "str_s7_scouts"),
##      (else_try),
##        (eq, ":party_type", spt_patrol),
##        (assign, ":party_template", "pt_patrol_party"),
#        (assign, ":party_name_str", "str_s7_patrol"),
##      (else_try),
        (eq, ":party_type", spt_kingdom_caravan),
        (assign, ":party_template", "pt_kingdom_caravan_party"),
#        (assign, ":party_name_str", "str_s7_caravan"),
##      (else_try),
##        (eq, ":party_type", spt_messenger),
##        (assign, ":party_template", "pt_messenger_party"),
#        (assign, ":party_name_str", "str_s7_messenger"),
##      (else_try),
##        (eq, ":party_type", spt_raider),
##        (assign, ":party_template", "pt_raider_party"),
##        (assign, ":party_name_str", "str_s7_raiders"),
##      (else_try),
##        (eq, ":party_type", spt_prisoner_train),
##        (assign, ":party_template", "pt_prisoner_train_party"),
#        (assign, ":party_name_str", "str_s7_prisoner_train"),
      (try_end),

      (assign, ":result", -1),
      (try_begin),
        (try_begin),
          (eq, ":party_type", spt_kingdom_caravan),
          (call_script,"script_cf_select_random_town_with_faction", ":faction_no", -1),
          (set_spawn_radius, 0),
        (else_try), #not used at the moment
          (call_script,"script_cf_select_random_walled_center_with_faction", ":faction_no", -1),
          (set_spawn_radius, 1),
        (try_end),
        (assign, ":spawn_center", reg0),
        (is_between, ":spawn_center", centers_begin, centers_end),
        (spawn_around_party,":spawn_center",":party_template"),
        (assign, ":result", reg0),
        (party_set_faction, ":result", ":faction_no"),
        (try_begin),
          (eq, ":party_type", spt_kingdom_caravan),
          (party_set_slot, ":result", slot_party_home_center, ":spawn_center"),
          (party_set_slot, ":result", slot_party_last_traded_center, ":spawn_center"),
		(try_end),
        (party_set_slot, ":result", slot_party_type, ":party_type"),
        (party_set_slot, ":result", slot_party_ai_state, spai_undefined),
        (try_begin),
          (neq, ":party_name_str", "str_no_string"),
          (party_set_name, ":result", ":party_name_str"),
        (try_end),

        (try_begin),
##          (eq, ":party_type", spt_forager),
##          (party_add_template, ":result", ":reinforcements_a"),
##        (else_try),
##          (eq, ":party_type", spt_scout),
##          (party_add_template, ":result", ":reinforcements_c"),
##        (else_try),
##          (eq, ":party_type", spt_patrol),
##          (party_add_template, ":result", ":reinforcements_a"),
##          (party_add_template, ":result", ":reinforcements_b"),
##        (else_try),
          (eq, ":party_type", spt_kingdom_caravan),
          (try_begin),
            (eq, ":faction_no", "fac_player_supporters_faction"),
            (party_get_slot, ":reinforcement_faction", ":spawn_center", slot_center_original_faction),
            (faction_get_slot, ":reinforcements_b", ":reinforcement_faction", slot_faction_reinforcements_b),
          (try_end),
          (party_add_template, ":result", ":reinforcements_b"),
          (party_add_template, ":result", ":reinforcements_b"),
          (party_set_ai_behavior,":result",ai_bhvr_travel_to_party),
          (party_set_ai_object,":result",":spawn_center"),
          (party_set_flags, ":result", pf_default_behavior, 1),
          (store_sub, ":item_to_price_slot", slot_town_trade_good_prices_begin, trade_goods_begin),
          (try_for_range, ":cur_goods", trade_goods_begin, trade_goods_end),
            (store_add, ":cur_goods_price_slot", ":cur_goods", ":item_to_price_slot"),
            (party_set_slot, ":result", ":cur_goods_price_slot", average_price_factor),
          (try_end),
##        (else_try),
##          (eq, ":party_type", spt_messenger),
##          (faction_get_slot, ":messenger_troop", ":faction_no", slot_faction_messenger_troop),
##          (party_add_leader, ":result", ":messenger_troop"),
##          (party_set_ai_behavior,":result",ai_bhvr_travel_to_party),
##          (party_set_ai_object,":result",":spawn_center"),
##          (party_set_flags, ":result", pf_default_behavior, 0),
##        (else_try),
##          (eq, ":party_type", spt_raider),
##          (party_add_template, ":result", ":reinforcements_c"),
##          (party_add_template, ":result", ":reinforcements_b"),
##          (party_add_template, ":result", "pt_raider_captives"),
##        (else_try),
##          (eq, ":party_type", spt_prisoner_train),
##          (party_add_template, ":result", ":reinforcements_b"),
##          (party_add_template, ":result", ":reinforcements_a"),
##          (try_begin),
##            (call_script,"script_cf_faction_get_random_enemy_faction",":faction_no"),
##            (store_random_in_range,":r",0,3),
##            (try_begin),
##              (lt, ":r", 1),
##              (faction_get_slot, ":captive_reinforcements", reg0, slot_faction_reinforcements_b),
##            (else_try),
##              (faction_get_slot, ":captive_reinforcements", reg0, slot_faction_reinforcements_a),
##            (try_end),
##            (party_add_template, ":result", ":captive_reinforcements",1),
##          (else_try),
##            (party_add_template, ":result", "pt_default_prisoners"),
##          (try_end),
        (try_end),
      (try_end),
      (ge, ":result", 0),
      (assign, reg0, ":result"),
  ]),

  # script_get_troop_attached_party
  # Input: arg1 = troop_no
  # Output: reg0 = party_no (-1 if troop's party is not attached to a party)
  ("get_troop_attached_party",
    [
      (store_script_param_1, ":troop_no"),

      (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
      (assign, ":attached_party_no", -1),
      (try_begin),
        (ge, ":party_no", 0),
        (party_get_attached_to, ":attached_party_no", ":party_no"),
      (try_end),
      (assign, reg0, ":attached_party_no"),
  ]),


  # script_center_get_food_consumption
  # Input: arg1 = center_no
  # Output: reg0: food consumption (1 food item counts as 100 units)
  ("center_get_food_consumption",
    [
      (store_script_param_1, ":center_no"),
      (assign, ":food_consumption", 0),
      (try_begin),
        (party_slot_eq, ":center_no", slot_party_type, spt_town),
        (assign, ":food_consumption", 500),
      (else_try),
        (party_slot_eq, ":center_no", slot_party_type, spt_castle),
        (assign, ":food_consumption", 50),
      (try_end),
      ##diplomacy start+
      (try_begin),
         (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_MEDIUM),
		 #Optional change: increase food consumption with garrison size
		 #The rationale goes like this:
		 #The average reinforcement size for a town or castle is 9.5 per round.
		 #At the start of the game:
		 #
		 #  Castles get 15 reinforcement rounds, for around 142.5 troops
		 #  Towns   get 40 reinforcement rounds, for around 380 troops
		 #
		 #Of course both the castles and the towns have other people living
		 #there as well.
		 (party_get_num_companions, ":garrison_size", ":center_no"),
		 (try_begin),
			(party_slot_eq, ":center_no", slot_party_type, spt_castle),
			(gt, ":garrison_size", 150),
			#Assume that the garrison accounts for most of the food consumption.
			(store_div, ":food_consumption", ":garrison_size", 3),
		 (else_try),
			(party_slot_eq, ":center_no", slot_party_type, spt_town),
			(gt, ":garrison_size", 380),
			#Assume that the garrison makes the same contribution to size for towns.
			(store_div, ":food_consumption", ":garrison_size", 3),#for 381, equals 127
			(val_add, ":food_consumption", 500 - 127),
		 (try_end),

		 #Optional change: increase food consumption with prosperity
		 (party_slot_eq, ":center_no", slot_party_type, spt_town),
         (party_get_slot, reg0, ":center_no", slot_town_prosperity),
			(gt, reg0, 50),#<- increase only
         (val_add, reg0, 75),
         (val_mul, ":food_consumption", reg0),
         (val_add, ":food_consumption", 62),
         (val_div, ":food_consumption", 125),
      (try_end),
      ##diplomacy+
      (assign, reg0, ":food_consumption"),
  ]),

  # script_center_get_food_store_limit
  # Input: arg1 = center_no
  # Output: reg0: food consumption (1 food item counts as 100 units)
  ("center_get_food_store_limit",
    [
      (store_script_param_1, ":center_no"),
      (assign, ":food_store_limit", 0),
      (try_begin),
        (party_slot_eq, ":center_no", slot_party_type, spt_town),
        (assign, ":food_store_limit", 50000),
      (else_try),
        (party_slot_eq, ":center_no", slot_party_type, spt_castle),
        (assign, ":food_store_limit", 1500),
      (try_end),
      (assign, reg0, ":food_store_limit"),
  ]),

  # script_refresh_village_merchant_inventory
  # Input: arg1 = village_no
  # Output: none
  ("refresh_village_merchant_inventory",
    [
      (store_script_param_1, ":village_no"),
      (party_get_slot, ":merchant_troop", ":village_no", slot_town_elder),
      (reset_item_probabilities,0),

	  (party_get_slot, ":bound_center", ":village_no", slot_village_bound_center),

	  (assign, ":total_probability", 0),
      (try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
	    (call_script, "script_center_get_production", ":village_no", ":cur_good"),
		(assign, ":cur_probability", reg0),

        (call_script, "script_center_get_production", ":bound_center", ":cur_good"),
		(val_div, reg0, 5), #also add 1/5 of bound center production to village's inventory.
		(val_add, ":cur_probability", reg0),

		(val_max, ":cur_probability", 5),
		(val_add, ":total_probability", ":cur_probability"),
      (try_end),

	  (try_begin),
		(party_get_slot, ":prosperity", ":village_no", slot_town_prosperity),
		(val_div, ":prosperity", 15), #up to 6
		(store_add, ":number_of_items_in_village", ":prosperity", 1),
	  (try_end),

      (try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
	    (call_script, "script_center_get_production", ":village_no", ":cur_good"),
		(assign, ":cur_probability", reg0),

        (call_script, "script_center_get_production", ":bound_center", ":cur_good"),
		(val_div, reg0, 5), #also add 1/5 of bound center production to village's inventory.
		(val_add, ":cur_probability", reg0),

		(val_max, ":cur_probability", 5),
        (val_mul, ":cur_probability", ":number_of_items_in_village"),
		(val_mul, ":cur_probability", 100),
		(val_div, ":cur_probability", ":total_probability"),

        (set_item_probability_in_merchandise, ":cur_good", ":cur_probability"),
      (try_end),

      #SB : probably do something like trash item at base values
      (troop_clear_inventory, ":merchant_troop"),
      (troop_add_merchandise, ":merchant_troop", itp_type_goods, ":number_of_items_in_village"),
      (troop_ensure_inventory_space, ":merchant_troop", 80),

      #Adding 1 prosperity to the village while reducing each 3000 gold from the elder
      (store_troop_gold, ":gold",":merchant_troop"),
      (try_begin),
        (gt, ":gold", 3500),
        (store_div, ":prosperity_added", ":gold", 3000),
        (store_mul, ":gold_removed", ":prosperity_added", 3000),
        (troop_remove_gold, ":merchant_troop", ":gold_removed"),
        (call_script, "script_change_center_prosperity", ":village_no", ":prosperity_added"),
      (try_end),
  ]),

  # script_refresh_village_defenders
  # Input: arg1 = village_no
  # Output: none
  ("refresh_village_defenders",
    [
      (store_script_param_1, ":village_no"),

      (assign, ":ideal_size", 50),
      (try_begin),
        (party_get_num_companions, ":party_size", ":village_no"),
        (lt, ":party_size", ":ideal_size"),
        #SB : add restriction of not reinforcing while looted or infested
        (call_script, "script_cf_village_normal_cond", ":village_no"),
        (party_add_template, ":village_no", "pt_village_defenders"),

        (try_begin), #SB : upgrade into watchmen, each template had at least 10 farmers
          (party_slot_ge, ":village_no", slot_center_has_watch_tower, 1),
          (party_count_companions_of_type, ":count", ":village_no", "trp_watchman"),
          (lt, ":count", 10),
          (store_random_in_range, ":random_no", 2, 5),
          (party_add_members, ":village_no", "trp_watchman", ":random_no"),
          (party_remove_members, ":village_no", "trp_farmer"),
        (try_end),
        (try_begin), #SB : add messenger
          (party_slot_ge, ":village_no", slot_center_has_messenger_post, 1),
          (store_faction_of_party, ":faction_no", ":village_no"),
          (assign, ":troop", "trp_dplmc_messenger"),
          (try_begin),
            (is_between, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
            (faction_get_slot, ":troop", ":faction_no", slot_faction_messenger_troop),
          (try_end),
          (party_count_companions_of_type, ":count", ":village_no", ":troop"),
          (lt, ":count", 1),
          (party_add_members, ":village_no", ":troop", 1),
        (try_end),
      (try_end),
  ]),

  # script_village_set_state
  # Input: arg1 = center_no arg2:new_state
  # Output: reg0: food consumption (1 food item counts as 100 units)
  ("village_set_state",
    [
      (store_script_param_1, ":village_no"),
      (store_script_param_2, ":new_state"),
      ##diplomacy start+
      (store_current_hours, ":hours"),
      (party_get_slot, ":attacker_party", ":village_no", slot_village_raided_by),
      (try_begin),
        (ge, ":attacker_party", 0),
        (party_is_active, ":attacker_party"),#added 2011-06-07
        (party_stack_get_troop_id, ":attack_leader", ":attacker_party", 0),
        (ge, ":attack_leader", 0),
        (party_set_slot, ":village_no", dplmc_slot_center_last_attacked_time, ":hours"),
        (party_set_slot, ":village_no", dplmc_slot_center_last_attacker, ":attack_leader"),


        (try_begin),
          (this_or_next|eq, ":new_state", svs_looted),
          (eq, ":new_state", svs_deserted),
          #SB : there's a fire whether real or fake, we set the bounding center to have guards investigate
          (try_begin),
            (party_get_slot, ":bound_center", ":village_no", slot_village_bound_center),
            (is_between, ":bound_center", centers_begin, centers_end),
            (party_set_slot, ":bound_center", slot_town_last_nearby_fire_time, ":hours"),
          (try_end),
          #SB : quest state
          (try_begin),
            (check_quest_active, "qst_hunt_down_fugitive"),
            (quest_slot_eq, "qst_hunt_down_fugitive", slot_quest_target_center, ":village_no"),
            #if we found and knocked him out in mission template this won't fire
            (neg|check_quest_succeeded, "qst_hunt_down_fugitive"),
            (neg|check_quest_failed, "qst_hunt_down_fugitive"),
            (quest_set_slot, "qst_hunt_down_fugitive", slot_quest_current_state, 3),
            (try_begin), #conclude quest if village raided
              (neq, ":attacker_party", "p_main_party"),
              (call_script, "script_conclude_quest", "qst_hunt_down_fugitive"),
            (else_try), #player raided village for some reason
              (call_script, "script_succeed_quest", "qst_hunt_down_fugitive"),
            (try_end),
          (try_end),
        (try_end),
      (try_end),
      ##diplomacy end+

      (try_begin),
        (eq, ":new_state", svs_normal),
        (party_set_extra_text, ":village_no", "str_empty_string"),
        #SB : redo village recruits immediately
        (try_begin),
          (this_or_next|le, ":attacker_party", 0),
          (neg|party_is_active, ":attacker_party"),
          (is_between, ":village_no", villages_begin, villages_end), #dckplmc
          (call_script, "script_update_volunteer_troops_in_village", ":village_no"),
          (call_script, "script_update_npc_volunteer_troops_in_village", ":village_no"),
        (try_end),
        (party_set_slot, ":village_no", slot_village_raided_by, -1),
      (else_try),
        (eq, ":new_state", svs_being_raided),
        (party_set_extra_text, ":village_no", "@(Being Raided)"),
      (else_try), #SB : deserted state as alternative to full looting
        (eq, ":new_state", svs_deserted),
        (party_set_extra_text, ":village_no", "@(Deserted)"),

        (party_set_slot, ":village_no", slot_village_raided_by, -1),
        (call_script, "script_change_center_prosperity", ":village_no", -20),
		(val_add, "$newglob_total_prosperity_from_villageloot", -20),
      (else_try),
        (eq, ":new_state", svs_looted),
        (party_set_extra_text, ":village_no", "@(Looted)"),

        (party_set_slot, ":village_no", slot_village_raided_by, -1),
        (call_script, "script_change_center_prosperity", ":village_no", -60),
		(val_add, "$newglob_total_prosperity_from_villageloot", -60),

		# (try_begin), #optional - lowers the relationship between a lord and his liege if his fief is looted
			# (eq, 5, 0),
			# (party_get_slot, ":town_lord", ":village_no", slot_town_lord),
			# (is_between, ":town_lord", active_npcs_begin, active_npcs_end),
			# (store_faction_of_troop, ":town_lord_faction", ":town_lord"),
			# (faction_get_slot, ":faction_leader", ":town_lord_faction", slot_faction_leader),
			# (call_script, "script_troop_change_relation_with_troop", ":town_lord", ":faction_leader", -1),
			# (val_add, "$total_battle_ally_changes", -1),
		# (try_end),
      (else_try),
        (eq, ":new_state", svs_under_siege),
        (party_set_extra_text, ":village_no", "@(Under Siege)"),

		#Divert all caravans heading to the center
		#Note that occasionally, no alternative center will be found. In that case, the caravan will try to run the blockade
		(try_for_parties, ":party_no"),
			(gt, ":party_no", "p_spawn_points_end"),
			(party_slot_eq, ":party_no", slot_party_type, spt_kingdom_caravan),
            (party_slot_eq, ":party_no", slot_party_ai_object, ":village_no"),

			(party_get_slot, ":origin", ":party_no", slot_party_last_traded_center),
			(store_faction_of_party, ":merchant_faction", ":party_no"),
            ##diplomacy start+ added new third parameter, the caravan party itself
            (call_script, "script_cf_select_most_profitable_town_at_peace_with_faction_in_trade_route", ":origin", ":merchant_faction",":party_no"),
			##diplomacy end+
            (assign, ":target_center", reg0),
			(is_between, ":target_center", centers_begin, centers_end),

            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_party),
            (party_set_ai_object, ":party_no", ":target_center"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", slot_party_ai_state, spai_trading_with_town),
            (party_set_slot, ":party_no", slot_party_ai_object, ":target_center"),
		(try_end),
      (try_end),
      (party_set_slot, ":village_no", slot_village_state, ":new_state"),
  ]),


  # script_process_village_raids
  # Input: none
  # Output: none
  # called from triggers every two hours
  ("process_village_raids",
    [
       ##diplomacy start+
       (store_current_hours, ":hours"),
       ##diplomacy end+
       (game_get_reduce_campaign_ai, ":reduce_campaign_ai"), #SB: also move to top
       (try_for_range, ":village_no", villages_begin, villages_end),
        ##CABA Fix
        (try_begin),
          (this_or_next|is_between, ":village_no", "p_village_16", "p_village_23"), #Shapeshte through Shulus (up to Ilvia)
          (this_or_next|is_between, ":village_no", "p_village_49", "p_village_51"), #Tismirr and Karindi
          (this_or_next|eq, ":village_no", "p_village_75"), #Bhulaban
          (is_between, ":village_no", "p_village_85", "p_village_87"), #Ismirala and Slezkh
          (assign, ":normal_village_icon", "icon_village_snow_a"),
          (assign, ":burnt_village_icon", "icon_village_snow_burnt_a"),
          (assign, ":deserted_village_icon", "icon_village_snow_deserted_a"),
        (else_try),
          (is_between, ":village_no", "p_village_91", "p_salt_mine"), #Ayn Assuadi through Rushdigh
          (assign, ":normal_village_icon", "icon_village_c"),
          (assign, ":burnt_village_icon", "icon_village_burnt_c"),
          (assign, ":deserted_village_icon", "icon_village_deserted_c"),
        (else_try),
          (assign, ":normal_village_icon", "icon_village_a"),
          (assign, ":burnt_village_icon", "icon_village_burnt_a"),
          (assign, ":deserted_village_icon", "icon_village_deserted_a"),
        (try_end),
        ##CABA Fix
         (party_get_slot, ":village_raid_progress", ":village_no", slot_village_raid_progress),
         (try_begin),
           (party_slot_eq, ":village_no", slot_village_state, svs_normal), #village is normal
           (val_sub, ":village_raid_progress", 5),
           (val_max, ":village_raid_progress", 0),
           (party_set_slot, ":village_no", slot_village_raid_progress, ":village_raid_progress"),
           (try_begin),
             (lt, ":village_raid_progress", 50),

             (try_begin),
              (party_get_icon, ":village_icon", ":village_no"),
              (neq, ":village_icon", ":normal_village_icon"), ##CABA FIX
              (party_set_icon, ":village_no", ":normal_village_icon"), ##CABA FIX
             (try_end),

             (party_slot_ge, ":village_no", slot_village_smoke_added, 1),
             (party_set_slot, ":village_no", slot_village_smoke_added, 0),
             (party_clear_particle_systems, ":village_no"),
           (try_end),
         (else_try),
           (party_slot_eq, ":village_no", slot_village_state, svs_being_raided), #village is being raided
           #End raid unless there is an enemy party nearby
           (assign, ":raid_ended", 1),
           (party_get_slot, ":raider_party", ":village_no", slot_village_raided_by),
           # (call_script, "script_party_count_fit_regulars", ":village_no"), #SB : calculate cur size
           # (assign, ":villager_count", reg0),
           # (party_get_num_companions, ":villager_count", ":village_no"), #SB : calculate cur size, including wounded
           (call_script, "script_party_calculate_strength", ":village_no", 0),
           (store_div, ":village_strength", reg0, 2),
           (try_begin),
             (ge, ":raider_party", 0),
             (party_is_active, ":raider_party"),
             (party_stack_get_troop_id, ":raid_leader", ":raider_party", 0), #SB : moved to top
             (this_or_next|neq, ":raider_party", "p_main_party"),
             (eq, "$g_player_is_captive", 0),
             #SB : strength conditional, player bypasses this however since they actually fought
             (call_script, "script_party_calculate_strength", ":raider_party", 0),
             (this_or_next|eq, ":raider_party", "p_main_party"), #player raiding conditions are different
             (ge, reg0, ":village_strength"),
             # (party_slot_ge, ":raider_party", slot_party_cached_strength, ":village_strength"),
             (store_distance_to_party_from_party, ":distance", ":village_no", ":raider_party"),
             (lt, ":distance", raid_distance),
             (party_get_battle_opponent, ":raid_opponent", ":raider_party"), #dckplmc
             (lt, ":raid_opponent", 0), #continue raid only if there is no opposition
             (assign, ":raid_ended", 0),
           (try_end),

           (try_begin),
             (eq, ":raid_ended", 1),
             (call_script, "script_village_set_state", ":village_no", svs_normal), #clear raid flag
             (party_set_slot, ":village_no", slot_village_smoke_added, 0),
             (party_clear_particle_systems, ":village_no"),
           (else_try),
             (assign, ":raid_progress_increase", 11),
             (party_get_slot, ":looter_party", ":village_no", slot_village_raided_by),
             (try_begin),
               (party_get_skill_level, ":looting_skill", ":looter_party", "skl_looting"),
               (val_add, ":raid_progress_increase", ":looting_skill"),
             (try_end),
             (try_begin),
               (party_slot_eq, ":village_no", slot_center_has_watch_tower, 1),
               (val_mul, ":raid_progress_increase", 2),
               (val_div, ":raid_progress_increase", 3),
             (try_end),
             (val_add, ":village_raid_progress", ":raid_progress_increase"),
             #SB : delay construction while being looted
             (try_begin),
               (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
               (party_slot_ge, ":village_no", slot_center_current_improvement, 1),
               (party_get_slot, ":cur_improvement_end_time", ":village_no", slot_center_improvement_end_hour),
               (store_div, ":delay", ":raid_progress_increase", 3),
               (try_begin),
                 (party_slot_eq, ":village_no", slot_town_lord, "trp_player"),
                 (val_sub, ":delay", ":reduce_campaign_ai"),
               (try_end),
               (val_clamp, ":delay", 2, 8), #delayed for at least duration of raid
               (val_add, ":cur_improvement_end_time", ":delay"),
             (try_end),
             (party_set_slot, ":village_no", slot_village_raid_progress, ":village_raid_progress"),
             (try_begin),
               (ge, ":village_raid_progress", 50),
               (party_slot_eq, ":village_no", slot_village_smoke_added, 0),
               (party_add_particle_system, ":village_no", "psys_map_village_fire"),
               (party_add_particle_system, ":village_no", "psys_map_village_fire_smoke"),
               (party_set_icon, ":village_no", ":burnt_village_icon"), ##CABA FIX
               (party_set_slot, ":village_no", slot_village_smoke_added, 1),
             (try_end),
			 ##diplomacy start+ set values of slots
			 (try_begin),
				(ge, ":looter_party", 0),
				# (party_stack_get_troop_id, ":raid_leader", ":looter_party", 0),
				(ge, ":raid_leader", 0),
				(party_set_slot, ":village_no", dplmc_slot_center_last_attacked_time, ":hours"),
				(party_set_slot, ":village_no", dplmc_slot_center_last_attacker, ":raid_leader"),
			 (try_end),
             (assign, ":raid_total_captured", 0),
             (try_begin), #SB : enslavement mode
               (eq, ":looter_party", "p_main_party"),
               (party_slot_eq, ":village_no", slot_town_last_nearby_fire_time, 2), #enslavement mode

               #do some wounding first, in the first iteration all wounded from the initial encounter will be grabbed
               (store_random_in_range, ":random_no", ":reduce_campaign_ai", 4), #0 to 2 up to 3 per iteration
               (party_wound_members, ":village_no", "trp_farmer", ":random_no"),
               #(val_mul, ":random_no", 2),
               #(val_div, ":random_no", 3),
               (party_wound_members, ":village_no", "trp_peasant_woman", ":random_no"),

               #this is only effective for p_main_party anyway
               (call_script, "script_game_get_party_prisoner_limit", ":looter_party"),
               (assign, ":prisoner_limit", reg0),
               (party_get_num_prisoners, ":num_prisoners", ":looter_party"),
               (val_sub, ":prisoner_limit", ":num_prisoners"),

               (party_get_num_companion_stacks, ":num_stacks", ":village_no"),
               # (assign, ":num_wounded", 0),
               (party_get_slot, ":village_raid_progress", ":village_no", slot_village_raid_progress),
               (try_for_range_backwards, ":stack_no", 0, ":num_stacks"), #backwards to enslave women first
                 (party_stack_get_num_wounded, ":cur_wounded",":village_no",":stack_no"),
                 (gt, ":cur_wounded", 0),
                 (party_stack_get_troop_id, ":stack_troop",":village_no",":stack_no"),

                 (try_begin),
                    (lt, ":prisoner_limit", ":cur_wounded"),
                    (val_add, ":raid_total_captured", ":prisoner_limit"),
                    (party_remove_members_wounded_first, ":village_no", ":stack_troop", ":prisoner_limit"),
                    (party_add_prisoners, "p_main_party", ":stack_troop", ":prisoner_limit"),
                 (else_try),
                    (val_add, ":raid_total_captured", ":cur_wounded"),
                    (party_remove_members_wounded_first, ":village_no", ":stack_troop", ":cur_wounded"),
                    (party_add_prisoners, "p_main_party", ":stack_troop", ":cur_wounded"),
                 (try_end),

                 (try_begin),
                   (val_sub, ":prisoner_limit", ":cur_wounded"),
                   (le, ":prisoner_limit", 0),
                   (assign, ":num_stacks", 0),
                 (try_end),
               (try_end),
               (assign, reg1, ":raid_total_captured"),
               (try_begin),
                 (neq, reg1, 0),
                 (display_message, "@Captured {reg1} villagers."),
                 (val_add, "$qst_eliminate_bandits_infesting_village_num_villagers", ":raid_total_captured"),
               (try_end),
               (try_begin),
                 (party_get_num_companions, ":amount", ":village_no"),
                 (this_or_next|eq, ":amount", 0), #we have captured all
                 (eq, ":num_stacks", 0), #we have captured too many and broke the loop
                 (assign, ":raid_total_captured", -1), #mark this condition for later
               (else_try),
                 #for each three prisoner taken we move back the counter a bit
                 (store_div, ":amount", ":raid_total_captured", 3),
                 (val_sub, ":village_raid_progress", ":amount"),
                 (party_set_slot, ":village_no", slot_village_raid_progress, ":village_raid_progress"),
               (try_end),
             (try_end),
             #SB : probably spawn random refugees here as the raid progresses
             ##diplomacy end+
             #SB : add in enslavement function at around 75% completion, simulate each level taking off 0.5 hour
             #if the looting skill is too high we won't capture as many peasants
             (try_begin),
               (eq, ":looter_party", "p_main_party"),
               (party_slot_eq, ":village_no", slot_town_last_nearby_fire_time, 2), #enslavement mode
               (party_get_skill_level, ":management", ":looter_party", "skl_prisoner_management"),
               (val_mul, ":management", 5), #0 to 50 to 75
               (val_div, ":management", 3), #around 25
               (store_sub, ":threshold", 90, ":management"), #make sure this is before regular looting completes
               # (party_get_num_companions, ":amount", ":village_no"),
               # (party_get_free_prisoners_capacity, ":capacity", "p_main_party"), #or use previous calculation
               # (this_or_next|le, ":amount", 0), #we have wounded and captured all inhabitants
               # (this_or_next|le, ":capacity", 0), #we have no more room for capturing
               (this_or_next|eq, ":raid_total_captured", -1),
               (gt, ":village_raid_progress", ":threshold"),

               (str_store_party_name_link, s1, ":village_no"),
               (str_store_troop_name_link, s2, ":raid_leader"),
               (store_faction_of_party, ":village_faction", ":village_no"),
               (faction_get_color, ":color", ":village_faction"),
               (display_log_message, "@The village of {s1} has been sacked by {s2}.", ":color"),

               (try_begin),
                 (party_get_slot, ":village_lord", ":village_no", slot_town_lord),
                 (is_between, ":village_lord", active_npcs_begin, active_npcs_end),
                 (call_script, "script_troop_change_relation_with_troop", ":raid_leader", ":village_lord", -1),
                 (val_add, "$total_battle_enemy_changes", -1),
               (try_end),
               (call_script, "script_village_set_state",  ":village_no", svs_deserted), #not svs_looted, less prosperity decrease
               # (party_set_slot, ":village_no", slot_center_accumulated_rents, 0),
               # (party_set_slot, ":village_no", slot_center_accumulated_tariffs, 0),
               (party_set_slot, ":village_no", slot_village_raid_progress, 0),
               (party_set_slot, ":village_no", slot_village_recover_progress, 50), #SB : jumps directly to deserted icon, not burnt
               (party_set_slot, ":village_no", slot_village_smoke_added, 2), #to force trigger the icon

               (try_begin), #SB : this crippled lords too much
                 (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_HIGH),
                 (party_set_slot, ":village_no", slot_center_volunteer_troop_type, -1),
                 (party_set_slot, ":village_no", slot_center_volunteer_troop_amount, -1),
                 (party_set_slot, ":village_no", slot_center_npc_volunteer_troop_type, -1),
                 (party_set_slot, ":village_no", slot_center_npc_volunteer_troop_amount, -1),
               (try_end),
               (call_script, "script_add_log_entry", logent_village_raided, ":raid_leader",  ":village_no", -1, -1),
               (store_faction_of_party, ":looter_faction", ":looter_party"), #enslavement less severe than plundering
               (call_script, "script_faction_inflict_war_damage_on_faction", ":looter_faction", ":village_faction", 4),
             (else_try),
               (gt, ":village_raid_progress", 100),
               (str_store_party_name_link, s1, ":village_no"),
               # (party_stack_get_troop_id, ":raid_leader", ":looter_party", 0), #SB : move to top
               (ge, ":raid_leader", 0),
               #SB : colorize, string link
               # (str_store_party_name, s2, ":looter_party"),
               (try_begin),
                 (troop_is_hero, ":raid_leader"),
                 (str_store_troop_name_link, s2, ":raid_leader"),
               (else_try),
                 (str_store_party_name, s2, ":looter_party"),
               (try_end),
               (store_faction_of_party, ":village_faction", ":village_no"),
               (faction_get_color, ":color", ":village_faction"),
               (display_log_message, "@The village of {s1} has been looted by {s2}.", ":color"),

               #refugees
               (set_spawn_radius, 2),
               (spawn_around_party, ":village_no", "pt_refugees"),
               (assign, ":refugee_party", reg0),
               (party_add_template, ":refugee_party", "pt_village_farmers"),
               (party_add_template, ":refugee_party", "pt_village_farmers"),
               (party_set_faction, ":refugee_party", ":village_faction"),
               (assign, ":minimum_distance", 1000000),
               #SB : get rid of useless range
               (store_random_in_range, ":nearest_ally_city", walled_centers_begin, walled_centers_end),
               (try_for_range, ":party_no", walled_centers_begin, walled_centers_end),
                 (party_get_position, pos1, ":party_no"),
                 (store_distance_to_party_from_party, ":dist", ":party_no", ":village_no"),
                 (try_begin),
                   (lt, ":dist", ":minimum_distance"),
                   (assign, ":minimum_distance", ":dist"),
                   (assign, ":nearest_ally_city", ":party_no"),
                 (try_end),
               (try_end),
               (party_set_ai_behavior, ":refugee_party", ai_bhvr_travel_to_party),
               (party_set_ai_object, ":refugee_party", ":nearest_ally_city"),
               (party_set_slot, ":refugee_party", slot_party_home_center, ":village_no"),

               (try_begin),
                 (party_get_slot, ":village_lord", ":village_no", slot_town_lord),
                 (is_between, ":village_lord", active_npcs_begin, active_npcs_end),
                 (call_script, "script_troop_change_relation_with_troop", ":raid_leader", ":village_lord", -1),
                 (val_add, "$total_battle_enemy_changes", -1),
               (try_end),

               #give loot gold to raid leader
               (troop_get_slot, ":raid_leader_gold", ":raid_leader", slot_troop_wealth),
			   ##diplomacy start+
			   #How did the next line ever work?  isn't it missing a slot number?!
               #  (party_get_slot, ":village_prosperity", ":village_no"),
			   #Replace it with the following:
			   (party_get_slot, ":village_prosperity", ":village_no", slot_town_prosperity),
			   ##diplomacy end+
               (store_mul, ":value_of_loot", ":village_prosperity", 60), #average is 3000
               (val_add, ":raid_leader_gold", ":value_of_loot"),
               (troop_set_slot, ":raid_leader", slot_troop_wealth, ":raid_leader_gold"),
			   (try_begin),
				   (eq, "$cheat_mode", 2),
				   (assign, reg2, ":raid_leader_gold"),
				   (str_store_troop_name_link, s2, ":raid_leader"),
				   (display_message, "@{s2} now has {reg2} denars from raiding"),#SB : debug
               (try_end),
               #take loot gold from village lord #new 1.126
			   ##diplomacy start+
			   #With economic changes enabled, this will first withdraw from accumulated taxes at center
               (try_begin),
				 #To support the possibility of kingdom_ladies becoming enfeoffed, changed the
				 #below line from active_npcs_begin/active_npcs_end to heroes_begin/heroes_end
                 (is_between, ":village_lord", heroes_begin, heroes_end),
				 (neq, ":village_lord", "trp_kingdom_heroes_including_player_begin"),
                 (troop_get_slot, ":village_lord_gold", ":village_lord", slot_troop_wealth),
				 (try_begin),
					#Optional behavior: subtract the looted wealth from the village's uncollected
					#rents and tariffs
					(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_HIGH),#<-- check experimental changes are enabled
					(assign, ":gold_lost_by_lord", ":value_of_loot"),
					#Accumulated rents & tariffs get zeroed further down, so we don't need to worry
					#about modifying the slot's value to reflect the loss.
					(party_get_slot, ":x", ":village_no", slot_center_accumulated_rents),
					(val_max, ":x", 0),
					(val_sub, ":gold_lost_by_lord", ":x"),
					(party_get_slot, ":x", ":village_no", slot_center_accumulated_tariffs),
					(val_max, ":x", 0),
					(val_sub, ":gold_lost_by_lord", ":x"),
					#Only then subtract the remainder from the lord
					(val_max, ":gold_lost_by_lord", 0),
					(val_sub, ":village_lord_gold", ":gold_lost_by_lord"),
				 (else_try),
					#Unaltered behavior
					(val_sub, ":village_lord_gold", ":value_of_loot"),
				 (try_end),
				 #Apply the gold change
                 (val_max, ":village_lord_gold", 0),
                 (troop_set_slot, ":village_lord", slot_troop_wealth, ":village_lord_gold"),
                 (try_begin),
                    (eq, "$cheat_mode", 2),
                     (assign, reg2, ":village_lord_gold"),
                     (str_store_troop_name_link, s2, ":village_lord"),
                     (display_message, "@{s2} now has {reg2} denars from being raided"),#SB : debug
                 (try_end),
			   (else_try),
			      #Option: player loses gold when his fiefs are raided, just as an NPC does
				  #(default behavior in Native is the player loses no gold).  The gold is
				  #lost from the treasury, and is reduced by uncollected taxes.
				  #
				  #Only do this if the option is explicitly enabled and the player has
				  # a chamberlain.
				  (eq, ":village_lord", "trp_player"),
				  (gt, "$g_player_chamberlain", 0),#check the player has a chamberlain
			      (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_MEDIUM),#<-- check experimental changes are enabled
				  (party_slot_eq, ":village_no", slot_town_lord, "trp_player"),
				  #Do some double-checking, to avoid potential erroneous gold loss
				  #if some careless code has improperly left the "slot_town_lord"
				  #slot of the village initialized to zero.
				  (store_faction_of_party, ":village_faction", ":village_no"),
				 ##diplomacy start+ Handle player is co-ruler of faction
				 (assign, ":is_coruler", 0),
 				 (try_begin),
				    (eq, ":village_faction", "$players_kingdom"),
					(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
					(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
					(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
					(assign, ":is_coruler", 1),
				 (try_end),
				 (this_or_next|eq, ":is_coruler", 1),
				 ##diplomacy end+
				  (this_or_next|eq, "fac_player_supporters_faction", ":village_faction"),
				     (eq, "$players_kingdom", ":village_faction"),
				  #Adjust the amount lost by difficulty setting.
				  (assign, ":gold_lost_by_lord", ":value_of_loot"),
				  # (game_get_reduce_campaign_ai, ":reduce_campaign_ai"), #SB: move to top
				  (try_begin),
				    (eq, ":reduce_campaign_ai", 0),#hard, 125% loss
					(val_mul, ":gold_lost_by_lord", 5),
					(val_div, ":gold_lost_by_lord", 4),
				  (else_try),
					(eq, ":reduce_campaign_ai", 1),#medium, 100% loss
				  (else_try),
					(eq, ":reduce_campaign_ai", 2),#easy, 50% loss
					(val_div, ":gold_lost_by_lord", 2),
				  (try_end),

				  #First defray the lost gold with rents and tarriffs from the village
				  (party_get_slot, ":x", ":village_no", slot_center_accumulated_rents),
				  (val_max, ":x", 0),
				  (val_sub, ":gold_lost_by_lord", ":x"),
				  (party_get_slot, ":x", ":village_no", slot_center_accumulated_tariffs),
				  (val_max, ":x", 0),
				  (val_sub, ":gold_lost_by_lord", ":x"),
				  (val_max, ":gold_lost_by_lord", 0),
				  #Remove the remainder (if any) from the player's treasury
				  (store_troop_gold, ":x", "trp_household_possessions"),
				  (val_min, ":gold_lost_by_lord", ":x"),
				  (ge, ":gold_lost_by_lord", 1),
				  (call_script, "script_dplmc_withdraw_from_treasury", ":gold_lost_by_lord"),
               (try_end),
			   ##diplomacy end+

               (call_script, "script_village_set_state",  ":village_no", svs_looted),
               (party_set_slot, ":village_no", slot_center_accumulated_rents, 0), #new 1.126
               (party_set_slot, ":village_no", slot_center_accumulated_tariffs, 0), #new 1.126

               (party_set_slot, ":village_no", slot_village_raid_progress, 0),
               (party_set_slot, ":village_no", slot_village_recover_progress, 0),

               #SB : also get rid of recruits, technically they should have perished in the fighting
               (try_begin), #SB : this crippled lords too much
                 (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_HIGH),
                 (party_set_slot, ":village_no", slot_center_volunteer_troop_type, -1),
                 (party_set_slot, ":village_no", slot_center_volunteer_troop_amount, -1),
                 (party_set_slot, ":village_no", slot_center_npc_volunteer_troop_type, -1),
                 (party_set_slot, ":village_no", slot_center_npc_volunteer_troop_amount, -1),
               (try_end),
               #finally clear the party
               # (party_clear, ":village_no"),
               (call_script, "script_party_wound_all_members", ":village_no"),
               (try_begin),
                 (store_faction_of_party, ":village_faction", ":village_no"),
				 ##diplomacy start+ Handle player is co-ruler of faction
				 (assign, ":is_coruler", 0),
 				 (try_begin),
				    (eq, ":village_faction", "$players_kingdom"),
					(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
					(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
					(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
					(assign, ":is_coruler", 1),
				 (try_end),
				 (this_or_next|eq, ":is_coruler", 1),
				 ##diplomacy end+
                 (this_or_next|party_slot_eq, ":village_no", slot_town_lord, "trp_player"),
                 (eq, ":village_faction", "fac_player_supporters_faction"),
                 (call_script, "script_add_notification_menu", "mnu_notification_village_raided", ":village_no", ":raid_leader"),
               (try_end),
               (call_script, "script_add_log_entry", logent_village_raided, ":raid_leader",  ":village_no", -1, -1),
               (store_faction_of_party, ":looter_faction", ":looter_party"),
               (call_script, "script_faction_inflict_war_damage_on_faction", ":looter_faction", ":village_faction", 5),
             (try_end),
           (try_end),
         (else_try),
           (this_or_next|party_slot_eq, ":village_no", slot_village_state, svs_looted), #village is looted
           (party_slot_eq, ":village_no", slot_village_state, svs_deserted), #SB : village is deserted
           (party_get_slot, ":recover_progress", ":village_no", slot_village_recover_progress),
           (val_add, ":recover_progress", 1),
           (party_set_slot, ":village_no", slot_village_recover_progress, ":recover_progress"), #village looted

           (try_begin), #SB : add some looters, around twice per lifetime
             (store_mod, ":looter_chance", ":recover_progress", 10),
             (eq, ":looter_chance", 0),
             (store_random_in_range, ":random_value", 0, 5),
             (eq, ":random_value", 0),
             (set_spawn_radius, 5),
             (spawn_around_party, ":village_no", "pt_looters"),
           (try_end),
           (try_begin),
             (ge, ":recover_progress", 10),
             (party_slot_eq, ":village_no", slot_village_smoke_added, 1),
             (party_clear_particle_systems, ":village_no"),
             (party_add_particle_system, ":village_no", "psys_map_village_looted_smoke"),
             (party_set_slot, ":village_no", slot_village_smoke_added, 2),
           (try_end),
           (try_begin),
             (gt, ":recover_progress", 50),
             (party_slot_eq, ":village_no", slot_village_smoke_added, 2),
             (party_clear_particle_systems, ":village_no"),
             (party_set_slot, ":village_no", slot_village_smoke_added, 3),
             (party_set_icon, ":village_no", ":deserted_village_icon"), ##CABA FIX
           (try_end),
           (try_begin),
             (gt, ":recover_progress", 100),
             (call_script, "script_village_set_state",  ":village_no", svs_normal),#village back to normal
             (party_set_slot, ":village_no", slot_village_recover_progress, 0),
             (party_clear_particle_systems, ":village_no"),
             (party_set_slot, ":village_no", slot_village_smoke_added, 0),
             (party_set_icon, ":village_no", ":normal_village_icon"), ##CABA FIX
           (try_end),
         (try_end),
       (try_end),
  ]),


  # script_process_sieges
  # Input: none
  # Output: none
  #called from triggers
  ("process_sieges",
    [
       (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
         #Reducing siege hardness every day by 20
         (party_get_slot, ":siege_hardness", ":center_no", slot_center_siege_hardness),
         (val_sub, ":siege_hardness", 20),
         (val_max, ":siege_hardness", 0),
         (party_set_slot, ":center_no", slot_center_siege_hardness, ":siege_hardness"),

         (party_get_slot, ":town_food_store", ":center_no", slot_party_food_store),
         (call_script, "script_center_get_food_store_limit", ":center_no"),
         (assign, ":food_store_limit", reg0),
         (try_begin),
           (party_get_slot, ":besieger_party", ":center_no", slot_center_is_besieged_by),
           (ge, ":besieger_party", 0), #town is under siege

           #Reduce prosperity of besieged castle/town by -0.33/-4 every day.
           (try_begin),
             (try_begin),
               (is_between, ":center_no", castles_begin, castles_end),
               (store_random_in_range, ":random_value", 0, 3),
               (try_begin),
                 (eq, ":random_value", 0),
                 (assign, ":daily_siege_effect_on_prosperity", -1),
               (else_try),
                 (assign, ":daily_siege_effect_on_prosperity", 0),
               (try_end),
             (else_try),
               (assign, ":daily_siege_effect_on_prosperity", -4),
             (try_end),

             (call_script, "script_change_center_prosperity", ":center_no", ":daily_siege_effect_on_prosperity"),
             (val_add, "$newglob_total_prosperity_from_townloot", ":daily_siege_effect_on_prosperity"),
           (try_end),

           (store_faction_of_party, ":center_faction", ":center_no"),
        # Lift siege unless there is an enemy party nearby
           (assign, ":siege_lifted", 0),
           (try_begin),
             (try_begin),
               (neg|party_is_active, ":besieger_party"),
               (assign, ":siege_lifted", 1),
             (else_try),
               (store_distance_to_party_from_party, ":besieger_distance", ":center_no", ":besieger_party"),
               (gt, ":besieger_distance", 5),
               (assign, ":siege_lifted", 1),
			 (else_try),
  			 ##diplomacy begin
         (neg|party_slot_eq, ":center_no", slot_village_infested_by_bandits, "trp_peasant_woman"),
         ##diplomacy end
			   (store_faction_of_party, ":besieger_faction", ":besieger_party"),
               (store_relation, ":reln", ":besieger_faction", ":center_faction"),
               (ge, ":reln", 0),
               (assign, ":siege_lifted", 1),
             (try_end),


             (eq, ":siege_lifted", 1),
			 #If another lord can take over the siege, it isn't lifted
             ##diplomacy start+ Support promoted kingdom ladies
             #(try_for_range, ":enemy_hero", active_npcs_begin, active_npcs_end),
             (try_for_range, ":enemy_hero", heroes_begin, heroes_end),
             ##diplomacy end+
               (troop_slot_eq, ":enemy_hero", slot_troop_occupation, slto_kingdom_hero),
               (troop_get_slot, ":enemy_party", ":enemy_hero", slot_troop_leaded_party),
               (ge, ":enemy_party", 0),
               (party_is_active, ":enemy_party"),
               (store_faction_of_party, ":party_faction", ":enemy_party"),
               (store_relation, ":reln", ":party_faction", ":center_faction"),
               (lt, ":reln", 0),
               (store_distance_to_party_from_party, ":distance", ":center_no", ":enemy_party"),
               (lt, ":distance", 4),
               (assign, ":besieger_party", ":enemy_party"),
               (party_set_slot, ":center_no", slot_center_is_besieged_by, ":enemy_party"),
               (assign, ":siege_lifted", 0),
             (try_end),
           (try_end),
           (try_begin),
             (eq, ":siege_lifted", 1),
             (call_script, "script_lift_siege", ":center_no", 1),
           (else_try),
             (call_script, "script_center_get_food_consumption", ":center_no"),
             (assign, ":food_consumption", reg0),
             (val_sub, ":town_food_store", ":food_consumption"), # reduce food only under siege???
             (try_begin),
               (le, ":town_food_store", 0), #town is starving
               (store_random_in_range, ":r", 0, 100),
               (lt, ":r", 10),
               (call_script, "script_party_wound_all_members", ":center_no"), # town falls with 10% chance if starving
             (try_end),
           (try_end),
         (else_try),
           #town is not under siege...
           (val_add, ":town_food_store", 30), #add 30 food (significant for castles only.
         (try_end),

         (val_min, ":town_food_store", ":food_store_limit"),
         (val_max, ":town_food_store", 0),
         (party_set_slot, ":center_no", slot_party_food_store, ":town_food_store"),
       (try_end),
  ]),

  # script_lift_siege
  # Input: arg1 = center_no, arg2 = display_message
  # Output: none
  #called from triggers
  ("lift_siege",
    [
      (store_script_param, ":center_no", 1),
      (store_script_param, ":display_message", 2),
      (party_set_slot, ":center_no", slot_center_is_besieged_by, -1), #clear siege
      (call_script, "script_village_set_state",  ":center_no", 0), #clear siege flag
      (try_begin),
        (eq, ":center_no", "$g_player_besiege_town"),
        (assign, "$g_siege_method", 0), #remove siege progress
      (try_end),
      (try_begin),
        (eq, ":display_message", 1),
        (str_store_party_name_link, s3, ":center_no"),
        (display_message, "@{s3} is no longer under siege."),
      (try_end),

      #SB : ideally we deal with post-conquest here but this is also called for cancelled sieges
      ]),


  # script_process_alarms
  # Input: none
  # Output: none
  #called from triggers
  ("process_alarms",
    [
      (assign, ":current_modula", "$g_alarm_modula"),
      (val_add, "$g_alarm_modula", 1),
      (try_begin),
        (eq, "$g_alarm_modula", 3),
        (assign, "$g_alarm_modula", 0),
      (try_end),

      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_mod, ":center_modula", ":center_no", 3),
        (eq, ":center_modula", ":current_modula"),

        (party_set_slot, ":center_no", slot_center_last_spotted_enemy, -1),
        (party_set_slot, ":center_no", slot_center_sortie_strength, 0),
        (party_set_slot, ":center_no", slot_center_sortie_enemy_strength, 0),

        (assign, ":spotting_range", 3),
        (try_begin),
          (is_currently_night),
          (assign, ":spotting_range", 2),
        (try_end),

        (try_begin),
          (party_slot_eq, ":center_no", slot_center_has_watch_tower, 1),
          (val_mul, ":spotting_range", 2),
        (else_try),
          (neg|is_between, ":center_no", villages_begin, villages_end),
          (val_add, ":spotting_range", 1),
          (val_mul, ":spotting_range", 2),
        (try_end),

        (store_faction_of_party, ":center_faction", ":center_no"),

        (try_for_parties, ":party_no"),
          (this_or_next|party_slot_eq, ":party_no", slot_party_type, spt_kingdom_hero_party),
          (eq, ":party_no", "p_main_party"),

          (store_faction_of_party, ":party_faction", ":party_no"),

          (try_begin),
            (eq, ":party_no", "p_main_party"),
            (assign, ":party_faction", "$players_kingdom"),
          (try_end),

          (try_begin),
            (eq, ":party_faction", ":center_faction"),

            (store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),
            (le, ":distance", ":spotting_range"),

            (party_get_slot, ":cached_strength", ":party_no", slot_party_cached_strength),
            (party_get_slot, ":sortie_strength", ":center_no", slot_center_sortie_strength),
            (val_add, ":sortie_strength", ":cached_strength"),
            (party_set_slot, ":center_no", slot_center_sortie_strength, ":sortie_strength"),
          (else_try),
            (neq, ":party_faction", ":center_faction"),

            (store_distance_to_party_from_party, ":distance", ":party_no", ":center_no"),

			(try_begin),
				(lt, ":distance", 10),
				(store_current_hours, ":hours"),
				(store_sub, ":faction_recce_slot", ":party_faction", kingdoms_begin),
				(val_add, ":faction_recce_slot", slot_center_last_reconnoitered_by_faction_time),
				(party_set_slot, ":center_no", ":faction_recce_slot", ":hours"),

				#(eq, "$cheat_mode", 1),
				#(str_store_faction_name, s4, ":party_faction"),
				#(str_store_party_name, s5, ":center_no"),
				#(display_message, "@{!}DEBUG -- {s4} reconnoiters {s5}"),
			(try_end),

		    (store_relation, ":reln", ":center_faction", ":party_faction"),
            (lt, ":reln", 0),
			(try_begin),
	            (le, ":distance", ":spotting_range"),

	            (party_get_slot, ":cached_strength", ":party_no", slot_party_cached_strength),
	            (party_get_slot, ":enemy_strength", ":center_no", slot_center_sortie_enemy_strength),
	            (val_add, ":enemy_strength", ":cached_strength"),
	            (party_set_slot, ":center_no", slot_center_sortie_enemy_strength, ":enemy_strength"),
	            (party_set_slot, ":center_no", slot_center_last_spotted_enemy, ":party_no"),
			(try_end),

          (try_end),
        (try_end),
      (try_end),

      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_mod, ":center_modula", ":center_no", 3),
        (eq, ":center_modula", ":current_modula"),

        (try_begin), #eligible units sortie out of castle
          (is_between, ":center_no", walled_centers_begin, walled_centers_end),
          (party_slot_ge, ":center_no", slot_center_last_spotted_enemy, 0),

          (party_get_slot, ":sortie_strength", ":center_no", slot_center_sortie_strength),
          (party_get_slot, ":enemy_strength", ":center_no", slot_center_sortie_enemy_strength),

          #Below two lines are new added by ozan. While AI want to drive nearby besieging enemy parties by making sortie them, they give up current battle if they are already joining one.
          #Lets assume there is a battle inside the castle, because enemies are inside castle and they are so close to castle they will be also added to slot_center_sortie_enemy_strength
          #But in this scenario, they are not outside the castle, so searching/patrolling enemy outside the castle is useless at this point.
          #So if there is already a battle inside the center, do not sortie and search enemy outside.
          (party_get_battle_opponent, ":center_battle_opponent", ":center_no"),
          (try_begin),
		    (ge, "$cheat_mode", 1),
            (ge, ":center_battle_opponent", 0),
            (str_store_party_name, s7, ":center_no"),
            (str_store_party_name, s6, ":center_battle_opponent"),
            (display_message, "@{!}DEBUG : There are already enemies ({s6}) inside {s7}."),
          (try_end),
          (lt, ":center_battle_opponent", 0),
          #New added by ozan ended.

          (try_begin),
            (eq, "$cheat_mode", 1),
            (str_store_party_name, s4, ":center_no"),
            (assign, reg3, ":sortie_strength"),
            (assign, reg4, ":enemy_strength"),
            (display_message, "@{!}DEBUG -- Calculating_sortie for {s4} strength of {reg3} vs {reg4} enemies"),
          (try_end),

          (store_mul, ":enemy_strength_mul_14_div_10", ":enemy_strength", 14),
          (val_div, ":enemy_strength_mul_14_div_10", 10),
          (gt, ":sortie_strength", ":enemy_strength_mul_14_div_10"),

          (assign, ":at_least_one_party_sorties", 0),
          (try_for_parties, ":sortie_party"),
            (party_get_attached_to, ":town", ":sortie_party"),
            (eq, ":town", ":center_no"),

            (party_slot_eq, ":sortie_party", slot_party_type, spt_kingdom_hero_party),

            (party_get_slot, ":cached_strength", ":sortie_party", slot_party_cached_strength),
            (ge, ":cached_strength", 100),

            (party_detach, ":sortie_party"),
            (call_script, "script_party_set_ai_state", ":sortie_party",  spai_patrolling_around_center, ":center_no"),

            (try_begin),
              (eq, "$cheat_mode", 1),
              (str_store_party_name, s4, ":sortie_party"),
              (display_message, "str_s4_sorties"),
            (try_end),

            (eq, ":at_least_one_party_sorties", 0),
            (assign, ":at_least_one_party_sorties", ":sortie_party"),
          (try_end),

          (try_begin),
            (party_is_in_town, "p_main_party", ":center_no"),
			(eq, "$g_player_is_captive", 0),
            (gt, ":at_least_one_party_sorties", 0),
            (call_script, "script_add_notification_menu", "mnu_notification_sortie_possible", ":center_no", ":sortie_party"),
          (try_end),
		(try_end),

		(store_faction_of_party, ":center_faction", ":center_no"),

		#Send message
		(this_or_next|eq, "$cheat_mode", 1), #this is message
		(this_or_next|party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
		(eq, ":center_faction", "$players_kingdom"),

		(party_get_slot, ":enemy_party", ":center_no", slot_center_last_spotted_enemy),
		(ge, ":enemy_party", 0),
		(store_distance_to_party_from_party, ":dist", "p_main_party", ":center_no"),
		(assign, ":has_messenger", 0),
		(try_begin),
		 ##diplomacy start+ Handle player is co-ruler of faction
		 (assign, ":is_coruler", 0),
		 (try_begin),
			(eq, ":center_faction", "$players_kingdom"),
			(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
			(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
			(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
			(assign, ":is_coruler", 1),
		 (try_end),
		 (this_or_next|eq, ":is_coruler", 1),
		 ##diplomacy end+
		  (this_or_next|party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
		  (eq, ":center_faction", "fac_player_supporters_faction"),
		  (party_slot_eq, ":center_no", slot_center_has_messenger_post, 1),
		  (assign, ":has_messenger", 1),
		(try_end),

		(this_or_next|eq, "$cheat_mode", 1),
		(this_or_next|lt, ":dist", 30),
			(eq, ":has_messenger", 1),

		(str_store_party_name_link, s1, ":center_no"),
        (party_get_slot, ":exact_enemy_strength", ":center_no", slot_center_sortie_enemy_strength),

		(try_begin),
			(lt, ":exact_enemy_strength", 500),
			(display_message, "@Small bands of enemies spotted near {s1}."),
		(else_try),
			(lt, ":exact_enemy_strength", 1000),
			(display_message, "@Enemy patrols spotted near {s1}."),
		(else_try),
			(lt, ":exact_enemy_strength", 2000),
			(display_message, "@Medium-sized group of enemies spotted near {s1}."),
		(else_try),
			(lt, ":exact_enemy_strength", 4000),
			(display_message, "@Significant group of enemies spotted near {s1}."),
		(else_try),
			(lt, ":exact_enemy_strength", 8000),
			(display_message, "@Army of enemies spotted near {s1}."),
		(else_try),
			(lt, ":exact_enemy_strength", 16000),
			(display_message, "@Large army of enemies spotted near {s1}."),
		(else_try),
			(display_message, "@Great host of enemies spotted near {s1}."),
		(try_end),
		#maybe do audio sound?

      (try_end),
     ]),

  # script_allow_vassals_to_join_indoor_battle
  # Input: none
  # Output: none
  ("allow_vassals_to_join_indoor_battle",
    [
     #if our commander attacks an enemy army
     ##diplomacy start+ Support promoted kingdom ladies
     #(try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
     (try_for_range, ":troop_no", heroes_begin, heroes_end),
     ##diplomacy end+
       (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
       (neg|troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0),
       (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
       (gt, ":party_no", 0),
       (party_is_active, ":party_no"),

       (party_get_attached_to, ":party_is_attached_to", ":party_no"),
       (lt, ":party_is_attached_to", 0),

       (store_troop_faction, ":faction_no", ":troop_no"),

       (try_begin),
         #(faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemies_around_center),
         (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
         (party_get_slot, ":commander_party", ":party_no", slot_party_ai_object),
         (gt, ":commander_party", 0),
         (party_is_active, ":commander_party"),

         (assign, ":besieged_center", -1),
         (try_begin),
           (party_slot_eq, ":commander_party", slot_party_ai_state, spai_holding_center), #if commander is holding a center
           (party_get_slot, ":commander_object", ":commander_party", slot_party_ai_object), #get commander's ai object (center they are holding)
           (party_get_battle_opponent, ":besieger_enemy", ":commander_object"), #get this object's battle opponent
           (party_is_active, ":besieger_enemy"),
           (assign, ":besieged_center", ":commander_object"),
           (assign, ":commander_object", ":besieger_enemy"),
         (else_try),
           (party_slot_eq, ":commander_party", slot_party_ai_state, spai_engaging_army), #if commander is engaging an army
           (party_get_slot, ":commander_object", ":commander_party", slot_party_ai_object), #get commander's ai object (army which they engaded)
           (ge, ":commander_object", 0), #if commander has an object
           (neg|is_between, ":commander_object", centers_begin, centers_end), #if this object is not a center, so it is a party
           (party_is_active, ":commander_object"),
           (party_get_battle_opponent, ":besieged_center", ":commander_object"), #get this object's battle opponent
         (else_try),
           (assign, ":besieged_center", -1),
         (try_end),

         (is_between, ":besieged_center", walled_centers_begin, walled_centers_end), #if battle opponent of our commander's ai object is a walled center

         (party_get_attached_to, ":attached_to_party", ":commander_party"), #if commander is attached to besieged center already.
         (eq, ":attached_to_party", ":besieged_center"),

         (store_faction_of_party, ":besieged_center_faction", ":besieged_center"),#get (battle opponent of our commander's ai object)'s faction
         (eq, ":besieged_center_faction", ":faction_no"), #if battle opponent of our commander's ai object is from same faction with current party
         (party_is_active, ":commander_object"),
         #make also follow_or_not check if needed

         (call_script, "script_party_set_ai_state", ":party_no", spai_engaging_army, ":commander_object"), #go and help commander

         (try_begin),
           (eq, "$cheat_mode", 1),
           (str_store_party_name, s7, ":party_no"),
           (str_store_party_name, s6, ":commander_object"),
           (display_message, "@{!}DEBUG : {s7} is helping his commander by fighting with {s6}."),
         (try_end),
       (else_try),
         #(faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_center),

         (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
         (party_get_slot, ":commander_party", ":party_no", slot_party_ai_object),
         (gt, ":commander_party", 0),
         (party_is_active, ":commander_party"),

         (party_get_battle_opponent, ":besieged_center", ":commander_party"), #get this object's battle opponent

         #make also follow_or_not check if needed

         (is_between, ":besieged_center", walled_centers_begin, walled_centers_end), #if this object is a center
         (party_get_attached_to, ":attached_to_party", ":party_no"),
         (neq, ":attached_to_party", ":besieged_center"),
         (party_is_active, ":besieged_center"),

         (call_script, "script_party_set_ai_state", ":party_no", spai_engaging_army, ":besieged_center"), #go and help commander

         #(try_begin),
         #  (eq, "$cheat_mode", 1),
         #  (str_store_party_name, s7, ":party_no"),
         #  (str_store_party_name, s6, ":besieged_center"),
         #  (display_message, "@{!}DEBUG : {s7} is helping his commander by attacking {s6}."),
         #(try_end),

         #(party_set_ai_behavior, ":party_no", ai_bhvr_attack_party),
         #(party_set_ai_object, ":party_no", ":besieged_center"),
         #(party_set_flags, ":party_no", pf_default_behavior, 1), #is these needed?
         #(party_set_slot, ":party_no", slot_party_ai_substate, 1), #is these needed?
       (try_end),
     (try_end),
     ]),

  # script_party_set_ai_state
  # Input: arg1 = party_no, arg2 = new_ai_state, arg3 = action_object (if necessary)
  # Output: none (Can fail)

  #Redone somewhat on Feb 18 to make sure that initative is set properly

  ("party_set_ai_state",
    [
      (store_script_param, ":party_no", 1),
      (store_script_param, ":new_ai_state", 2),
      (store_script_param, ":new_ai_object", 3),

      (party_get_slot, ":old_ai_state", ":party_no", slot_party_ai_state),
      (party_get_slot, ":old_ai_object", ":party_no", slot_party_ai_object),
      (party_get_attached_to, ":attached_to_party", ":party_no"),
      (assign, ":party_is_in_town", 0),
      (try_begin),
        (is_between, ":attached_to_party", centers_begin, centers_end),
        (assign, ":party_is_in_town", ":attached_to_party"),
      (try_end),

      (assign, ":commander", -1),
      (try_begin),
        (party_is_active, ":party_no"),
	    (party_stack_get_troop_id, ":commander", ":party_no", 0),
	    (store_faction_of_party, ":faction_no", ":party_no"),
	  (try_end),

	  (try_begin),
	    (lt, ":commander", 0),
        #sometimes 0 sized parties enter "party_set_ai_state" script. So only discard them
	    #(try_begin),
        #  (eq, "$cheat_mode", 1),
	    #  (str_store_troop_name, s6, ":party_no"),
        #  (party_get_num_companions, reg6, ":party_no"),
        #  (display_message, "@{!}DEBUGS : party name is : {s6}, party size is : {reg6}, new ai discarded."),
        #(try_end),
	  (else_try),
	    #Party does any business in town
	    (try_begin),
	      (is_between, ":party_is_in_town", walled_centers_begin, walled_centers_end),
	      (party_slot_eq, ":party_is_in_town", slot_center_is_besieged_by, -1),
	      (call_script, "script_troop_does_business_in_center", ":commander", ":party_is_in_town"),
	    (else_try),
	      (party_slot_eq, ":party_no", slot_party_ai_state, spai_visiting_village),
	      (party_get_slot, ":party_is_in_village", ":party_no", slot_party_ai_object),
	      (is_between, ":party_is_in_village", villages_begin, villages_end),
	      #(party_slot_eq, ":party_is_in_village", slot_center_is_looted_by, -1),
          (call_script, "script_cf_village_normal_cond", ":party_is_in_village"), #SB : script condition
		  # (neg|party_slot_eq, ":party_is_in_village", slot_village_state, svs_being_raided),
		  # (neg|party_slot_eq, ":party_is_in_village", slot_village_state, svs_deserted), #SB : deserted condition
		  # (neg|party_slot_eq, ":party_is_in_village", slot_village_state, svs_looted),
	      (store_distance_to_party_from_party, ":distance", ":party_no", ":party_is_in_village"),
	      (lt, ":distance", 3),
	      (call_script, "script_troop_does_business_in_center", ":commander", ":party_is_in_village"),
	    (try_end),

	    (party_set_slot, ":party_no", slot_party_follow_me, 0),

	    (try_begin),
	      (eq, ":old_ai_state", ":new_ai_state"),
	      (eq, ":old_ai_object", ":new_ai_object"),
          #do nothing. Nothing is changed.
        (else_try),
          (assign, ":initiative", 100),
          (assign, ":aggressiveness", 8),
          (assign, ":courage", 8),

          (try_begin),
            (this_or_next|eq, ":new_ai_state", spai_accompanying_army),
            (eq, ":new_ai_state", spai_screening_army),

            (party_set_ai_behavior, ":party_no", ai_bhvr_escort_party),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),

            (try_begin),
              (gt, ":party_is_in_town", 0),
              (party_detach, ":party_no"),
            (try_end),

            (try_begin),
              (eq, ":new_ai_state", spai_screening_army),
              (assign, ":aggressiveness", 9),
              (assign, ":courage", 9),
              (assign, ":initiative", 80),
            (else_try),
              (assign, ":aggressiveness", 6),
              (assign, ":courage", 9),
              (assign, ":initiative", 10),
            (try_end),
          (else_try),
            (eq, ":new_ai_state", spai_besieging_center),

            (party_get_position, pos1, ":new_ai_object"),
            (map_get_random_position_around_position, pos2, pos1, 2),
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_point),
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", slot_party_follow_me, 1),
            (party_set_slot, ":party_no", slot_party_ai_substate, 0),

            (try_begin),
              (gt, ":party_is_in_town", 0),
              (neq, ":party_is_in_town", ":new_ai_object"),
              (party_detach, ":party_no"),
            (try_end),

            (assign, ":aggressiveness", 1),
            (assign, ":courage", 9),
            (assign, ":initiative", 20),
            #(assign, ":initiative", 100),
          (else_try),
            (eq, ":new_ai_state", spai_holding_center),

            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_party),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),

            (try_begin),
              (gt, ":party_is_in_town", 0),
              (neq, ":party_is_in_town", ":new_ai_object"),
              (party_detach, ":party_no"),
            (try_end),

            (assign, ":aggressiveness", 7),
            (assign, ":courage", 9),
            (assign, ":initiative", 100),
            #(party_set_ai_initiative, ":party_no", 99),
          (else_try),
            (eq, ":new_ai_state", spai_patrolling_around_center),
            (party_get_position, pos1, ":new_ai_object"),
            (map_get_random_position_around_position, pos2, pos1, 1),
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_point),
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":new_ai_object"),

            (try_begin),
              (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemies_around_center),
              (party_set_ai_patrol_radius, ":party_no", 1), #line 100
            (else_try),
              (party_set_ai_patrol_radius, ":party_no", 5), #line 100
            (try_end),

            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", slot_party_follow_me, 1),
            (party_set_slot, ":party_no", slot_party_ai_substate, 0),

            (try_begin),
              (gt, ":party_is_in_town", 0),
              (party_detach, ":party_no"),
            (try_end),

            (try_begin),
              #new to avoid losing time of marshal with attacking unimportant targets while there is a threat in our centers.
              (ge, ":commander", 0),
              (faction_slot_eq, ":faction_no", slot_faction_marshall, ":commander"),
	          (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemies_around_center),

	          (party_get_position, pos3, ":party_no"),
	          (get_distance_between_positions, ":distance_to_center", pos1, pos3),

	          (try_begin),
	            (ge, ":distance_to_center", 800), #added new (1.122)
                (assign, ":initiative", 10),
                (assign, ":aggressiveness", 1),
                (assign, ":courage", 8),
              (else_try), #below added new (1.122)
                (assign, ":initiative", 100),
                (assign, ":aggressiveness", 8),
                (assign, ":courage", 8),
              (try_end),
            (else_try),
              (assign, ":aggressiveness", 8),
              (assign, ":courage", 8),
              (assign, ":initiative", 100),
            (try_end),
          (else_try),
            (eq, ":new_ai_state", spai_visiting_village),
            (party_get_position, pos1, ":new_ai_object"),
            (map_get_random_position_around_position, pos2, pos1, 2),
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_point),
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", slot_party_ai_substate, 0),
            (try_begin),
              (gt, ":party_is_in_town", 0),
              (neq, ":party_is_in_town", ":new_ai_object"),
              (party_detach, ":party_no"),
            (try_end),

            (assign, ":aggressiveness", 8),
            (assign, ":courage", 8),
            (assign, ":initiative", 100),
          (else_try), #0.660: this is where the 1625/1640 bugs happen with an improper ai_object
            (eq, ":new_ai_state", spai_raiding_around_center),
            (party_get_position, pos1, ":new_ai_object"),
            (map_get_random_position_around_position, pos2, pos1, 1),
            (party_set_ai_behavior, ":party_no", ai_bhvr_patrol_location),
            (party_set_ai_patrol_radius, ":party_no", 10),
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":new_ai_object"),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
	        (party_set_slot, ":party_no", slot_party_follow_me, 1),
	        (party_set_slot, ":party_no", slot_party_ai_substate, 0),
	        (try_begin),
	          (gt, ":party_is_in_town", 0),
	          (neq, ":party_is_in_town", ":new_ai_object"),
	          (party_detach, ":party_no"),
	        (try_end),

	        (try_begin),
	          (ge, ":commander", 0),
	          (faction_slot_eq, ":faction_no", slot_faction_marshall, ":commander"),
	          (assign, ":aggressiveness", 1),
	          (assign, ":courage", 8),
	          (assign, ":initiative", 20),
	        (else_try),
	          (assign, ":aggressiveness", 7),
	          (assign, ":courage", 8),
	          (assign, ":initiative", 100),
	        (try_end),
	      (else_try),
	        (eq, ":new_ai_state", spai_engaging_army),

	        (party_set_ai_behavior, ":party_no", ai_bhvr_attack_party),
	        (party_set_ai_object, ":party_no", ":new_ai_object"),
	        (party_set_flags, ":party_no", pf_default_behavior, 0),
	        (try_begin),
	          (gt, ":party_is_in_town", 0),
	          (party_detach, ":party_no"),
	        (try_end),

            (try_begin),
              #new to avoid losing time of marshal with attacking unimportant targets while there is a threat in our centers.
              (ge, ":commander", 0),
              (faction_slot_eq, ":faction_no", slot_faction_marshall, ":commander"),
	          (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemies_around_center),
              (assign, ":initiative", 10),
              (assign, ":aggressiveness", 1),
              (assign, ":courage", 8),
            (else_try),
              (assign, ":aggressiveness", 8),
	          (assign, ":courage", 8),
	          (assign, ":initiative", 100),
	        (try_end),
	      (else_try),
	        (eq, ":new_ai_state", spai_retreating_to_center),
	        (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_party),
	        (party_set_ai_object, ":party_no", ":new_ai_object"),
	        (party_set_flags, ":party_no", pf_default_behavior, 1),
	        (party_set_slot, ":party_no", slot_party_commander_party, -1),
	        (try_begin),
	          (gt, ":party_is_in_town", 0),
	          (neq, ":party_is_in_town", ":new_ai_object"),
	          (party_detach, ":party_no"),
	        (try_end),

	        (assign, ":aggressiveness", 3),
	        (assign, ":courage", 4),
	        (assign, ":initiative", 100),
	      (else_try),
	        (eq, ":new_ai_state", spai_undefined),
	        (party_set_ai_behavior, ":party_no", ai_bhvr_hold),
	        (party_set_flags, ":party_no", pf_default_behavior, 0),
	      (try_end),

	      (try_begin),
	        (troop_slot_eq, ":commander", slot_lord_reputation_type, lrep_martial),
	        (val_add, ":aggressiveness", 2),
	        (val_add, ":courage", 2),
	      (else_try),
			  ##diplomacy start+ support lady personality types
			  (neg|troop_slot_eq, ":commander", slot_lord_reputation_type, lrep_adventurous),
			  (this_or_next|troop_slot_ge, ":commander", slot_lord_reputation_type, dplmc_lrep_ladies_begin),
			  ##diplomacy end+
	        (troop_slot_eq, ":commander", slot_lord_reputation_type, lrep_debauched),
	        (val_sub, ":aggressiveness", 1),
	        (val_sub, ":courage", 1),
	      (try_end),

	      (party_set_slot, ":party_no", slot_party_ai_state, ":new_ai_state"),
	      (party_set_slot, ":party_no", slot_party_ai_object, ":new_ai_object"),
	      (party_set_aggressiveness, ":party_no", ":aggressiveness"),
	      (party_set_courage, ":party_no", ":courage"),
	      (party_set_ai_initiative, ":party_no", ":initiative"),
	    (try_end),
	  (try_end),

	  #Helpfulness
	  (try_begin),
	    (ge, ":commander", 0),

	    (party_set_helpfulness, ":party_no", 101),
	    (try_begin),
  	      (troop_slot_eq, ":commander", slot_lord_reputation_type, lrep_martial),
 	      (party_set_helpfulness, ":party_no", 200),
	    (else_try),
  	      (troop_slot_eq, ":commander", slot_lord_reputation_type, lrep_upstanding),
	      (party_set_helpfulness, ":party_no", 150),
	    (else_try),
	      (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
	      (party_set_helpfulness, ":party_no", 110),
	    (else_try),
	      (troop_slot_eq, ":commander", slot_lord_reputation_type, lrep_quarrelsome),
	      (party_set_helpfulness, ":party_no", 90),
	    (else_try),
	      (troop_slot_eq, ":commander", slot_lord_reputation_type, lrep_selfrighteous),
	      (party_set_helpfulness, ":party_no", 80),
	    (else_try),
	      (troop_slot_eq, ":commander", slot_lord_reputation_type, lrep_debauched),
	      (party_set_helpfulness, ":party_no", 50),
	    (try_end),
	  (try_end),
  ]),

  ("cf_party_under_player_suggestion",
    [
    (store_script_param, ":party_no", 1),

	(party_slot_eq, ":party_no", slot_party_following_orders_of_troop, "trp_kingdom_heroes_including_player_begin"),

	(party_get_slot, ":ai_state", ":party_no", slot_party_ai_state),
	(party_slot_eq, ":party_no", slot_party_orders_type, ":ai_state"),

	(party_get_slot, ":ai_object", ":party_no", slot_party_ai_object),
	(party_slot_eq, ":party_no", slot_party_orders_object, ":ai_object"),

	(store_current_hours, ":hours_since_orders_given"),
	(party_get_slot, ":orders_time", ":party_no", slot_party_orders_time),

	(val_sub, ":hours_since_orders_given", ":orders_time"),
	(lt, ":hours_since_orders_given", 12),
	]),

  #Currently called from process_ai_state, could be called from elsewhere
  #It is used for lord to (1)Court ladies (2)Collect rents (3)Look for volunteers
  ## Upgrade equipment (by quality) and hire mercenaries (if Martial personality)
  ("troop_does_business_in_center",
  [
    (store_script_param, ":troop_no", 1),
    (store_script_param, ":center_no", 2),
	##diplomacy start+
	#Call this once and reuse below.
	(call_script, "script_dplmc_is_affiliated_family_member", ":troop_no"),
	(assign, ":is_affiliated", reg0),
	#Also enable for the spouse, unless you're on bad terms
	(try_begin),
		(lt, ":is_affiliated", 0),
		(this_or_next|troop_slot_eq,":troop_no",slot_troop_spouse, "trp_player"),
			(troop_slot_eq,"trp_player",slot_troop_spouse, ":troop_no"),
		(call_script, "script_troop_get_player_relation", ":troop_no"),
		(store_skill_level, ":persuasion", "skl_persuasion", "trp_player"),
		(val_add, reg0, ":persuasion"),
		#reduce magnitude, since >= 0 succeeds
		(store_sub, ":persuasion_modifier", 20, ":persuasion"),
		(val_mul, reg0, ":persuasion_modifier"),
		(val_div, reg0, 20),
		#final number must be >= -5
		(ge, reg0, -5),
		(assign, ":is_affiliated", 1),
	(try_end),
	##diplomacy end+

    (troop_get_slot, ":led_party", ":troop_no", slot_troop_leaded_party),
    (troop_get_slot, ":troop_wealth", ":troop_no", slot_troop_wealth), #SB : moved up
    (assign, ":initial_wealth", ":troop_wealth"), #DEBUG

    (store_current_hours, ":current_time"),
    (try_begin),
#      (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"), #this was added to get lords in centers out and visiting their fiefs, but I've adjusted the decision checklist
      (is_between, ":center_no", walled_centers_begin, walled_centers_end),
      (party_set_slot, ":led_party", slot_party_last_in_any_center, ":current_time"),
      (try_begin),
        (call_script, "script_lord_get_home_center", ":troop_no"),
        (eq, ":center_no", reg0),
        (party_set_slot, ":led_party", slot_party_last_in_home_center, ":current_time"),
      (try_end),
    (try_end),

    #Collect the rents
    (try_begin),
      (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),

      (party_get_slot, ":accumulated_rents", ":center_no", slot_center_accumulated_rents),
      (party_get_slot, ":accumulated_tariffs", ":center_no", slot_center_accumulated_tariffs),
      # (troop_get_slot, ":troop_wealth", ":troop_no", slot_troop_wealth),
      (val_add, ":troop_wealth", ":accumulated_rents"),
      (val_add, ":troop_wealth", ":accumulated_tariffs"),

      (troop_set_slot, ":troop_no", slot_troop_wealth, ":troop_wealth"),
      (party_set_slot, ":center_no", slot_center_accumulated_rents, 0),
      (party_set_slot, ":center_no", slot_center_accumulated_tariffs, 0),

      ## upgrade owned centers

      (call_script, "script_calculate_improvement_limit", ":troop_no", ":center_no"),
      (assign, ":limit", reg0),

      (try_begin),
        (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
        (gt, ":troop_wealth", ":limit"), #surplus cash
        (party_slot_eq, ":center_no", slot_center_current_improvement, 0), #not already building
        (assign, ":continue", 1),
        #this randomization applies so that there is a chance of not building an improvement (1/6) or (4/6)
        (store_random_in_range, ":improvement_no", village_improvements_begin, walled_center_improvements_end),
        (party_slot_eq, ":center_no", ":improvement_no", 0), #not already built
        (try_begin), #villages
          (party_slot_eq, ":center_no", slot_party_type, spt_village),
          (ge, ":improvement_no", village_improvements_end),
          (assign, ":continue", 0),
        (else_try), #towns, castles
          (lt, ":improvement_no", walled_center_improvements_begin),
          (assign, ":continue", 0),
        (try_end),
        (eq, ":continue", 1),
        (call_script, "script_get_improvement_details", ":improvement_no"),
        (assign, ":improvement_cost", reg0), # 4000-9000
        # calculate cost offset from lord
        (store_attribute_level, ":int", ":troop_no", ca_intelligence), #10-70
        (store_skill_level, ":skill", "skl_engineer", ":troop_no"), #0 to 15
        (val_mul, ":skill", ":int"), # 0 to 105
        (store_character_level, ":level", ":troop_no"), #22-50
        (val_add, ":skill", ":level"),
        (val_sub, ":improvement_cost", ":skill"),

        #get working strength
        (party_get_num_companions, ":divider", ":center_no"), #0~300, ignoring wounded
        (party_get_num_prisoners, ":num_prisoners", ":center_no"), #possibly up to 100
        (val_min, ":num_prisoners", 100),

        #account for serfs, each level past base adds 25 effective manpower
        (store_faction_of_party, ":faction_no", ":center_no"),
        (faction_get_slot, ":serfdom", ":faction_no", dplmc_slot_faction_serfdom),
        (val_add, ":serfdom", 3),
        (val_mul, ":serfdom", 25),
        (val_add, ":divider", ":serfdom"),
        (gt, ":divider", ":num_prisoners"),

        #calculate time - manpower, prosperity, and int/level-based
        (party_get_slot, ":multiplier", ":center_no", slot_town_prosperity), #0 to 100
        (val_sub, ":multiplier", ":num_prisoners"), #feeding drags prosperity down
        (store_sub, ":multiplier", 300, ":multiplier"), #300 to 100
        (val_add, ":divider", ":skill"), #total 30~500 added from lord

        (store_mul, ":improvement_time", ":improvement_cost", ":multiplier"), #400000 - 2700000
        (val_div, ":improvement_time", 100),
        (val_div, ":improvement_time", ":divider"), #18.18~800
        (lt, ":improvement_time", 160), #feasible
        (val_max, ":improvement_time", 3), #not instantaneous

        (val_sub, ":troop_wealth", ":improvement_cost"),
        (troop_set_slot, ":troop_no", slot_troop_wealth, ":troop_wealth"),
        (try_begin),
          (this_or_next|eq, "$cheat_mode", 3),
          (ge, ":is_affiliated", 1),#<-- dplmc+ added
          (assign, reg6, ":improvement_time"),
          (str_store_troop_name_link, s10, ":troop_no"),
          #s0 comes from improvement_details
          (display_log_message, "@{s10} constructs a {s0} in {s4}", message_alert),
        (try_end),
        (assign, "$g_improvement_type", ":improvement_no"),
        # (assign, reg6, ":improvement_time"),
        (call_script, "script_improve_center", ":center_no", ":troop_no", ":improvement_time"),
      (try_end),
      ##
      ##diplomacy start+
      #Modify the next block to display for affiliates
      (try_begin),
        (this_or_next|ge, ":is_affiliated", 1),#<-- dplmc+ added
        (this_or_next|eq, "$cheat_mode", 1),
        (eq, "$cheat_mode", 3),
        (assign, reg1, ":troop_wealth"),
        (str_store_party_name_link, s4, ":center_no"),
        (add_troop_note_from_sreg, ":troop_no", 1, "str_current_wealth_reg1_taxes_last_collected_from_s4", 0),
        #New section, print a message for affiliates:
        (ge, ":is_affiliated", 1),
        (store_add, reg0, ":accumulated_rents", ":accumulated_tariffs"),
        (str_store_troop_name_link, s0, ":troop_no"),
        (try_begin),
           (gt, reg0, 0),
           (display_log_message, "@{s0} collects {reg0} denars from {s4}, current wealth: {reg1} denars"),
        (try_end),
      (try_end),
      ##diplomacy end+
    (try_end),

    #Recruit volunteers
    (try_begin),
        (is_between, ":center_no", villages_begin, villages_end),
        (party_get_slot, ":troop_amount", ":center_no", slot_center_npc_volunteer_troop_amount),
        (gt, ":troop_amount", 0),

        (party_get_slot, ":troop_type", ":center_no", slot_center_npc_volunteer_troop_type),
        (party_set_slot, ":center_no", slot_center_npc_volunteer_troop_amount, -1),
        ##diplomacy begin
        (try_begin),
          (store_faction_of_party, ":party_faction", ":led_party"),
          (eq, ":party_faction", "fac_player_supporters_faction"),
          (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
          (faction_get_slot, ":troop_type", "$g_player_culture", slot_faction_tier_1_troop),
        (try_end),

        (try_begin), #debug
          ##nested diplomacy start+
          (this_or_next|ge, ":is_affiliated", 1),#<- Show for affiliates
          (eq, "$cheat_mode", 1),
          ##nested diplomacy end+
          (assign, reg2, ":troop_amount"),
          # (str_store_string, s11, "@{reg2}"),
          (str_store_troop_name, s12, ":troop_type"),
          (str_store_faction_name_link, s13, ":party_faction"),
          (str_store_party_name_link, s14, ":center_no"),
          (str_store_party_name, s10, ":led_party"),
          (display_log_message, "@ {s10} of {s13} recruits {reg2} {s12} in {s14}"),
        (try_end),

        ##diplomacy end
        (party_add_members, ":led_party", ":troop_type", ":troop_amount"),
    (else_try), ##do business in centers
      (is_between, ":center_no", towns_begin, towns_end),
      (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),

      (try_begin), #hiring mercenaries
        (this_or_next|troop_slot_eq, ":troop_no", slot_troop_morality_type, tmt_egalitarian),
        (this_or_next|troop_slot_eq, ":troop_no", slot_troop_2ary_morality_type, tmt_egalitarian),
        (this_or_next|troop_slot_eq, ":troop_no", slot_troop_2ary_morality_type, tmt_aristocratic),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_martial),
        (party_get_slot, ":mercenary_troop", ":center_no", slot_center_mercenary_troop_type),
        (gt, ":mercenary_troop", 0),
        (store_character_level, ":level", ":mercenary_troop"),
        #chance of not hiring
        (store_random_in_range, ":reduce", ":level", 100),
        (gt, ":reduce", 69), #favors high-level
        # (game_get_reduce_campaign_ai, ":reduce"), #0 to 2
        # (val_mul, ":reduce", 5), #0 to 10
        # (store_sub, ":reduce", 26, ":reduce"), #26 to 16
        # (lt, ":level", ":reduce"), #no special mercs - on hard can hire top-tier, on easy caravan guard/xbow/lower
        (party_get_slot, ":mercenary_amount", ":center_no", slot_center_mercenary_troop_amount),
        (call_script, "script_game_get_join_cost", ":mercenary_troop"),
        (assign, ":troop_cost", reg0),
        # (try_begin), #slight discount for improvement
          # (party_get_slot, ":reduce", ":center_no", slot_center_has_mercenary_hall),
          # (val_add, ":reduce", 5),
          # (val_mul, ":troop_cost", 5),
          # (val_div, ":troop_cost", ":reduce"),
        # (try_end),
        #test wealth levels - a tenth normally can be used
        (store_faction_of_troop, ":faction_no", ":troop_no"),
        (faction_get_slot, ":quality", ":faction_no", dplmc_slot_faction_quality),
        (val_add, ":quality", 10),
        #use faction quality to determine percentage of wealth used for mercenaries
        (store_div, ":divider", ":troop_wealth", ":quality"),
        (val_div, ":divider", ":troop_cost"),
        (val_min, ":divider", ":mercenary_amount"),


        #set the proper slots
        (try_begin),
          (gt, ":divider", 0),
          (party_add_members, ":led_party", ":mercenary_troop", ":divider"),
          (val_mul, ":troop_cost", ":divider"),
          (val_sub, ":troop_wealth", ":troop_cost"),
          (store_sub, ":mercenary_amount", ":mercenary_amount", ":divider"),
          (party_set_slot, ":center_no", slot_center_mercenary_troop_amount, ":mercenary_amount"),
          (try_begin),
            (le, ":mercenary_amount", 0),
            (party_set_slot, ":center_no", slot_center_mercenary_troop_amount, -1),
            (party_set_slot, ":center_no", slot_center_mercenary_troop_type, -1),
          (else_try),
            (party_set_slot, ":center_no", slot_center_mercenary_troop_amount, ":mercenary_amount"),
          (try_end),
          (try_begin), #debug
            (this_or_next|ge, ":is_affiliated", 1),#<- Show for affiliates
            (ge, "$cheat_mode", 1),
            (assign, reg2, ":divider"),
            (str_store_troop_name_by_count, s12, ":mercenary_troop", reg2),
            (display_log_message, "@{s10} hires {reg2} {s12} in {s4}"),
          (try_end),
        (try_end),
      (try_end),
      ##upgrade equipment from merchants
      (call_script, "script_calculate_equipment_limit", ":troop_no", ":center_no"),
      (assign, ":equipment_limit", reg0),
      #we assume startup gear is sufficient - only quality matters
      # (try_for_range, ":slot", ek_item_0, ek_food), #can't only check equipment, it'll reload if you visit lord's hall
      (troop_get_inventory_capacity, ":cap", ":troop_no"),
      (try_for_range, ":slot", ek_item_0, ":cap"),
        (gt, ":troop_wealth", ":equipment_limit"), #has spare cash
        (troop_get_inventory_slot, ":item_no", ":troop_no", ":slot"),
        (neq, ":item_no", -1),
        (neg|item_has_property, ":item_no", itp_unique),
        (neg|item_has_property, ":item_no", itp_civilian), #why bother upgrading underwear
        (item_has_property, ":item_no", itp_merchandise), #can be sold, although player can drop loot off
        (troop_get_inventory_slot_modifier, ":old_imod", ":troop_no", ":slot"),
        # (item_get_slot, ":imod_mult", ":old_imod", slot_item_modifier_multiplier),
        (call_script, "script_dplmc_get_item_value_with_imod", ":item_no", ":old_imod"),
        (assign, ":imod_mult", reg0),
        (try_begin),
          (is_between, ":slot", ek_item_0, ek_head),
          (assign, ":merchant", slot_town_weaponsmith),
        (else_try),
          (is_between, ":slot", ek_item_0, ek_head),
          (assign, ":merchant", slot_town_armorer),
        (else_try),
          (eq, ":slot", ek_horse),
          (assign, ":merchant", slot_town_horse_merchant),
        (try_end),
        (party_get_slot, ":merchant", ":center_no", ":merchant"),
        #valid merchant
        (is_between, ":merchant", armor_merchants_begin, mayors_begin),
        (troop_get_inventory_capacity, ":cap", ":merchant"),
        (try_for_range, ":i_slot", 10, ":cap"),
          (troop_get_inventory_slot, ":item_id", ":merchant", ":i_slot"),
          (eq, ":item_id", ":item_no"), #same item found
          (troop_get_inventory_slot_modifier, ":imod", ":merchant", ":i_slot"),
          (neq, ":imod", ":old_imod"), ## in general higher imod = upgrade

          # (is_between, ":imod", imod_balanced, imod_large_bag + 1), #eliminate bad+plain ones
          # (item_get_slot, ":imod_cost", ":imod", slot_item_modifier_multiplier),
          (call_script, "script_dplmc_get_item_value_with_imod", ":item_id", ":imod"),
          (assign, ":imod_cost", reg0),
          (gt, ":imod_cost", ":imod_mult"), #superior price not necessarily better quality
          #troop can use item
          (call_script, "script_dplmc_troop_can_use_item", ":troop_no", ":item_id", ":imod"),
          (eq, reg0, 1),
          #we go for a pure value ratio - get_trade_penalty applies to player only
          (store_item_value, ":val", ":item_no"),
          (store_sub, ":cost", ":imod_cost", ":imod_mult"),
          (val_mul, ":cost", ":val"),
          (val_div, ":cost", 100),#base
          (gt, ":troop_wealth", ":cost"),
          (try_begin), #debug
            (eq, "$cheat_mode", 2),
            #(str_store_string, s11, "@{reg2}"),

            # (str_store_party_name_link, s14, ":center_no"),
            (str_store_item_name, s11, ":item_no"),
            (str_store_troop_name_link, s10, ":troop_no"),
            (str_store_party_name_link, s4, ":center_no"),
            (store_add, ":string", ":old_imod", "str_imod_plain"),
            (str_store_string, s3, ":string"),
            (call_script, "script_game_get_money_text", ":cost"),
            (assign, reg0, ":troop_wealth"),
            (display_log_message, "@{s10} upgrades {s3}{s11} (costing {s1}) in {s4}, {reg0} denars remaining."),
          (try_end),
          (val_sub, ":troop_wealth", ":cost"),
          (troop_set_inventory_slot_modifier, ":troop_no", ":slot", ":imod"),
          (troop_set_inventory_slot_modifier, ":merchant", ":i_slot", ":old_imod"),
          (troop_add_gold, ":merchant", ":cost"),
          (assign, ":cap", 10), #one item has one upgrade at a time
        (try_end),
      (try_end),
      ##upgrade end
    (try_end),

    # SB : set wealth after tax and consumption
    (troop_set_slot, ":troop_no", slot_troop_wealth, ":troop_wealth"),
    #DEBUG
    (try_begin),
	  (eq, "$cheat_mode", 2),
      (neq, ":troop_wealth", ":initial_wealth"),
      (assign, reg1, ":initial_wealth"),
      (str_store_troop_name_link, s1, ":troop_no"),
      (str_store_party_name_link, s2, ":center_no"),
      (assign, reg2, ":troop_wealth"),
      (display_message, "@{s1} spends time in {s2}, {reg1} -> {reg2} denars"),
    (try_end),
    #Courtship
    (try_begin),
		(party_get_slot, ":time_of_last_courtship", ":led_party", slot_party_leader_last_courted),
		(store_sub, ":hours_since_last_courtship", ":current_time", ":time_of_last_courtship"),
		(gt, ":hours_since_last_courtship", 72),

		(troop_slot_eq, ":troop_no", slot_troop_spouse, -1),
		##diplomacy start+ Disable this for inappropriate types
		(neg|is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),#They use the last visited slots for other purposes
		(neg|is_between, ":troop_no", kings_begin, kings_end),#They should not be participating in this system
		(neg|is_between, ":troop_no", pretenders_begin, pretenders_end),#They should not be participating in this system
		##diplomacy end+
		(try_for_range, ":love_interest_slot", slot_troop_love_interest_1, slot_troop_love_interests_end),
			(troop_get_slot, ":love_interest", ":troop_no", ":love_interest_slot"),
			(gt, ":love_interest", 0),
			(troop_get_slot, ":love_interest_town", ":love_interest", slot_troop_cur_center),
			(eq, ":center_no", ":love_interest_town"),

			(call_script, "script_courtship_event_troop_court_lady", ":troop_no", ":love_interest"),
			(party_set_slot, ":led_party", slot_party_leader_last_courted, ":current_time"),
		(try_end),
    (try_end),

    ]),

  # script_process_kingdom_parties_ai
  # This is called more frequently than decide_kingdom_parties_ai
  # Input: none
  # Output: none
  #called from triggers
  ("process_kingdom_parties_ai",
    [
		##diplomacy start+ add support for promoted kingdom ladies
       (try_for_range, ":troop_no", heroes_begin, heroes_end),#<- change active_npcs to heroes
	   ##diplomacy end+
         (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
         (neg|troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0),
         (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
         (gt, ":party_no", 0),
         (call_script, "script_process_hero_ai", ":troop_no"),
       (try_end),
  ]),

  # script_process_hero_ai
  # This is called more frequently than script_decide_kingdom_party_ais
  #Handles sieges, raids, etc -- does not change the party's basic mission.
  # Input: none
  # Output: none
  #called from triggers
  ("process_hero_ai",
    [
      (store_script_param_1, ":troop_no"),
      (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
      (try_begin),
        (party_is_active, ":party_no"),
        (store_faction_of_party, ":faction_no", ":party_no"),
        (party_get_slot, ":ai_state", ":party_no", slot_party_ai_state),
        (party_get_slot, ":ai_object", ":party_no", slot_party_ai_object),
        (try_begin),
          (eq, ":ai_state", spai_besieging_center),
          (try_begin),
            (party_slot_eq, ":ai_object", slot_center_is_besieged_by, -1),
            (store_distance_to_party_from_party, ":distance", ":party_no", ":ai_object"),
            (lt, ":distance", 3),
            (try_begin),
              (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
              (party_get_slot, ":commander_party", ":party_no", slot_party_ai_object),
              (party_set_slot, ":ai_object", slot_center_is_besieged_by, ":commander_party"),
            (else_try),
              (party_set_slot, ":ai_object", slot_center_is_besieged_by, ":party_no"),
            (try_end),
            (store_current_hours, ":cur_hours"),
            (party_set_slot, ":ai_object", slot_center_siege_begin_hours, ":cur_hours"),


            (try_begin),
              (store_faction_of_party, ":ai_object_faction", ":ai_object"),
				 ##diplomacy start+ Handle player is co-ruler of faction
				 (assign, ":is_coruler", 0),
				 (try_begin),
					(eq, ":ai_object_faction", "$players_kingdom"),
					(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
					(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
					(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
					(assign, ":is_coruler", 1),
				 (try_end),
				 (this_or_next|eq, ":is_coruler", 1),
				 ##diplomacy end+
              (this_or_next|party_slot_eq, ":ai_object", slot_town_lord, "trp_player"),
              (eq, ":ai_object_faction", "fac_player_supporters_faction"),
              (call_script, "script_add_notification_menu", "mnu_notification_center_under_siege", ":ai_object", ":troop_no"),
            (try_end),
            (str_store_party_name_link, s1, ":ai_object"),
            (str_store_troop_name_link, s2, ":troop_no"),
            (str_store_faction_name_link, s3, ":faction_no"),
            #SB : store color of center object
            (faction_get_color, ":color", ":ai_object_faction"),
            (display_log_message, "@{s1} has been besieged by {s2} of {s3}.", ":color"),
            (call_script, "script_village_set_state", ":ai_object", svs_under_siege),
            (assign, "$g_recalculate_ais", 1),
          (try_end),
        (else_try),
          (eq, ":ai_state", spai_raiding_around_center),
          (party_slot_eq, ":party_no", slot_party_ai_substate, 0),
          (assign, ":selected_village", 0),
          (try_for_range, ":enemy_village_no", villages_begin, villages_end),
            (eq, ":selected_village", 0),
            (store_faction_of_party, ":enemy_village_faction", ":enemy_village_no"),
            (try_begin),
              (party_slot_eq, ":enemy_village_no", slot_town_lord, "trp_player"),
              (store_relation, ":reln", "fac_player_supporters_faction", ":faction_no"),
            (else_try),
              (store_relation, ":reln", ":enemy_village_faction", ":faction_no"),
            (try_end),
            (lt, ":reln", 0),
            (store_distance_to_party_from_party, ":dist", ":enemy_village_no", ":party_no"),
            (lt, ":dist", 15),
            (party_slot_eq, ":enemy_village_no", slot_village_state, svs_normal), #village is not already raided
            #CHANGE STATE TO RAID THIS VILLAGE
            (assign, ":selected_village", ":enemy_village_no"),
          (try_end),
          (try_begin),
            (eq, ":selected_village", 0),
            (is_between, ":ai_object", villages_begin, villages_end),
            (assign, ":selected_village", ":ai_object"),
          (try_end),
          (try_begin),
            (gt, ":selected_village", 0),
            #SB : minimum of 15 in raiding party, although in process_village_raids we calculate actual ratio
            (party_get_num_companions, ":num_troops", ":party_no"),
            (ge, ":num_troops", 15), #about 2 party template of reinforcements
            (call_script, "script_party_set_ai_state", ":party_no", spai_raiding_around_center, ":selected_village"),
            (try_begin),
              (faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),
              (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_raiding_village),
              (faction_set_slot, ":faction_no", slot_faction_ai_object, ":selected_village"),
            (try_end),
            (party_get_position, pos1, ":selected_village"),
            (map_get_random_position_around_position, pos2, pos1, 1),
            (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_point),
            (party_set_ai_target_position, ":party_no", pos2),
            (party_set_ai_object, ":party_no", ":selected_village"),
            (party_set_slot, ":party_no", slot_party_ai_substate, 1),
          (try_end),
        (else_try),
          (eq, ":ai_state", spai_raiding_around_center),#substate is 1
          (try_begin),
            (store_distance_to_party_from_party, ":distance", ":party_no", ":ai_object"),
            (lt, ":distance", 2),
            (try_begin),
              (party_slot_eq, ":ai_object", slot_village_state, svs_normal),
              (call_script, "script_village_set_state", ":ai_object", svs_being_raided),
              (party_set_slot, ":ai_object", slot_village_raided_by, ":party_no"),
              (try_begin),
                (store_faction_of_party, ":village_faction", ":ai_object"),
				 ##diplomacy start+ Handle player is co-ruler of faction
				 (assign, ":is_coruler", 0),
				 (try_begin),
					(eq, ":village_faction", "$players_kingdom"),
					(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
					(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
					(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
					(assign, ":is_coruler", 1),
				 (try_end),
				 (this_or_next|eq, ":is_coruler", 1),
				 ##diplomacy end+
                (this_or_next|party_slot_eq, ":ai_object", slot_town_lord, "trp_player"),
                (eq, ":village_faction", "fac_player_supporters_faction"),
                (store_distance_to_party_from_party, ":dist", "p_main_party", ":ai_object"),
                (this_or_next|lt, ":dist", 30),
                (party_slot_eq, ":ai_object", slot_center_has_messenger_post, 1),
                (call_script, "script_add_notification_menu", "mnu_notification_village_raid_started", ":ai_object", ":troop_no"),
              (try_end),
            (else_try),
              (party_slot_eq, ":ai_object", slot_village_state, svs_being_raided),
            (else_try),
              #if anything other than being_raided leave
              (party_set_slot, ":party_no", slot_party_ai_substate, 0),
            (try_end),
          (try_end),
        (else_try),
          (eq, ":ai_state", spai_retreating_to_center),
          (try_begin),
            (party_get_battle_opponent, ":enemy_party", ":party_no"),
            (ge, ":enemy_party", 0), #we are in a battle! we may be caught in a loop!
            (call_script, "script_party_set_ai_state", ":party_no", spai_undefined, -1),
            (party_set_flags, ":party_no", pf_default_behavior, 0),
            (party_set_slot, ":party_no", slot_party_commander_party, -1),
          (try_end),
        (else_try),
          (eq, ":ai_state", spai_patrolling_around_center),

          (try_begin),
            (party_slot_eq, ":party_no", slot_party_ai_substate, 0),
            (store_distance_to_party_from_party, ":distance", ":party_no", ":ai_object"),
            (lt, ":distance", 6),
            (party_set_slot, ":party_no", slot_party_ai_substate, 1),

	        (party_set_aggressiveness, ":party_no", 8),
	        (party_set_courage, ":party_no", 8),
	        (party_set_ai_initiative, ":party_no", 100),

            (party_set_ai_behavior, ":party_no", ai_bhvr_patrol_party),
            (party_set_ai_object, ":party_no", ":ai_object"),
          (try_end),
        (else_try),
          (eq, ":ai_state", spai_holding_center),
        (try_end),
      (try_end),
  ]),

  # script_begin_assault_on_center
  # Input: arg1: faction_no
  # Output: none
  #called from triggers
  ("begin_assault_on_center",
   [
     (store_script_param, ":center_no", 1),
	 ##diplomacy start+ add support for promoted kingdom ladies
     (try_for_range, ":troop_no", heroes_begin, heroes_end),#<- change active_npcs to heroes
	 ##diplomacy end+
       (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
       (neg|troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0),
       (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
       (gt, ":party_no", 0),
       (party_is_active, ":party_no"),

       (assign, ":continue", 0),
       (try_begin),
         (party_slot_eq, ":party_no", slot_party_ai_state, spai_besieging_center),
         (party_slot_eq, ":party_no", slot_party_ai_object, ":center_no"),
         (party_slot_eq, ":party_no", slot_party_ai_substate, 0),
         (assign, ":continue", 1),
       (else_try),
         (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
         (party_get_slot, ":commander_party", ":party_no", slot_party_ai_object),
         (gt, ":commander_party", 0),
         (party_is_active, ":commander_party"),
         (party_slot_eq, ":commander_party", slot_party_ai_state, spai_besieging_center),
         (party_slot_eq, ":commander_party", slot_party_ai_object, ":center_no"),
         (call_script, "script_party_set_ai_state", ":party_no", spai_besieging_center, ":center_no"),
         (assign, ":continue", 1),
       (try_end),

       (eq, ":continue", 1),

       (party_set_ai_behavior, ":party_no", ai_bhvr_attack_party),
       (party_set_ai_object, ":party_no", ":center_no"),
       (party_set_flags, ":party_no", pf_default_behavior, 1),
       (party_set_slot, ":party_no", slot_party_ai_substate, 1),
     (try_end),
   ]),

  #DEPRECATED - Using new political issue system instead
  ("select_faction_marshall",
   [
#     (store_script_param_1, ":faction_no"),
 #    (faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),
  #   (faction_get_slot, ":old_faction_marshall", ":faction_no", slot_faction_marshall),

   #  (assign, ":old_marshal_is_avaliable", 0),
    # (try_begin),
     #  (gt, ":old_faction_marshall", 0),
      # (troop_get_slot, ":old_marshal_party", ":old_faction_marshall", slot_troop_leaded_party),
     #  (party_is_active, ":old_marshal_party"),
    #   (assign, ":old_marshal_is_avaliable", 1),
   #  (try_end),

     #Ozan : I am adding some codes here because sometimes armies demobilize during last seconds of an
	 #important event like taking a castle, ext because of marshal change. When marshal changes during
	 #an important event occurs new marshal's followers become 0 and continueing siege attack seems less
	 #valuable then armies demobilize, faction ai become "do nothing", "I cannot think anything to do" ext.

   #  (assign, ":there_is_an_important_situation", 0),
   #  (faction_get_slot, ":current_ai_object", ":faction_no", slot_faction_ai_object),

   #  (try_begin), #do not demobilize during taking a castle/town (fighting in the castle)
   #    (is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
   #    (party_get_battle_opponent, ":besieger_party", ":current_ai_object"),
   #    (ge, ":besieger_party", 0),
   #    (party_is_active, ":besieger_party"),
   #    (store_faction_of_party, ":besieger_faction", ":besieger_party"),
   #    (this_or_next|eq, ":besieger_faction", ":faction_no"),
   #    (eq, ":besieger_faction", "fac_player_faction"),
   #    (assign, ":there_is_an_important_situation", 1),
   #  (try_end),

   #  (try_begin), #do not demobilize during raiding a village (holding around village)
   #    (is_between, ":current_ai_object", centers_begin, centers_end),
   #    (neg|is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
   #    (party_slot_eq, ":current_ai_object", slot_village_state, svs_being_raided),
   #    (assign, ":there_is_an_important_situation", 1),
   #  (try_end),

   #  (try_begin), #do not demobilize during besigning a siege (holding around castle)
   #    (is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
   #    #(str_store_party_name, s7, ":current_ai_object"),
   #    (party_get_slot, ":besieger_party", ":current_ai_object", slot_center_is_besieged_by),
   #    (ge, ":besieger_party", 0),
   #    (party_is_active, ":besieger_party"),
   #    #(str_store_party_name, s7, ":besieger_party"),
   #    (store_faction_of_party, ":besieger_faction", ":besieger_party"),
   #    (this_or_next|eq, ":besieger_faction", ":faction_no"),
   #    (eq, ":besieger_faction", "fac_player_faction"),
   #    (assign, ":there_is_an_important_situation", 1),
   #  (try_end),

   #  (try_begin),
   #    (this_or_next|eq, ":there_is_an_important_situation", 0),
   #    (eq, ":old_marshal_is_avaliable", 0),
       #end addition ozan


    #   (assign, ":total_renown", 0),
    #   (try_for_range, ":loop_var", active_npcs_including_player_begin, active_npcs_end),
    #     (assign, ":cur_troop", ":loop_var"),
    #     (assign, ":continue", 0),
    #     (try_begin),
    #       (eq, ":loop_var", "trp_kingdom_heroes_including_player_begin"),
    #       (assign, ":cur_troop", "trp_player"),
    #       (try_begin),
    #         (eq, ":faction_no", "$players_kingdom"),
    #         (assign, ":continue", 1),
    #       (try_end),
    #     (else_try),
    #       (troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
    #       (store_troop_faction, ":cur_faction", ":cur_troop"),
    #       (eq, ":cur_faction", ":faction_no"),
    #       (troop_get_slot, ":cur_party", ":cur_troop", slot_troop_leaded_party),
    #       (gt, ":cur_party", 0),
    #       (party_is_active, ":cur_party"),
    #       (call_script, "script_party_count_fit_for_battle", ":cur_party"),
    #       (assign, ":party_fit_for_battle", reg0),
    #       (call_script, "script_party_get_ideal_size", ":cur_party"),
    #       (assign, ":ideal_size", reg0),
    #       (store_mul, ":relative_strength", ":party_fit_for_battle", 100),
    #       (val_div, ":relative_strength", ":ideal_size"),
    #       (ge, ":relative_strength", 25),
    #       (assign, ":continue", 1),
    #     (try_end),

     #    (eq, ":continue", 1),

    #     (troop_get_slot, ":renown", ":cur_troop", slot_troop_renown),
	#     (call_script, "script_troop_get_relation_with_troop", ":cur_troop", ":faction_leader"),
	#     (store_mul, ":relation_modifier", reg0, 15),
	#     (val_add, ":renown", ":relation_modifier"),
	#     (val_max, ":renown", 1),
	#
    #     (try_begin),
    #       (eq, ":cur_troop", "trp_player"),
    #       (neq, ":old_faction_marshall", "trp_player"),
    #       (assign, ":renown", 0),
   #      (try_end),
    #     (try_begin),
    #       (eq, ":cur_troop", ":faction_leader"),
    #       (val_mul, ":renown", 3),
    #       (val_div, ":renown", 4),
    #     (try_end),
    #     (try_begin),
    #       (eq, ":cur_troop", ":old_faction_marshall"),
    #       (val_mul, ":renown", 1000),
    #     (try_end),
    #     (val_add, ":total_renown", ":renown"),
    #   (try_end),
    #   (assign, ":result", -1),
    #   (try_begin),
    #     (gt, ":total_renown", 0),
    #     (store_random_in_range, ":random_renown", 0, ":total_renown"),
    #     (try_for_range, ":loop_var", active_npcs_including_player_begin, active_npcs_end),
    #       (eq, ":result", -1),
    #       (assign, ":cur_troop", ":loop_var"),
    #       (assign, ":continue", 0),
    #       (try_begin),
    #         (eq, ":loop_var", "trp_kingdom_heroes_including_player_begin"),
    #         (assign, ":cur_troop", "trp_player"),
   #          (try_begin),
   #            (eq, ":faction_no", "$players_kingdom"),
   #            (assign, ":continue", 1),
   #          (try_end),
   #        (else_try),
   #          (troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
   #          (store_troop_faction, ":cur_faction", ":cur_troop"),
   #          (eq, ":cur_faction", ":faction_no"),
   #          (troop_get_slot, ":cur_party", ":cur_troop", slot_troop_leaded_party),
   #          (gt, ":cur_party", 0),
   #          (party_is_active, ":cur_party"),
   #          (call_script, "script_party_count_fit_for_battle", ":cur_party"),
   #          (assign, ":party_fit_for_battle", reg0),
      #       (call_script, "script_party_get_ideal_size", ":cur_party"),
      #       (assign, ":ideal_size", reg0),
      #       (store_mul, ":relative_strength", ":party_fit_for_battle", 100),
      #       (val_div, ":relative_strength", ":ideal_size"),
      #       (ge, ":relative_strength", 25),
      #       (assign, ":continue", 1),
      #     (try_end),
      #     (eq, ":continue", 1),

		#   (troop_get_slot, ":renown", ":cur_troop", slot_troop_renown),
	    #   (call_script, "script_troop_get_relation_with_troop", ":cur_troop", ":faction_leader"),
	    #   (store_mul, ":relation_modifier", reg0, 15),
	    #   (val_add, ":renown", ":relation_modifier"),
	    #   (val_max, ":renown", 1),
		#
        #   (try_begin),
        #     (eq, ":cur_troop", "trp_player"),
        #     (neq, ":old_faction_marshall", "trp_player"),
        #     (assign, ":renown", 0),
        #   (try_end),
        #   (try_begin),
        #     (eq, ":cur_troop", ":faction_leader"),
        #     (val_mul, ":renown", 3),
         #    (val_div, ":renown", 4),
         #  (try_end),
         #  (try_begin),
       #      (eq, ":cur_troop", ":old_faction_marshall"),
       #      (val_mul, ":renown", 1000),
       #    (try_end),
       #    (val_sub, ":random_renown", ":renown"),
       #    (lt, ":random_renown", 0),
       #    (assign, ":result", ":cur_troop"),
       #  (try_end),
      # (try_end),
      # (try_begin),
         #(eq, "$cheat_mode", 1),
        # (ge, ":result", 0),
       #  (str_store_troop_name, s1, ":result"),
      #   (str_store_faction_name, s2, ":faction_no"),
     #    (display_message, "@{!}{s1} is chosen as the marshall of {s2}."),
    #   (try_end),
   #  (else_try),
   #    (faction_get_slot, ":old_faction_marshall", ":faction_no", slot_faction_marshall),
   #    (assign, ":result", ":old_faction_marshall"),
   #  (try_end),

   #  (assign, reg0, ":result"),
     ]),




  # script_get_center_faction_relation_including_player
  # Input: arg1: center_no, arg2: target_faction_no
  # Output: reg0: relation
  #called from triggers
  ("get_center_faction_relation_including_player",
   [
     (store_script_param, ":center_no", 1),
     (store_script_param, ":target_faction_no", 2),
     (store_faction_of_party, ":center_faction", ":center_no"),
     (store_relation, ":relation", ":center_faction", ":target_faction_no"),
     (try_begin),
       (party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
       (store_relation, ":relation", "fac_player_supporters_faction", ":target_faction_no"),
     (try_end),
     (assign, reg0, ":relation"),
     ]),

   #script_update_report_to_army_quest_note
   ("update_report_to_army_quest_note",
   [
     (store_script_param, ":faction_no", 1),
     (store_script_param, ":new_strategy", 2),
     (store_script_param, ":old_faction_ai_state", 3),

     (try_begin),
     (le, "$number_of_report_to_army_quest_notes", 13),

     (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),

     (try_begin), #updating quest notes for only report to army quest
       (eq, ":faction_no", "$players_kingdom"),
       (neq, ":new_strategy", ":old_faction_ai_state"),
       (check_quest_active, "qst_report_to_army"),
       (ge, ":faction_marshal", 0),

       (str_store_troop_name_link, s11, ":faction_marshal"),
       (store_current_hours, ":hours"),
       (call_script, "script_game_get_date_text", 0, ":hours"),

       (try_begin),
         (this_or_next|eq, ":new_strategy", sfai_attacking_enemies_around_center),
         (this_or_next|eq, ":new_strategy", sfai_attacking_center),
         (eq, ":new_strategy", sfai_gathering_army),
         (faction_get_slot, ":faction_object", ":faction_no", slot_faction_ai_object),
         (ge, ":faction_object", 0),
         (str_store_party_name_link, s21, ":faction_object"),
       (try_end),

       (try_begin),
         (eq, ":new_strategy", sfai_gathering_army),

         (try_begin),
           (ge, "$g_gathering_reason", 0),
           (str_store_party_name_link, s21, "$g_gathering_reason"),
           (str_store_string, s14, "str_we_should_prepare_to_defend_s21_but_we_should_gather_our_forces_until_we_are_strong_enough_to_engage_them"),
         (else_try),
           (str_store_string, s14, "str_it_is_time_to_go_on_the_offensive_and_we_must_first_assemble_the_army"),
         (try_end),

         (str_store_string, s14, "@({s1}) {s11}: {s14}"),
         (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
         (val_add, "$number_of_report_to_army_quest_notes", 1),
       (else_try),
         (eq, ":new_strategy", sfai_attacking_enemies_around_center),

         (try_begin),
           (is_between, ":faction_object", walled_centers_begin, walled_centers_end),
           (str_store_string, s14, "str_we_should_ride_to_break_the_siege_of_s21"),
           (str_store_string, s14, "@({s1}) {s11}: {s14}"),
           (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
           (val_add, "$number_of_report_to_army_quest_notes", 1),
         (else_try),
           (is_between, ":faction_object", villages_begin, villages_end),
           (str_store_string, s14, "str_we_should_ride_to_defeat_the_enemy_gathered_near_s21"),
           (str_store_string, s14, "@({s1}) {s11}: {s14}"),
           (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
           (val_add, "$number_of_report_to_army_quest_notes", 1),
         (try_end),
       (else_try),
         (this_or_next|eq, ":new_strategy", sfai_attacking_center),
         (eq, ":new_strategy", sfai_raiding_village),

         (try_begin),
           (is_between, ":faction_object", walled_centers_begin, walled_centers_end),
           (str_store_string, s14, "str_we_believe_the_fortress_will_be_worth_the_effort_to_take_it"),
           (str_store_string, s14, "@{s14} ({s21})"),
           (str_store_string, s14, "@({s1}) {s11}: {s14}"),
           (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
           (val_add, "$number_of_report_to_army_quest_notes", 1),
         (else_try),
           (is_between, ":faction_object", villages_begin, villages_end),
           (str_store_string, s14, "str_we_shall_leave_a_fiery_trail_through_the_heart_of_the_enemys_lands_targeting_the_wealthy_settlements_if_we_can"),
           (str_store_string, s14, "@{s14} ({s21})"),
           (str_store_string, s14, "@({s1}) {s11}: {s14}"),
           (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
           (val_add, "$number_of_report_to_army_quest_notes", 1),
         (try_end),
       (try_end),
     (try_end),
     (try_end),
   ]),


  # script_decide_faction_ai
  # Input: arg1: faction_no
  # Output: none
  #called from triggers
  ("decide_faction_ai",
  #This handles political issues and faction issues
   [
    (store_script_param_1, ":faction_no"),


    (faction_get_slot, ":old_faction_ai_state", ":faction_no", slot_faction_ai_state),
    (faction_get_slot, ":old_faction_ai_object", ":faction_no", slot_faction_ai_object),
	(faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),


	#Remove marshal if he has become too controversial,, or he has defected, or has been taken prisoner
	(try_begin),
        (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
		(neq, ":faction_no", "fac_player_supporters_faction"),
		(ge, ":faction_marshal", "trp_player"),

		(store_faction_of_troop, ":marshal_faction", ":faction_marshal"),
		(try_begin),
			(eq, ":faction_marshal", "trp_player"),
			(assign, ":marshal_faction", "$players_kingdom"),
		(try_end),


		(assign, ":player_marshal_is_prisoner", 0),
		(try_begin),
			(eq, ":faction_marshal", "trp_player"),
			(eq, "$g_player_is_captive", 1),
			(assign, ":player_marshal_is_prisoner", 1),
		(try_end),


		#High controversy level, or marshal has defected, or is prisoner
		(this_or_next|neq, ":marshal_faction", ":faction_no"),
		(this_or_next|troop_slot_ge, ":faction_marshal", slot_troop_controversy, 80),
		(this_or_next|eq, ":player_marshal_is_prisoner", 1),
			(troop_slot_ge, ":faction_marshal", slot_troop_prisoner_of_party, 0),

		(assign, ":few_following_player_campaign", 0),
		(try_begin),
			(eq, ":faction_marshal", "trp_player"),
			(assign, ":vassals_following_player_campaign", 0),
			(gt, "$g_player_days_as_marshal", 1),
			(try_for_range, ":vassal", active_npcs_begin, active_npcs_end),
				(troop_slot_eq, ":vassal", slot_troop_occupation, slto_kingdom_hero),
				(store_faction_of_troop, ":vassal_faction", ":vassal"),
				(eq, ":vassal_faction", ":faction_no"),
				(call_script, "script_npc_decision_checklist_troop_follow_or_not", ":vassal"),
				(eq, reg0, 1),
				(val_add, ":vassals_following_player_campaign", 1),
			(try_end),
			(lt, ":vassals_following_player_campaign", 4),
			(assign, ":few_following_player_campaign", 1),
		(try_end),

		#Only remove marshal for controversy if offensive campaign in progress
		(this_or_next|eq, ":old_faction_ai_state", sfai_default),
		(this_or_next|eq, ":old_faction_ai_state", sfai_feast),
		(this_or_next|neq, ":marshal_faction", ":faction_no"),
		(this_or_next|eq, ":few_following_player_campaign", 1),
		(this_or_next|eq, ":player_marshal_is_prisoner", 1),
			(troop_slot_ge, ":faction_marshal", slot_troop_prisoner_of_party, 0),

		#No current issue on the agenda
		(this_or_next|faction_slot_eq, ":faction_no", slot_faction_political_issue, 0),
		(this_or_next|eq, ":player_marshal_is_prisoner", 1),
			(troop_slot_ge, ":faction_marshal", slot_troop_prisoner_of_party, 0),

		(faction_set_slot, ":faction_no", slot_faction_political_issue, 1), #Appointment of marshal
		(store_current_hours, ":hours"),
		(val_max, ":hours", 0),
		(faction_set_slot, ":faction_no", slot_faction_political_issue_time, ":hours"), #Appointment of marshal

        (faction_get_slot, ":old_marshall", ":faction_no", slot_faction_marshall),
        (try_begin),
		  (ge, ":old_marshall", 0),
		  (troop_get_slot, ":old_marshall_party", ":old_marshall", slot_troop_leaded_party),
          (party_is_active, ":old_marshall_party"),
          (party_set_marshal, ":old_marshall_party", 0),
        (try_end),

		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(faction_slot_eq, "$players_kingdom", slot_faction_marshall, "trp_player"),
			(call_script, "script_add_notification_menu", "mnu_notification_relieved_as_marshal", 0, 0),
		(else_try),
			(neq, ":old_marshall", "trp_player"),
			(call_script, "script_change_troop_renown", ":old_marshall", 15),
		(try_end),
		(faction_set_slot, ":faction_no", slot_faction_marshall, -1),
		(assign, ":faction_marshal", -1),


		##diplomacy start+ add support for promoted kingdom ladies
		(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
		##diplomacy end+
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
		(try_end),
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),
		(try_end),

	(else_try),	 #If marshal not present, and not already on agenda, make political issue
		(eq, ":faction_marshal", -1),
		(neg|faction_slot_ge, ":faction_no", slot_faction_political_issue, 1), #This to avoid resetting votes every time

        (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
		(neq, ":faction_no", "fac_player_supporters_faction"),

		(faction_set_slot, ":faction_no", slot_faction_political_issue, 1), #Appointment of marshal
		(store_current_hours, ":hours"),
		(val_max, ":hours", 0),
		(faction_set_slot, ":faction_no", slot_faction_political_issue_time, ":hours"), #Appointment of marshal

		##diplomacy start+ add support for promoted kingdom ladies
		(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
		##diplomacy end+
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
		(try_end),
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),
		(try_end),


	(else_try),	#If player is marshal, but not part of faction
		(eq, ":faction_marshal", "trp_player"),
		(neq, "$players_kingdom", ":faction_no"),

		(faction_set_slot, ":faction_no", slot_faction_political_issue, 1), #Appointment of marshal
		(store_current_hours, ":hours"),
		(val_max, ":hours", 0),
		(faction_set_slot, ":faction_no", slot_faction_political_issue_time, ":hours"), #Appointment of marshal

        (faction_get_slot, ":old_marshall", ":faction_no", slot_faction_marshall),
        (try_begin),
		  (ge, ":old_marshall", 0),
		  (troop_get_slot, ":old_marshall_party", ":old_marshall", slot_troop_leaded_party),
          (party_is_active, ":old_marshall_party"),
          (party_set_marshal, ":old_marshall_party", 0),
        (try_end),

		(faction_set_slot, ":faction_no", slot_faction_marshall, -1),
		(assign, ":faction_marshal", -1),

		##diplomacy start+ add support for promoted kingdom ladies
		(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
		##diplomacy end+
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
		(try_end),
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),
		(try_end),

	(try_end),

	#If the faction issue is a center no longer under faction control, remove and reset
	(try_begin),
		(faction_get_slot, ":faction_political_issue", ":faction_no", slot_faction_political_issue),
		(is_between, ":faction_political_issue", centers_begin, centers_end),
		(store_faction_of_party, ":disputed_center_faction", ":faction_political_issue"),
		(neq, ":disputed_center_faction", ":faction_no"),

		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_faction_name, s4, ":faction_no"),
			(str_store_party_name, s5, ":disputed_center_faction"),
			(display_message, "@{!}DEBUG -- {s4} drops {s5} as issue as it has changed hands"),
		(try_end),

		#Reset political issue
		(faction_set_slot, ":faction_no", slot_faction_political_issue, 0),
		##diplomacy start+ add support for promoted kingdom ladies
		(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
		##diplomacy end+
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
		(try_end),
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),
		(try_end),

	(try_end),


	#Resolve the political issue on the agenda
	(try_begin),
		(faction_slot_ge, ":faction_no", slot_faction_political_issue, 1),
		(neq, ":faction_no", "fac_player_supporters_faction"),

		#Do not switch marshals during a campaign
		(this_or_next|faction_slot_ge, ":faction_no", slot_faction_political_issue, centers_begin),
		(this_or_next|faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_default),
			(faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_feast),


		(faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),

		(assign, ":total_lords", 0),
		(assign, ":lords_who_have_voted", 0),
		(assign, ":popular_favorite", -1),

		#Reset number of votes
		(troop_set_slot, "trp_player", slot_troop_temp_slot, 0),
		##diplomacy start+ add support for promoted kingdom ladies
		(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
		##diplomacy end+
			(troop_set_slot, ":active_npc", slot_troop_temp_slot, 0),
		(try_end),

		#Tabulate votes

		##diplomacy start+
		(try_begin),#count the player's vote
			(eq, "$players_kingdom", ":faction_no"),
			(ge, "$player_has_homage", 1),
			(troop_get_slot, ":lord_chosen_candidate", "trp_player", slot_troop_stance_on_faction_issue),
      			(gt, ":lord_chosen_candidate", -1),
			#You may notice that I don't count the player for "total_lords" if he was undecided.
			#This is so faction behavior will not be changed from Native if the player did not
			#support anyone.
			(val_add, ":total_lords", 1),
			(val_add, ":lords_who_have_voted", 1),
			(troop_set_slot, ":lord_chosen_candidate", slot_troop_temp_slot, 1),
			(assign, ":popular_favorite", ":lord_chosen_candidate"),
		(try_end),
		#add support for promoted kingdom ladies
		(try_for_range, ":voting_lord", heroes_begin, heroes_end),#<- changed active_npcs_begin/end to heroes_begin/end
			(this_or_next|troop_slot_eq, ":voting_lord", slot_troop_occupation, slto_kingdom_hero),
				(is_between, ":voting_lord", active_npcs_begin, active_npcs_end),
		       	#the dead / retired / exiled do not vote
			(neg|troop_slot_ge, ":voting_lord", slot_troop_occupation, slto_retirement),
		##diplomacy end+
			(store_faction_of_troop, ":voting_lord_faction", ":voting_lord"),
			(eq, ":voting_lord_faction", ":faction_no"),
			(val_add, ":total_lords", 1),
			(troop_get_slot, ":lord_chosen_candidate", ":voting_lord", slot_troop_stance_on_faction_issue),
			(gt, ":lord_chosen_candidate", -1),
			(val_add, ":lords_who_have_voted", 1),
			(troop_get_slot, ":total_votes", ":lord_chosen_candidate", slot_troop_temp_slot),
			(val_add, ":total_votes", 1),
			(troop_set_slot, ":lord_chosen_candidate", slot_troop_temp_slot, ":total_votes"),
			(try_begin),
				(gt, ":popular_favorite", -1),
				(troop_get_slot, ":current_winner_votes", ":popular_favorite", slot_troop_temp_slot),
				(gt, ":total_votes", ":current_winner_votes"),
				(assign, ":popular_favorite", ":lord_chosen_candidate"),
			(else_try),
				(eq, ":popular_favorite", -1),
				(assign, ":popular_favorite", ":lord_chosen_candidate"),
			(try_end),
		(try_end),

		#Check to see if enough lords have voted
		(store_div, ":number_required_for_quorum", ":total_lords", 5),
		(val_mul, ":number_required_for_quorum", 4),
		##diplomacy start+
		#Replace number required for quorum, altering it based on the centralization
		#value.  Do the same for the minimum time left on the agenda.
		(faction_get_slot, ":centralization", ":faction_no", dplmc_slot_faction_centralization),
		(val_clamp, ":centralization", -3, 4),
		(try_begin),
			#Disable this for now, since NPC kingdoms set their policies randomly.
			(eq, 0, 1),
			(neq, ":centralization", 0),
			(store_sub, ":number_required_for_quorum", 15, ":centralization"),#fully centralized = 12/20 , fully decentralized = 18/20
			(try_begin),
				#If the plutocracy/aristocracy slider is negative, allow it to offset
				#a negative centralization value for the purpose of quorum, on the
				#assumption that part of the "quorum" is accounted for by the influence
				#of merchants.  They do not vote currently, although integrating guild masters
				#and/or village elders into the faction issue system is something to consider
				#for the future.
				(ge, ":number_required_for_quorum", 16),
				(faction_get_slot, ":aristocracy", ":faction_no", dplmc_slot_faction_aristocracy),
				(lt, ":aristocracy", 0),
				(val_clamp, ":aristocracy", -3, 4),
				(val_add, ":number_required_for_quorum", ":aristocracy"),
				(val_max, ":number_required_for_quorum", 15),
			(try_end),
			(val_mul, ":number_required_for_quorum", ":total_lords"),
			(val_div, ":number_required_for_quorum", 20),
		(try_end),
		##diplomacy end+

#		(gt, ":lords_who_have_voted", ":number_required_for_quorum"),

		(store_current_hours, ":hours_on_agenda"),
		(faction_get_slot, ":hours_when_put_on_agenda", ":faction_no", slot_faction_political_issue_time), #Appointment of marshal
		(val_sub, ":hours_on_agenda", ":hours_when_put_on_agenda"),

		##diplomacy start+
		#Before, the maximum number of hours on the agenda for an issue before it became
		#eligible for resolution regardless of quorum was fixed at 120 (five days).
		#Modify this by 16 hours for every point of centralization, for a minimum
		#of 3 days and a maximum of 7 days.
		(assign, ":hours_on_agenda_threshold", 120),
		(try_begin),
			#Disable this for now, since arguably all of the NPC kingdoms are
			#supposed to have fairly similar structures.  From a gameplay perspective,
			#they choose their kingdom policy at random, so enabling this is  probably
			#not going to have good effects, unless more thought is given to balancing
			#centralization/decentralization for NPC kingdoms.
			(eq, 0, 1),
			(store_mul, ":hours_on_agenda_threshold", ":centralization", 16),
			(val_add, ":hours_on_agenda_threshold", 120),
			(try_begin),
				(neq, ":centralization", 0),
			(try_end),
		(try_end),

		#(this_or_next|gt, ":lords_who_have_voted", ":number_required_for_quorum"),
		#	(ge, ":hours_on_agenda", 120),

		(this_or_next|gt, ":lords_who_have_voted", ":number_required_for_quorum"),
			(ge, ":hours_on_agenda", ":hours_on_agenda_threshold"),
		##diplomacy end+

		(try_begin),
			(eq, "$cheat_mode", 1),
			(assign, reg4, ":lords_who_have_voted"),
			(assign, reg5, ":number_required_for_quorum"),
			(assign, reg7, ":hours_on_agenda"),
			(str_store_faction_name, s4, ":faction_no"),
			(display_message, "@{!}DEBUG -- Issue resolution for {s4}: {reg4} votes for a quorum of {reg5}, {reg7} hours on agenda"),
		(try_end),


		(try_begin),
		  (eq, "$cheat_mode", 1),
		  (display_message, "@{!}DEBUG -- Faction resolves political issue"),
		(try_end),


		#Resolve faction political issue
		(assign, ":winning_candidate", -1),

		##diplomacy start+
		#Change "liege overrules lords" check.  The version in Native caused relation death spirals:
		#a lord who has no fiefs becomes unhappy, and since relation is symmetrical, this can result
		#in the liege never granting him fiefs.
		#
		#OLD BEHAVIOR:
#		(else_try)
#			(call_script, "script_troop_get_relation_with_troop", ":faction_leader", ":popular_favorite"),
#			(this_or_next|ge, reg0, 10),
#			(this_or_next|troop_slot_eq, ":faction_leader", slot_troop_stance_on_faction_issue, ":popular_favorite"),
#				(troop_slot_eq, ":faction_leader", slot_troop_stance_on_faction_issue, -1),
#
#			(assign, ":winning_candidate", ":popular_favorite"),
#		(else_try),#Lord overrules lords' opinion
#			(gt, ":faction_leader", -1), #not sure why this is necessary
#			(troop_get_slot, ":liege_choice", ":faction_leader", slot_troop_stance_on_faction_issue),
#			(ge, ":liege_choice", -1),
#
#			(assign, ":winning_candidate", ":liege_choice"),
#      (try_end),
#
#      NEW BEHAVIOR
        (troop_get_slot, ":liege_choice", ":faction_leader", slot_troop_stance_on_faction_issue),
		(assign, ":min_liege_relation", 10),#<-- Same as in default
		(faction_get_slot, ":issue_on_table", ":faction_no", slot_faction_political_issue),
		(try_begin),
		  (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		  #Alter the minimum for villages and castles, but not towns or the marshall.
		  (this_or_next|is_between, ":issue_on_table", villages_begin, villages_end),
		     (is_between, ":issue_on_table", castles_begin, castles_end),
		  (store_random_in_range, ":min_liege_relation", 0, 16),
		  (val_sub, ":min_liege_relation", 5),#-5 to 10
		(try_end),
		#New override check
		(try_begin),
			#When the player is co-ruler of the kingdom, his/her support for the popular
			#candidate can be sufficient to guarantee success over the opposition of the
			#king/queen.
			(ge, ":faction_leader", 1),
			(eq, "$players_kingdom", ":faction_no"),
			(this_or_next|troop_slot_eq, ":faction_leader", slot_troop_spouse, "trp_player"),
				(troop_slot_eq, "trp_player", slot_troop_spouse, ":faction_leader"),
			(troop_slot_eq, "trp_player", slot_troop_stance_on_faction_issue, ":popular_favorite"),
			(assign, ":winning_candidate", ":popular_favorite"),
            (else_try),
            	#The leader may overrule a choice he disagrees with, if he dislikes the candidate
            	#sufficiently and has someone else in mind.
            	(ge, ":faction_leader", 1),
			(neq, ":liege_choice", ":popular_favorite"),
			(gt, ":liege_choice", -1),
			(call_script, "script_troop_get_relation_with_troop", ":faction_leader", ":liege_choice"),
			(val_min, ":min_liege_relation", reg0),
            	(call_script, "script_troop_get_relation_with_troop", ":faction_leader", ":popular_favorite"),
			(gt, ":min_liege_relation", reg0),
			(assign, reg0, 0),
            	(try_begin),
			   (troop_slot_ge, ":faction_leader", slot_troop_prisoner_of_party, 0),
			   (store_random_in_range, reg0, 0, 2),
			(try_end),
			(try_begin),
			    #The leader would have overruled the choice, but cannot because he is a prisoner.
            		#Print a message letting people know when this happens.
				(eq, reg0, 1),
				(gt, ":popular_favorite", -1),
            		(this_or_next|eq, "$players_kingdom", ":faction_no"),
            		(ge, "$cheat_mode", 1),
            		(str_store_faction_name, s4, ":faction_no"),
            		(str_store_troop_name, s5, ":popular_favorite"),
            		(str_store_troop_name, s0, ":faction_leader"),
            		(try_begin),
            			(eq, ":issue_on_table", 1),
					(display_message, "@{s5} has the greatest support among the lords of the {s4} to be the next marshall.  {s0} is indisposed and cannot overrule their choice."),
            		(else_try),
            			(is_between, ":issue_on_table", centers_begin, centers_end),
            			(str_store_party_name, s1, ":issue_on_table"),
					(display_message, "@{s5} has the greatest support among the lords of the {s4} to receive {s1}.  {s0} is indisposed and cannot overrule their choice."),
            		(try_end),
            	(try_end),
			(eq, reg0, 0),
			(assign, ":winning_candidate", ":liege_choice"),
			(try_begin),
				#Print a message letting people know when this happens.
				(gt, ":popular_favorite", -1),
				(this_or_next|eq, "$players_kingdom", ":faction_no"),
					(ge, "$cheat_mode", 1),
				(str_store_faction_name, s4, ":faction_no"),
				(str_store_troop_name, s5, ":popular_favorite"),
				(str_store_troop_name, s0, ":faction_leader"),
				(try_begin),
					(eq, ":issue_on_table", 1),
					(display_message, "@{s5} has the greatest support among the lords of the {s4} to be the next marshall, but {s0} overrules their choice."),
				(else_try),
					(is_between, ":issue_on_table", centers_begin, centers_end),
					(str_store_party_name, s1, ":issue_on_table"),
					(display_message, "@{s5} has the greatest support among the lords of the {s4} to receive {s1}, but {s0} overrules their choice."),
				(try_end),
			(try_end),
		(else_try),
			#No override: use popular candidate
			(assign, ":winning_candidate", ":popular_favorite"),
		(try_end),
		##diplomacy end+

		#Carry out faction decision
		(try_begin), #Nothing happens
			(eq, ":winning_candidate", -1),

		(else_try), #For player, create a menu to accept or refuse
			(eq, ":winning_candidate", "trp_player"),
			(eq, "$players_kingdom", ":faction_no"),
			(call_script, "script_add_notification_menu", "mnu_notification_player_faction_political_issue_resolved_for_player", 0, 0),
		(else_try),
			(eq, ":winning_candidate", "trp_player"),
			(neq, "$players_kingdom", ":faction_no"),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_faction_name, s4, ":faction_no"),
				(str_store_party_name, s5, ":winning_candidate"),
				(display_message, "@{!}DEBUG -- {s4} drops {s5} as winner, for having changed sides"),
			(try_end),

			##diplomacy start+ add support for promoted kingdom ladies
			(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
				(this_or_next|troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),
					(is_between, ":active_npc", active_npcs_begin, active_npcs_end),
			##diplomacy end+
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":faction_no"),
				(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
			(try_end),
			(try_begin),
				(eq, "$players_kingdom", ":faction_no"),
				(troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),
			(try_end),

		(else_try),	#If candidate is not of winning faction, reset lrod votes
			(store_faction_of_troop, ":winning_candidate_faction", ":winning_candidate"),
			(neq, ":winning_candidate_faction", ":faction_no"),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_faction_name, s4, ":faction_no"),
				(str_store_party_name, s5, ":winning_candidate"),
				(display_message, "@{!}DEBUG -- {s4} drops {s5} as winner, for having changed sides"),
			(try_end),
			##diplomacy start+ add support for promoted kingdom ladies
			(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
				(this_or_next|troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),
					(is_between, ":active_npc", active_npcs_begin, active_npcs_end),
			##diplomacy end+
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":faction_no"),
				(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
			(try_end),
			(try_begin),
				(eq, "$players_kingdom", ":faction_no"),
				(troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),
			(try_end),

		(else_try), #Honor awarded to another
			(faction_get_slot, ":issue_on_table", ":faction_no", slot_faction_political_issue),
			(try_begin), #A marshalship awarded to another
				(eq, ":issue_on_table", 1),
				(is_between, ":winning_candidate", active_npcs_begin, active_npcs_end),

				##diplomacy start+ add support for promoted kingdom ladies
				(this_or_next|is_between, ":winning_candidate", heroes_begin, heroes_end),
					(eq, "$players_kingdom", ":faction_no"),
				(this_or_next|troop_slot_eq, ":winning_candidate", slot_troop_occupation, slto_kingdom_hero),
				##diplomacy end+
				(this_or_next|is_between, ":winning_candidate", active_npcs_begin, active_npcs_end), #Prevents bug in which player given marshaldom of kingdom of which he/she is not a member
					(eq, "$players_kingdom", ":faction_no"),

				(assign, ":faction_marshal", ":winning_candidate"),
			(else_try), #A fief awarded to another
				(is_between, ":issue_on_table", centers_begin, centers_end),

				#If given to the player, resolved above
				(call_script, "script_give_center_to_lord", ":issue_on_table", ":winning_candidate", 0), #Zero means don't add garrison

				#If the player had requested a captured castle
				(try_begin),
					(eq, ":issue_on_table", "$g_castle_requested_by_player"),
					(party_slot_ge, ":issue_on_table", slot_town_lord, active_npcs_begin),
					(store_faction_of_party, ":faction_of_issue", ":issue_on_table"),
					(eq, ":faction_of_issue", "$players_kingdom"),
					(assign, "$g_center_to_give_to_player", ":issue_on_table"),
					(try_begin),
						(troop_get_slot, ":husband", "trp_player", slot_troop_spouse),
						##diplomacy start+ add support for promotede kingdom ladies
						(is_between, ":husband", heroes_begin, heroes_end),
						(this_or_next|troop_slot_eq, ":winning_candidate", slot_troop_occupation, slto_kingdom_hero),
						##diplomacy end+
						(is_between, ":husband", active_npcs_begin, active_npcs_end),
						(eq, "$g_castle_requested_for_troop", ":husband"),
						(neq, ":winning_candidate", ":husband"),
						(jump_to_menu, "mnu_requested_castle_granted_to_another_female"),
					(else_try),
						(jump_to_menu, "mnu_requested_castle_granted_to_another"),
					(try_end),
				(try_end),

			(try_end),

			(try_begin),
				(eq, ":faction_no", "$players_kingdom"),
				(call_script, "script_add_notification_menu", "mnu_notification_player_faction_political_issue_resolved", ":issue_on_table", ":winning_candidate"),
			(try_end),

		#Reset political issue
			(faction_set_slot, ":faction_no", slot_faction_political_issue, 0),
			##diplomacy start+ add support for promoted kingdom ladies
			(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
			##diplomacy end+
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":faction_no"),
				(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
			(try_end),
			(try_begin),
				(eq, "$players_kingdom", ":faction_no"),
				(troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),
			(try_end),
		(try_end),
	(try_end),

	#Add fief to faction issues
	(try_begin),
		(faction_get_slot, ":faction_issue", ":faction_no", slot_faction_political_issue),
		(le, ":faction_issue", 0),

		(assign, ":landless_lords", 0),
		(assign, ":unassigned_centers", 0),
		(assign, ":first_unassigned_center_found", 0),

		(troop_set_slot, "trp_player", slot_troop_temp_slot, 0),
		##diplomacy start+ add support for promoted kingdom ladies
		(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
		##diplomacy end+
			(troop_set_slot, ":active_npc", slot_troop_temp_slot, 0),
		(try_end),

		(try_for_range, ":center", centers_begin, centers_end),
			(store_faction_of_party, ":center_faction", ":center"),
			(eq, ":center_faction", ":faction_no"),

			(party_get_slot, ":town_lord", ":center", slot_town_lord),

			(try_begin),
				(lt, ":town_lord", 0),
				(val_add, ":unassigned_centers", 1),
				(try_begin),
					(eq, ":first_unassigned_center_found", 0),
					(assign, ":first_unassigned_center_found", ":center"),
				(try_end),
			(else_try),
				(troop_set_slot, ":town_lord", slot_troop_temp_slot, 1),
			(try_end),
		(try_end),

		(store_add, ":landless_lords_plus_unassigned_centers", ":landless_lords", ":unassigned_centers"),
		(ge, ":landless_lords_plus_unassigned_centers", 2),

		(faction_set_slot, ":faction_no", slot_faction_political_issue, ":first_unassigned_center_found"),
		(store_current_hours, ":hours"),
		(faction_set_slot, ":faction_no", slot_faction_political_issue_time, ":hours"), #Fief put on agenda

		##diplomacy start+ add support for promoted kingdom ladies
		(try_for_range, ":active_npc", heroes_begin, heroes_end),#<- change active_npcs to heroes
		##diplomacy end+
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":faction_no"),
			(troop_set_slot, ":active_npc", slot_troop_stance_on_faction_issue, -1),
		(try_end),
		(try_begin),
			(eq, "$players_kingdom", ":faction_no"),
			(troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),
		(try_end),
	(try_end),


    (try_begin), #If the marshal is changed
       (neg|faction_slot_eq, ":faction_no", slot_faction_marshall, ":faction_marshal"),
       #(assign, ":marshall_changed", 1),
       (eq, "$players_kingdom", ":faction_no"),
       (str_store_troop_name_link, s1, ":faction_marshal"),
       (str_store_faction_name_link, s2, ":faction_no"),
       (display_message, "@{s1} is the new marshal of {s2}."),
       (call_script, "script_check_and_finish_active_army_quests_for_faction", ":faction_no"),
    (try_end),

    (try_begin), #If the marshal is changed
       (neg|faction_slot_eq, ":faction_no", slot_faction_marshall, ":faction_marshal"),
	   (gt, ":faction_marshal", -1),
       (call_script, "script_appoint_faction_marshall", ":faction_no", ":faction_marshal"),
    (try_end),

	#DO FACTION AI HERE
	(try_begin),
		(eq, ":faction_no", "$players_kingdom"),
		(eq, ":faction_marshal", "trp_player"),
	    (assign, ":faction_ai_decider", "trp_player"),
	(else_try),
		##diplomacy start+ add support for promoted kingdom ladies
		(is_between, ":faction_marshal", heroes_begin, heroes_end),
		#(this_or_next|troop_slot_eq, ":faction_marshal", slot_troop_occupation, slto_kingdom_hero),
		#(is_between, ":faction_marshal", active_npcs_begin, active_npcs_end),
		##diplomacy end+
		(assign, ":faction_ai_decider", ":faction_marshal"),
	(else_try),
		(faction_get_slot, ":faction_ai_decider", ":faction_no", slot_faction_leader),
	(try_end),

    (call_script, "script_npc_decision_checklist_faction_ai_alt",  ":faction_ai_decider"),
    (assign, ":new_strategy", reg0),
    (assign, ":new_object", reg1),

    #new ozan
    (try_begin),
       (neq, ":new_strategy", ":old_faction_ai_state"),
       (eq, ":new_strategy", sfai_gathering_army),
       (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),
       ##diplomacy begin
       #native script error bug fix when no marshal
       (gt, ":faction_marshal", -1),
       ##diplomacy end
       (troop_get_slot, ":marshal_party", ":faction_marshal", slot_troop_leaded_party),
       (party_set_slot, ":marshal_party", slot_party_ai_object, -1),
       (assign, "$g_gathering_new_started", 1),
       (call_script, "script_npc_decision_checklist_party_ai", ":faction_marshal"), #This handles AI for both marshal and other parties
       (call_script, "script_party_set_ai_state", ":marshal_party", reg0, reg1),
       (assign, "$g_gathering_new_started", 0),
    (else_try),
       #check if marshal arrived his target city during active gathering

       #for now i disabled below lines because after always/active gathering armies become very large.
       #in current style marshal makes active gathering only at first, it travels to a city and waits there.

       (eq, ":new_strategy", ":old_faction_ai_state"),
       (eq, ":new_strategy", sfai_gathering_army),
       (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),
       ##diplomacy begin
       #native script error bug fix when no marshal
       (gt, ":faction_marshal", -1),
       ##diplomacy end
       (troop_get_slot, ":marshal_party", ":faction_marshal", slot_troop_leaded_party),
       ##diplomacy start+ 2011-06-08 Fix bug when the marshall leaded party is set negative!
       (gt, ":marshal_party", -1),
       ##diplomacy end+
       (party_get_slot, ":party_ai_object", ":marshal_party", slot_party_ai_object),
       (ge, ":party_ai_object", 0),
       (ge, ":marshal_party", 0),
       (party_is_active, ":marshal_party"),
       (party_is_active, ":party_ai_object"),
       (store_distance_to_party_from_party, ":dist", ":marshal_party", ":party_ai_object"),
       (le, ":dist", 5),
       (party_set_slot, ":marshal_party", slot_party_ai_object, -1),
    (try_end),
     #end ozan

     #The following logic is mostly transplanted to the new decision_checklist
     #Decision_checklist is used because I want to be able to reproduce the logic for strings
     #(call_script, "script_old_faction_ai"),
     #ozan - I collected all comment-out lines in here (faction ai script) and placed most bottom of scripts.py to avoid confusing.

    (faction_set_slot, ":faction_no", slot_faction_ai_state, ":new_strategy"),
    (faction_set_slot, ":faction_no", slot_faction_ai_object, ":new_object"),

    (call_script, "script_update_report_to_army_quest_note", ":faction_no", ":new_strategy", ":old_faction_ai_state"),


    (try_begin),
       (neq, ":old_faction_ai_state", sfai_feast),     #dckplmc
       (eq, ":new_strategy", sfai_feast),

       (store_current_hours, ":hours"),
       (faction_set_slot, ":faction_no", slot_faction_last_feast_start_time, ":hours"), #new

       (try_begin),
         (eq, "$g_player_eligible_feast_center_no", ":new_object"),
         (assign, "$g_player_eligible_feast_center_no", -1), #reset needed
       (try_end),
       (try_begin),
         (is_between, ":new_object", towns_begin, towns_end),
         (party_set_slot, ":new_object", slot_town_has_tournament, 1), #dckplmc - was 2
       (try_end),
    (try_end),

     #Change of strategy
    (try_begin),
       (neq, ":new_strategy", ":old_faction_ai_state"),

       (try_begin),
         (ge, "$cheat_mode", 1),
         (str_store_faction_name, s5, ":faction_no"),
         (display_message, "str_s5_decides_s14"),
       (try_end),

       (store_current_hours, ":hours"),
       (faction_set_slot, ":faction_no", slot_faction_ai_current_state_started, ":hours"),

       #Feast ends
       (try_begin),
         (eq, ":old_faction_ai_state", sfai_feast),
         (call_script, "script_faction_conclude_feast", ":faction_no", ":old_faction_ai_object"),
       (try_end),


       #Feast begins
       (try_begin),
         (eq, ":new_strategy", sfai_feast),
         (faction_get_slot, ":faction_object", ":faction_no", slot_faction_ai_object),

##         (str_store_faction_name, s1, ":faction_no"),
##         (str_store_party_name, s2, ":faction_object"),
##         (display_message, "str_lords_of_the_s1_gather_for_a_feast_at_s2"),

         (party_get_slot, ":feast_host", ":faction_object", slot_town_lord),

         (try_begin),
           (check_quest_active, "qst_wed_betrothed"),

           (quest_slot_eq, "qst_wed_betrothed", slot_quest_giver_troop, ":feast_host"),
           (neg|quest_slot_ge, "qst_wed_betrothed", slot_quest_expiration_days, 362),
           (call_script, "script_add_notification_menu", "mnu_notification_player_wedding_day", ":feast_host", ":faction_object"),
		 (else_try),
           (check_quest_active, "qst_wed_betrothed_female"),

           (quest_get_slot, ":player_betrothed", "qst_wed_betrothed", slot_quest_giver_troop),
		   (store_faction_of_troop, ":player_betrothed_faction", ":player_betrothed"),
		   (eq, ":player_betrothed_faction", ":faction_no"),
           (neg|quest_slot_ge, "qst_wed_betrothed", slot_quest_expiration_days, 362),
           (call_script, "script_add_notification_menu", "mnu_notification_player_kingdom_holds_feast", ":feast_host", ":faction_object"),
         (else_try),
           (eq, "$players_kingdom", ":faction_no"),
           (troop_slot_ge, "trp_player", slot_troop_renown, 150),


           (party_get_slot, ":feast_host", ":faction_object", slot_town_lord),
           (call_script, "script_add_notification_menu", "mnu_notification_player_kingdom_holds_feast", ":feast_host", ":faction_object"),
         (try_end),
       (try_end),


       #Offensive begins
       (try_begin),
         (eq, ":old_faction_ai_state", sfai_gathering_army),
         (is_between, ":new_strategy", sfai_attacking_center, sfai_feast),
		 (try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_faction_name, s5, ":faction_no"),
			(display_message, "str_s5_begins_offensive"),
		 (try_end),

         #Appoint screening party
         (try_begin),
           (assign, ":total_lords_participating", 0),
           (assign, ":best_screening_party", -1),
           (assign, ":score_to_beat", 30), #closest in size to 50
           (troop_get_slot, ":faction_marshal_party", ":faction_marshal", slot_troop_leaded_party),
           (party_is_active, ":faction_marshal_party"),

           ##diplomacy start+
    #           (try_for_range, ":screen_leader", active_npcs_begin, active_npcs_end),##OLD
           (try_for_range, ":screen_leader", heroes_begin, heroes_end),##NEW
           ##diplomacy end+
             (store_faction_of_troop, ":screen_leader_faction", ":screen_leader"),
             (eq, ":screen_leader_faction", ":faction_no"),

             (troop_get_slot, ":screening_party", ":screen_leader", slot_troop_leaded_party),
             ##diplomacy start+ Guard against things such as the party being 0 (p_main_party)
             (gt, ":screening_party", 0),
             ##diplomacy end+
             (party_is_active, ":screening_party"),
             (party_slot_eq, ":screening_party", slot_party_ai_state, spai_accompanying_army),
             (party_slot_eq, ":screening_party", slot_party_ai_object, ":faction_marshal_party"),
             (val_add, ":total_lords_participating", 1),

		     (try_begin),
			  (ge, "$cheat_mode", 1),
		      (str_store_party_name, s4, ":screening_party"),
			  (display_message, "@{!}DEBUG -- {s4} participates in offensive"),
		     (try_end),


             (store_party_size_wo_prisoners, ":screening_party_score", ":screening_party"),
             (val_sub, ":screening_party_score", 50),
             (val_abs, ":screening_party_score"),


             (lt, ":screening_party_score", ":score_to_beat"),

             #set party and score
             (assign, ":best_screening_party", ":screening_party"),
             (assign, ":score_to_beat", ":screening_party_score"),
           (try_end),

           (gt, ":total_lords_participating", 2),
           (party_is_active, ":best_screening_party"),
           (party_is_active, ":faction_marshal_party"),
           (call_script, "script_party_set_ai_state", ":best_screening_party", spai_screening_army, ":faction_marshal_party"),
           (try_begin),
             (ge, "$cheat_mode", 1),
             (str_store_party_name, s4, ":best_screening_party"),
             (display_message, "@{!}DEBUG -- {s4} chosen as screen"),
           (try_end),
           #after this - dialogs on what doing, npc_decision_checklist
         (try_end),

       #Offensive concludes
       (else_try),
	     (store_current_hours, ":hours"),
         (this_or_next|eq, ":old_faction_ai_state", sfai_gathering_army),
         (this_or_next|eq, ":old_faction_ai_state", sfai_attacking_center),
         (this_or_next|eq, ":old_faction_ai_state", sfai_raiding_village),
		 #(this_or_next|eq, ":old_faction_ai_state", sfai_attacking_enemies_around_center),
			(eq, ":old_faction_ai_state", sfai_attacking_enemy_army),

         (this_or_next|eq, ":new_strategy", sfai_default),
			(eq, ":new_strategy", sfai_feast),

         (call_script, "script_check_and_finish_active_army_quests_for_faction", ":faction_no"),
         (faction_set_slot, ":faction_no", slot_faction_last_offensive_concluded, ":hours"),
        (try_end),
    (try_end),

    (try_begin),
       (eq, "$players_kingdom", ":faction_no"),
       (neg|faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_center),
       (check_quest_active, "qst_join_siege_with_army"),
       (call_script, "script_abort_quest", "qst_join_siege_with_army", 0),
    (try_end),

    (try_begin),
       #old condition to rest, I changed below part - ozan, to rest (a faction's old strategy should be feast or default) and (a faction's new strategy should be feast or default)
       #(this_or_next|eq, ":new_strategy", sfai_default),
       #(this_or_next|eq, ":new_strategy", sfai_feast),
       #(this_or_next|eq, ":old_faction_ai_state", sfai_default),
       #(eq, ":old_faction_ai_state", sfai_feast),

       #new condition to rest, (a faction's new strategy should be feast or default) and (":hours_at_current_state" > 20)
       (this_or_next|eq, ":new_strategy", sfai_default),
		(eq, ":new_strategy", sfai_feast),

       (store_current_hours, ":hours_at_current_state"),
       (faction_get_slot, ":current_state_started", ":faction_no", slot_faction_ai_current_state_started),
       (val_sub, ":hours_at_current_state", ":current_state_started"),
       (ge, ":hours_at_current_state", 18), #Must have at least 18 hours to reset

       (store_current_hours, ":hours"),
       (faction_set_slot, ":faction_no", slot_faction_ai_last_rest_time, ":hours"),
    (try_end),
  ]),

  # script_check_and_finish_active_army_quests_for_faction
  # Input: faction_no
  # Output: none
  ("check_and_finish_active_army_quests_for_faction",
   [
     (store_script_param_1, ":faction_no"),
     (try_begin),
       (eq, "$players_kingdom", ":faction_no"),
       (try_begin),
         (check_quest_active, "qst_report_to_army"),
         (call_script, "script_cancel_quest", "qst_report_to_army"),
       (try_end),
       (assign, ":one_active", 0),
       (try_for_range, ":quest_no", army_quests_begin, army_quests_end),
         (check_quest_active, ":quest_no"),
         (call_script, "script_cancel_quest", ":quest_no"),
		 (troop_get_slot, ":army_quest_giver_troop", ":quest_no", slot_quest_giver_troop),
         (assign, ":one_active", 1),
       (try_end),
       (try_begin),
         (check_quest_active, "qst_follow_army"),
         (assign, ":one_active", 1),
		 (troop_get_slot, ":army_quest_giver_troop", "qst_follow_army", slot_quest_giver_troop),
         (call_script, "script_end_quest", "qst_follow_army"),
       (try_end),
       (eq, ":one_active", 1),
       (faction_get_slot, ":last_offensive_time", ":faction_no", slot_faction_last_offensive_concluded),
       (store_current_hours, ":cur_hours"),
       (store_sub, ":total_time_served", ":cur_hours", ":last_offensive_time"),
       (store_mul, ":xp_reward", ":total_time_served", 5),
       (val_div, ":xp_reward", 50),
       (val_mul, ":xp_reward", 50),
       (val_add, ":xp_reward", 50),
       (add_xp_as_reward, ":xp_reward"),
	   (call_script, "script_troop_change_relation_with_troop", "trp_player", ":army_quest_giver_troop", 2),
     (try_end),
    ]),

    # script_troop_get_player_relation
    # Input: arg1 = troop_no
    # Output: reg0 = effective relation (modified by troop reputation, honor, etc.)
    ("troop_get_player_relation",
      [
        (store_script_param_1, ":troop_no"),
        (troop_get_slot, ":reputation", ":troop_no", slot_lord_reputation_type),
        (troop_get_slot, ":effective_relation", ":troop_no", slot_troop_player_relation),
        (assign, ":honor_bonus", 0),
        (try_begin),
          (eq,  ":reputation", lrep_quarrelsome),
          (val_add, ":effective_relation", -3),
        (try_end),
        (try_begin),
          (ge, "$player_honor", 0),
          (try_begin),
            (this_or_next|eq,  ":reputation", lrep_upstanding),
            (             eq,  ":reputation", lrep_goodnatured),
             (store_div, ":honor_bonus", "$player_honor", 3),
		  ##diplomacy start+
		  (else_try),
			#In general this should not apply to ladies, as they operate by different
			#reputation rules, but if a "kingdom lady" has become a "kingdom hero" instead,
			#it should apply.
		     (eq,  ":reputation", lrep_moralist),#-- verify that the lady is effectively a lord:
		     (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
			 (store_div, ":honor_bonus", "$player_honor", 3),
		  (else_try),
			 #Personality type that values keeping your word
			 (call_script, "script_dplmc_get_troop_morality_value", ":troop_no", tmt_honest),
			 (ge, reg0, 1),
			 (store_div, ":honor_bonus", "$player_honor", 3),
		  ##diplomacy end+
          (try_end),
        (try_end),
        (try_begin),
          (lt, "$player_honor", 0),
          (try_begin),
            (this_or_next|eq,  ":reputation", lrep_upstanding),
            (             eq,  ":reputation", lrep_goodnatured),
            (store_div, ":honor_bonus", "$player_honor", 3),
          ##diplomacy start+
		  (else_try),
			(call_script, "script_dplmc_get_troop_morality_value", ":troop_no", tmt_honest),
			(ge, reg0, 1),#Personality type that values keeping your word
			(store_div, ":honor_bonus", "$player_honor", 3),
		  (else_try),
		  	 #"My kind of scum" - a few rare individuals might actively approve.
		  	 (lt, reg0, 0),#<-- must have negative value for tmt_honest; by default this is only Rolf.
		  	 (this_or_next|eq, ":reputation", lrep_roguish),
		  	 (this_or_next|eq, ":reputation", lrep_custodian),
		  	 (this_or_next|eq, ":reputation", lrep_debauched),
		  	 (this_or_next|eq, ":reputation", lrep_ambitious),
		  		(eq, ":reputation", lrep_cunning),
		  	 (store_div, ":honor_bonus", "$player_honor", -5),
		  	 (val_clamp, ":honor_bonus", 1, 6),
          (else_try),
			#"Honorable" lords can be awful people, so no bonus with benefactors,
			#but dishonorable lords are *guaranteed* to be awful.
            (eq, ":reputation", lrep_benefactor),
            (store_div, ":honor_bonus", "$player_honor", 5),
		  (else_try),
			#Self-righteous lords are moralizing but hypocritical.
			(eq, ":reputation", lrep_selfrighteous),
			(store_div, ":honor_bonus", "$player_honor", 5),
		  (else_try),
			 #In general this should not apply to ladies, as they operate by different
			 #reputation rules, but if a "kingdom lady" has become a "kingdom hero" instead,
			 #it should apply.
			 (eq,  ":reputation", lrep_moralist),#-- verify that the lady is effectively a lord:
		     (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
			 (store_div, ":honor_bonus", "$player_honor", 3),
		  (else_try),
			 (eq,  ":reputation", lrep_conventional),#-- verify that the lady is effectively a lord:
		     (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
			 (store_div, ":honor_bonus", "$player_honor", 5),
          ##diplomacy end+
          (else_try),
            (eq,  ":reputation", lrep_martial),
            (store_div, ":honor_bonus", "$player_honor", 5),
          (try_end),
        (try_end),
        (val_add, ":effective_relation", ":honor_bonus"),
        (val_clamp, ":effective_relation", -100, 101),
        (assign, reg0, ":effective_relation"),
    ]),

  # script_change_troop_renown
  # Input: arg1 = troop_no, arg2 = relation difference
  # Output: none
  ("change_troop_renown",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":renown_change"),

      (troop_get_slot, ":old_renown", ":troop_no", slot_troop_renown),

	  (try_begin),
		(gt, ":renown_change", 0),
		(assign, reg4, ":renown_change"),

		(store_div, ":subtraction", ":old_renown", 200),
	    (val_sub, ":renown_change", ":subtraction"),
	    (val_max, ":renown_change", 0),

	    (eq, ":troop_no", "trp_player"),
	    (assign, reg5, ":renown_change"),

		(eq, "$cheat_mode", 1),
	    (display_message, "str_renown_change_of_reg4_reduced_to_reg5_because_of_high_existing_renown"),
	  (try_end),

      (store_add, ":new_renown", ":old_renown", ":renown_change"),
      (val_max, ":new_renown", 0),
      (troop_set_slot, ":troop_no", slot_troop_renown, ":new_renown"),

      (try_begin),
        (eq, ":troop_no", "trp_player"),

		(try_begin),
		  (ge, ":new_renown", 50),

          (try_begin),
            (troop_get_type, ":is_female", "trp_player"),
            (eq, ":is_female", 1),
            (unlock_achievement, ACHIEVEMENT_TALK_OF_THE_TOWN),
          (try_end),
		(try_end),

        # (str_store_troop_name, s1, ":troop_no"),
        (assign, reg12, ":renown_change"),
        (val_abs, reg12),
        (try_begin),
         (gt, ":renown_change", 0),
         (display_message, "@You gained {reg12} renown.", message_positive),
        (else_try),
          (lt, ":renown_change", 0),
          (display_message, "@You lose {reg12} renown.", message_negative),
        (try_end),
      (try_end),
      (call_script, "script_update_troop_notes", ":troop_no"),
  ]),


  # script_change_player_relation_with_troop
  # Input: arg1 = troop_no, arg2 = relation difference
  # Output: none
  ("change_player_relation_with_troop",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":difference"),

      (try_begin),
        (neq, ":troop_no", "trp_player"),
        (neg|is_between, ":troop_no", soldiers_begin, soldiers_end),
        ##diplomacy start+
		  (neq, ":troop_no", "trp_kingdom_heroes_including_player_begin"),
		  #(neq, ":troop_no", -1),#OLD
		  (ge, ":troop_no", 1),#NEW
        ##diplomacy end+
        (neq, ":difference", 0),
        (call_script, "script_troop_get_player_relation", ":troop_no"),
        (assign, ":old_effective_relation", reg0),
        (troop_get_slot, ":player_relation", ":troop_no", slot_troop_player_relation),
        (val_add, ":player_relation", ":difference"),
        (val_clamp, ":player_relation", -100, 101),
        (try_begin),
          (troop_set_slot, ":troop_no", slot_troop_player_relation, ":player_relation"),

          (try_begin),
            (le, ":player_relation", -50),
            (unlock_achievement, ACHIEVEMENT_OLD_DIRTY_SCOUNDREL),
          (try_end),

          (str_store_troop_name_link, s1, ":troop_no"),
          (call_script, "script_troop_get_player_relation", ":troop_no"),
          (assign, ":new_effective_relation", reg0),
          (neq, ":old_effective_relation", ":new_effective_relation"),
          (assign, reg1, ":old_effective_relation"),
          (assign, reg2, ":new_effective_relation"),
          (try_begin),
			##diplomacy start+ Suppress this message for dead people except in cheat mode
            (lt, "$cheat_mode", 1),
			(troop_slot_eq, ":troop_no", slot_troop_occupation, dplmc_slto_dead),
			(neq, ":troop_no", "$g_talk_troop"),
		  (else_try),
		  ##diplomacy end+
            (gt, ":difference", 0),
            (display_message, "str_troop_relation_increased", message_positive),
          (else_try),
            (lt, ":difference", 0),
            (display_message, "str_troop_relation_detoriated", message_negative),
          (try_end),
          (try_begin),
            (eq, ":troop_no", "$g_talk_troop"),
            (assign, "$g_talk_troop_relation", ":new_effective_relation"),
            (call_script, "script_setup_talk_info"),
          (try_end),
          (call_script, "script_update_troop_notes", ":troop_no"),
        (try_end),
      (try_end),
  ]),

  # script_change_player_relation_with_center
  # Input: arg1 = party_no, arg2 = relation difference
  # Output: none
  ("change_player_relation_with_center",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":difference"),

      (party_get_slot, ":player_relation", ":center_no", slot_center_player_relation),
      (assign, reg1, ":player_relation"),
      (val_add, ":player_relation", ":difference"),
      (val_clamp, ":player_relation", -100, 100),
      (assign, reg2, ":player_relation"),
      (party_set_slot, ":center_no", slot_center_player_relation, ":player_relation"),

      (try_begin),
        (le, ":player_relation", -50),
        (unlock_achievement, ACHIEVEMENT_OLD_DIRTY_SCOUNDREL),
      (try_end),


      (str_store_party_name_link, s1, ":center_no"),
      (try_begin),
        (gt, ":difference", 0),
        (display_message, "@Your relation with {s1} has improved.", message_positive),
      (else_try),
        (lt, ":difference", 0),
        (display_message, "@Your relation with {s1} has deteriorated.", message_negative),
      (try_end),
      (try_begin),
        (party_slot_eq, ":center_no", slot_party_type, spt_village),
        (call_script, "script_update_volunteer_troops_in_village", ":center_no"),
      (try_end),

      (try_begin),
        (this_or_next|is_between, "$g_talk_troop", village_elders_begin, village_elders_end),
        (is_between, "$g_talk_troop", mayors_begin, mayors_end),
        ##diplomacy start+
		  #Fix potential bug: don't adjust relations except with *that* center's
		  #mayor.
		  (party_slot_eq, ":center_no", slot_town_elder, "$g_talk_troop"),
	    ##diplomacy end+
        (assign, "$g_talk_troop_relation", ":player_relation"),
        (call_script, "script_setup_talk_info"),
      (try_end),
  ]),


  # script_change_player_relation_with_faction
  # Input: arg1 = faction_no, arg2 = relation difference
  # Output: none
  ("change_player_relation_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":difference"),

      (store_relation, ":player_relation", ":faction_no", "fac_player_supporters_faction"),
      (assign, reg1, ":player_relation"),
      (val_add, ":player_relation", ":difference"),
      (assign, reg2, ":player_relation"),
      (set_relation, ":faction_no", "fac_player_faction", ":player_relation"),
      (set_relation, ":faction_no", "fac_player_supporters_faction", ":player_relation"),

      (try_begin),
        (le, ":player_relation", -50),
        (unlock_achievement, ACHIEVEMENT_OLD_DIRTY_SCOUNDREL),
      (try_end),


      (str_store_faction_name_link, s1, ":faction_no"),
      #SB : colorize message, although faction color might be better
      (try_begin),
        (gt, ":difference", 0),
        (display_message, "str_faction_relation_increased", message_positive),
      (else_try),
        (lt, ":difference", 0),
        (display_message, "str_faction_relation_detoriated", message_negative),
      (try_end),
      (call_script, "script_update_all_notes"),
      ]),

  # script_set_player_relation_with_faction
  # Input: arg1 = faction_no, arg2 = relation
  # Output: none
  ("set_player_relation_with_faction",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":relation"),

      (store_relation, ":player_relation", ":faction_no", "fac_player_supporters_faction"),
      (store_sub, ":reln_dif", ":relation", ":player_relation"),
      (call_script, "script_change_player_relation_with_faction", ":faction_no", ":reln_dif"),
      ]),



  # script_change_player_relation_with_faction_ex
  # changes relations with other factions also (according to their relations between each other)
  # Input: arg1 = faction_no, arg2 = relation difference
  # Output: none
  ("change_player_relation_with_faction_ex",
    [
      (store_script_param_1, ":faction_no"),
      (store_script_param_2, ":difference"),

      (store_relation, ":player_relation", ":faction_no", "fac_player_supporters_faction"),
      (assign, reg1, ":player_relation"),
      (val_add, ":player_relation", ":difference"),
      (assign, reg2, ":player_relation"),
      (set_relation, ":faction_no", "fac_player_faction", ":player_relation"),
      (set_relation, ":faction_no", "fac_player_supporters_faction", ":player_relation"),

      (str_store_faction_name_link, s1, ":faction_no"),
      #SB : positive/negative messages
      (try_begin),
        (gt, ":difference", 0),
        (display_message, "str_faction_relation_increased", message_positive),
      (else_try),
        (lt, ":difference", 0),
        (display_message, "str_faction_relation_detoriated", message_negative),
      (try_end),
      #SB : morale adjustments
      (store_mul, ":morale_change", ":difference", 50), #instead of x100
      (call_script, "script_change_faction_troop_morale", ":faction_no", ":morale_change", 0),

      (try_for_range, ":other_faction", kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":other_faction", slot_faction_state, sfs_active),
        (neq, ":faction_no", ":other_faction"),
        (store_relation, ":other_faction_relation", ":faction_no", ":other_faction"),
        (store_relation, ":player_relation", ":other_faction", "fac_player_supporters_faction"),
        (store_mul, ":relation_change", ":difference", ":other_faction_relation"),
        (val_div, ":relation_change", 100),
        (val_add, ":player_relation", ":relation_change"),
        ##diplomacy start
        (try_begin),
            (store_add, ":truce_slot", "fac_player_supporters_faction", slot_faction_truce_days_with_factions_begin),
  		    (val_sub, ":truce_slot", kingdoms_begin),
  		    (faction_get_slot, ":truce_days", ":other_faction", ":truce_slot"),
			##nested diplomacy start+ Changed "eq 0", to "le 0", since now negative truce days track war length
            (this_or_next|le, ":truce_days", 0), #other faction only affected if no truce
			##nested diplomacy end+
            (gt, ":difference", 0), #or change > 0
            (store_relation, ":cur_relation", ":other_faction", "fac_player_supporters_faction"),

            #display relation change message
            (store_sub,  ":relation_change", ":player_relation", ":cur_relation"),
            (str_store_faction_name_link, s1, ":other_faction"),
            (assign, reg1, ":cur_relation"),
            (assign, reg2, ":player_relation"),
            (try_begin),
              (gt, ":relation_change", 0),
              (display_message, "str_faction_relation_increased", message_positive),
            (else_try),
              (lt, ":relation_change", 0),
              (display_message, "str_faction_relation_detoriated", message_negative),
            (try_end),

            #display war declaration
            (try_begin),
                (ge, ":cur_relation", 0), #old relation > 0 -> peace
                (lt, ":player_relation", 0), #new relation < 0 -> war
                ##nested diplomacy start+
                #This is the source of the "fake war" bug.  I think this should get rid of it:
                (try_begin),
                    (this_or_next|eq, "$players_kingdom", "fac_player_faction"),
                       (eq, "$players_kingdom", "fac_player_supporters_faction"),
                ##nested diplomacy end+
                (call_script, "script_add_notification_menu", "mnu_notification_war_declared", ":other_faction", "$players_kingdom"),
                ##nested diplomacy start+
				(else_try),
					(is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
					(store_relation, ":players_kingdom_relation", ":other_faction", "$players_kingdom"),
					(lt, ":players_kingdom_relation", 0),
					(call_script, "script_add_notification_menu", "mnu_notification_war_declared", ":other_faction", "$players_kingdom"),
				(else_try),
					#Display some sort of message so you know something happened
				    (display_message, "@{!} There is widespread ill-will towards you in the {s1}."),
                (try_end),
                ##nested diplomacy end+
            (try_end),
        ##diplomacy end
        (set_relation, ":other_faction", "fac_player_faction", ":player_relation"),
        (set_relation, ":other_faction", "fac_player_supporters_faction", ":player_relation"),
        ##diplomacy begin
        (try_end),
        ##diplomacy end
      (try_end),
      (try_begin),
        (faction_slot_eq, "fac_player_supporters_faction", slot_faction_state, sfs_active),
        (try_for_range, ":kingdom_no", kingdoms_begin, kingdoms_end),
          (faction_slot_eq, ":kingdom_no", slot_faction_state, sfs_active),
          (call_script, "script_update_faction_notes", ":kingdom_no"),
        (try_end),
      (try_end),
  ]),

  # script_cf_get_random_active_faction_except_player_faction_and_faction
  # Input: arg1 = except_faction_no
  # Output: reg0 = random_faction
  ("cf_get_random_active_faction_except_player_faction_and_faction",
    [
      (store_script_param_1, ":except_faction_no"),
      (assign, ":num_factions", 0),
      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (neq, ":faction_no", ":except_faction_no"),
        (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
        (val_add, ":num_factions", 1),
      (try_end),
      (gt, ":num_factions", 0),
      (assign, ":selected_faction", -1),
      (store_random_in_range, ":random_faction", 0, ":num_factions"),
      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (ge, ":random_faction", 0),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (neq, ":faction_no", ":except_faction_no"),
        (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
        (val_sub, ":random_faction", 1),
        (lt, ":random_faction", 0),
        (assign, ":selected_faction", ":faction_no"),
      (try_end),
      (assign, reg0, ":selected_faction"),
  ]),

  # script_make_kingdom_hostile_to_player
  # Input: arg1 = faction_no, arg2 = relation difference
  # Output: none
  ("make_kingdom_hostile_to_player",
    [
      (store_script_param_1, ":kingdom_no"),
      (store_script_param_2, ":difference"),

      (try_begin),
        (lt, ":difference", 0),
        (store_relation, ":player_relation", ":kingdom_no", "fac_player_supporters_faction"),
        (val_min, ":player_relation", 0),
        (val_add, ":player_relation", ":difference"),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_no", ":player_relation"),
      (try_end),
  ]),

  # script_change_player_honor
  # Input: arg1 = honor difference
  # Output: none
  ("change_player_honor",
    [
      (store_script_param_1, ":honor_dif"),
      ##diplomacy start+
      #Exacerbate the effect of honor losses as the player's honor increases
      (try_begin),
         (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_HIGH),#<-- experimental settings must be enabled
         (ge, "$player_honor", 10),
         (lt, ":honor_dif", 0),
         (store_add, ":honor_multiplier", "$player_honor", 100),
         (val_mul, ":honor_dif", ":honor_multiplier"),
         (val_sub, ":honor_dif", 50),
         (val_div, ":honor_dif", 100),
      (try_end),
      ##diplomacy end+
      (val_add, "$player_honor", ":honor_dif"),
      (try_begin),
        (gt, ":honor_dif", 0),
        (display_message, "@You gain honour.", message_positive),
      (else_try),
        (lt, ":honor_dif", 0),
        (display_message, "@You lose honour.", message_negative),
      (try_end),

##      (val_mul, ":honor_dif", 1000),
##      (assign, ":temp_honor", 0),
##      (assign, ":num_nonlinear_steps", 10),
##      (try_begin),
##        (gt, "$player_honor", 0),
##        (lt, ":honor_dif", 0),
##        (assign, ":num_nonlinear_steps", 0),
##      (else_try),
##        (lt, "$player_honor", 0),
##        (gt, ":honor_dif", 0),
##        (assign, ":num_nonlinear_steps", 3),
##      (try_end),
##
##      (try_begin),
##        (ge, "$player_honor", 0),
##        (assign, ":temp_honor", "$player_honor"),
##      (else_try),
##        (val_sub, ":temp_honor", "$player_honor"),
##      (try_end),
##      (try_for_range, ":unused",0,":num_nonlinear_steps"),
##        (ge, ":temp_honor", 10000),
##        (val_div, ":temp_honor", 2),
##        (val_div, ":honor_dif", 2),
##      (try_end),
##      (val_add, "$player_honor", ":honor_dif"),
  ]),

  # script_change_player_party_morale
  # Input: arg1 = morale difference
  # Output: none
  ("change_player_party_morale",
    [
      (store_script_param_1, ":morale_dif"),
      (party_get_morale, ":cur_morale", "p_main_party"),
      (val_clamp, ":cur_morale", 0, 100),

      (store_add, ":new_morale", ":cur_morale", ":morale_dif"),
      (val_clamp, ":new_morale", 0, 100),

      (party_set_morale, "p_main_party", ":new_morale"),
      #SB : colorize message
      (try_begin),
        (lt, ":new_morale", ":cur_morale"),
        (store_sub, reg1, ":cur_morale", ":new_morale"),
        (display_message, "str_party_lost_morale", message_negative),
      (else_try),
        (gt, ":new_morale", ":cur_morale"),
        (store_sub, reg1, ":new_morale", ":cur_morale"),
        (display_message, "str_party_gained_morale", message_positive),
      (try_end),
  ]),

  # script_cf_player_has_item_without_modifier
  # Input: arg1 = item_id, arg2 = modifier
  # Output: none (can_fail)
  ("cf_player_has_item_without_modifier",
    [
      (store_script_param, ":item_id", 1),
      (store_script_param, ":modifier", 2),
      (player_has_item, ":item_id"),
      #checking if any of the meat is not rotten
      (assign, ":has_without_modifier", 0),
      (troop_get_inventory_capacity, ":inv_size", "trp_player"),
      (try_for_range, ":i_slot", 0, ":inv_size"),
        (troop_get_inventory_slot, ":cur_item", "trp_player", ":i_slot"),
        (eq, ":cur_item", ":item_id"),
        (troop_get_inventory_slot_modifier, ":cur_modifier", "trp_player", ":i_slot"),
        (neq, ":cur_modifier", ":modifier"),
        (assign, ":has_without_modifier", 1),
        (assign, ":inv_size", 0), #break
      (try_end),
      (eq, ":has_without_modifier", 1),
  ]),

  # script_get_player_party_morale_values
  # Output: reg0 = player_party_morale_target
  ("get_player_party_morale_values",
    [
      (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
      (assign, ":num_men", 0),
      (try_for_range, ":i_stack", 1, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
        (try_begin),
          (troop_is_hero, ":stack_troop"),
          (val_add, ":num_men", 1), #it was 3 in "Mount&Blade", now it is 1 in Warband
        (else_try),
          (party_stack_get_size, ":stack_size","p_main_party",":i_stack"),
          (val_add, ":num_men", ":stack_size"),
        (try_end),
      (try_end),
      (assign, "$g_player_party_morale_modifier_party_size", ":num_men"),

      (store_skill_level, ":player_leadership", "skl_leadership", "trp_player"),

      (try_begin),
        (eq, "$players_kingdom", "fac_player_supporters_faction"),
        (faction_get_slot, ":cur_faction_king", "$players_kingdom", slot_faction_leader),
        (eq, ":cur_faction_king", "trp_player"),
        (store_mul, "$g_player_party_morale_modifier_leadership", ":player_leadership", 15),
      (else_try),
        (store_mul, "$g_player_party_morale_modifier_leadership", ":player_leadership", 12),
      (try_end),

      (assign, ":new_morale", "$g_player_party_morale_modifier_leadership"),
      (val_sub, ":new_morale", "$g_player_party_morale_modifier_party_size"),

      (val_add, ":new_morale", 50),

      (assign, "$g_player_party_morale_modifier_food", 0),
      (try_for_range, ":cur_edible", "itm_raw_date_fruit", food_end),
        (neq, ":cur_edible", "itm_furs"),
        (item_slot_eq, ":cur_edible", slot_item_edible, 1),
        (call_script, "script_cf_player_has_item_without_modifier", ":cur_edible", imod_rotten),
        (item_get_slot, ":food_bonus", ":cur_edible", slot_item_food_bonus),

        (val_mul, ":food_bonus", 3),
        (val_div, ":food_bonus", 2),

        (val_add, "$g_player_party_morale_modifier_food", ":food_bonus"),
      (try_end),
      (val_add, ":new_morale", "$g_player_party_morale_modifier_food"),

      (try_begin),
        (eq, "$g_player_party_morale_modifier_food", 0),
        (assign, "$g_player_party_morale_modifier_no_food", 30),
        (val_sub, ":new_morale", "$g_player_party_morale_modifier_no_food"),
      (else_try),
        (assign, "$g_player_party_morale_modifier_no_food", 0),
      (try_end),

      (assign, "$g_player_party_morale_modifier_debt", 0),
      (try_begin),
        (gt, "$g_player_debt_to_party_members", 0),
        (call_script, "script_calculate_player_faction_wage"),
        (assign, ":total_wages", reg0),
        (store_mul, "$g_player_party_morale_modifier_debt", "$g_player_debt_to_party_members", 10),
		(val_max, ":total_wages", 1),
        (val_div, "$g_player_party_morale_modifier_debt", ":total_wages"),
        (val_clamp, "$g_player_party_morale_modifier_debt", 1, 31),
        (val_sub, ":new_morale", "$g_player_party_morale_modifier_debt"),
      (try_end),

      (val_clamp, ":new_morale", 0, 100),
      (assign, reg0, ":new_morale"),
      ]),

  # script_diplomacy_start_war_between_kingdoms
  # Input: arg1 = kingdom_1, arg2 = kingdom_2, arg3 = initializing_war_peace_cond
  # Output: none
  ("diplomacy_start_war_between_kingdoms", #sets relations between two kingdoms and their vassals.
    [
      (store_script_param, ":kingdom_a", 1),
      (store_script_param, ":kingdom_b", 2),
      (store_script_param, ":initializing_war_peace_cond", 3), #1 = after start of game

	  (call_script, "script_npc_decision_checklist_peace_or_war", ":kingdom_a", ":kingdom_b", -1),
	  (assign, ":explainer_string", reg1),

	  #
    ##diplomacy begin
    (try_begin),
      (lt, ":initializing_war_peace_cond", 2),
    ##diplomacy end
	  (try_begin),
	    (eq, ":kingdom_a", "fac_player_supporters_faction"),
		(assign, ":war_event", logent_player_faction_declares_war),
	  (else_try),
		(eq, ":explainer_string", "str_s12s15_declared_war_to_control_calradia"),
		(assign, ":war_event", logent_player_faction_declares_war), #for savegame compatibility, this event stands in for the attempt to declare war on all of calradia
	  (else_try),
		(eq, ":explainer_string", "str_s12s15_considers_s16_to_be_dangerous_and_untrustworthy_and_shehe_wants_to_bring_s16_down"),
		(assign, ":war_event", logent_faction_declares_war_out_of_personal_enmity),
	  (else_try),
		(eq, ":explainer_string", "str_s12s15_is_anxious_to_reclaim_old_lands_such_as_s18_now_held_by_s16"),
		(assign, ":war_event", logent_faction_declares_war_to_regain_territory),
	  (else_try),
		(eq, ":explainer_string", "str_s12s15_faces_too_much_internal_discontent_to_feel_comfortable_ignoring_recent_provocations_by_s16s_subjects"),
		(assign, ":war_event", logent_faction_declares_war_to_respond_to_provocation),
	  (else_try),
		(eq, ":explainer_string", "str_s12s15_is_alarmed_by_the_growing_power_of_s16"),
		(assign, ":war_event", logent_faction_declares_war_to_curb_power),
	  (try_end),
	  (call_script, "script_add_log_entry", ":war_event", ":kingdom_a", 0, 0, ":kingdom_b"),



	  (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":kingdom_a", ":kingdom_b"),
	  (assign, ":current_diplomatic_status", reg0),
	  (try_begin), #effects of policy only after the start of the game
	    (eq, ":initializing_war_peace_cond", 1),
		(eq, ":current_diplomatic_status", -1),
		(call_script, "script_faction_follows_controversial_policy", ":kingdom_a", logent_policy_ruler_declares_war_with_justification),
	  (else_try),
	    (eq, ":initializing_war_peace_cond", 1),
		(eq, ":current_diplomatic_status", 0),
		(call_script, "script_faction_follows_controversial_policy", ":kingdom_a", logent_policy_ruler_attacks_without_provocation),
	  (else_try),
		(eq, ":current_diplomatic_status", 1),
		(call_script, "script_faction_follows_controversial_policy", ":kingdom_a", logent_policy_ruler_breaks_truce),
	  (try_end),
	  ##diplomacy begin
    (else_try),
      (assign, ":war_event", logent_faction_declares_war_to_fulfil_pact),
      (call_script, "script_faction_follows_controversial_policy", ":kingdom_a", logent_policy_ruler_declares_war_with_justification),
      (assign, ":initializing_war_peace_cond", 1),
	  (try_end),
	  ##diplomacy end

      (store_relation, ":relation", ":kingdom_a", ":kingdom_b"),
      (val_min, ":relation", -10),
      (val_add, ":relation", -30),
      (set_relation, ":kingdom_a", ":kingdom_b", ":relation"),

      (try_begin),
        (eq, "$players_kingdom", ":kingdom_a"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_b"),
        (val_min, ":relation", -30),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_b", ":relation"),
      (else_try),
        (eq, "$players_kingdom", ":kingdom_b"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_a"),
        (val_min, ":relation", -30),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_a", ":relation"),
      (try_end),

      (try_begin),
        (eq, ":initializing_war_peace_cond", 1),

		#Remove this -- this scrambles who declares war on whom
#        (try_begin),
 #         (store_random_in_range, ":random_no", 0, 2),
  #        (this_or_next|eq, ":kingdom_a", "fac_player_supporters_faction"),
	#		(eq, ":random_no", 0),
     #     (assign, ":local_temp", ":kingdom_a"),
      #    (assign, ":kingdom_a", ":kingdom_b"),
       #   (assign, ":kingdom_b", ":local_temp"),
        #(try_end),

        (str_store_faction_name_link, s1, ":kingdom_a"),
        #SB : don't colorize message, if it's relevant script_set_player_relation_with_faction calls will show it
        # (faction_get_color, ":color", ":kingdom_a"),
        (str_store_faction_name_link, s2, ":kingdom_b"),
        (display_log_message, "@{s1} has declared war against {s2}.", message_alert),

		(store_current_hours, ":hours"),
		(faction_set_slot, ":kingdom_a", slot_faction_ai_last_decisive_event, ":hours"),
		(faction_set_slot, ":kingdom_b", slot_faction_ai_last_decisive_event, ":hours"),

		#set provocation and truce days
		(store_add, ":truce_slot", ":kingdom_b", slot_faction_truce_days_with_factions_begin),
		(store_add, ":provocation_slot", ":kingdom_b", slot_faction_provocation_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
		(val_sub, ":provocation_slot", kingdoms_begin),
		(faction_set_slot, ":kingdom_a", ":truce_slot", 0),
		(faction_set_slot, ":kingdom_a", ":provocation_slot", 0),

		(store_add, ":truce_slot", ":kingdom_a", slot_faction_truce_days_with_factions_begin),
		(store_add, ":provocation_slot", ":kingdom_a", slot_faction_provocation_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
		(val_sub, ":provocation_slot", kingdoms_begin),
		(faction_set_slot, ":kingdom_b", ":truce_slot", 0),
		(faction_set_slot, ":kingdom_b", ":provocation_slot", 0),

        (call_script, "script_add_notification_menu", "mnu_notification_war_declared", ":kingdom_a", ":kingdom_b"),

        (call_script, "script_update_faction_notes", ":kingdom_a"),
        (call_script, "script_update_faction_notes", ":kingdom_b"),
        (assign, "$g_recalculate_ais", 1),
      (try_end),

	  (try_begin),
		(check_quest_active, "qst_cause_provocation"),
	    (neg|check_quest_succeeded, "qst_cause_provocation"),
		(this_or_next|eq, "$players_kingdom", ":kingdom_a"),
			(eq, "$players_kingdom", ":kingdom_b"),
		(call_script, "script_abort_quest", "qst_cause_provocation", 0),
	  (try_end),
    ##diplomacy begin
    #check for defensive
    (try_for_range, ":cur_kingdom", kingdoms_begin, kingdoms_end),
      (neq, ":cur_kingdom", ":kingdom_a"),
      (neq, ":cur_kingdom", ":kingdom_b"),

      (store_relation, ":cur_relation", ":cur_kingdom", ":kingdom_a"),
			(ge, ":cur_relation", 0), #AT PEACE

      (store_add, ":truce_slot", ":kingdom_b", slot_faction_truce_days_with_factions_begin),
  		(val_sub, ":truce_slot", kingdoms_begin),
  		(faction_get_slot, ":truce_days", ":cur_kingdom", ":truce_slot"),
  		##nested diplomacy start+ replace "40" with a named constant
  		#(gt, ":truce_days", 40),
  		(gt, ":truce_days", dplmc_treaty_defense_days_expire),
  		##nested diplomacy end+
  		(try_begin),
  		  (lt, ":initializing_war_peace_cond", 2), #only if war was not caused by defensive or alliance pact
  		  (call_script, "script_diplomacy_start_war_between_kingdoms", ":cur_kingdom", ":kingdom_a", 2),
  		(try_end),
    (try_end),

    #check for alliance
    (try_for_range, ":cur_kingdom", kingdoms_begin, kingdoms_end),
      (neq, ":cur_kingdom", ":kingdom_a"),
      (neq, ":cur_kingdom", ":kingdom_b"),

      (store_relation, ":cur_relation", ":cur_kingdom", ":kingdom_b"),
			(ge, ":cur_relation", 0), #AT PEACE

  		(store_add, ":truce_slot", ":kingdom_a", slot_faction_truce_days_with_factions_begin),
  		(val_sub, ":truce_slot", kingdoms_begin),
  		(faction_get_slot, ":truce_days", ":cur_kingdom", ":truce_slot"),
  		##nested diplomacy start+ replace "60" with a named constant
  		#(gt, ":truce_days", 60),
  		(gt, ":truce_days", dplmc_treaty_alliance_days_expire),
  		##nested diplomacy end+
  		(call_script, "script_diplomacy_start_war_between_kingdoms", ":cur_kingdom", ":kingdom_b", 3),
    (try_end),
    ##diplomacy end
  ]),


  #script_diplomacy_party_attacks_neutral
  ("diplomacy_party_attacks_neutral", #called from game_menus (plundering a village, raiding a village),  from dialogs: surprise attacking a neutral lord, any attack on caravan or villagers
#Has no effect if factions are already at war
    [
      (store_script_param, ":attacker_party", 1),
      (store_script_param, ":defender_party", 2),

	  (store_faction_of_party, ":attacker_faction", ":attacker_party"),
	  (store_faction_of_party, ":defender_faction", ":defender_party"),

	  (party_stack_get_troop_id, ":attacker_leader", ":attacker_party", 0),

	  (try_begin),
		(eq, ":attacker_party", "p_main_party"),
		(neq, ":attacker_faction", "fac_player_supporters_faction"),
		(assign, ":attacker_faction", "$players_kingdom"),
	  (else_try),
		(eq, ":attacker_party", "p_main_party"),
		(eq, ":attacker_faction", "fac_player_supporters_faction"),
	  (try_end),

	  (try_begin),
	    (eq, ":attacker_party", "p_main_party"),
		(store_relation, ":relation", ":attacker_faction", ":defender_faction"),
	    (ge, ":relation", 0),
		(call_script, "script_change_player_honor", -2),
	  (try_end),


	  (try_begin),
		(check_quest_active, "qst_cause_provocation"),
		(quest_slot_eq, "qst_cause_provocation", slot_quest_target_faction, ":defender_faction"),
		(quest_get_slot, ":giver_troop", "qst_cause_provocation", slot_quest_giver_troop),
		(store_faction_of_troop, ":attacker_faction", ":giver_troop"),
		(call_script, "script_succeed_quest", "qst_cause_provocation"),
	  (try_end),

	  (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":attacker_faction", ":defender_faction"),
	  (assign, ":diplomatic_status", reg0),

	  (try_begin),
	    (eq, ":attacker_faction", "fac_player_supporters_faction"),
		(neg|faction_slot_eq, "fac_player_supporters_faction", slot_faction_state, sfs_active),
		#player faction inactive, no effect
	  (else_try),
		(eq, ":diplomatic_status", -2),
	    #war, no effect
	  (else_try),

	    (eq, ":attacker_faction", "fac_player_supporters_faction"),
		(faction_slot_eq, ":attacker_faction", slot_faction_leader, "trp_player"),
		(call_script, "script_faction_follows_controversial_policy", "fac_player_supporters_faction",logent_policy_ruler_attacks_without_provocation),
	  (else_try),
		(eq, ":diplomatic_status", 1),
		#truce
		(party_stack_get_troop_id, ":defender_party_leader", ":defender_party", 0),
		(try_begin),
			##diplomacy start+ add support for promoted kingdom ladies
			#(i.e. verify not a promoted kingdom lady, since they exist)
			(this_or_next|neg|is_between, ":defender_party_leader", kingdom_ladies_begin, kingdom_ladies_end),
				(neg|troop_slot_eq, ":defender_party_leader", slot_troop_occupation, slto_kingdom_hero),
			##diplomacy end+
			(neg|is_between, ":defender_party_leader", active_npcs_begin, active_npcs_end),
			(store_faction_of_party, ":defender_party_faction", ":defender_party"),
			(faction_get_slot, ":defender_party_leader", ":defender_party_faction", slot_faction_leader),
		(try_end),

		(call_script, "script_add_log_entry", logent_border_incident_troop_breaks_truce, ":attacker_leader", -1, ":defender_party_leader", ":attacker_faction"),
	  (else_try),
		#truce
		(call_script, "script_add_log_entry", logent_border_incident_troop_attacks_neutral, ":attacker_leader", -1, ":defender_party_leader", ":attacker_faction"),
	  (try_end),

	  (try_begin),
	    (is_between, ":defender_party", villages_begin, villages_end),
	    (call_script, "script_add_log_entry", logent_village_raided, ":attacker_leader",  ":defender_party", -1, ":defender_faction"),
        #SB : add quest cancellation when raiding villages
        (try_begin),
          (eq, ":attacker_party", "p_main_party"),
          (party_get_slot, ":elder", ":defender_party", slot_town_elder),
          (gt, ":elder", 0),
          (try_for_range, ":quest_no", village_elder_quests_begin, village_elder_quests_end),
            (quest_slot_eq, ":quest_no", slot_quest_giver_troop, ":elder"),
            (call_script, "script_abort_quest", ":quest_no", 1),
          (try_end),
        (try_end),
	  (else_try),
	    (party_get_template_id, ":template", ":defender_party"),
	    # (neq, ":template", "pt_kingdom_hero_party"),
	    (eq, ":template", "pt_kingdom_caravan_party"), #SB: fix this to specifically apply to caravans
		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_faction_name, s5, ":defender_faction"),
			(display_message, "@{!}Debug - {s5} caravan attacked"),
		(try_end),

	    (call_script, "script_add_log_entry", logent_caravan_accosted, ":attacker_leader",  -1, -1, ":defender_faction"),
	  (try_end),

	  (store_add, ":slot_truce_days", ":attacker_faction", slot_faction_provocation_days_with_factions_begin),
	  (val_sub, ":slot_truce_days", kingdoms_begin),
	  (faction_set_slot, ":defender_faction", ":slot_truce_days", 0),

	  (store_add, ":slot_provocation_days", ":attacker_faction", slot_faction_provocation_days_with_factions_begin),
	  (val_sub, ":slot_provocation_days", kingdoms_begin),
	  (try_begin),
	    (neq, ":diplomatic_status", -2),
		(faction_slot_eq, ":defender_faction", ":slot_provocation_days", 0),
		(faction_set_slot, ":defender_faction", ":slot_provocation_days", 30),
	  (try_end),
	]),

  # script_party_calculate_and_set_nearby_friend_enemy_follower_strengths
  # Input: party_no
  # Output: none
  ("party_calculate_and_set_nearby_friend_enemy_follower_strengths",
    [
      (store_script_param, ":party_no", 1),
      (assign, ":follower_strength", 0),
      (assign, ":friend_strength", 0),
      (assign, ":enemy_strength", 0),
      (store_faction_of_party, ":party_faction", ":party_no"),
	  ##diplomacy start+ add support for promoted kingdom ladies
      (store_add, ":end_cond", heroes_end, 1),#<- changed active_npcs to heroes
      (try_for_range, ":iteration", heroes_begin, ":end_cond"),#<- changed active_npcs to heroes
        (try_begin),
          (eq, ":iteration", heroes_end),#<- changed active_npcs to heroes
          (assign, ":cur_troop", "trp_player"),
        (else_try),
          (assign, ":cur_troop", ":iteration"),
        (try_end),
		##diplomacy end+

        (troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
        (troop_get_slot, ":cur_troop_party", ":cur_troop", slot_troop_leaded_party),
        (ge, ":cur_troop_party", 0),
        (party_is_active, ":cur_troop_party"),


        #I moved these lines here from (*1) to faster process, ozan.
        (store_troop_faction, ":army_faction", ":cur_troop"),
        (store_relation, ":relation", ":army_faction", ":party_faction"),
        (this_or_next|neq, ":relation", 0),
        (eq, ":army_faction", ":party_faction"),
        #ozan end


        (neq, ":party_no", ":cur_troop_party"),
        (party_get_slot, ":str", ":cur_troop_party", slot_party_cached_strength),
        (try_begin),
          (neg|is_between, ":party_no", centers_begin, centers_end),
          (party_slot_eq, ":cur_troop_party", slot_party_ai_state, spai_accompanying_army),
          (party_get_slot, ":commander_party", ":cur_troop_party", slot_party_ai_object),
          (eq, ":commander_party", ":party_no"),
          (val_add, ":follower_strength", ":str"),
        (else_try),
          (store_distance_to_party_from_party, ":distance", ":cur_troop_party", ":party_no"),
          (lt, ":distance", 20),

          #(*1)

          (try_begin),
            (lt, ":distance", 5),
            (assign, ":str_divided", ":str"),
          (else_try),
            (lt, ":distance", 10),
            (store_div, ":str_divided", ":str", 2),
          (else_try),
            (lt, ":distance", 15),
            (store_div, ":str_divided", ":str", 4),
          (else_try),
            (store_div, ":str_divided", ":str", 8),
          (try_end),

          (try_begin),
            (this_or_next|eq, ":army_faction", ":party_faction"),
            (gt, ":relation", 0),
            (val_add, ":friend_strength", ":str_divided"),
          (else_try),
            (lt, ":relation", 0),
            (val_add, ":enemy_strength", ":str_divided"),
          (try_end),
        (try_end),
      (try_end),

      (party_set_slot, ":party_no", slot_party_follower_strength, ":follower_strength"),
      (party_set_slot, ":party_no", slot_party_nearby_friend_strength, ":friend_strength"),
      (party_set_slot, ":party_no", slot_party_nearby_enemy_strength, ":enemy_strength"),
      ]),

  # script_init_ai_calculation
  # Input: none
  # Output: none
  ("init_ai_calculation",
    [
      ##diplomacy start+
	  #(assign, ":real_party_strength"),
	  ##If terrain advantage is enabled, use it to calculate troop strengths.
      (try_begin),
         (eq, "$g_dplmc_terrain_advantage", DPLMC_TERRAIN_ADVANTAGE_ENABLE),

		 #First update all lords
		 (try_for_range, ":cur_troop", heroes_begin, heroes_end),
            (troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
            (troop_get_slot, ":cur_party", ":cur_troop", slot_troop_leaded_party),
			(gt, ":cur_party", 0),
            (party_is_active, ":cur_party"),

		    (party_get_current_terrain, ":terrain_code", ":cur_party"),

			(party_get_attached_to, ":attachment", ":cur_party"),
			(try_begin),
				(ge, ":attachment", 0),
				(is_between, ":attachment", centers_begin, centers_end),
				(assign, ":terrain_code", dplmc_terrain_code_siege),#siege constant defined in header_terrain_types.py
			(try_end),

            (call_script, "script_dplmc_party_calculate_strength_in_terrain", ":cur_party", ":terrain_code", 0, 1), #will update slot_party_cached_strength
         (try_end),

		 #Then update player
		 (party_get_current_terrain, ":terrain_code", "p_main_party"),

		 (party_get_attached_to, ":attachment", "p_main_party"),
			(try_begin),
				(ge, ":attachment", 0),
				(is_between, ":attachment", centers_begin, centers_end),
				(assign, ":terrain_code", dplmc_terrain_code_siege),#siege constant defined in header_terrain_types.py
			(try_end),

		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_main_party", ":terrain_code", 0, 1), #will update slot_party_cached_strength

         (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
		    #Update with walled center alterations
            (call_script, "script_dplmc_party_calculate_strength_in_terrain", ":cur_center", -2, 0, 1),
         (try_end),
      (else_try),
	   #The old behavior, unchanged:
         (try_for_range, ":cur_troop", heroes_begin, heroes_end),
            (troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
            (troop_get_slot, ":cur_party", ":cur_troop", slot_troop_leaded_party),
            (party_is_active, ":cur_party"),
            (call_script, "script_party_calculate_strength", ":cur_party", 0), #will update slot_party_cached_strength
         (try_end),
         (call_script, "script_party_calculate_strength", "p_main_party", 0), #will update slot_party_cached_strength
         (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
            (call_script, "script_party_calculate_strength", ":cur_center", 0), #will update slot_party_cached_strength
         (try_end),
      (try_end),
      ##diplomacy end+

      (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
        (call_script, "script_party_calculate_and_set_nearby_friend_enemy_follower_strengths", ":cur_center"),
      (try_end),

      (try_for_range, ":cur_troop", heroes_begin, heroes_end),
        (troop_get_slot, ":cur_troop_party", ":cur_troop", slot_troop_leaded_party),
        (gt, ":cur_troop_party", 0),
        (party_is_active, ":cur_troop_party"),
        (call_script, "script_party_calculate_and_set_nearby_friend_enemy_follower_strengths", ":cur_troop_party"),
      (try_end),
      (call_script, "script_party_calculate_and_set_nearby_friend_enemy_follower_strengths", "p_main_party"),
      ]),


  # script_recalculate_ais
  # Input: none
  # Output: none

  #When a lord changes factions
  #When a center changes factions
  #When a center is captured
  #When a marshal is defeated
  #Every 23 hours
    ("recalculate_ais",
    [
      (call_script, "script_init_ai_calculation"),

      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
      (assign, reg8, ":faction_no"),
        (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
        #(neg|faction_slot_eq, ":faction_no",  slot_faction_marshall, "trp_player"),
        (call_script, "script_decide_faction_ai", ":faction_no"),
      (try_end),

	  ##diplomacy start+ add support for promoted kingdom ladies
	  (try_for_range, ":troop_no", heroes_begin, heroes_end),#<- change active_npcs to heroes
	  ##diplomacy end+
        (store_troop_faction, ":faction_no", ":troop_no"),
        (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
        (call_script, "script_calculate_troop_ai", ":troop_no"),
      (try_end),
    ]),

  # script_calculate_troop_ai
  # Input: troop_no
  # Output: none
  #Now called directly from scripts
  ("calculate_troop_ai",
    [
      (store_script_param, ":troop_no", 1),

      (try_begin),
        (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
        (neg|troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0),
        (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
        (gt, ":party_no", 0),
		(party_is_active, ":party_no"),
		##diplomacy start+
		#Testing notifications
		(party_get_slot, ":old_ai_state", ":party_no", slot_party_ai_state),
		#(party_get_slot, ":old_ai_object", ":party_no", slot_party_ai_object),
		##diplomacy end+
		(call_script, "script_npc_decision_checklist_party_ai", ":troop_no"), #This handles AI for both marshal and other parties
		(call_script, "script_party_set_ai_state", ":party_no", reg0, reg1),
		##diplomacy start+
		#Notify the player of changes to spouse and affiliates
		(party_get_slot, ":new_ai_state", ":party_no", slot_party_ai_state),
		(party_get_slot, ":new_ai_object", ":party_no", slot_party_ai_object),

		##(this_or_next|neq, ":old_ai_object", ":new_ai_object",
		(neq, ":old_ai_state", ":new_ai_state"),
		(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		#(assign, reg0, 0),
		#(try_begin),
		#	(this_or_next|troop_slot_eq, ":troop_no", slot_troop_spouse, "trp_player"),
		#	(troop_slot_eq, "trp_player", slot_troop_spouse, ":troop_no"),
		#	(assign, reg0, 1),
		##(else_try),
		##	(store_faction_of_troop, ":troop_faction", ":troop_no"),
		##	(is_between,
		##(else_try),
		#	(call_script, "script_dplmc_is_affiliated_family_member", ":troop_no"),
		#(try_end),
		(call_script, "script_dplmc_store_troop_is_eligible_for_affiliate_messages", ":troop_no"),
		(gt, reg0, 0),


		#Some of these have non-obvious secondary uses.
		#xxx TODO: Later, I should go and verify all of them.
		(str_store_troop_name, s0, ":troop_no"),

		(try_begin),
			(eq, ":new_ai_state", spai_besieging_center),
			(is_between, ":new_ai_object", centers_begin, centers_end),
			(str_store_party_name, s1, ":new_ai_object"),
			(display_message, "@{s0} is laying siege to {s1}."),
		(else_try),
			(eq, ":new_ai_state", spai_patrolling_around_center),
			(is_between, ":new_ai_object", centers_begin, centers_end),
			(str_store_party_name, s1, ":new_ai_object"),
			(display_message, "@{s0} is patrolling around {s1}."),
		(else_try),
			(eq, ":new_ai_state", spai_raiding_around_center),
			(is_between, ":new_ai_object", centers_begin, centers_end),
			(str_store_party_name, s1, ":new_ai_object"),
			(display_message, "@{s0} is raiding around {s1}."),
		(else_try),
			(eq, ":new_ai_state", spai_engaging_army),
			(gt, ":new_ai_object", -1),
			(party_is_active, ":new_ai_object"),
			(str_store_party_name, s1, ":new_ai_object"),
			(display_message, "@{s0} is engaging {s1}."),
		(else_try),
			(eq, ":new_ai_state", spai_accompanying_army),
			(gt, ":new_ai_object", -1),
			(party_is_active, ":new_ai_object"),
			(str_store_party_name, s1, ":new_ai_object"),
			(display_message, "@{s0} is accompanying {s1}."),
		(else_try),
			(eq, ":new_ai_state", spai_screening_army),
			(gt, ":new_ai_object", -1),
			(party_is_active, ":new_ai_object"),
			(str_store_party_name, s1, ":new_ai_object"),
			(display_message, "@{s0} is screening the advance of {s1}."),
		(else_try),
			(eq, ":new_ai_state", spai_trading_with_town),
			(is_between, ":new_ai_object", centers_begin, centers_end),
			(str_store_party_name, s1, ":new_ai_object"),
			(display_message, "@{s0} is trading with {s1}."),
		(else_try),
			(eq, ":new_ai_state", spai_retreating_to_center),
			(is_between, ":new_ai_object", centers_begin, centers_end),
			(str_store_party_name, s1, ":new_ai_object"),
			(display_message, "@{s0} is retreating to {s1}."),
		(else_try),
			(eq, ":new_ai_state", spai_visiting_village),
			(is_between, ":new_ai_object", centers_begin, centers_end),
			(str_store_party_name, s1, ":new_ai_object"),
			(display_message, "@{s0} is visiting {s1}."),
		(try_end),
		#Make it obvious that something went wrong if something tries to use the registers
		(str_store_string, s0, "str_ERROR_string"),
		(str_store_string, s1, "str_ERROR_string"),
		##diplomacy end+
      (try_end),
    ]),

  # script_diplomacy_start_peace_between_kingdoms
  # Input: arg1 = kingdom_1, arg2 = kingdom_2, arg3 = initializing_war_peace_cond
  # Output: none
  ("diplomacy_start_peace_between_kingdoms", #sets relations between two kingdoms
    [
      (store_script_param, ":kingdom_a", 1),
      (store_script_param, ":kingdom_b", 2),
      (store_script_param, ":initializing_war_peace_cond", 3), #set to 1 if not the start of the game

      (store_relation, ":relation", ":kingdom_a", ":kingdom_b"),
      (val_max, ":relation", 0),
      (set_relation, ":kingdom_a", ":kingdom_b", ":relation"),
      (call_script, "script_exchange_prisoners_between_factions", ":kingdom_a", ":kingdom_b"),

      (try_begin),
        (eq, "$players_kingdom", ":kingdom_a"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_b"),
        (val_max, ":relation", 0),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_b", ":relation"),
        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", "fac_player_supporters_faction"), #event cancels certain quests
      (else_try),
        (eq, "$players_kingdom", ":kingdom_b"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_a"),
        (val_max, ":relation", 0),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_a", ":relation"),
        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", "fac_player_supporters_faction"), #event cancels certain quests
      (try_end),

      (try_for_range, ":cur_center", centers_begin, centers_end),
        (store_faction_of_party, ":faction_no", ":cur_center"),
        (this_or_next|eq, ":faction_no", ":kingdom_a"),
        (eq, ":faction_no", ":kingdom_b"),
        (party_get_slot, ":besieger_party", ":cur_center", slot_center_is_besieged_by),
        (ge, ":besieger_party", 0), #town is under siege
        (party_is_active, ":besieger_party"),
        (store_faction_of_party, ":besieger_party_faction_no", ":besieger_party"),
        (this_or_next|eq, ":besieger_party_faction_no", ":kingdom_a"),
        (eq, ":besieger_party_faction_no", ":kingdom_b"),
        (call_script, "script_lift_siege", ":cur_center", 0),
      (try_end),

      (try_begin),
        (this_or_next|eq, "$players_kingdom", ":kingdom_a"),
        (eq, "$players_kingdom", ":kingdom_b"),

        (ge, "$g_player_besiege_town", 0),
        (party_is_active, "$g_player_besiege_town"),

        (store_faction_of_party, ":besieged_center_faction_no", "$g_player_besiege_town"),

        (this_or_next|eq, ":besieged_center_faction_no", ":kingdom_a"),
        (eq, ":besieged_center_faction_no", ":kingdom_b"),

        (call_script, "script_lift_siege", "$g_player_besiege_town", 0),
        (assign, "$g_player_besiege_town", -1),
      (try_end),

      (try_begin),
        (eq, ":initializing_war_peace_cond", 1),
        (str_store_faction_name_link, s1, ":kingdom_a"),
        (str_store_faction_name_link, s2, ":kingdom_b"),
        (display_log_message, "@{s1} and {s2} have made peace with each other.", message_alert),
        (call_script, "script_add_notification_menu", "mnu_notification_peace_declared", ":kingdom_a", ":kingdom_b"), #stability penalty for early peace is in the menu
        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", ":kingdom_b"), #cancels quests
        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", ":kingdom_a"), #cancels quests
        (assign, "$g_recalculate_ais", 1),
      (try_end),

	  (try_begin), #add truce
		(store_add, ":truce_slot", ":kingdom_a", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
		##diplomacy begin
	    #(faction_set_slot, ":kingdom_b", ":truce_slot", 40),
        ##nested diplomacy start+ replace "20" with constant for truce length
#        (faction_set_slot, ":kingdom_b", ":truce_slot", 20),
        (faction_set_slot, ":kingdom_b", ":truce_slot", dplmc_treaty_truce_days_initial),
        ##nested diplomacy end+
	    ##diplomacy end
		(store_add, ":truce_slot", ":kingdom_b", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
	    ##diplomacy begin
	    #(faction_set_slot, ":kingdom_a", ":truce_slot", 40),
        ##nested diplomacy start+ replace "20" with constant for truce length
        #(faction_set_slot, ":kingdom_a", ":truce_slot", 20),
        (faction_set_slot, ":kingdom_a", ":truce_slot", dplmc_treaty_truce_days_initial),
        ##nested diplomacy end+
        ##diplomacy end
		(store_add, ":slot_war_damage_inflicted_on_b", ":kingdom_b", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_b", kingdoms_begin),
		#(faction_get_slot, ":damage_inflicted_by_a", ":kingdom_a", ":slot_war_damage_inflicted_on_b"),
		(faction_set_slot, ":kingdom_a", ":slot_war_damage_inflicted_on_b", 0),
		(store_add, ":slot_war_damage_inflicted_on_a", ":kingdom_a", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_a", kingdoms_begin),
		#(faction_get_slot, ":damage_inflicted_by_b", ":kingdom_b", ":slot_war_damage_inflicted_on_a"),
		(faction_set_slot, ":kingdom_b", ":slot_war_damage_inflicted_on_a", 0),
	  (try_end),
  ]),



  ("event_kingdom_make_peace_with_kingdom",
    [
      (store_script_param_1, ":source_kingdom"),
      (store_script_param_2, ":target_kingdom"),
      (try_begin),
        (check_quest_active, "qst_capture_prisoners"),
        (try_begin),
          (eq, "$players_kingdom", ":source_kingdom"),
          (quest_slot_eq, "qst_capture_prisoners", slot_quest_target_faction, ":target_kingdom"),
          (call_script, "script_cancel_quest", "qst_capture_prisoners"),
        (else_try),
          (eq, "$players_kingdom", ":target_kingdom"),
          (quest_slot_eq, "qst_capture_prisoners", slot_quest_target_faction, ":source_kingdom"),
          (call_script, "script_cancel_quest", "qst_capture_prisoners"),
        (try_end),
      (try_end),

      (try_begin),
        (check_quest_active, "qst_capture_enemy_hero"),
        (try_begin),
          (eq, "$players_kingdom", ":source_kingdom"),
          (quest_slot_eq, "qst_capture_enemy_hero", slot_quest_target_faction, ":target_kingdom"),
          (call_script, "script_cancel_quest", "qst_capture_enemy_hero"),
        (else_try),
          (eq, "$players_kingdom", ":target_kingdom"),
          (quest_slot_eq, "qst_capture_enemy_hero", slot_quest_target_faction, ":source_kingdom"),
          (call_script, "script_cancel_quest", "qst_capture_enemy_hero"),
        (try_end),
      (try_end),



      (try_begin),
        (check_quest_active, "qst_persuade_lords_to_make_peace"),
        (quest_get_slot, ":lord_1", "qst_persuade_lords_to_make_peace", slot_quest_target_troop),
        (quest_get_slot, ":lord_2", "qst_persuade_lords_to_make_peace", slot_quest_object_troop),

        (try_begin),
            (lt, ":lord_1", 0),
            (val_mul, ":lord_1", -1),
        (try_end),
        (try_begin),
            (lt, ":lord_2", 0),
            (val_mul, ":lord_2", -1),
        (try_end),


        (store_faction_of_troop, ":lord_1_faction", ":lord_1"),
        (store_faction_of_troop, ":lord_2_faction", ":lord_2"),

        (this_or_next|eq, ":lord_1_faction", ":source_kingdom"),
            (eq, ":lord_2_faction", ":source_kingdom"),

        (this_or_next|eq, ":lord_1_faction", ":target_kingdom"),
            (eq, ":lord_2_faction", ":target_kingdom"),

        (call_script, "script_cancel_quest", "qst_persuade_lords_to_make_peace"),

      (try_end),

      #Rescue prisoners cancelled in simple_triggers

      (try_begin),
        #SB : better checking, also adds rtr for co-ruler
        (this_or_next|eq, "$players_kingdom", ":source_kingdom"),
        (eq, "$players_kingdom", ":target_kingdom"),
        (call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
        (ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
        (call_script, "script_change_player_right_to_rule", 3),
      (try_end),

  ]),

  # script_randomly_start_war_peace
  # Input: arg1 = initializing_war_peace_cond (1 = true, 0 = false)
  # Output: none

  #Aims to introduce a slightly simpler system in which the AI kings' reasoning could be made more  transparent to the player. At the start of the game, this may lead to less variation in outcomes, though
  ("randomly_start_war_peace_new",
    [
    (store_script_param_1, ":initializing_war_peace_cond"),

	(assign, ":players_kingdom_at_peace", 0), #if the player kingdom is at peace, then create an enmity
	(try_begin),
		(is_between, "$players_kingdom", "fac_kingdom_1", kingdoms_end),
		(assign, ":players_kingdom_at_peace", 1),
	(try_end),

	##diplomacy start+
	#Introduce some minor variation by changing the order in which factions consider things.
	##OLD:
    #(try_for_range, ":cur_kingdom", "fac_kingdom_1", kingdoms_end),
    #    (faction_slot_eq, ":cur_kingdom", slot_faction_state, sfs_active),
	#
	#	(try_for_range, ":cur_kingdom_2", kingdoms_begin, kingdoms_end),
	##NEW:
	(store_random_in_range, ":random_offset_1", "fac_kingdom_1", kingdoms_end),
	(val_sub, ":random_offset_1", "fac_kingdom_1"),
	(try_for_range, ":cur_kingdom", "fac_kingdom_1", kingdoms_end),
		(val_add, ":cur_kingdom", ":random_offset_1"),
		(try_begin),
			(ge, ":cur_kingdom", kingdoms_end),
			(val_sub, ":cur_kingdom", kingdoms_end),
			(val_add, ":cur_kingdom", "fac_kingdom_1"),
		(try_end),
		(faction_slot_eq, ":cur_kingdom", slot_faction_state, sfs_active),
		(store_random_in_range, ":random_offset_2", kingdoms_begin, kingdoms_end),
		(val_sub, ":random_offset_2", kingdoms_begin),
		(try_for_range, ":cur_kingdom_2", kingdoms_begin, kingdoms_end),
			(val_add, ":cur_kingdom_2", ":random_offset_2"),
			(try_begin),
				(ge, ":cur_kingdom_2", kingdoms_end),
				(val_sub, ":cur_kingdom_2", kingdoms_end),
				(val_add, ":cur_kingdom_2", kingdoms_begin),
			(try_end),
	##diplomacy end+
			(neq, ":cur_kingdom", ":cur_kingdom_2"),
			(faction_slot_eq, ":cur_kingdom_2", slot_faction_state, sfs_active),

			(call_script, "script_npc_decision_checklist_peace_or_war", ":cur_kingdom", ":cur_kingdom_2", -1),
			(assign, ":kingdom_1_to_kingdom_2", reg0),

			(store_relation, ":cur_relation", ":cur_kingdom", ":cur_kingdom_2"),
			(try_begin),
				(lt, ":cur_relation", 0), #AT WAR

				(try_begin),
					(eq, ":cur_kingdom", "$players_kingdom"),
					(assign, ":players_kingdom_at_peace", 0),
				(try_end),

				(ge, ":kingdom_1_to_kingdom_2", 1),

        ##diplomacy begin
        (try_begin),
      	  (store_current_hours, ":cur_hours"),
          (faction_get_slot, ":faction_ai_last_decisive_event", ":cur_kingdom", slot_faction_ai_last_decisive_event),
          (store_sub, ":hours_since_last_decisive_event", ":cur_hours", ":faction_ai_last_decisive_event"),
          (ge, ":hours_since_last_decisive_event", 96), #wait 4 days until you conclude peace after war
        ##diplomacy end
          (try_begin),
            (eq, ":cur_kingdom_2", "fac_player_supporters_faction"),

            (store_mul, ":goodwill_level", ":kingdom_1_to_kingdom_2", 2),
            (store_random_in_range, ":random", 0, 20),
            (try_begin),
              (lt, ":random", ":goodwill_level"),
              (call_script, "script_add_notification_menu", "mnu_question_peace_offer", ":cur_kingdom", 0),
            (try_end),
          (else_try),
            (call_script, "script_npc_decision_checklist_peace_or_war", ":cur_kingdom_2", ":cur_kingdom", -1),
            (assign, ":kingdom_2_to_kingdom_1", reg0),
            (ge, ":kingdom_2_to_kingdom_1", 1),

            (store_mul, ":goodwill_level", ":kingdom_1_to_kingdom_2", ":kingdom_2_to_kingdom_1"),
            (store_random_in_range, ":random", 0, 20),
            (lt, ":random", ":goodwill_level"),

            (try_begin),
              (eq, "$g_include_diplo_explanation", 0),
              (assign, "$g_include_diplo_explanation", ":cur_kingdom"),
              (str_store_string, s57, "str_s14"),
            (try_end),

            (call_script, "script_diplomacy_start_peace_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),
          (try_end),
        ##diplomacy begin
        (try_end),
        ##diplomacy end
			(else_try),
				(ge, ":cur_relation", 0), #AT PEACE

			    (call_script, "script_npc_decision_checklist_peace_or_war", ":cur_kingdom", ":cur_kingdom_2", -1),

				#negative, leans towards war/positive, leans towards peace
				(le, reg0, 0), #still no chance of war unless provocation, or at start of game

			    (assign, ":hostility", reg0),

			    (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":cur_kingdom", ":cur_kingdom_2"),
			    (le, reg0, 0), #no truce

				(val_add, ":hostility", reg0), #increase hostility if there is a provocation

				(val_sub, ":hostility", 1), #greater chance at start of game
				(val_add, ":hostility", ":initializing_war_peace_cond"), #this variable = 1 after the start

				(store_mul, ":hostility_squared", ":hostility", ":hostility"),
				(store_random_in_range, ":random", 0, 50),

        ##diplomacy begin
        #check for pact and lower probability if there is one
        (try_for_range, ":third_kingdom", kingdoms_begin, kingdoms_end),
          (neq, ":third_kingdom", ":cur_kingdom"),
          (neq, ":third_kingdom", ":cur_kingdom_2"),
		  ##nested diplomacy start+  Faction must be active
		  (faction_slot_eq, ":third_kingdom", slot_faction_state, sfs_active),
		  ##nested diplomacy end+

          (store_relation, ":cur_relation", ":cur_kingdom_2", ":third_kingdom"),
    			(ge, ":cur_relation", 0), #AT PEACE

          (store_add, ":truce_slot", ":third_kingdom", slot_faction_truce_days_with_factions_begin),
      		(val_sub, ":truce_slot", kingdoms_begin),
      		(faction_get_slot, ":truce_days", ":cur_kingdom_2", ":truce_slot"),
      		##nested diplomacy start+ replace "40" with a named constant
      		#(gt, ":truce_days", 40),
      		(gt, ":truce_days", dplmc_treaty_defense_days_expire),
      		##nested diplomacy end+
      		(store_div, ":hostility_change", ":truce_days", 20),
      		(val_sub, ":hostility_squared", ":hostility_change"),
        (try_end),
        ##diplomacy end

			    (lt, ":random", ":hostility_squared"),

				(try_begin),
					(eq, "$g_include_diplo_explanation", 0),
					(assign, "$g_include_diplo_explanation", ":cur_kingdom"),
					(str_store_string, s57, "str_s14"),
				(try_end),
                (call_script, "script_diplomacy_start_war_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),

				(try_begin), #do some war damage for
					(eq, ":initializing_war_peace_cond", 0),
					(store_random_in_range, ":war_damage_inflicted", 10, 120),
					(store_add, ":slot_war_damage_inflicted", ":cur_kingdom", slot_faction_war_damage_inflicted_on_factions_begin),
					(val_sub, ":slot_war_damage_inflicted", kingdoms_begin),
					(faction_set_slot, ":cur_kingdom_2",  ":slot_war_damage_inflicted", ":war_damage_inflicted"),

					(store_add, ":slot_war_damage_inflicted", ":cur_kingdom_2", slot_faction_war_damage_inflicted_on_factions_begin),
					(val_sub, ":slot_war_damage_inflicted", kingdoms_begin),
					(faction_set_slot, ":cur_kingdom", ":slot_war_damage_inflicted", ":war_damage_inflicted"),
				(try_end),
      ##diplomacy begin
      (else_try),
        (ge, ":cur_relation", 0), #AT PEACE
        (ge, ":kingdom_1_to_kingdom_2", 1),

        #(assign, ":barrier", 2),
        (store_add, ":faction1_to_faction2_slot", ":cur_kingdom_2", dplmc_slot_faction_attitude_begin),
        (party_get_slot, ":barrier",":cur_kingdom", ":faction1_to_faction2_slot"),

        (try_for_range, ":third_kingdom", kingdoms_begin, kingdoms_end),
          (neq, ":third_kingdom", ":cur_kingdom"),
          (neq, ":third_kingdom", ":cur_kingdom_2"),

          (store_add, ":slot_truce_days", ":cur_kingdom", slot_faction_truce_days_with_factions_begin),
          (val_sub, ":slot_truce_days", kingdoms_begin),
          (faction_get_slot, ":truce_days", ":third_kingdom", ":slot_truce_days"),
          ##nested diplomacy start+ change to use constants
          #(gt, ":truce_days", 10),
          (gt, ":truce_days", dplmc_treaty_truce_days_half_done),
          ##nested diplomacy end+
          (val_sub, ":barrier", 1),

          (try_begin), #debug
            (eq, "$cheat_mode", 1),
            (str_store_faction_name, s5, ":cur_kingdom"),
            (str_store_faction_name, s6, ":third_kingdom"),
            (str_store_faction_name, s7, ":cur_kingdom_2"),
            (display_message, "@{!}DEBUG: {s5} has truce with {s6}. Pact with {s7} is harder!"),
          (try_end),

        (try_end),

        (val_max, ":barrier", 0),
        (store_random_in_range, ":random", 0, 130),
        (le, ":random", ":barrier"),

        (store_add, ":slot_truce_days", ":cur_kingdom", slot_faction_truce_days_with_factions_begin),
        (val_sub, ":slot_truce_days", kingdoms_begin),
        (faction_get_slot, ":truce_days", ":cur_kingdom_2", ":slot_truce_days"),

        (store_random_in_range, ":random", 0, 3),
        (assign, ":continue", 0),
        (try_begin),
          ##nested diplomacy start+ change to use constants
          #(is_between, ":truce_days", 0, 50),
          (is_between, ":truce_days", 0, dplmc_treaty_defense_days_half_done),#50 = halfway from a defensive alliance to a trade treaty
          ##nested diplomacy end+
          (ge, ":cur_relation", 20),
          (try_begin),
            (le, ":random", 0), #1/3 for alliance, defensive
            (assign, ":continue", 1),
          (try_end),
        (else_try),
          ##nested diplomacy start+ change to use constants
          #(is_between, ":truce_days", 0, 10),
          (is_between, ":truce_days", 0, dplmc_treaty_truce_days_half_done),#10 = halfway done with a truce
          ##nested diplomacy end+
          (ge, ":cur_relation", 10),
          (try_begin),
            (le, ":random", 1), #2/3 # for trade
            (assign, ":continue", 1),
          (try_end),
        (else_try),
          (assign, ":continue", 1),  # for non-aggression
        (try_end),
        (eq, ":continue", 1),

        (try_begin),
		  ##nested diplomacy start+
		  (call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", ":cur_kingdom_2"),
		  (this_or_next|ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
		  ##nested diplomacy end+
          (eq, ":cur_kingdom_2", "fac_player_supporters_faction"),
          (ge, ":kingdom_1_to_kingdom_2", 1),

          (try_begin),
            ##nested diplomacy start+ change to use constants
            #(is_between, ":truce_days", 20, 50),
            (is_between, ":truce_days", dplmc_treaty_trade_days_expire, dplmc_treaty_defense_days_half_done),
            ##nested diplomacy end+
            (ge, ":cur_relation", 30),
            (faction_slot_eq, ":cur_kingdom", slot_faction_recognized_player, 1), #recognized us
            (call_script, "script_add_notification_menu", "mnu_dplmc_question_alliance_offer", ":cur_kingdom", 0),
          (else_try),
            ##nested diplomacy start+ change to use constants
            #(is_between, ":truce_days", 0, 30), #you need a non-aggression or trade aggreement for an defensive pact
            (is_between, ":truce_days", 0, dplmc_treaty_trade_days_half_done),
            ##nested diplomacy end+
            (ge, ":cur_relation", 20),
            (faction_slot_eq, ":cur_kingdom", slot_faction_recognized_player, 1), #recognized us
            (call_script, "script_add_notification_menu", "mnu_dplmc_question_defensive_offer", ":cur_kingdom", 0),
          (else_try),
            ##nested diplomacy start+ change to use constants
            #(is_between, ":truce_days", 0, 10),
            (is_between, ":truce_days", 0, dplmc_treaty_truce_days_half_done),
            ##diplomacy end+
            (ge, ":cur_relation", 10),
            (faction_slot_eq, ":cur_kingdom", slot_faction_recognized_player, 1), #recognized us
            (call_script, "script_add_notification_menu", "mnu_dplmc_question_trade_offer", ":cur_kingdom", 0),
          (else_try),
            (eq, ":truce_days", 0),
            (ge, ":cur_relation", 5),
            (call_script, "script_add_notification_menu", "mnu_dplmc_question_nonaggression_offer", ":cur_kingdom", 0),
          (try_end),
        (else_try),
          (ge, ":kingdom_1_to_kingdom_2", 1),

          (call_script, "script_npc_decision_checklist_peace_or_war", ":cur_kingdom_2", ":cur_kingdom", -1),
          (assign, ":kingdom_2_to_kingdom_1", reg0),
          (ge, ":kingdom_2_to_kingdom_1", 1),

          (try_begin),
            ##nested diplomacy start+ change to use constants
            #(is_between, ":truce_days", 20, 50),
            (is_between, ":truce_days", dplmc_treaty_trade_days_expire, dplmc_treaty_defense_days_half_done),
            ##nested diplomacy end+
            (ge, ":cur_relation", 30),
            (call_script, "script_dplmc_start_alliance_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),
          (else_try),
            ##nested diplomacy start+ change to use constants
            #(is_between, ":truce_days", 0, 30), #you need a non-aggression or trade aggreement for an defensive pact
            (is_between, ":truce_days", 0, dplmc_treaty_trade_days_half_done),
            ##nested diplomacy end+
            (ge, ":cur_relation", 20),
            (call_script, "script_dplmc_start_defensive_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),
          (else_try),
            ##nested diplomacy start+ change to use constants
            #(is_between, ":truce_days", 0, 10),
            (is_between, ":truce_days", 0, dplmc_treaty_truce_days_half_done),
            ##nested diplomacy end+
            (ge, ":cur_relation", 10),
            (call_script, "script_dplmc_start_trade_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),
          (else_try),
            (eq, ":truce_days", 0),
            (call_script, "script_dplmc_start_nonaggression_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),
          (try_end),
        (try_end),
      ##diplomacy end
      (try_end),
		(try_end),
	(try_end),

	(try_begin),
		(eq, ":players_kingdom_at_peace", 1),
		(val_add, "$players_kingdom_days_at_peace", 1),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(assign, reg3, "$players_kingdom_days_at_peace"),
			(display_message, "@{!}DEBUG -- Player's kingdom has had {reg3} days of peace"),
		(try_end),
	(else_try),
		(assign, "$players_kingdom_days_at_peace", 0),
	(try_end),

     ]),


  # script_randomly_start_war_peace
  # Input: arg1 = initializing_war_peace_cond (1 = true, 0 = false)
  # Output: none
#  ("randomly_start_war_peace",
#    [
#      (store_script_param_1, ":initializing_war_peace_cond"),
#      (assign, ":total_resources", 0),
#      (assign, ":total_active_kingdoms", 0),
#      (try_for_range, ":cur_kingdom", kingdoms_begin, kingdoms_end),
#        (faction_slot_eq, ":cur_kingdom", slot_faction_state, sfs_active),
#        (val_add, ":total_active_kingdoms", 1),
#        (faction_get_slot, ":num_towns", ":cur_kingdom", slot_faction_num_towns),
#        (store_mul, ":kingdom_resources_value", ":num_towns", 2),
#        (faction_get_slot, ":num_castles", ":cur_kingdom", slot_faction_num_castles),
#        (val_add, ":kingdom_resources_value", ":num_castles"),
#        (val_mul, ":kingdom_resources_value", 10),
#        (val_max, ":kingdom_resources_value", 1),
#        (val_mul, ":kingdom_resources_value", 1000),
#        (faction_get_slot, ":num_armies", ":cur_kingdom", slot_faction_num_armies),
#        (val_max, ":num_armies", 1),
#        (val_div, ":kingdom_resources_value", ":num_armies"),
#        (val_add, ":total_resources", ":kingdom_resources_value"),
#      (try_end),
#      (val_max, ":total_active_kingdoms", 1),
#      (store_div, ":average_resources", ":total_resources", ":total_active_kingdoms"),

#      (try_for_range, ":cur_kingdom", kingdoms_begin, kingdoms_end),
 ##       (neq, ":cur_kingdom", "fac_player_supporters_faction"),
#        (faction_slot_eq, ":cur_kingdom", slot_faction_state, sfs_active),
#        (assign, ":num_ongoing_wars", 0),
#        (try_for_range, ":other_kingdom", kingdoms_begin, kingdoms_end),
#          (faction_slot_eq, ":other_kingdom", slot_faction_state, sfs_active),
#          (store_relation, ":other_relation", ":cur_kingdom", ":other_kingdom"),
#          (lt, ":other_relation", 0),
#          (val_add, ":num_ongoing_wars", 1),
#        (try_end),

#        (faction_get_slot, ":num_towns", ":cur_kingdom", slot_faction_num_towns),
#        (store_mul, ":kingdom_1_resources_value", ":num_towns", 2),
#        (faction_get_slot, ":num_castles", ":cur_kingdom", slot_faction_num_castles),
#        (val_add, ":kingdom_1_resources_value", ":num_castles"),
#        (val_mul, ":kingdom_1_resources_value", 10),
#        (val_max, ":kingdom_1_resources_value", 1),
#        (val_mul, ":kingdom_1_resources_value", 1000),
#        (faction_get_slot, ":num_armies", ":cur_kingdom", slot_faction_num_armies),
#        (val_max, ":num_armies", 1),
#        (val_div, ":kingdom_1_resources_value", ":num_armies"),

#        (store_add, ":start_cond", ":cur_kingdom", 1),
#        (try_for_range, ":cur_kingdom_2", ":start_cond", kingdoms_end),
 ##         (neq, ":cur_kingdom", "fac_player_supporters_faction"),
#          (faction_slot_eq, ":cur_kingdom_2", slot_faction_state, sfs_active),

#          (assign, ":num_ongoing_wars_2", 0),
#          (try_for_range, ":other_kingdom", kingdoms_begin, kingdoms_end),
#            (faction_slot_eq, ":other_kingdom", slot_faction_state, sfs_active),
#            (store_relation, ":other_relation", ":cur_kingdom_2", ":other_kingdom"),
#            (lt, ":other_relation", 0),
#            (val_add, ":num_ongoing_wars_2", 1),
#          (try_end),

#          (store_add, ":total_ongoing_wars", ":num_ongoing_wars", ":num_ongoing_wars_2"),

#          (faction_get_slot, ":num_towns", ":cur_kingdom_2", slot_faction_num_towns),
#          (store_mul, ":kingdom_2_resources_value", ":num_towns", 2),
#          (faction_get_slot, ":num_castles", ":cur_kingdom_2", slot_faction_num_castles),
#          (val_add, ":kingdom_2_resources_value", ":num_castles"),
#          (val_mul, ":kingdom_2_resources_value", 10),
#          (val_max, ":kingdom_2_resources_value", 1),
#          (val_mul, ":kingdom_2_resources_value", 1000),
#          (faction_get_slot, ":num_armies", ":cur_kingdom_2", slot_faction_num_armies),
#          (val_max, ":num_armies", 1),
#          (val_div, ":kingdom_2_resources_value", ":num_armies"),

#          (assign, ":max_resources_value", ":kingdom_1_resources_value"),
#          (val_max, ":max_resources_value", ":kingdom_2_resources_value"),
#          (val_mul, ":max_resources_value", 100),
#          (val_div, ":max_resources_value", ":average_resources"),

#          (assign, ":cur_king", -1),
#          (try_begin),
#            (eq, ":cur_kingdom", "fac_player_supporters_faction"),
#            (faction_get_slot, ":cur_king", ":cur_kingdom_2", slot_faction_leader),
#            (assign, ":cur_relation", reg0),
#            (store_sub, ":relation_effect", 200, ":cur_relation"),
#            (val_mul, ":kingdom_1_resources_value", ":relation_effect"),
#            (val_div, ":kingdom_1_resources_value", 200),
#          (else_try),
#            (eq, ":cur_kingdom_2", "fac_player_supporters_faction"),
#            (faction_get_slot, ":cur_king", ":cur_kingdom", slot_faction_leader),
#          (try_end),

#          (try_begin),
#            (ge, ":cur_king", 0),
#            (call_script, "script_troop_get_player_relation", ":cur_king"),
#            (assign, ":cur_relation", reg0),
#            (store_sub, ":relation_effect", 200, ":cur_relation"),
#            (val_mul, ":max_resources_value", ":relation_effect"),
#            (val_div, ":max_resources_value", 200),
#          (try_end),

          #max_resources_value is the obtained value that gives us how tempting the kingdom's values are
          #average is 100
 #         (val_clamp, ":max_resources_value", 20, 500),
          #not letting more than 5 times higher chance of declaring war or peace

  #        (store_random_in_range, ":random_no", 0, 10000),
 #         (store_relation, ":cur_relation", ":cur_kingdom", ":cur_kingdom_2"),
 #         (try_begin),
 #           (lt, ":cur_relation", 0), #AT WAR
 #           (store_mul, ":chance_to_make_peace", ":total_ongoing_wars", 50),
 #           (val_mul, ":chance_to_make_peace", 100),
 #           (val_div, ":chance_to_make_peace", ":max_resources_value"),
 #           (try_begin),
              #disable random peace for special conditions
 #             (this_or_next|eq, ":cur_kingdom", "fac_player_supporters_faction"),
 #             (eq, ":cur_kingdom_2", "fac_player_supporters_faction"),
 #             (assign, ":continue", 0),
          #    (try_begin),
           #     (gt, "$supported_pretender", 0),
            #    (this_or_next|eq, ":cur_kingdom", "$supported_pretender_old_faction"),
           #     (eq, ":cur_kingdom_2", "$supported_pretender_old_faction"),
          #      (assign, ":continue", 1),
         #     (else_try),
       #         (is_between, "$players_oath_renounced_against_kingdom", kingdoms_begin, kingdoms_end),
      #          (this_or_next|eq, ":cur_kingdom", "$players_oath_renounced_against_kingdom"),
     #           (eq, ":cur_kingdom_2", "$players_oath_renounced_against_kingdom"),
    #            (assign, ":continue", 1),
   #           (try_end),
         #     (eq, ":continue", 1),
        #      (assign, ":chance_to_make_peace", 0),
       #     (try_end),
      #      (try_begin),
     #         (lt, ":random_no", ":chance_to_make_peace"),
    #          (assign, ":continue", 1),
   #           (try_begin),
  #              (check_quest_active, "qst_persuade_lords_to_make_peace"),
              #  (quest_get_slot, ":quest_target_faction", "qst_persuade_lords_to_make_peace", slot_quest_target_faction),
             #   (quest_get_slot, ":quest_object_faction", "qst_persuade_lords_to_make_peace", slot_quest_object_faction),
            #    (this_or_next|eq, ":cur_kingdom", ":quest_target_faction"),
           #     (eq, ":cur_kingdom", ":quest_object_faction"),
          #      (this_or_next|eq, ":cur_kingdom_2", ":quest_target_faction"),
         #       (eq, ":cur_kingdom_2", ":quest_object_faction"),
        #        (assign, ":continue", 0), #Do not declare war if the quest is active for the specific kingdoms
       #       (try_end),
      #        (eq, ":continue", 1),
     #         (try_begin),
    #            (eq, ":cur_kingdom", "fac_player_supporters_faction"),
   #             (call_script, "script_add_notification_menu", "mnu_question_peace_offer", ":cur_kingdom_2", 0),
  #            (else_try),
            #    (eq, ":cur_kingdom_2", "fac_player_supporters_faction"),
           #     (call_script, "script_add_notification_menu", "mnu_question_peace_offer", ":cur_kingdom", 0),
          #    (else_try),
         #       (call_script, "script_diplomacy_start_peace_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),
        #      (try_end),
       #     (try_end),
      #    (else_try), # AT PEACE
     #       (assign, ":chance_to_declare_war", 6),
    #        (val_sub, ":chance_to_declare_war", ":total_ongoing_wars"),
   #         (val_mul, ":chance_to_declare_war", 50),
          #  (val_mul, ":chance_to_declare_war", ":max_resources_value"),
         #   (val_div, ":chance_to_declare_war", 100),
        #    (try_begin),
       #       (lt, ":random_no", ":chance_to_declare_war"),
      #        (assign, ":continue", 1),
     #         (try_begin),
    #            (check_quest_active, "qst_raid_caravan_to_start_war"),
               # (quest_get_slot, ":quest_target_faction", "qst_raid_caravan_to_start_war", slot_quest_target_faction),
              #  (quest_get_slot, ":quest_object_faction", "qst_raid_caravan_to_start_war", slot_quest_object_faction),
             #   (this_or_next|eq, ":cur_kingdom", ":quest_target_faction"),
            #    (eq, ":cur_kingdom", ":quest_object_faction"),
           #     (this_or_next|eq, ":cur_kingdom_2", ":quest_target_faction"),
          #      (eq, ":cur_kingdom_2", ":quest_object_faction"),
         #       (assign, ":continue", 0), #Do not declare war if the quest is active for the specific kingdoms
        #      (try_end),
       #       (eq, ":continue", 1),
      #        (call_script, "script_diplomacy_start_war_between_kingdoms", ":cur_kingdom", ":cur_kingdom_2", ":initializing_war_peace_cond"),
     #       (try_end),
    #      (try_end),
   #     (try_end),
  #    (try_end),
 #    ]),



# script_exchange_prisoners_between_factions
# Input: arg1 = faction_no_1, arg2 = faction_no_2
  ("exchange_prisoners_between_factions",
   [
       (store_script_param_1, ":faction_no_1"),
       (store_script_param_2, ":faction_no_2"),
       (assign, ":faction_no_3", -1),
       (assign, ":faction_no_4", -1),
       (assign, ":free_companions_too", 0),
       (try_begin),
         (this_or_next|eq, "$players_kingdom", ":faction_no_1"),
         (eq, "$players_kingdom", ":faction_no_2"),
         (assign, ":faction_no_3", "fac_player_faction"),
         (assign, ":faction_no_4", "fac_player_supporters_faction"),
         (assign, ":free_companions_too", 1),
       (try_end),

       (try_for_parties, ":party_no"),
         (store_faction_of_party, ":party_faction", ":party_no"),
         (this_or_next|eq, ":party_faction", ":faction_no_1"),
         (this_or_next|eq, ":party_faction", ":faction_no_2"),
         (this_or_next|eq, ":party_faction", ":faction_no_3"),
         (eq, ":party_faction", ":faction_no_4"),
         (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
         (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
           (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":party_no", ":troop_iterator"),

           (assign, ":continue", 0),
           (try_begin),
             (is_between, ":cur_troop_id", companions_begin, companions_end),
             (eq, ":free_companions_too", 1),
             (assign, ":continue", 1),
           (else_try),
             (neg|is_between, ":cur_troop_id", companions_begin, companions_end),
             (store_troop_faction, ":cur_faction", ":cur_troop_id"),
             (this_or_next|eq, ":cur_faction", ":faction_no_1"),
             (this_or_next|eq, ":cur_faction", ":faction_no_2"),
             (this_or_next|eq, ":cur_faction", ":faction_no_3"),
             (eq, ":cur_faction", ":faction_no_4"),
             (assign, ":continue", 1),
           (try_end),
           (eq, ":continue", 1),

           (try_begin),
             (troop_is_hero, ":cur_troop_id"),
             (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),
           (try_end),
           (party_prisoner_stack_get_size, ":stack_size", ":party_no", ":troop_iterator"),
           (party_remove_prisoners, ":party_no", ":cur_troop_id", ":stack_size"),
         (try_end),
       (try_end),

    ]),

  # script_add_notification_menu
  # Input: arg1 = menu_no, arg2 = menu_var_1, arg3 = menu_var_2
  # Output: none
  ("add_notification_menu",
    [
      (try_begin),
        (eq, "$g_infinite_camping", 0),
        (store_script_param, ":menu_no", 1),
        (store_script_param, ":menu_var_1", 2),
        (store_script_param, ":menu_var_2", 3),
        (assign, ":end_cond", 1),
        (try_for_range, ":cur_slot", 0, ":end_cond"),
          (try_begin),
            (troop_slot_ge, "trp_notification_menu_types", ":cur_slot", 1),
            (val_add, ":end_cond", 1),
          (else_try),
            (troop_set_slot, "trp_notification_menu_types", ":cur_slot", ":menu_no"),
            (troop_set_slot, "trp_notification_menu_var1", ":cur_slot", ":menu_var_1"),
            (troop_set_slot, "trp_notification_menu_var2", ":cur_slot", ":menu_var_2"),
          (try_end),
        (try_end),
      (try_end),
      ]),

  # script_finish_quest
  # Input: arg1 = quest_no, arg2 = finish_percentage
  # Output: none
  ("finish_quest",
    [
      (store_script_param_1, ":quest_no"),
      (store_script_param_2, ":finish_percentage"),

      (quest_get_slot, ":quest_giver", ":quest_no", slot_quest_giver_troop),
      (quest_get_slot, ":quest_importance", ":quest_no", slot_quest_importance),
      (quest_get_slot, ":quest_xp_reward", ":quest_no", slot_quest_xp_reward),
      (quest_get_slot, ":quest_gold_reward", ":quest_no", slot_quest_gold_reward),

      (try_begin),
        (lt, ":finish_percentage", 100),
        (val_mul, ":quest_xp_reward", ":finish_percentage"),
        (val_div, ":quest_xp_reward", 100),
        (val_mul, ":quest_gold_reward", ":finish_percentage"),
        (val_div, ":quest_gold_reward", 100),
        #Changing the relation factor. Negative relation if less than 75% of the quest is finished.
        #Positive relation if more than 75% of the quest is finished.
        (neq, ":quest_importance", -1), #has to have a value assigned
        (assign, ":importance_multiplier", ":finish_percentage"),
        (val_sub, ":importance_multiplier", 75),
        (val_mul, ":quest_importance", ":importance_multiplier"),
        (val_div, ":quest_importance", 100),
      (try_end),
      #SB : separate condition
      (try_begin),
        (neq, ":quest_importance", -1), #has to have a value assigned
        (val_mul, ":quest_importance", 4), #was div 4. Relation was increasing very less. I changed it to mul 4.
        (val_add, ":quest_importance", 1),
        (call_script, "script_change_player_relation_with_troop", ":quest_giver", ":quest_importance"),
      (try_end),

      (add_xp_as_reward, ":quest_xp_reward"),
      (call_script, "script_troop_add_gold", "trp_player", ":quest_gold_reward"),
      (call_script, "script_end_quest", ":quest_no"),

  ]),


  # script_get_information_about_troops_position
  # Input: arg1 = troop_no, arg2 = time (0 if present tense, 1 if past tense)
  # Output: s1 = String, reg0 = knows-or-not
  ("get_information_about_troops_position",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, reg3),
	  ##diplomacy start+
	  #(troop_get_type, reg4, ":troop_no"),
     (call_script, "script_dplmc_store_troop_is_female_reg", ":troop_no", 4),
	  ##diplomacy end+
      (str_store_troop_name, s2, ":troop_no"),

      (assign, ":found", 0),
      (troop_get_slot, ":center_no", ":troop_no", slot_troop_cur_center),
      (try_begin),
        (gt, ":center_no", 0),
        (is_between, ":center_no", centers_begin, centers_end),
        (str_store_party_name_link, s3, ":center_no"),
        (str_store_string, s1, "@{s2} {reg3?was:is currently} at {s3}."),
        (assign, ":found", 1),
      (else_try),
        (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
        (gt, ":party_no", 0),
        (call_script, "script_get_troop_attached_party", ":troop_no"),
        (assign, ":center_no", reg0),
        (try_begin),
          (is_between, ":center_no", centers_begin, centers_end),
          (str_store_party_name_link, s3, ":center_no"),
          (str_store_string, s1, "@{s2} {reg3?was:is currently} at {s3}."),
          (assign, ":found", 1),
        (else_try),
          (get_party_ai_behavior, ":ai_behavior", ":party_no"),
          (eq, ":ai_behavior", ai_bhvr_travel_to_party),
          (get_party_ai_object, ":ai_object", ":party_no"),
          (is_between, ":ai_object", centers_begin, centers_end),
		  ##diplomacy start+
		  #(call_script, "script_get_closest_center", ":party_no"),
		  (call_script, "script_dplmc_get_closest_center_or_two", ":party_no"),
		  ##diplomacy end+
          (str_store_party_name_link, s4, reg0),
          (str_store_party_name_link, s3, ":ai_object"),
          (str_store_string, s1, "@{s2} {reg3?was:is} travelling to {s3} and {reg4?she:he} {reg3?was:should be} close to {s4}{reg3?: at the moment}."),
          (assign, ":found", 1),
		  ##diplomacy start+
		  (try_begin),
		     (gt, reg1, -1),
			 (str_store_party_name_link, s1, reg1),
			 (str_store_string, s1, "@{s2} {reg3?was:is} travelling to {s3} and {reg4?she:he} {reg3?was:should be} between {s4} and {s1}{reg3?: at the moment}."),
		  (try_end),
		  ##diplomacy end+
        (else_try),
		  ##diplomacy start+
		  #(call_script, "script_get_closest_center", ":party_no"),
		  (call_script, "script_dplmc_get_closest_center_or_two", ":party_no"),
		  ##diplomacy end+
          (str_store_party_name_link, s3, reg0),
          (str_store_string, s1, "@{s2} {reg3?was:is} in the field and {reg4?she:he} {reg3?was:should be} close to {s3}{reg3?: at the moment}."),
          (assign, ":found", 1),
		  ##diplomacy start+
		  (try_begin),
		     (gt, reg1, -1),
			 (str_store_party_name_link, s1, reg1),
			 (str_store_string, s1, "@{s2} {reg3?was:is} in the field and {reg4?she:he} {reg3?was:should be} between {s3} and {s1}{reg3?: at the moment}."),
		  (try_end),
		  ##diplomacy end+
        (try_end),
      (else_try),
        #(troop_slot_ge, ":troop_no", slot_troop_is_prisoner, 1),
        (troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0),
        (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
          (party_count_prisoners_of_type, ":num_prisoners", ":center_no", ":troop_no"),
          (gt, ":num_prisoners", 0),
          (assign, ":found", 1),
          (str_store_party_name_link, s3, ":center_no"),
          (str_store_string, s1, "@{s2} {reg3?was:is} being held captive at {s3}."),
        (try_end),
        (try_begin),
          (eq, ":found", 0),
          (str_store_string, s1, "@{s2} {reg3?was:has been} taken captive by {reg4?her:his} enemies."),
          (assign, ":found", 1),
        (try_end),
      (try_end),
      (try_begin),
        (eq, ":found", 0),
        (str_store_string, s1, "@{reg3?{s2}'s location was unknown:I don't know where {s2} is}."),
      (try_end),
      (assign, reg0, ":found"),
  ]),

  # script_recruit_troop_as_companion
  # Input: arg1 = troop_no,
  # Output: none
  ("recruit_troop_as_companion",
    [
      (store_script_param_1, ":troop_no"),
      ##diplomacy start+
      ##Save civilian clothing of companions (and ladies, etc.)
      (try_begin),
         (troop_is_hero, ":troop_no"),
         (neg|troop_slot_ge, ":troop_no", slot_troop_playerparty_history, 1),#only call this the first time they join
         (call_script, "script_dplmc_save_civilian_clothing", ":troop_no"),#although, redundant calls should be save
         (call_script, "script_change_troop_renown", ":troop_no", 1),#although, redundant calls should be save
      (try_end),
      ##Preserve former occupations enfeoffed companions
      (try_begin),
          (troop_is_hero, ":troop_no"),
          (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
          (neg|troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_nonplayer_entry),
          (troop_set_slot, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_lord_rejoined),
      (try_end),
      ##diplomacy end+
      (try_begin), #SB :  spouse scripts
        (neg|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_lady),
        (troop_set_slot, ":troop_no", slot_troop_occupation, slto_player_companion),
        (troop_set_slot, ":troop_no", slot_troop_cur_center, -1),
      (else_try), #SB : store that lady was recruited as companion
        (troop_set_slot, ":troop_no", slot_troop_first_encountered, "$current_town"),
        (troop_set_slot, ":troop_no", slot_troop_cur_center, -1), #dckplmc
      (try_end),
      (troop_set_auto_equip, ":troop_no", 0),
      (party_add_members, "p_main_party", ":troop_no", 1),
      (str_store_troop_name_link, s6, ":troop_no"),
      (display_log_message, "@{s6} has joined your party.", message_alert), #SB : colourize
      (play_sound, "snd_tutorial_2"), #SB : chime sound
      (troop_set_note_available, ":troop_no", 1),

      (try_begin),
        (is_between, ":troop_no", companions_begin, companions_end),
        (store_sub, ":companion_number", ":troop_no", companions_begin),

        (set_achievement_stat, ACHIEVEMENT_KNIGHTS_OF_THE_ROUND, ":companion_number", 1),

        (assign, ":number_of_companions_hired", 0),
        (try_for_range, ":cur_companion", 0, 16),
          (get_achievement_stat, ":is_hired", ACHIEVEMENT_KNIGHTS_OF_THE_ROUND, ":cur_companion"),
          (eq, ":is_hired", 1),
          (val_add, ":number_of_companions_hired", 1),
        (try_end),

        (try_begin),
          (ge, ":number_of_companions_hired", 6),
          (unlock_achievement, ACHIEVEMENT_KNIGHTS_OF_THE_ROUND),
        (try_end),
      (try_end),
  ]),


  # script_setup_random_scene
  # Input: arg1 = center_no, arg2 = mission_template_no
  # Output: none
  ("setup_random_scene",
    [
      (party_get_current_terrain, ":terrain_type", "p_main_party"),
      (assign, ":scene_to_use", "scn_random_scene"),
      (try_begin),
        (eq, ":terrain_type", rt_steppe),
        (assign, ":scene_to_use", "scn_random_scene_steppe"),
      (else_try),
        (eq, ":terrain_type", rt_plain),
        (assign, ":scene_to_use", "scn_random_scene_plain"),
      (else_try),
        (eq, ":terrain_type", rt_snow),
        (assign, ":scene_to_use", "scn_random_scene_snow"),
      (else_try),
        (eq, ":terrain_type", rt_desert),
        (assign, ":scene_to_use", "scn_random_scene_desert"),
      (else_try),
        (eq, ":terrain_type", rt_steppe_forest),
        (assign, ":scene_to_use", "scn_random_scene_steppe_forest"),
      (else_try),
        (eq, ":terrain_type", rt_forest),
        (assign, ":scene_to_use", "scn_random_scene_plain_forest"),
      (else_try),
        (eq, ":terrain_type", rt_snow_forest),
        (assign, ":scene_to_use", "scn_random_scene_snow_forest"),
      (else_try),
        (eq, ":terrain_type", rt_desert_forest),
        (assign, ":scene_to_use", "scn_random_scene_desert_forest"),
      (else_try),
        (this_or_next|eq, ":terrain_type", rt_river),
        (eq, ":terrain_type", rt_water),
        (assign,  ":scene_to_use", "scn_sea_boarding_a_a"),

        (party_get_slot, ":ship_type", "p_main_party", slot_party_ship_type),

        (try_begin),
          (eq, "$g_joined_battle_to_help", 1),
          (party_get_slot, ":ship_type", "$g_ally_party", slot_party_ship_type),
        (try_end),

        (party_get_slot, ":enemy_ship_type", "$g_enemy_party", slot_party_ship_type),

        (assign, reg0, ":ship_type"),
        (assign, reg1, ":enemy_ship_type"),
        (display_message, "@our ship: {reg0}, enemy ship: {reg1}"),

        (try_begin),
          (eq, ":ship_type", 1),
          (assign, "$g_player_attacker", 1),
          (try_begin),
            (eq, ":enemy_ship_type", 1),
            (assign,  ":scene_to_use", "scn_sea_boarding_a_a"),
          (else_try),
            (eq, ":enemy_ship_type", 2),
            (assign,  ":scene_to_use", "scn_sea_boarding_a_b"),
          (else_try),
            (eq, ":enemy_ship_type", 3),
            (assign,  ":scene_to_use", "scn_sea_boarding_a_c"),
          (else_try),
            (eq, ":enemy_ship_type", 4),
            (assign,  ":scene_to_use", "scn_sea_boarding_a_d"),
          (try_end),
        (else_try),
          (eq,  ":ship_type", 2),
          (assign, "$g_player_attacker", 1),
          (try_begin),
            (eq, ":enemy_ship_type", 1),
            (assign, "$g_player_attacker", 0),
            (assign,  ":scene_to_use", "scn_sea_boarding_a_b"),
          (else_try),
            (eq, ":enemy_ship_type", 2),
            (assign,  ":scene_to_use", "scn_sea_boarding_b_b"),
          (else_try),
            (eq, ":enemy_ship_type", 3),
            (assign,  ":scene_to_use", "scn_sea_boarding_b_c"),
          (else_try),
            (eq, ":enemy_ship_type", 4),
            (assign,  ":scene_to_use", "scn_sea_boarding_b_d"),
          (try_end),
        (else_try),
          (eq,  ":ship_type", 3),
          (assign, "$g_player_attacker", 1),
          (try_begin),
            (eq, ":enemy_ship_type", 1),
            (assign, "$g_player_attacker", 0),
            (assign,  ":scene_to_use", "scn_sea_boarding_a_c"),
          (else_try),
            (eq, ":enemy_ship_type", 2),
            (assign, "$g_player_attacker", 0),
            (assign,  ":scene_to_use", "scn_sea_boarding_b_c"),
          (else_try),
            (eq, ":enemy_ship_type", 3),
            (assign,  ":scene_to_use", "scn_sea_boarding_c_c"),
          (else_try),
            (eq, ":enemy_ship_type", 4),
            (assign, "$g_player_attacker", 0), #
            (assign,  ":scene_to_use", "scn_sea_boarding_c_d"),
          (try_end),
        (else_try),
          (eq,  ":ship_type", 4),
          (assign, "$g_player_attacker", 0),
          (try_begin),
            (eq, ":enemy_ship_type", 1),
            (assign,  ":scene_to_use", "scn_sea_boarding_a_d"),
          (else_try),
            (eq, ":enemy_ship_type", 2),
            (assign,  ":scene_to_use", "scn_sea_boarding_b_d"),
          (else_try),
            (eq, ":enemy_ship_type", 3),
            (assign, "$g_player_attacker", 1), #
            (assign,  ":scene_to_use", "scn_sea_boarding_c_d"),
          (else_try),
            (eq, ":enemy_ship_type", 4),
            (assign, "$g_player_attacker", 1),
            (assign,  ":scene_to_use", "scn_sea_boarding_d_d"),
          (try_end),
        (try_end),

        (try_begin),
          (eq, "$g_joined_battle_to_help", 1),
          (set_jump_mission,"mt_ship_battle"),
        (else_try),
          (eq, "$g_player_attacker", 1),
          (set_jump_mission,"mt_ship_battle"),
        (else_try),
          (set_jump_mission,"mt_ship_battle_reversed"),
        (try_end),

       (try_for_range, ":entry_no", 0, 5),
         (mission_tpl_entry_set_override_flags, "mt_ship_battle", ":entry_no", af_override_horse),
         (mission_tpl_entry_set_override_flags, "mt_ship_battle_reversed", ":entry_no", af_override_horse),
       (try_end),
      (else_try),
        (eq, ":terrain_type", rt_bridge),
        (assign, ":scene_to_use", "scn_random_scene_plain"),
      (try_end),
      (jump_to_scene,":scene_to_use"),
  ]),

  # script_enter_dungeon
  # Input: arg1 = center_no, arg2 = mission_template_no
  # Output: none
  ("enter_dungeon",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":mission_template_no"),

      (set_jump_mission,":mission_template_no"),
      #new added...
      (mission_tpl_entry_set_override_flags, ":mission_template_no", 0, af_override_horse),
      (try_begin),
        (gt, "$sneaked_into_town", disguise_none),
        (mission_tpl_entry_set_override_flags, ":mission_template_no", 0, af_override_everything), #boots + gloves
        # (mission_tpl_entry_clear_override_items, ":mission_template_no", 0),
        #SB : different disguises
        (call_script, "script_set_disguise_override_items", ":mission_template_no", 0, 0), #no weapons
        # (mission_tpl_entry_add_override_item, ":mission_template_no", 0, "itm_pilgrim_hood"),
        # (mission_tpl_entry_add_override_item, ":mission_template_no", 0, "itm_wrapping_boots"), #SB add boots
        # (mission_tpl_entry_add_override_item, ":mission_template_no", 0, "itm_pilgrim_disguise"),
        # (mission_tpl_entry_add_override_item, ":mission_template_no", 0, "itm_practice_staff"),
        # (mission_tpl_entry_add_override_item, ":mission_template_no", 0, "itm_throwing_daggers"),
      (try_end),
      #new added end

      (party_get_slot, ":dungeon_scene", ":center_no", slot_town_prison),

      (modify_visitors_at_site,":dungeon_scene"),
      (reset_visitors),
      (assign, ":cur_pos", 16),


      (call_script, "script_get_heroes_attached_to_center_as_prisoner", ":center_no", "p_temp_party"),
      (party_get_num_companion_stacks, ":num_stacks","p_temp_party"),
      ##diplomacy start+ Allow some variation in which prisoners appear,
      #when there are too many to all fit in the jail at once.
      (try_begin),
         	(gt, ":num_stacks", 15),
            (store_random_in_range, ":offset", 0, ":num_stacks"),
      (else_try),
           	(assign, ":offset", 0),
      (try_end),
      ##diplomacy end+
      (try_for_range, ":i_stack", 0, ":num_stacks"),
      ##diplomacy start+
        (val_add, ":i_stack", ":offset"),
        (try_begin),
           (ge, ":i_stack", ":num_stacks"),
           (val_sub, ":i_stack", ":num_stacks"),
        (try_end),
      ##diplomacy end+
        (party_stack_get_troop_id, ":stack_troop","p_temp_party",":i_stack"),

		(assign, ":prisoner_offered_parole", 0),
		(try_begin),
			(party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
		(else_try),
			(call_script, "script_cf_prisoner_offered_parole", ":stack_troop"),
			(assign, ":prisoner_offered_parole", 1),
		(else_try),
			(assign, ":prisoner_offered_parole", 0),
		(try_end),
		(eq, ":prisoner_offered_parole", 0),

        (lt, ":cur_pos", 32), # spawn up to entry point 32
        (set_visitor, ":cur_pos", ":stack_troop"),
        (val_add,":cur_pos", 1),
      (try_end),

#	  (set_visitor, ":cur_pos", "trp_npc3"),
#	  (troop_set_slot, "trp_npc3", slot_troop_prisoner_of_party, "$g_encountered_party"),

      (set_jump_entry, 0),
      (jump_to_scene,":dungeon_scene"),
      (scene_set_slot, ":dungeon_scene", slot_scene_visited, 1),
      (change_screen_mission),
  ]),

  # script_enter_court
  # Input: arg1 = center_no
  # Output: none
  #other search term: setup_court
  ("enter_court",
    [
      (store_script_param_1, ":center_no"),

      (assign, "$talk_context", tc_court_talk),

      (set_jump_mission,"mt_visit_town_castle"),

      (mission_tpl_entry_clear_override_items, "mt_visit_town_castle", 0),
      #(mission_tpl_entry_set_override_flags, "mt_visit_town_castle", 0, af_override_all),

      (party_get_slot, ":castle_scene", ":center_no", slot_town_castle),
      (modify_visitors_at_site,":castle_scene"),
      (reset_visitors),
      #Adding guards
      (store_faction_of_party, ":center_faction", ":center_no"),
      ##diplomacy begin
      (try_begin),
         (eq, ":center_faction", "$players_kingdom"),
         (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
         (faction_get_slot, ":guard_troop", "$g_player_culture", slot_faction_guard_troop),
	  ##nested diplomacy start+
	  (else_try),
	     #Reflect multicultural empires.
		 (party_get_slot, ":town_lord", ":center_no", slot_town_lord),
		 (gt, ":town_lord", "trp_player"),
		 (troop_get_slot, ":lord_original_faction", ":town_lord", slot_troop_original_faction),
		 (neq, ":lord_original_faction", ":center_faction"),
		 (is_between, ":lord_original_faction", npc_kingdoms_begin, npc_kingdoms_end),
		 (this_or_next|party_slot_eq, ":center_no", slot_center_original_faction, ":lord_original_faction"),
			(troop_slot_eq, ":town_lord", slot_troop_home, ":center_no"),
		 (faction_get_slot, ":guard_troop", ":lord_original_faction", slot_faction_guard_troop),
	  ##nested diplomacy end+
      (else_try),
        (faction_get_slot, ":guard_troop", ":center_faction", slot_faction_guard_troop),
      (try_end),
      ##diplomacy end
      (try_begin),
        (le, ":guard_troop", 0),
		#diplomacy start+
		#rubik changes this in Custom Commander, and I agree: the "generic" guard
		#should be non-faction-specific.
		##OLD:
        #(assign, ":guard_troop", "trp_swadian_sergeant"),
		##NEW:
		(assign, ":guard_troop", "trp_hired_blade"),
		##diplomacy end+
      (try_end),
      (set_visitor, 6, ":guard_troop"),
      (set_visitor, 7, ":guard_troop"),

      (assign, ":cur_pos", 16),

	  (try_begin),
		(troop_get_slot, ":player_spouse", "trp_player", slot_troop_spouse),
	    (gt, ":player_spouse", 0),
		(troop_slot_eq, ":player_spouse", slot_troop_cur_center, ":center_no"),
        (set_visitor, ":cur_pos", ":player_spouse"),
        (val_add,":cur_pos", 1),
	  (else_try),
		(troop_get_slot, ":player_betrothed", "trp_player", slot_troop_betrothed),
	    (gt, ":player_betrothed", 0),
		(troop_slot_eq, ":player_betrothed", slot_troop_cur_center, ":center_no"),
        (set_visitor, ":cur_pos", ":player_betrothed"),
        (val_add,":cur_pos", 1),
	  (try_end),

	  (try_begin),
		(eq, "$g_player_court", ":center_no"),
		(gt, "$g_player_minister", 0),
		(neg|troop_slot_eq, "trp_player", slot_troop_spouse, "$g_player_minister"),
        (set_visitor, ":cur_pos", "$g_player_minister"),
        (val_add,":cur_pos", 1),
	  (try_end),
    ##diplomacy begin

    # (try_begin), #dckplmc seneschals
      # (call_script, "script_assign_seneschals"),
      # (party_get_slot, ":town_seneschal", ":center_no", slot_town_seneschal),
      # (gt, ":town_seneschal", -1),
      # (set_visitor, ":cur_pos", ":town_seneschal"),
      # (val_add,":cur_pos", 1),
    # (try_end),

    (try_begin),
      (gt, "$g_player_chamberlain", 0),
      (call_script, "script_dplmc_appoint_chamberlain"),  #fix for wrong troops after update
      (party_get_slot, ":town_lord", ":center_no", slot_town_lord),
      (eq, ":town_lord", "trp_player"),
      (set_visitor, ":cur_pos", "$g_player_chamberlain"),
      (val_add,":cur_pos", 1),
    (try_end),

    (try_begin),
      (gt, "$g_player_constable", 0),
      (call_script, "script_dplmc_appoint_constable"),  #fix for wrong troops after update
      (party_get_slot, ":town_lord", ":center_no", slot_town_lord),
      (eq, ":town_lord", "trp_player"),
      (set_visitor, ":cur_pos", "$g_player_constable"),
      (val_add,":cur_pos", 1),
    (try_end),

    (try_begin),
      (gt, "$g_player_chancellor", 0),
      (call_script, "script_dplmc_appoint_chancellor"), #fix for wrong troops after update
      (party_get_slot, ":town_lord", ":center_no", slot_town_lord),
      (eq, ":town_lord", "trp_player"),
      (set_visitor, ":cur_pos", "$g_player_chancellor"),
      (val_add,":cur_pos", 1),
    (try_end),
    ##diplomacy end

      #Lords wishing to pledge allegiance - inactive, but part of player faction
      #SB : move down to sorted script call
	  (try_begin),
		(eq, "$g_player_court", ":center_no"),
	    (faction_slot_eq, ":center_faction", slot_faction_leader, "trp_player"),
	    (try_for_range, ":active_npc", heroes_begin, heroes_end), #support for upgraded kingdom ladies
	      (store_faction_of_troop, ":active_npc_faction", ":active_npc"),
	      (eq, ":active_npc_faction", "fac_player_supporters_faction"),
	      (troop_slot_eq, ":active_npc", slot_troop_occupation, slto_inactive),
	      (neg|troop_slot_ge, ":active_npc", slot_troop_prisoner_of_party, 0), #if he/she is not prisoner in any center.
	      (neq, ":active_npc", "$g_player_minister"),
	      (set_visitor, ":cur_pos", ":active_npc"),
	      (val_add,":cur_pos", 1),
		(try_end),
	  (try_end),

      ##diplomacy start+
      #Show heroes you haven't seen recently first, to deal with crowded feast halls
      #(call_script, "script_get_heroes_attached_to_center", ":center_no", "p_temp_party"),
      (call_script, "script_dplmc_time_sorted_heroes_for_center", ":center_no", "p_temp_party"),
	  #Reserve a certain number of feast positions for ladies, both for practical
	  #reasons of courtship and for visual variety.
	  (try_begin),
		#If the player is unmarried, reserve zero to 8 slots for women
		(lt, ":player_spouse", 1),
		(store_random_in_range, ":reserved", 0, 9),
	  (else_try),
		#If the player is married, reserve zero to four slots for women
		(store_random_in_range, ":reserved", 0, 5),
	  (try_end),
	  (store_sub, ":non_lady_max", 32, ":reserved"),
      #diplomacy end+
      (party_get_num_companion_stacks, ":num_stacks","p_temp_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop","p_temp_party",":i_stack"),
		##diplomacy start+
        #(lt, ":cur_pos", 32), # spawn up to entry point 32 - is it possible to add another 10 spots?
		(lt, ":cur_pos", ":non_lady_max"),#Leave some room for ladies in huge feasts
		##diplomacy end+
        (set_visitor, ":cur_pos", ":stack_troop"),
        (val_add,":cur_pos", 1),
      (try_end),
      (try_for_range, ":cur_troop", kingdom_ladies_begin, kingdom_ladies_end),
        (neq, ":cur_troop", "trp_knight_1_1_wife"), #The one who should not appear in game
        #(troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_lady),
        (troop_slot_eq, ":cur_troop", slot_troop_cur_center, ":center_no"),

        (assign, ":lady_meets_visitors", 0),
		(assign, ":tribute_entertainer", 0),
        (try_begin),
            (this_or_next|troop_slot_eq, "trp_player", slot_troop_spouse, ":cur_troop"), #player spouse goes in position of honor
            (troop_slot_eq, "trp_player", slot_troop_betrothed, ":cur_troop"), #player spouse goes in position of honor
            (assign, ":lady_meets_visitors", 0), #She is already in the place of honor
            (try_begin), #SB : primary spouse
                (eq, "$cheat_mode", 1),
                (str_store_troop_name, s4, ":cur_troop"),
                (display_message, "str_s4_is_present_at_the_center_and_in_place_of_honor"),
            (try_end),
        (else_try),
            (this_or_next|troop_slot_eq, ":cur_troop", slot_troop_spouse, "trp_player"), #player spouse goes in position of honor
            (troop_slot_eq, ":cur_troop", slot_troop_betrothed, "trp_player"),
            (assign, ":lady_meets_visitors", 1),
            (try_begin), #SB : secondary spouse, normally shadowed due to above behaviour
                (eq, "$cheat_mode", 1),
                (str_store_troop_name, s4, ":cur_troop"),
                (display_message, "str_s4_is_present_at_the_center_and_is_married"),
            (try_end),
        (else_try), #lady is troop
            (store_faction_of_troop, ":lady_faction", ":cur_troop"),
            (neq, ":lady_faction", ":center_faction"),

            (assign, ":lady_meets_visitors", 1),


            (try_begin),
                (eq, "$cheat_mode", 1),
                (str_store_troop_name, s4, ":cur_troop"),
                (try_begin), #SB : distinguish between refugee and prisoner
                  (troop_slot_eq, ":cur_troop", slot_troop_prisoner_of_party, ":center_no"),
                  (display_message, "@{s4} is present at the center as a prisoner"),
				  #Prisoner Entertainer
				  (assign, ":lady_meets_visitors", 1),
                (else_try),
                  (display_message, "str_s4_is_present_at_the_center_as_a_refugee"),
                (try_end),
            (try_end),

        (else_try),
            (troop_slot_ge, ":cur_troop", slot_troop_spouse, 1),

            (try_begin),
             #married ladies at a feast will not mingle - this is ahistorical, as married women and widows probably had much more freedom than unmarried ones, at least in the West, but the game needs to leave slots for them to show off their unmarried daughters
                (faction_slot_eq, ":center_faction", slot_faction_ai_state, sfai_feast),
                (faction_slot_eq, ":center_faction", slot_faction_ai_object, ":center_no"),
                (assign, ":lady_meets_visitors", 0),

                (try_begin),
                    (eq, "$cheat_mode", 1),
                    (str_store_troop_name, s4, ":cur_troop"),
                    (display_message, "str_s4_is_present_at_the_center_and_not_attending_the_feast"),
                (try_end),
            (else_try),
                (assign, ":lady_meets_visitors", 1),

                (try_begin),
                    (eq, "$cheat_mode", 1),
                    (str_store_troop_name, s4, ":cur_troop"),
                    (display_message, "str_s4_is_present_at_the_center_and_is_married"),
                (try_end),
            (try_end),

		(else_try), #feast is in progress
			(faction_slot_eq, ":center_faction", slot_faction_ai_state, sfai_feast),
			(faction_slot_eq, ":center_faction", slot_faction_ai_object, ":center_no"),
			(assign, ":lady_meets_visitors", 1),

			(try_begin),
				(store_random_in_range,":r",1,8),
				(eq,":r", 3),
				(assign, ":tribute_entertainer", 1),
			(try_end),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "@{!}DEBUG -- {s4} is present at the center and is attending the feast"),
			(try_end),

		(else_try), #already met - awaits in private
			(troop_slot_ge, ":cur_troop", slot_troop_met, 2),
			(assign, ":lady_meets_visitors", 0),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "@{!}DEBUG -- {s4} is present at the center and is awaiting the player in private"),
			(try_end),

		(else_try),
			(call_script, "script_get_kingdom_lady_social_determinants", ":cur_troop"),
			(call_script, "script_npc_decision_checklist_male_guardian_assess_suitor", reg0, "trp_player"),
			(gt, reg0, 0),
			(assign, ":lady_meets_visitors", 1),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "@{!}DEBUG -- {s4} is_present_at_the_center_and_is_allowed_to_meet_the_player"),
			(try_end),

		(else_try),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":cur_troop"),
				(display_message, "@{!}DEBUG -- {s4}is_present_at_the_center_and_is_not_allowed_to_meet_the_player"),
			(try_end),

		(try_end),

		(eq, ":lady_meets_visitors", 1),

		(try_begin),
			(eq, ":tribute_entertainer", 1),
			(try_begin),
				(eq, "$tep_entertainer1", 69),
				(assign, "$tep_entertainer1", ":cur_troop"),
			(else_try),
				(eq, "$tep_entertainer2", 69),
				(assign, "$tep_entertainer2", ":cur_troop"),
			(else_try),
				(eq, "$tep_entertainer3", 69),
				(assign, "$tep_entertainer3", ":cur_troop"),
			(else_try),
				(eq, "$tep_entertainer4", 69),
				(assign, "$tep_entertainer4", ":cur_troop"),
			(else_try),
				(assign, ":tribute_entertainer", 0),
		(try_end),
			#(troop_set_slot, ":cur_troop", slot_troop_entertainer, 1), Now used for permanently abused ladies
		(try_end),

        (lt, ":cur_pos", 32), # spawn up to entry point 32
        (set_visitor, ":cur_pos", ":cur_troop"),
        (val_add,":cur_pos", 1),
      (try_end),

      (set_jump_entry, 0),

      (jump_to_scene,":castle_scene"),
      (scene_set_slot, ":castle_scene", slot_scene_visited, 1),
      (change_screen_mission),
  ]),


   ("setup_meet_lady",
    [
      (store_script_param_1, ":lady_no"),
      (store_script_param_2, ":center_no"),

      #(mission_tpl_entry_set_override_flags, "mt_visit_town_castle", 0, af_override_horse),
      (troop_set_slot, ":lady_no", slot_lady_last_suitor, "trp_player"),

      (set_jump_mission,"mt_visit_town_castle"),
      (party_get_slot, ":castle_scene", ":center_no", slot_town_castle),
      (modify_visitors_at_site,":castle_scene"),
      (reset_visitors),

	  (troop_set_age, "trp_nurse_for_lady", 100),
      (set_visitor, 7, "trp_nurse_for_lady"),

      (assign, ":cur_pos", 16),
	  (set_visitor, ":cur_pos", ":lady_no"),

      (assign, "$talk_context", tc_garden),

      (jump_to_scene,":castle_scene"),
      (scene_set_slot, ":castle_scene", slot_scene_visited, 1),
      (change_screen_mission),
	]),

  # script_find_high_ground_around_pos1
  # Input: pos1 should hold center_position_no
  #        arg1: team_no
  #        arg2: search_radius (in meters)
  # Output: pos52 contains highest ground within <search_radius> meters of team leader
  # Destroys position registers: pos10, pos11, pos15
  ("find_high_ground_around_pos1",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":search_radius", 2),
      (val_mul, ":search_radius", 100),
      (get_scene_boundaries, pos10,pos11),
      (team_get_leader, ":ai_leader", ":team_no"),
      (agent_get_position, pos1, ":ai_leader"),
      (set_fixed_point_multiplier, 100),
      (position_get_x, ":o_x", pos1),
      (position_get_y, ":o_y", pos1),
      (store_sub, ":min_x", ":o_x", ":search_radius"),
      (store_sub, ":min_y", ":o_y", ":search_radius"),
      (store_add, ":max_x", ":o_x", ":search_radius"),
      (store_add, ":max_y", ":o_y", ":search_radius"),
      (position_get_x, ":scene_min_x", pos10),
      (position_get_x, ":scene_max_x", pos11),
      (position_get_y, ":scene_min_y", pos10),
      (position_get_y, ":scene_max_y", pos11),
      #do not find positions close to borders (20 m)
      (val_add, ":scene_min_x", 2000),
      (val_sub, ":scene_max_x", 2000),
      (val_add, ":scene_min_y", 2000),
      (val_sub, ":scene_max_y", 2000),
      (val_max, ":min_x", ":scene_min_x"),
      (val_max, ":min_y", ":scene_min_y"),
      (val_min, ":max_x", ":scene_max_x"),
      (val_min, ":max_y", ":scene_max_y"),

      (store_div, ":min_x_meters", ":min_x", 100),
      (store_div, ":min_y_meters", ":min_y", 100),
      (store_div, ":max_x_meters", ":max_x", 100),
      (store_div, ":max_y_meters", ":max_y", 100),

      (assign, ":highest_pos_z", -10000),
      (copy_position, pos52, pos1),
      (init_position, pos15),

      (try_for_range, ":i_x", ":min_x_meters", ":max_x_meters"),
        (store_mul, ":i_x_cm", ":i_x", 100),
        (try_for_range, ":i_y", ":min_y_meters", ":max_y_meters"),
          (store_mul, ":i_y_cm", ":i_y", 100),
          (position_set_x, pos15, ":i_x_cm"),
          (position_set_y, pos15, ":i_y_cm"),
          (position_set_z, pos15, 10000),
          (position_set_z_to_ground_level, pos15),
          (position_get_z, ":cur_pos_z", pos15),
          (try_begin),
            (gt, ":cur_pos_z", ":highest_pos_z"),
            (copy_position, pos52, pos15),
            (assign, ":highest_pos_z", ":cur_pos_z"),
          (try_end),
        (try_end),
      (try_end),
  ]),

  # script_select_battle_tactic
  # Input: none
  # Output: none
  ("select_battle_tactic",
    [
      (assign, "$ai_team_1_battle_tactic", 0),
      (get_player_agent_no, ":player_agent"),
      (agent_get_team, ":player_team", ":player_agent"),
      (try_begin),
        (num_active_teams_le, 2),
        (try_begin),
          (eq, ":player_team", 0),
          (assign, "$ai_team_1", 1),
        (else_try),
          (assign, "$ai_team_1", 0),
        (try_end),
        (assign, "$ai_team_2", -1),
      (else_try),
        (try_begin),
          (eq, ":player_team", 0),
          (assign, "$ai_team_1", 1),
        (else_try),
          (assign, "$ai_team_1", 0),
        (try_end),
        (store_add, "$ai_team_2", ":player_team", 2),
      (try_end),
      (call_script, "script_select_battle_tactic_aux", "$ai_team_1", 0),
      (assign, "$ai_team_1_battle_tactic", reg0),
      (try_begin),
        (ge, "$ai_team_2", 0),
        (assign, ":defense_not_an_option", 0),
        (try_begin),
          (eq, "$ai_team_1_battle_tactic", btactic_hold),
          (assign, ":defense_not_an_option", 1), #don't let two AI defend at the same time
        (try_end),
        (call_script, "script_select_battle_tactic_aux", "$ai_team_2", ":defense_not_an_option"),
        (assign, "$ai_team_2_battle_tactic", reg0),
      (try_end),
  ]),

  # script_select_battle_tactic_aux
  # Input: team_no
  # Output: battle_tactic
  ("select_battle_tactic_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":defense_not_an_option", 2),
      (assign, ":battle_tactic", 0),
      (get_player_agent_no, ":player_agent"),
      (agent_get_team, ":player_team", ":player_agent"),
      (try_begin),
        (eq, "$cant_leave_encounter", 1),
        (teams_are_enemies, ":team_no", ":player_team"),
        (assign, ":defense_not_an_option", 1),
      (try_end),
      (call_script, "script_team_get_class_percentages", ":team_no", 0),
      #      (assign, ":ai_perc_infantry", reg0),
      (assign, ":ai_perc_archers",  reg1),
      (assign, ":ai_perc_cavalry",  reg2),
      (call_script, "script_team_get_class_percentages", ":team_no", 1),#enemies of the ai_team
      #      (assign, ":enemy_perc_infantry", reg0),
      #      (assign, ":enemy_perc_archers",  reg1),
      #      (assign, ":enemy_perc_cavalry",  reg2),

      (store_random_in_range, ":rand", 0, 100),
      (try_begin),
        (assign, ":continue", 0),
        (try_begin),
          (teams_are_enemies, ":team_no", ":player_team"),
          (party_slot_eq, "$g_enemy_party", slot_party_type, spt_kingdom_hero_party),
          (assign, ":continue", 1),
        (else_try),
          (neg|teams_are_enemies, ":team_no", ":player_team"),
          (gt, "$g_ally_party", 0),
          (party_slot_eq, "$g_ally_party", slot_party_type, spt_kingdom_hero_party),
          (assign, ":continue", 1),
        (try_end),
        #(this_or_next|lt, ":rand", 20),
        (eq, ":continue", 1),
		(store_faction_of_party, ":enemy_faction_no", "$g_enemy_party"),
		(neq, ":enemy_faction_no", "fac_kingdom_3"), #don't let khergits use battle tactics
        (try_begin),
          (eq, ":defense_not_an_option", 0),
          (gt, ":ai_perc_archers", 50),
          (lt, ":ai_perc_cavalry", 35),
          (assign, ":battle_tactic", btactic_hold),
        (else_try),
          (lt, ":rand", 80),
          (assign, ":battle_tactic", btactic_follow_leader),
        (try_end),
      (try_end),
      (assign, reg0, ":battle_tactic"),
  ]),

  # script_battle_calculate_initial_powers
  # Input: none
  # Output: none
  #("battle_calculate_initial_powers",
  #  [
  #    (try_for_agents, ":agent_no"),
  #      (agent_is_human, ":agent_no"),
  #
  #      (call_script, "script_calculate_team_powers", ":agent_no"),
  #      (assign, ":ally_power", reg0),
  #      (assign, ":enemy_power", reg1),
  #
  #      (agent_set_slot, ":agent_no", slot_agent_initial_ally_power, ":ally_power"),
  #      (agent_set_slot, ":agent_no", slot_agent_initial_enemy_power, ":enemy_power"),
  #    (try_end),
  #]),

  # script_battle_tactic_init
  # Input: none
  # Output: none
  ("battle_tactic_init",
    [
      (call_script, "script_battle_tactic_init_aux", "$ai_team_1", "$ai_team_1_battle_tactic"),
      (try_begin),
        (ge, "$ai_team_2", 0),
        (call_script, "script_battle_tactic_init_aux", "$ai_team_2", "$ai_team_2_battle_tactic"),
      (try_end),

      (try_for_agents, ":cur_agent"),
        (agent_set_slot, ":cur_agent",  slot_agent_is_running_away, 0), #initially nobody is running away.
      (try_end),
  ]),

  # script_battle_tactic_init_aux
  # Input: team_no, battle_tactic
  # Output: none
  ("orig_battle_tactic_init_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
      (team_get_leader, ":ai_leader", ":team_no"),
      (try_begin),
        (eq, ":battle_tactic", btactic_hold),
        (agent_get_position, pos1, ":ai_leader"),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30),
        (copy_position, pos1, pos52),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30), # call again just in case we are not at peak point.
        (copy_position, pos1, pos52),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30), # call again just in case we are not at peak point.
        (team_give_order, ":team_no", grc_everyone, mordr_hold),
        (team_set_order_position, ":team_no", grc_everyone, pos52),
        (team_give_order, ":team_no", grc_archers, mordr_advance),
        (team_give_order, ":team_no", grc_archers, mordr_advance),
      (else_try),
        (eq, ":battle_tactic", btactic_follow_leader),
        (team_get_leader, ":ai_leader", ":team_no"),
        (ge, ":ai_leader", 0),
        (agent_set_speed_limit, ":ai_leader", 8),
        (agent_get_position, pos60, ":ai_leader"),
        (team_give_order, ":team_no", grc_everyone, mordr_hold),
        (team_set_order_position, ":team_no", grc_everyone, pos60),
      (try_end),
  ]),

  # script_calculate_team_powers
  # Input: none
  # Output: ally_power, enemy_power
  ("calculate_team_powers",
     [
       (store_script_param, ":agent_no", 1),

       (try_begin),
         (assign, ":agent_side", 0),
         (agent_is_ally, ":agent_no"),
         (assign, ":agent_side", 1),
       (try_end),

       (assign, ":ally_power", 0),
       (assign, ":enemy_power", 0),

       (try_for_agents, ":cur_agent"),
         (agent_is_human, ":cur_agent"),
         (agent_is_alive, ":cur_agent"),

         (try_begin),
           (assign, ":agent_side_cur", 0),
           (agent_is_ally, ":cur_agent"),
           (assign, ":agent_side_cur", 1),
         (try_end),

         (try_begin),
           (agent_get_horse, ":agent_horse_id", ":cur_agent"),
           (neq, ":agent_horse_id", -1),
           (assign, ":agent_power", 2), #if this agent is horseman then his power effect is 2
         (else_try),
           (assign, ":agent_power", 1), #if this agent is walker then his power effect is 1
         (try_end),

         (try_begin),
           (eq, ":agent_side", ":agent_side_cur"),
           (val_add, ":ally_power", ":agent_power"),
         (else_try),
           (val_add, ":enemy_power", ":agent_power"),
         (try_end),
       (try_end),

       (assign, reg0, ":ally_power"),
       (assign, reg1, ":enemy_power"),
  ]), #ozan

  # script_apply_effect_of_other_people_on_courage_scores
  # Input: none
  # Output: none
  ("apply_effect_of_other_people_on_courage_scores",
    [
      (get_player_agent_no, ":player_agent"),

      (try_for_agents, ":centered_agent_no"),
        (agent_is_human, ":centered_agent_no"),
        (agent_is_alive, ":centered_agent_no"),
        (neq, ":centered_agent_no", ":player_agent"),
        (agent_get_position, pos0, ":centered_agent_no"),
        (try_begin),
          (agent_is_ally, ":centered_agent_no"),
          (assign, ":is_centered_agent_ally", 1),
        (else_try),
          (assign, ":is_centered_agent_ally", 0),
        (try_end),

        (try_for_agents, ":agent_no"),
          (agent_is_human, ":agent_no"),
          (agent_is_alive, ":agent_no"),
          (neq, ":centered_agent_no", ":agent_no"),

          (try_begin),
            (agent_is_ally, ":agent_no"),
            (assign, ":is_agent_ally", 1),
          (else_try),
            (assign, ":is_agent_ally", 0),
          (try_end),

          (eq, ":is_centered_agent_ally", ":is_agent_ally"), #if centered agent and other agent is at same team then continue.
          (agent_get_slot, ":agent_is_running_away_or_not", ":agent_no", slot_agent_is_running_away),

          (try_begin),
            (eq, ":agent_no", ":player_agent"),
            (assign, ":agent_delta_courage_score", 6),
          (else_try),
            (agent_get_troop_id, ":troop_id", ":agent_no"),
            (troop_is_hero, ":troop_id"),

            #Hero Agent : if near agent (hero, agent_no) is not running away his positive effect on centered agent (centered_agent_no) fighting at his side is effected by his hit points.
            (try_begin),
              (neq, ":agent_is_running_away_or_not", 1), #if agent is not running away
              (store_agent_hit_points, ":agent_hit_points", ":agent_no"),
              (try_begin),
                (eq, ":agent_hit_points", 100),
                (assign, ":agent_delta_courage_score", 6),
              (else_try),
                (ge, ":agent_hit_points", 75),
                (assign, ":agent_delta_courage_score", 5),
              (else_try),
                (ge, ":agent_hit_points", 60),
                (assign, ":agent_delta_courage_score", 4),
              (else_try),
                (ge, ":agent_hit_points", 45),
                (assign, ":agent_delta_courage_score", 3),
              (else_try),
                (ge, ":agent_hit_points", 30),
                (assign, ":agent_delta_courage_score", 2),
              (else_try),
                (ge, ":agent_hit_points", 15),
                (assign, ":agent_delta_courage_score", 1),
              (end_try),
            (else_try),
              (assign, ":agent_delta_courage_score", 4),
            (end_try),
          (else_try),
            #Normal Agent : if near agent (agent_no) is not running away his positive effect on centered agent (centered_agent_no) fighting at his side is effected by his hit points.
            (try_begin),
              (neq, ":agent_is_running_away_or_not", 1), # if agent is not running away
              (store_agent_hit_points, ":agent_hit_points", ":agent_no"),
              (try_begin),
                (eq, ":agent_hit_points", 100),
                (assign, ":agent_delta_courage_score", 4),
              (else_try),
                (ge, ":agent_hit_points", 75),
                (assign, ":agent_delta_courage_score", 3),
              (else_try),
                (ge, ":agent_hit_points", 50),
                (assign, ":agent_delta_courage_score", 2),
              (else_try),
                (ge, ":agent_hit_points", 25),
                (assign, ":agent_delta_courage_score", 1),
              (try_end),
              (try_begin), # to make our warrior run away easier we decrease one, because they have player_agent (+6) advantage.
                (agent_is_ally, ":agent_no"),
                (val_sub, ":agent_delta_courage_score", 1),
              (try_end),
            (else_try),
              (assign, ":agent_delta_courage_score", 2),
            (end_try),
          (try_end),

          (try_begin),
            (neq, ":agent_is_running_away_or_not", 1),
            (val_mul, ":agent_delta_courage_score", 1),
            (try_begin), # centered agent not running away cannot take positive courage score from one another agent not running away.
              (agent_get_slot, ":agent_is_running_away_or_not", ":centered_agent_no", slot_agent_is_running_away),
              (eq, ":agent_is_running_away_or_not", 0),
              (val_mul, ":agent_delta_courage_score", 0),
            (try_end),
          (else_try),
            (try_begin),
              (agent_get_slot, ":agent_is_running_away_or_not", ":agent_no", slot_agent_is_running_away),
              (eq, ":agent_is_running_away_or_not", 0),
              (val_mul, ":agent_delta_courage_score", -2), # running away agent fears not running away agent more.
            (else_try),
              (val_mul, ":agent_delta_courage_score", -1),
            (try_end),
          (try_end),

          (neq, ":agent_delta_courage_score", 0),

          (agent_get_position, pos1, ":agent_no"),
          (get_distance_between_positions, ":dist", pos0, pos1),

          (try_begin),
            (ge, ":agent_delta_courage_score", 0),
            (try_begin),
              (lt, ":dist", 2000), #0-20 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 50),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 4000), #21-40 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 40),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 7000), #41-70 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 30),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 11000), #71-110 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 20),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 16000), # 111-160 meter, assumed that eye can see agents friendly at most 160 meters far while fighting.
                                    # this is more than below limit (108 meters) because we hear that allies come from further.
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 10),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (try_end),
          (else_try),                                               # negative effect of running agent on other ally agents are lower then positive effects above, to avoid starting
            (try_begin),                                            # run away of all agents at a moment. I want to see agents running away one by one during battle, not all together.
              (lt, ":dist", 200), #1-2 meter,                       # this would create better game play.
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 15),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 400), #3-4 meter,
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 13),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 600), #5-6 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 11),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 800), #7-8 meter
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 9),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 1200), #9-12 meters
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 7),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 2400), #13-24 meters
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 5),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 4800), #25-48 meters
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 3),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (else_try),
              (lt, ":dist", 9600), #49-98 meters, assumed that eye can see agents running away at most 98 meters far while fighting.
              (agent_get_slot, ":agent_courage_score", ":centered_agent_no", slot_agent_courage_score),
              (val_mul, ":agent_delta_courage_score", 1),
              (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
              (agent_set_slot, ":centered_agent_no", slot_agent_courage_score, ":agent_courage_score"),
            (try_end),
          (try_end),
        (try_end),
      (try_end),
  ]), #ozan


#jacobhinds Morale Code BEGIN

  # script_apply_death_effect_on_courage_scores
  # Input: dead agent id, killer agent id
  # Output: none
  ("apply_death_effect_on_courage_scores",
    [
      (store_script_param, ":dead_agent_no", 1),
      (store_script_param, ":killer_agent_no", 2),



      (try_begin),
        (agent_is_human, ":dead_agent_no"),

        (try_begin),
          (agent_is_ally, ":dead_agent_no"),
          (assign, ":is_dead_agent_ally", 1),
        (else_try),
          (assign, ":is_dead_agent_ally", 0),
        (try_end),

        #(agent_get_position, pos0, ":dead_agent_no"),
        #(assign, ":number_of_near_allies_to_dead_agent", 0),

        # (try_for_agents, ":agent_no"),
          # (agent_is_human, ":agent_no"),
          # (agent_is_alive, ":agent_no"),

          # (agent_get_position, pos1, ":agent_no"),
          # (get_distance_between_positions, ":dist", pos0, pos1),

          # (le, ":dist", 1300), # to count number of allies within 13 meters to dead agent.

          # (try_begin),
            # (agent_is_ally, ":agent_no"),
            # (assign, ":is_agent_ally", 1),
          # (else_try),
            # (assign, ":is_agent_ally", 0),
          # (try_end),

          # (try_begin),
            # (eq, ":is_dead_agent_ally", ":is_agent_ally"),
            # (val_add, ":number_of_near_allies_to_dead_agent", 1), #was 1
																	# # (number_of_near_allies_to_dead_agent) is counted because if there are
          # (try_end),                                              # many allies of dead agent around him, negative courage effect become less.

			# # jacobhinds edit: wait a second, this doesn't really make sense.
			# # If a soldier in a blob of soldiers gets slaughtered, nobody routs,
			# # but if they're outside, they cause more routing. Halve this effect:
			# # distance should play the biggest role.
          # (val_div, ":number_of_near_allies_to_dead_agent", 2),

        # (try_end),

        (try_for_agents, ":agent_no"),
          (agent_is_human, ":agent_no"),
          (agent_is_alive, ":agent_no"),

          (try_begin),
            (agent_is_ally, ":agent_no"),
            (assign, ":is_agent_ally", 1),
          (else_try),
            (assign, ":is_agent_ally", 0),
          (try_end),

          (try_begin), # each agent is effected by a killed agent positively if he is rival or negatively if he is ally.
            (neq, ":is_dead_agent_ally", ":is_agent_ally"),
            (assign, ":agent_delta_courage_score", 3),  # if killed agent is agent of rival side, add points to fear score #was 10 #after that, was 1
          (else_try),
            (assign, ":agent_delta_courage_score", -5), # if killed agent is agent of our side, decrease points from fear score #jacobhinds was -15, was -4 before battle_ratio overhaul, FEAR SCORE
            #(val_add, ":agent_delta_courage_score", ":number_of_near_allies_to_dead_agent"), # ":number_of_near_allies_to_dead_agent" is added because if there are many # allies of dead agent around him, negative courage effect become less.
            # (try_begin),
              # (lt, ":agent_delta_courage_score", -4), #was -5 #was -2 before battle_ratio overhaul #was gt
              # (assign, ":agent_delta_courage_score", -4), #was -5
            # (try_end),

            (agent_get_slot, ":dead_agent_was_running_away_or_not", ":dead_agent_no",  slot_agent_is_running_away), #look dead agent was running away or not.
            (try_begin),
              (eq, ":dead_agent_was_running_away_or_not", 1),
              (val_div, ":agent_delta_courage_score", 3), #was 3 # if killed agent was running away his negative effect on ally courage scores become very less. This added because
            (try_end),                                     # running away agents are easily killed and courage scores become very in a running away group after a time, and
          (try_end),                                       # they do not stop running away although they pass near a new powerful ally party.
          (agent_get_position, pos1, ":agent_no"),
          (get_distance_between_positions, ":dist", pos0, pos1),

          (try_begin), #if agent is the killer, give him x20 more courage than usual
            (eq, ":killer_agent_no", ":agent_no"),
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 20),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (try_end),

			#jacobhinds edit: prevent morale from getting too high
          (try_begin),
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
			(ge, ":agent_courage_score", max_morale),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, max_morale),
          (try_end),

          (try_begin),
            (lt, ":dist", 100), #0-1 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 120), #was 150
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 200), #2 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 110), #was 120
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 300), #3 meter
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 100),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 400), #4 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 90),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 600), #5-6 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 80),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 800), #7-8 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 70),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 1000), #9-10 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 60),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 1500), #11-15 meter
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 50),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 2500), #16-25 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 40),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 4000), #26-40 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 30),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 6500), #41-65 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 20),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (else_try),
            (lt, ":dist", 10000), #61-100 meters
            (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            (val_mul, ":agent_delta_courage_score", 10),
            (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          (try_end),
        (try_end),
      (try_end),

			#housekeeping
			# (store_random_in_range, ":rand", 0, 10),
			# (try_begin),
				# (eq, ":rand", 1),
				# (assign, reg4, ":agent_delta_courage_score"),
				# (display_message, "@{reg4}"),
			# (try_end),
			#housekeeping

      ]), #ozan

#jacobhinds Morale Code END

#jacobhinds Morale Code BEGIN
#(Native version)

  # script_decide_run_away_or_not
  # Input: none
  # Output: none
  ("decide_run_away_or_not",
    [
      (store_script_param, ":cur_agent", 1),
      (store_script_param, ":mission_time", 2),



      (assign, ":force_retreat", 0),
      (agent_get_team, ":agent_team", ":cur_agent"),
      (agent_get_division, ":agent_division", ":cur_agent"),
      (try_begin),
        (lt, ":agent_division", 9), #static classes
        (team_get_movement_order, ":agent_movement_order", ":agent_team", ":agent_division"),
        (eq, ":agent_movement_order", mordr_retreat),
        (assign, ":force_retreat", 1),
      (try_end),

      (agent_get_slot, ":is_cur_agent_running_away", ":cur_agent", slot_agent_is_running_away),
      (try_begin),
		#(neg|agent_slot_eq, ":cur_agent", slot_agent_courage_score_bonus, -1),
        (eq, ":is_cur_agent_running_away", 0),
        (try_begin),
          (eq, ":force_retreat", 1),
          (agent_clear_scripted_mode, ":cur_agent"),	#handle scripted mode troops - motomataru
          (agent_start_running_away, ":cur_agent"),
		  #(call_script, "script_agent_remove_from_square", ":cur_agent"), #jacobhinds infantry square script (remove if you don't have the infantry square script)
          (agent_set_slot, ":cur_agent",  slot_agent_is_running_away, 1),
		  #(agent_set_speed_limit, ":cur_agent", 60),
        (else_try),
          (ge, ":mission_time", 4), #first 4 seconds anyone does not run away whatever happens.
          (agent_get_slot, ":agent_courage_score", ":cur_agent",  slot_agent_courage_score),
          (store_agent_hit_points, ":agent_hit_points", ":cur_agent"),
          (val_mul, ":agent_hit_points", 10), #was 4
         # (try_begin),
          #  (agent_is_ally, ":cur_agent"),
           # (val_sub, ":agent_hit_points", 100), #ally agents will be more tend to run away, to make game more funnier/harder
         # (try_end),

#	IGNORE THIS, just rambling from several workarounds ago BEGIN

#	ratio
#	assume major battle 100(enemy) vs 100(ally)
#	20/100 = 0.2 = nigh unbreakable (for now give no negative effects)
#	100/20 = 5	= rout
#	battle ratio * 100
#	potential swing from 0-1000 courage score malus before rout
#	perhaps link to battle ai....? or unbalanced?

#	IGNORE THIS, just rambling from several workarounds ago END

		  (try_begin),
			(call_script, "script_cf_agent_can_rout", ":cur_agent"),
			(agent_is_ally, ":cur_agent"),
			(val_add, ":agent_hit_points", "$battle_ratio"),
		  (else_try),
			(call_script, "script_cf_agent_can_rout", ":cur_agent"),
			(val_sub, ":agent_hit_points", "$battle_ratio"),
		  (try_end),

          #(val_mul, ":agent_hit_points", 10),
          (store_sub, ":start_running_away_courage_score_limit", 1500, ":agent_hit_points"), #was 3500
          #(assign, reg11, ":agent_courage_score"),
          #(assign, reg12, ":start_running_away_courage_score_limit"),
          #(display_message, "@courage: {reg11}, limit: {reg12}"),
          (lt, ":agent_courage_score", ":start_running_away_courage_score_limit"), #if (courage score < 3500 - (agent hit points * 40)) and (agent is not running away) then start running away, average hit points : 50, average running away limit = 1500

          (agent_get_troop_id, ":troop_id", ":cur_agent"), #for now do not let heroes to run away from battle
          (neg|troop_is_hero, ":troop_id"),

		  # (try_begin), #this block is optional, delete if you don't have diplomacy or if you don't want retreating voices.
			  # (call_script, "script_dplmc_store_troop_is_female", ":troop_id"), #shout "retreat" if male
			  # (neq, reg0, 1),
			  # #(agent_play_sound, ":cur_agent", "snd_man_retreat"), #uncomment if you want retreating voices
		  # (try_end),

          (agent_clear_scripted_mode, ":cur_agent"),	#handle scripted mode troops - motomataru
          (agent_start_running_away, ":cur_agent"),
		  #(call_script, "script_agent_remove_from_square", ":cur_agent"), #jacobhinds infantry square script (remove if you don't have the infantry square script)
		  #(agent_set_speed_limit, ":cur_agent", 60),
          (agent_set_slot, ":cur_agent",  slot_agent_is_running_away, 1),
          #(display_message, "@AGENT HAS STARTED RUNNING"),
        (try_end),


      (else_try),
		#(neg|agent_slot_eq, ":cur_agent", slot_agent_courage_score_bonus, -1),
        (neq, ":force_retreat", 1),
        (agent_get_slot, ":agent_courage_score", ":cur_agent",  slot_agent_courage_score),
        (store_agent_hit_points, ":agent_hit_points", ":cur_agent"),
        (val_mul, ":agent_hit_points", 10), #was 4
   #     (try_begin),
    #      (agent_is_ally, ":cur_agent"),
     #     (val_sub, ":agent_hit_points", 100), #ally agents will be more tend to run away, to make game more funnier/harder
      #  (try_end),

		  (try_begin),
			(call_script, "script_cf_agent_can_rout", ":cur_agent"),
			(agent_is_ally, ":cur_agent"),
			(val_add, ":agent_hit_points", "$battle_ratio"),
		  (else_try),
			(call_script, "script_cf_agent_can_rout", ":cur_agent"),
			(val_sub, ":agent_hit_points", "$battle_ratio"),
		  (try_end),

        #(val_mul, ":agent_hit_points", 10),
        (store_sub, ":stop_running_away_courage_score_limit", 1800, ":agent_hit_points"),#what

        #(assign, reg11, ":agent_courage_score"),
        #(assign, reg12, ":start_running_away_courage_score_limit"),
        #(display_message, "@courage: {reg11}, limit: {reg12}"),

        (ge, ":agent_courage_score", ":stop_running_away_courage_score_limit"), #if (courage score > 3700 - agent hit points) and (agent is running away) then stop running away, average hit points : 50, average running away limit = 1700
        (agent_stop_running_away, ":cur_agent"),
        (agent_set_slot, ":cur_agent",  slot_agent_is_running_away, 0),
        #(display_message, "@AGENT HAS STOPPED RUNNING"),
      (try_end),
  ]), #ozan


#jacobhinds Morale Code END
#(Native version)

  # script_apply_death_effect_on_courage_scores
  # Input: dead agent id, killer agent id
  # Output: none
  # ("apply_death_effect_on_courage_scores",
    # [
      # (store_script_param, ":dead_agent_no", 1),
      # (store_script_param, ":killer_agent_no", 2),

      # (try_begin),
        # (agent_is_human, ":dead_agent_no"),

        # (try_begin),
          # (agent_is_ally, ":dead_agent_no"),
          # (assign, ":is_dead_agent_ally", 1),
        # (else_try),
          # (assign, ":is_dead_agent_ally", 0),
        # (try_end),

        # (agent_get_position, pos0, ":dead_agent_no"),
        # (assign, ":number_of_near_allies_to_dead_agent", 0),

        # (try_for_agents, ":agent_no"),
          # (agent_is_human, ":agent_no"),
          # (agent_is_alive, ":agent_no"),

          # (agent_get_position, pos1, ":agent_no"),
          # (get_distance_between_positions, ":dist", pos0, pos1),

          # (le, ":dist", 1300), # to count number of allies within 13 meters to dead agent.

          # (try_begin),
            # (agent_is_ally, ":agent_no"),
            # (assign, ":is_agent_ally", 1),
          # (else_try),
            # (assign, ":is_agent_ally", 0),
          # (try_end),

          # (try_begin),
            # (eq, ":is_dead_agent_ally", ":is_agent_ally"),
            # (val_add, ":number_of_near_allies_to_dead_agent", 1), # (number_of_near_allies_to_dead_agent) is counted because if there are
          # (try_end),                                              # many allies of dead agent around him, negative courage effect become less.
        # (try_end),

        # (try_for_agents, ":agent_no"),
          # (agent_is_human, ":agent_no"),
          # (agent_is_alive, ":agent_no"),

          # (try_begin),
            # (agent_is_ally, ":agent_no"),
            # (assign, ":is_agent_ally", 1),
          # (else_try),
            # (assign, ":is_agent_ally", 0),
          # (try_end),

          # (try_begin), # each agent is effected by a killed agent positively if he is rival or negatively if he is ally.
            # (neq, ":is_dead_agent_ally", ":is_agent_ally"),
            # (assign, ":agent_delta_courage_score", 10),  # if killed agent is agent of rival side, add points to fear score
          # (else_try),
            # (assign, ":agent_delta_courage_score", -15), # if killed agent is agent of our side, decrease points from fear score
            # (val_add, ":agent_delta_courage_score", ":number_of_near_allies_to_dead_agent"), # ":number_of_near_allies_to_dead_agent" is added because if there are many
            # (try_begin),                                                                     # allies of dead agent around him, negative courage effect become less.
              # (gt, ":agent_delta_courage_score", -5),
              # (assign, ":agent_delta_courage_score", -5),
            # (try_end),

            # (agent_get_slot, ":dead_agent_was_running_away_or_not", ":dead_agent_no",  slot_agent_is_running_away), #look dead agent was running away or not.
            # (try_begin),
              # (eq, ":dead_agent_was_running_away_or_not", 1),
              # (val_div, ":agent_delta_courage_score", 3),  # if killed agent was running away his negative effect on ally courage scores become very less. This added because
            # (try_end),                                     # running away agents are easily killed and courage scores become very in a running away group after a time, and
          # (try_end),                                       # they do not stop running away althought they pass near a new powerfull ally party.
          # (agent_get_position, pos1, ":agent_no"),
          # (get_distance_between_positions, ":dist", pos0, pos1),

          # (try_begin),
            # (eq, ":killer_agent_no", ":agent_no"),
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 20),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (try_end),

          # (try_begin),
            # (lt, ":dist", 100), #0-1 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 150),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 200), #2 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 120),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 300), #3 meter
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 100),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 400), #4 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 90),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 600), #5-6 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 80),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 800), #7-8 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 70),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 1000), #9-10 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 60),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 1500), #11-15 meter
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 50),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 2500), #16-25 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 40),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 4000), #26-40 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 30),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 6500), #41-65 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 20),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (else_try),
            # (lt, ":dist", 10000), #61-100 meters
            # (agent_get_slot, ":agent_courage_score", ":agent_no", slot_agent_courage_score),
            # (val_mul, ":agent_delta_courage_score", 10),
            # (val_add, ":agent_courage_score", ":agent_delta_courage_score"),
            # (agent_set_slot, ":agent_no", slot_agent_courage_score, ":agent_courage_score"),
          # (try_end),
        # (try_end),
      # (try_end),
      # ]), #ozan

  # # script_decide_run_away_or_not
  # # Input: none
  # # Output: none
  # ("decide_run_away_or_not",
    # [
      # (store_script_param, ":cur_agent", 1),
      # (store_script_param, ":mission_time", 2),

      # (assign, ":force_retreat", 0),
      # (agent_get_team, ":agent_team", ":cur_agent"),
      # (agent_get_division, ":agent_division", ":cur_agent"),
      # (try_begin),
        # (lt, ":agent_division", 9), #static classes
        # (team_get_movement_order, ":agent_movement_order", ":agent_team", ":agent_division"),
        # (eq, ":agent_movement_order", mordr_retreat),
        # (assign, ":force_retreat", 1),
      # (try_end),

      # (agent_get_slot, ":is_cur_agent_running_away", ":cur_agent", slot_agent_is_running_away),
      # (try_begin),
        # (eq, ":is_cur_agent_running_away", 0),
        # (try_begin),
          # (eq, ":force_retreat", 1),
          # (agent_start_running_away, ":cur_agent"),
          # (agent_set_slot, ":cur_agent",  slot_agent_is_running_away, 1),
        # (else_try),
          # (ge, ":mission_time", 4), #first 45 seconds anyone does not run away whatever happens.
          # (agent_get_slot, ":agent_courage_score", ":cur_agent",  slot_agent_courage_score),
          # (store_agent_hit_points, ":agent_hit_points", ":cur_agent"),
          # (val_mul, ":agent_hit_points", 4),
          # (try_begin),
            # (agent_is_ally, ":cur_agent"),
            # (val_sub, ":agent_hit_points", 100), #ally agents will be more tend to run away, to make game more funnier/harder
          # (try_end),
          # (val_mul, ":agent_hit_points", 10),
          # (store_sub, ":start_running_away_courage_score_limit", 3500, ":agent_hit_points"),
          # (lt, ":agent_courage_score", ":start_running_away_courage_score_limit"), #if (courage score < 3500 - (agent hit points * 40)) and (agent is not running away) then start running away, average hit points : 50, average running away limit = 1500

          # (agent_get_troop_id, ":troop_id", ":cur_agent"), #for now do not let heroes to run away from battle
          # (neg|troop_is_hero, ":troop_id"),

          # (agent_start_running_away, ":cur_agent"),
          # (agent_set_slot, ":cur_agent",  slot_agent_is_running_away, 1),
        # (try_end),
      # (else_try),
        # (neq, ":force_retreat", 1),
        # (agent_get_slot, ":agent_courage_score", ":cur_agent",  slot_agent_courage_score),
        # (store_agent_hit_points, ":agent_hit_points", ":cur_agent"),
        # (val_mul, ":agent_hit_points", 4),
        # (try_begin),
          # (agent_is_ally, ":cur_agent"),
          # (val_sub, ":agent_hit_points", 100), #ally agents will be more tend to run away, to make game more funnier/harder
        # (try_end),
        # (val_mul, ":agent_hit_points", 10),
        # (store_sub, ":stop_running_away_courage_score_limit", 3700, ":agent_hit_points"),
        # (ge, ":agent_courage_score", ":stop_running_away_courage_score_limit"), #if (courage score > 3700 - agent hit points) and (agent is running away) then stop running away, average hit points : 50, average running away limit = 1700
        # (agent_stop_running_away, ":cur_agent"),
        # (agent_set_slot, ":cur_agent",  slot_agent_is_running_away, 0),
      # (try_end),
  # ]), #ozan

  # script_battle_tactic_apply
  # Input: none
  # Output: none
  ("battle_tactic_apply",
    [
      (call_script, "script_battle_tactic_apply_aux", "$ai_team_1", "$ai_team_1_battle_tactic"),
      (assign, "$ai_team_1_battle_tactic", reg0),
      (try_begin),
        (ge, "$ai_team_2", 0),
        (call_script, "script_battle_tactic_apply_aux", "$ai_team_2", "$ai_team_2_battle_tactic"),
        (assign, "$ai_team_2_battle_tactic", reg0),
      (try_end),
  ]),

  # script_battle_tactic_apply_aux
  # Input: team_no, battle_tactic
  # Output: battle_tactic
  ("orig_battle_tactic_apply_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
      (store_mission_timer_a, ":mission_time"),
      (try_begin),
        (eq, ":battle_tactic", btactic_hold),
        (copy_position, pos1, pos52),
        (call_script, "script_get_closest3_distance_of_enemies_at_pos1", ":team_no", 1),
        (assign, ":avg_dist", reg0),
        (assign, ":min_dist", reg1),
        (try_begin),
          (this_or_next|lt, ":min_dist", 1000),
          (lt, ":avg_dist", 4000),
          (assign, ":battle_tactic", 0),
          (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (try_end),
      (else_try),
        (eq, ":battle_tactic", btactic_follow_leader),
        (team_get_leader, ":ai_leader", ":team_no"),
        (try_begin),
          (ge, ":ai_leader", 0),
          (agent_is_alive, ":ai_leader"),
          (agent_set_speed_limit, ":ai_leader", 9),
          (call_script, "script_team_get_average_position_of_enemies", ":team_no"),
          (copy_position, pos60, pos0),
          (agent_get_position, pos61, ":ai_leader"),
          (position_transform_position_to_local, pos62, pos61, pos60), #pos62 = vector to enemy w.r.t leader
          (position_normalize_origin, ":distance_to_enemy", pos62),
          (convert_from_fixed_point, ":distance_to_enemy"),
          (assign, reg17, ":distance_to_enemy"),
          (position_get_x, ":dir_x", pos62),
          (position_get_y, ":dir_y", pos62),
          (val_mul, ":dir_x", 23),
          (val_mul, ":dir_y", 23), #move 23 meters
          (position_set_x, pos62, ":dir_x"),
          (position_set_y, pos62, ":dir_y"),

          (position_transform_position_to_parent, pos63, pos61, pos62), #pos63 is 23m away from leader in the direction of the enemy.
          (position_set_z_to_ground_level, pos63),

          (team_give_order, ":team_no", grc_everyone, mordr_hold),
          (team_set_order_position, ":team_no", grc_everyone, pos63),
          (agent_get_position, pos1, ":ai_leader"),
          (try_begin),
            (lt, ":distance_to_enemy", 50),
            (ge, ":mission_time", 30),
            (assign, ":battle_tactic", 0),
            (team_give_order, ":team_no", grc_everyone, mordr_charge),
            (agent_set_speed_limit, ":ai_leader", 60),
          (try_end),
        (else_try),
          (assign, ":battle_tactic", 0),
          (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (try_end),
      (try_end),

      (try_begin), # charge everyone after a while
        (neq, ":battle_tactic", 0),
        (ge, ":mission_time", 300),
        (assign, ":battle_tactic", 0),
        (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (team_get_leader, ":ai_leader", ":team_no"),
        (agent_set_speed_limit, ":ai_leader", 60),
      (try_end),
      (assign, reg0, ":battle_tactic"),
  ]),


##  # script_siege_defender_tactic_apply
##  # Input: none
##  # Output: none
##  ("siege_defender_tactic_apply",
##    [
##      (try_begin),
##        (eq, "$defender_team", 1),
##        (ge, "$belfry_positioned", 2),
##
##        (assign, ":enemy_too_weak", 0),
##        (try_begin),
##          (ge, "$attacker_reinforcement_stage", 2),
##          (call_script, "script_calculate_team_strength", "$defender_team"),
##          (assign, ":defender_strength", reg0),
##          (call_script, "script_calculate_team_strength", "$attacker_team"),
##          (assign, ":attacker_strength", reg0),
##          (store_mul, ":attacker_strength_multiplied", ":attacker_strength", 2),
##          (ge, ":defender_strength", ":attacker_strength_multiplied"),
##          (assign, ":enemy_too_weak", 1),
##        (try_end),
##
##        (try_begin),
##          (eq, ":enemy_too_weak", 1),
##          (neq, "$ai_battle_tactic", btactic_charge),
##          (assign, "$ai_battle_tactic", btactic_charge),
##          (team_give_order, "$defender_team", grc_infantry, mordr_charge),
##        (else_try),
##          (neq, "$ai_battle_tactic", btactic_charge),
##          (neq, "$ai_battle_tactic", btactic_hold),
##          (assign, "$ai_battle_tactic", btactic_hold),
##          (team_give_order, "$defender_team", grc_infantry, mordr_hold),
##          (team_give_order, "$defender_team", grc_heroes, mordr_hold),
##          (entry_point_get_position,pos1,10),
##          (team_set_order_position, "$defender_team", grc_infantry, pos1),
##          (team_set_order_position, "$defender_team", grc_heroes, pos1),
##        (try_end),
##      (try_end),
##  ]),


  # script_team_get_class_percentages
  # Input: arg1: team_no, arg2: try for team's enemies
  # Output: reg0: percentage infantry, reg1: percentage archers, reg2: percentage cavalry
  ("team_get_class_percentages",
    [
      (assign, ":num_infantry", 0),
      (assign, ":num_archers", 0),
      (assign, ":num_cavalry", 0),
      (assign, ":num_total", 0),
      (store_script_param, ":team_no", 1),
      (store_script_param, ":negate", 2),
      (try_for_agents,":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_get_team, ":agent_team", ":cur_agent"),
        (assign, ":continue", 0),
        (try_begin),
          (eq, ":negate", 1),
          (teams_are_enemies, ":agent_team", ":team_no"),
          (assign, ":continue", 1),
        (else_try),
          (eq, ":agent_team", ":team_no"),
          (assign, ":continue", 1),
        (try_end),
        (eq, ":continue", 1),
        (val_add, ":num_total", 1),
        (agent_get_class, ":agent_class", ":cur_agent"),
        (try_begin),
          (eq, ":agent_class", grc_infantry),
          (val_add,  ":num_infantry", 1),
        (else_try),
          (eq, ":agent_class", grc_archers),
          (val_add,  ":num_archers", 1),
        (else_try),
          (eq, ":agent_class", grc_cavalry),
          (val_add,  ":num_cavalry", 1),
        (try_end),
      (try_end),
      (try_begin),
        (eq,  ":num_total", 0),
        (assign,  ":num_total", 1),
      (try_end),
      (store_mul, ":perc_infantry",":num_infantry",100),
      (val_div, ":perc_infantry",":num_total"),
      (store_mul, ":perc_archers",":num_archers",100),
      (val_div, ":perc_archers",":num_total"),
      (store_mul, ":perc_cavalry",":num_cavalry",100),
      (val_div, ":perc_cavalry",":num_total"),
      (assign, reg0, ":perc_infantry"),
      (assign, reg1, ":perc_archers"),
      (assign, reg2, ":perc_cavalry"),
  ]),

  # script_get_closest3_distance_of_enemies_at_pos1
  # Input: arg1: team_no, pos1
  # Output: reg0: distance in cms.
  ("get_closest3_distance_of_enemies_at_pos1",
    [
      (assign, ":min_distance_1", 100000),
      (assign, ":min_distance_2", 100000),
      (assign, ":min_distance_3", 100000),

      (store_script_param, ":team_no", 1),
      (try_for_agents,":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_get_team, ":agent_team", ":cur_agent"),
        (teams_are_enemies, ":agent_team", ":team_no"),

        (agent_get_position, pos2, ":cur_agent"),
        (get_distance_between_positions,":cur_dist",pos2,pos1),
        (try_begin),
          (lt, ":cur_dist", ":min_distance_1"),
          (assign, ":min_distance_3", ":min_distance_2"),
          (assign, ":min_distance_2", ":min_distance_1"),
          (assign, ":min_distance_1", ":cur_dist"),
        (else_try),
          (lt, ":cur_dist", ":min_distance_2"),
          (assign, ":min_distance_3", ":min_distance_2"),
          (assign, ":min_distance_2", ":cur_dist"),
        (else_try),
          (lt, ":cur_dist", ":min_distance_3"),
          (assign, ":min_distance_3", ":cur_dist"),
        (try_end),
      (try_end),

      (assign, ":total_distance", 0),
      (assign, ":total_count", 0),
      (try_begin),
        (lt, ":min_distance_1", 100000),
        (val_add, ":total_distance", ":min_distance_1"),
        (val_add, ":total_count", 1),
      (try_end),
      (try_begin),
        (lt, ":min_distance_2", 100000),
        (val_add, ":total_distance", ":min_distance_2"),
        (val_add, ":total_count", 1),
      (try_end),
      (try_begin),
        (lt, ":min_distance_3", 100000),
        (val_add, ":total_distance", ":min_distance_3"),
        (val_add, ":total_count", 1),
      (try_end),
      (assign, ":average_distance", 100000),
      (try_begin),
        (gt, ":total_count", 0),
        (store_div, ":average_distance", ":total_distance", ":total_count"),
      (try_end),
      (assign, reg0, ":average_distance"),
      (assign, reg1, ":min_distance_1"),
      (assign, reg2, ":min_distance_2"),
      (assign, reg3, ":min_distance_3"),
  ]),

  # script_team_get_average_position_of_enemies
  # Input: arg1: team_no,
  # Output: pos0: average position.
  ("team_get_average_position_of_enemies",
    [
      (store_script_param_1, ":team_no"),
      (init_position, pos0),
      (assign, ":num_enemies", 0),
      (assign, ":accum_x", 0),
      (assign, ":accum_y", 0),
      (assign, ":accum_z", 0),
      (try_for_agents,":enemy_agent"),
        (agent_is_alive, ":enemy_agent"),
        (agent_is_human, ":enemy_agent"),
        (agent_get_team, ":enemy_team", ":enemy_agent"),
        (teams_are_enemies, ":team_no", ":enemy_team"),

        (agent_get_position, pos62, ":enemy_agent"),

        (position_get_x, ":x", pos62),
        (position_get_y, ":y", pos62),
        (position_get_z, ":z", pos62),

        (val_add, ":accum_x", ":x"),
        (val_add, ":accum_y", ":y"),
        (val_add, ":accum_z", ":z"),
        (val_add, ":num_enemies", 1),
      (try_end),

      (try_begin), #to avoid division by zeros at below division part.
        (le, ":num_enemies", 0),
        (assign, ":num_enemies", 1),
      (try_end),

      (store_div, ":average_x", ":accum_x", ":num_enemies"),
      (store_div, ":average_y", ":accum_y", ":num_enemies"),
      (store_div, ":average_z", ":accum_z", ":num_enemies"),

      (position_set_x, pos0, ":average_x"),
      (position_set_y, pos0, ":average_y"),
      (position_set_z, pos0, ":average_z"),

      (assign, reg0, ":num_enemies"),
  ]),


  # script_search_troop_prisoner_of_party
  # Input: arg1 = troop_no
  # Output: reg0 = party_no (-1 if troop is not a prisoner.)
  ("search_troop_prisoner_of_party",
    [
      (store_script_param_1, ":troop_no"),
      (assign, ":prisoner_of", -1),
      (try_for_parties, ":party_no"),
        (eq,  ":prisoner_of", -1),
        (this_or_next|eq, ":party_no", "p_main_party"),
        (ge, ":party_no", centers_begin),
        (party_count_prisoners_of_type, ":troop_found", ":party_no", ":troop_no"),
        (gt, ":troop_found", 0),
        (assign, ":prisoner_of", ":party_no"),
      (try_end),
      (assign, reg0, ":prisoner_of"),
  ]),


##  # script_clear_last_quest
##  # Input: arg1 = troop_no
##  # Output: none
##  ("clear_last_quest",
##    [
##      (store_script_param_1, ":troop_no"),
##
##      (troop_set_slot, ":troop_no",slot_troop_last_quest, 0),
##      (troop_set_slot, ":troop_no",slot_troop_last_quest_betrayed, 0)
##  ]),



  # script_change_debt_to_troop
  # Input: arg1 = troop_no, arg2 = new debt amount
  # Output: none
  ("change_debt_to_troop",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":new_debt"),

      (troop_get_slot, ":cur_debt", ":troop_no", slot_troop_player_debt),
      (assign, reg1, ":cur_debt"),
      (val_add, ":cur_debt", ":new_debt"),
      (assign, reg2, ":cur_debt"),
      (troop_set_slot, ":troop_no", slot_troop_player_debt, ":cur_debt"),
      (try_begin), #SB : display only if > 0
        (gt, ":cur_debt", 0),
        (str_store_troop_name_link, s1, ":troop_no"),
        (display_message, "@You now owe {reg2} denars to {s1}.", message_negative),
      (try_end),
  ]),




  # script_abort_quest
  # Input: arg1 = quest_no, arg2 = apply relation penalty
  # Output: none
  ("abort_quest",
    [
      (store_script_param_1, ":quest_no"),
      (store_script_param_2, ":abort_type"), #0=aborted by event, 1=abort by talking 2=abort by expire

      (assign, ":quest_return_penalty", -1),
      (assign, ":quest_expire_penalty", -2),

#      (quest_get_slot, ":quest_object_troop", ":quest_no", slot_quest_object_troop),
      (try_begin),
        (this_or_next|eq, ":quest_no", "qst_deliver_message"),
        (eq, ":quest_no", "qst_deliver_message_to_enemy_lord"),
        (assign, ":quest_return_penalty", -2),
        (assign, ":quest_expire_penalty", -3),
      (else_try),
        (eq, ":quest_no", "qst_kidnapped_girl"),
        (party_remove_members, "p_main_party", "trp_kidnapped_girl", 1),
        (quest_get_slot, ":quest_target_party", "qst_kidnapped_girl", slot_quest_target_party),
        (try_begin),
          (party_is_active, ":quest_target_party"),
          (remove_party, ":quest_target_party"),
        (try_end),
      (else_try),
        (eq, ":quest_no", "qst_escort_lady"),
        (quest_get_slot, ":quest_object_troop", "qst_escort_lady", slot_quest_object_troop),
        (party_remove_members, "p_main_party", ":quest_object_troop", 1),
        (assign, ":quest_return_penalty", -2),
        (assign, ":quest_expire_penalty", -3),
##      (else_try),
##        (eq, ":quest_no", "qst_rescue_lady_under_siege"),
##        (party_remove_members, "p_main_party", ":quest_object_troop", 1),
##      (else_try),
##        (eq, ":quest_no", "qst_deliver_message_to_lover"),
##      (else_try),
##        (eq, ":quest_no", "qst_bring_prisoners_to_enemy"),
##        (try_begin),
##          (check_quest_succeeded, ":quest_no"),
##          (quest_get_slot, ":quest_target_amount", ":quest_no", slot_quest_target_amount),
##          (quest_get_slot, ":quest_object_troop", ":quest_no", slot_quest_object_troop),
##          (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
##          (call_script, "script_game_get_join_cost", ":quest_object_troop"),
##          (assign, ":reward", reg0),
##          (val_mul, ":reward", ":quest_target_amount"),
##          (val_div, ":reward", 2),
##        (else_try),
##          (quest_get_slot, ":reward", ":quest_no", slot_quest_target_amount),
##        (try_end),
##        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", ":reward"),
##      (else_try),
##        (eq, ":quest_no", "qst_bring_reinforcements_to_siege"),
##        (quest_get_slot, ":quest_target_amount", ":quest_no", slot_quest_target_amount),
##        (quest_get_slot, ":quest_object_troop", ":quest_no", slot_quest_object_troop),
##        (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
##        (call_script, "script_game_get_join_cost", ":quest_object_troop"),
##        (assign, ":reward", reg0),
##        (val_mul, ":reward", ":quest_target_amount"),
##        (val_mul, ":reward", 2),
##        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", ":reward"),
##      (else_try),
##        (eq, ":quest_no", "qst_deliver_supply_to_center_under_siege"),
##        (quest_get_slot, ":quest_target_amount", ":quest_no", slot_quest_target_amount),
##        (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
##        (store_item_value, ":reward", "itm_siege_supply"),
##        (val_mul, ":reward", ":quest_target_amount"),
##        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", ":reward"),
      (else_try),
        (eq, ":quest_no", "qst_raise_troops"),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", 100),
        (assign, ":quest_return_penalty", -4),
        (assign, ":quest_expire_penalty", -5),
      (else_try),
        (eq, ":quest_no", "qst_deal_with_looters"),
        (try_for_parties, ":cur_party_no"),
          (party_get_template_id, ":cur_party_template", ":cur_party_no"),
          (eq, ":cur_party_template", "pt_looters"),
          (party_set_flags, ":cur_party_no", pf_quest_party, 0),
        (try_end),
        (assign, ":quest_return_penalty", -4),
        (assign, ":quest_expire_penalty", -5),
      (else_try),
        (eq, ":quest_no", "qst_deal_with_bandits_at_lords_village"),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", 200),
        (assign, ":quest_return_penalty", -5),
        (assign, ":quest_expire_penalty", -6),
      (else_try),
        (eq, ":quest_no", "qst_collect_taxes"),
        (quest_get_slot, ":gold_reward", ":quest_no", slot_quest_gold_reward),
        (quest_set_slot, ":quest_no", slot_quest_gold_reward, 0),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
        (call_script, "script_change_debt_to_troop", ":quest_giver_troop", ":gold_reward"),
        (assign, ":quest_return_penalty", -4),
        (assign, ":quest_expire_penalty", -6),
##      (else_try),
##        (eq, ":quest_no", "qst_capture_messenger"),
##      (else_try),
##        (eq, ":quest_no", "qst_bring_back_deserters"),
      (else_try),
        (eq, ":quest_no", "qst_hunt_down_fugitive"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -4),
        #SB : remove prisoner if player kept it intentionally
        (party_remove_prisoners, "p_main_party", "trp_fugitive", 1),
      (else_try),
        (eq, ":quest_no", "qst_kill_local_merchant"),
      (else_try),
        (eq, ":quest_no", "qst_bring_back_runaway_serfs"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -1),
      (else_try),
        (eq, ":quest_no", "qst_collect_debt"),
        (try_begin),
          (quest_slot_eq, "qst_collect_debt", slot_quest_current_state, 1), #debt collected but not delivered
          (quest_get_slot, ":debt", "qst_collect_debt", slot_quest_target_amount),
          (quest_get_slot, ":quest_giver", "qst_collect_debt", slot_quest_giver_troop),
          (call_script, "script_change_debt_to_troop", ":quest_giver", ":debt"),
          (assign, ":quest_return_penalty", -3),
          (assign, ":quest_expire_penalty", -6),
        (else_try),
          (assign, ":quest_return_penalty", -3),
          (assign, ":quest_expire_penalty", -4),
        (try_end),
      (else_try),
        (eq, ":quest_no", "qst_deal_with_bandits_at_lords_village"),
        (assign, ":quest_return_penalty", -6),
        (assign, ":quest_expire_penalty", -6),
      (else_try),
        (eq, ":quest_no", "qst_cause_provocation"),
        (assign, ":quest_return_penalty", -10),
        (assign, ":quest_expire_penalty", -13),
      (else_try),
        (eq, ":quest_no", "qst_persuade_lords_to_make_peace"),
        (assign, ":quest_return_penalty", -10),
        (assign, ":quest_expire_penalty", -13),
      (else_try),
        (eq, ":quest_no", "qst_deal_with_night_bandits"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -1),

      (else_try),
        (eq, ":quest_no", "qst_follow_spy"),
        (assign, ":quest_return_penalty", -2),
        (assign, ":quest_expire_penalty", -3),
        (try_begin),
          (party_is_active, "$qst_follow_spy_spy_party"),
          (remove_party, "$qst_follow_spy_spy_party"),
        (try_end),
        (try_begin),
          (party_is_active, "$qst_follow_spy_spy_partners_party"),
          (remove_party, "$qst_follow_spy_spy_partners_party"),
        (try_end),
      (else_try),
        (eq, ":quest_no", "qst_capture_enemy_hero"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -4),
      (else_try),
        (eq, ":quest_no", "qst_lend_companion"),
        (quest_get_slot, ":quest_target_troop", "qst_lend_companion", slot_quest_target_troop),
        (troop_set_slot, ":quest_target_troop", slot_troop_current_mission, npc_mission_rejoin_when_possible),
        (troop_set_slot, ":quest_target_troop", slot_troop_days_on_mission, 0),
      (else_try),
        (eq, ":quest_no", "qst_lend_surgeon"),
        (quest_get_slot, ":quest_target_troop", "qst_lend_surgeon", slot_quest_target_troop),
        (troop_set_slot, ":quest_target_troop", slot_troop_current_mission, npc_mission_rejoin_when_possible),
        (troop_set_slot, ":quest_target_troop", slot_troop_days_on_mission, 0),
##      (else_try),
##        (eq, ":quest_no", "qst_lend_companion"),
##        (quest_get_slot, ":quest_target_troop", "qst_lend_companion", slot_quest_target_troop),
##        (party_add_members, "p_main_party", ":quest_target_troop", 1),
##      (else_try),
##        (eq, ":quest_no", "qst_capture_conspirators"),
##      (else_try),
##        (eq, ":quest_no", "qst_defend_nobles_against_peasants"),
      (else_try),
        (eq, ":quest_no", "qst_incriminate_loyal_commander"),
        (assign, ":quest_return_penalty", -5),
        (assign, ":quest_expire_penalty", -6),
##      (else_try),
##        (eq, ":quest_no", "qst_hunt_down_raiders"),
##      (else_try),
##        (eq, ":quest_no", "qst_capture_prisoners"),
##        #Enemy lord quests
      (else_try),
        (eq, ":quest_no", "qst_lend_surgeon"),

        #Kingdom lady quests
      (else_try),
        (eq, ":quest_no", "qst_rescue_lord_by_replace"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -1),
      (else_try),
        (eq, ":quest_no", "qst_deliver_message_to_prisoner_lord"),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", -1),
      (else_try),
        (eq, ":quest_no", "qst_duel_for_lady"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -1),

      #Kingdom Army quests
      (else_try),
        (eq, ":quest_no", "qst_follow_army"),
        (assign, ":quest_return_penalty", 0), #was -4
        (assign, ":quest_expire_penalty", 0), #was -5
      (else_try),
        (eq, ":quest_no", "qst_deliver_cattle_to_army"),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", 0),
      (else_try),
        (eq, ":quest_no", "qst_join_siege_with_army"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -2),
      (else_try),
        (eq, ":quest_no", "qst_scout_waypoints"),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", 0),

      #Village Elder quests
      (else_try),
        (eq, ":quest_no", "qst_deliver_grain"),
        (assign, ":quest_return_penalty", -6),
        (assign, ":quest_expire_penalty", -7),
      (else_try),
        (eq, ":quest_no", "qst_deliver_cattle"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -4),
      (else_try),
        (eq, ":quest_no", "qst_train_peasants_against_bandits"),
        (assign, ":quest_return_penalty", -4),
        (assign, ":quest_expire_penalty", -5),

      #Mayor quests
      (else_try),
        (eq, ":quest_no", "qst_deliver_wine"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -3),
        (val_add, "$debt_to_merchants_guild", "$qst_deliver_wine_debt"),
      (else_try),
        (eq, ":quest_no", "qst_move_cattle_herd"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -3),
      (else_try),
        (eq, ":quest_no", "qst_escort_merchant_caravan"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -3),
      (else_try),
        (eq, ":quest_no", "qst_troublesome_bandits"),
        (assign, ":quest_return_penalty", -1),
        (assign, ":quest_expire_penalty", -2),
      #Other quests
      (else_try),
        (eq, ":quest_no", "qst_join_faction"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -3),
        (try_begin),
          (call_script, "script_get_number_of_hero_centers", "trp_player"),
          (gt, reg0, 0),
          (call_script, "script_change_player_relation_with_faction", "$g_invite_faction", -10),
        (try_end),


        (try_begin), #if the vassalage is part of a surrender option, then the faction returns to a state of war
          (quest_slot_eq, "qst_join_faction", slot_quest_failure_consequence, 1),
          (call_script, "script_diplomacy_start_war_between_kingdoms", "fac_player_supporters_faction", "$g_invite_faction", 0),
          (call_script, "script_change_player_honor", -5),
          (quest_set_slot, "qst_join_faction", slot_quest_failure_consequence, 0),
        (try_end),


        (assign, "$g_invite_faction", 0),
        (assign, "$g_invite_faction_lord", 0),
        (assign, "$g_invite_offered_center", 0),
      (else_try),
        (eq, ":quest_no", "qst_eliminate_bandits_infesting_village"),
        (assign, ":quest_return_penalty", -3),
        (assign, ":quest_expire_penalty", -3),
      (else_try),
        (ge, ":quest_no", "qst_resolve_dispute"),
        (assign, ":authority_loss", -2),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", 0),
      (else_try),
        (ge, ":quest_no", "qst_consult_with_minister"),
        (assign, ":authority_loss", -2),
        (assign, ":quest_return_penalty", 0),
        (assign, ":quest_expire_penalty", 0),
      (try_end),

      (try_begin),
        (gt, ":abort_type", 0),
        (lt, ":quest_no", "qst_resolve_dispute"),

        (quest_get_slot, ":quest_giver", ":quest_no", slot_quest_giver_troop),
        (assign, ":relation_penalty", ":quest_return_penalty"),
        (try_begin),
          (eq, ":abort_type", 2),
          (assign, ":relation_penalty", ":quest_expire_penalty"),
        (try_end),
        (try_begin),
          (this_or_next|is_between, ":quest_giver", village_elders_begin, village_elders_end),
          (this_or_next|eq, ":quest_no", "qst_eliminate_bandits_infesting_village"), #dckplmc
          (is_between, ":quest_giver", mayors_begin, mayors_end),
          (quest_get_slot, ":quest_giver_center", ":quest_no", slot_quest_giver_center),
          (call_script, "script_change_player_relation_with_center", ":quest_giver_center", ":relation_penalty"),
        (else_try),
          (call_script, "script_change_player_relation_with_troop", ":quest_giver", ":relation_penalty"),
        (try_end),
      (try_end),

      (fail_quest, ":quest_no"),

#NPC companion changes begin
      (try_begin),
        (gt, ":abort_type", 0),
		(neq, ":quest_no", "qst_consult_with_minister"),
		(neq, ":quest_no", "qst_resolve_dispute"),
		(neq, ":quest_no", "qst_visit_lady"),
		(neq, ":quest_no", "qst_formal_marriage_proposal"),
		(neq, ":quest_no", "qst_duel_courtship_rival"),
		(neq, ":quest_no", "qst_follow_army"),
		(neq, ":quest_no", "qst_denounce_lord"),
		(neq, ":quest_no", "qst_intrigue_against_lord"),
		(neq, ":quest_no", "qst_offer_gift"),
		(neq, ":quest_no", "qst_organize_feast"),

        (call_script, "script_objectionable_action", tmt_honest, "str_fail_quest"),
      (try_end),
#NPC companion changes end

	  (try_begin),
		(eq, ":quest_no", "qst_resolve_dispute"),
		##diplomacy start+
		#add support for "spouse of leader" arrangements
		#(faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
		(faction_get_slot, ":leader", "$players_kingdom", slot_faction_leader),#added
		(ge, ":leader", 0),
		(this_or_next|troop_slot_eq, ":leader", slot_troop_spouse, "trp_player"),
		(this_or_next|troop_slot_eq, "trp_player", slot_troop_spouse, ":leader"),
                   (eq, ":leader", "trp_player"),
		(call_script, "script_change_player_right_to_rule", ":authority_loss"),#<- unaltered
		#add support for promoted kingdom ladies
		(try_for_range, ":lord", heroes_begin, heroes_end),#<- changed active_npcs to heroes
			(this_or_next|troop_slot_eq, ":lord", slot_troop_occupation, slto_kingdom_hero),
				(is_between, ":lord", active_npcs_begin, active_npcs_end),
			#exempt retired/exiled/dead lords
			(neg|troop_slot_ge, ":lord", slot_troop_occupation, slto_retirement),
			(store_faction_of_troop, ":lord_faction", ":lord"),#<- unaltered
			(this_or_next|eq, ":lord_faction", "$players_kingdom"),#added for "spouse of leader" arrangements
		##diplomacy end+
			(eq, ":lord_faction", "fac_player_supporters_faction"),
			(call_script, "script_troop_change_relation_with_troop", ":lord", "trp_player", ":authority_loss"),
	    (try_end),
	  (try_end),


	  (try_begin),
		(eq, ":quest_no", "qst_organize_feast"),
		(call_script, "script_add_notification_menu", "mnu_notification_feast_quest_expired", 0, 0),
	  (try_end),


      (call_script, "script_end_quest", ":quest_no"),
  ]),


##  # script_event_center_captured
##  # Input: arg1 = center_no, arg2 = old_faction_no
##  # Output: none
##  ("event_center_captured",
##    [
##      #      (store_script_param_1, ":center_no"),
##      #       (store_script_param_2, ":old_faction_no"),
##      #       (store_faction_of_party, ":faction_no"),
##
##      (try_begin),
##        (check_quest_active, "qst_deliver_message"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_escort_lady"),
##        (quest_slot_eq, "qst_escort_lady", slot_quest_target_center, ":center_no"),
##        (call_script, "script_abort_quest", "qst_escort_lady"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_rescue_lady_under_siege"),
##        (quest_slot_eq, "qst_rescue_lady_under_siege", slot_quest_target_center, ":center_no"),
##        (quest_slot_eq, "qst_rescue_lady_under_siege", slot_quest_current_state, 0),
##        (call_script, "script_abort_quest", "qst_rescue_lady_under_siege", 1),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_deliver_message_to_lover"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_deliver_message_to_enemy_lord"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_bring_prisoners_to_enemy"),
##        (quest_slot_eq, "qst_bring_prisoners_to_enemy", slot_quest_target_center, ":center_no"),
##        (neg|check_quest_succeeded, "qst_bring_prisoners_to_enemy"),
##        (call_script, "script_abort_quest", "qst_bring_prisoners_to_enemy"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_bring_reinforcements_to_siege"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_deliver_supply_to_center_under_siege"),
##        (quest_slot_eq, "qst_deliver_supply_to_center_under_siege", slot_quest_target_center, ":center_no"),
##        (call_script, "script_abort_quest", "qst_deliver_supply_to_center_under_siege", 1),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_raise_troops"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_capture_messenger"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_bring_back_deserters"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_kill_local_merchant"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_bring_back_runaway_serfs"),
##        (quest_slot_eq, "qst_bring_back_runaway_serfs", slot_quest_object_center, ":center_no"),
##        (neg|check_quest_succeeded, "qst_bring_back_runaway_serfs"),
##        (neg|check_quest_failed, "qst_bring_back_runaway_serfs"),
##        (call_script, "script_abort_quest", "qst_bring_back_runaway_serfs"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_follow_spy"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_capture_enemy_hero"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_lend_companion"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_capture_conspirators"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_defend_nobles_against_peasants"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_incriminate_loyal_commander"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_hunt_down_raiders"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_capture_prisoners"),
##      (try_end),
##      #Enemy lord quests
##      (try_begin),
##        (check_quest_active, "qst_lend_surgeon"),
##      (try_end),
##      #Kingdom lady quests
##      (try_begin),
##        (check_quest_active, "qst_rescue_lord_by_replace"),
##        (quest_get_slot, ":quest_target_troop", "qst_rescue_lord_by_replace", slot_quest_target_troop),
##        (troop_slot_eq, ":quest_target_troop", slot_troop_is_prisoner, 0),
##        (neg|check_quest_succeeded, "qst_rescue_lord_by_replace"),
##        (call_script, "script_abort_quest", "qst_rescue_lord_by_replace"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_deliver_message_to_prisoner_lord"),
##      (try_end),
##      (try_begin),
##        (check_quest_active, "qst_duel_for_lady"),
##      (try_end),
##  ]),

  # script_cf_is_quest_troop
  # Input: arg1 = troop_no
  # Output: none (can fail)
  ("cf_is_quest_troop",
    [
      (store_script_param_1, ":troop_no"),
      (assign, ":is_quest_troop", 0),
      (try_for_range, ":cur_quest", all_quests_begin, all_quests_end),
        (check_quest_active, ":cur_quest"),
        (quest_get_slot, ":quest_troop_1", ":cur_quest", slot_quest_target_troop),
        (quest_get_slot, ":quest_troop_2", ":cur_quest", slot_quest_object_troop),
        (quest_get_slot, ":quest_troop_3", ":cur_quest", slot_quest_giver_troop),
        (this_or_next|eq, ":quest_troop_1", ":troop_no"),
        (this_or_next|eq, ":quest_troop_2", ":troop_no"),
        (eq, ":quest_troop_3", ":troop_no"),
        (assign, ":is_quest_troop", 1),
      (try_end),
      (eq, ":is_quest_troop", 1),
  ]),


##  # script_calculate_team_strength
##  # Input: arg1 = team_no
##  # Output: strength
##  ("calculate_team_strength",
##    [
##      (store_script_param_1, ":team_no"),
##      (assign, ":total_strength", 0),
##      (try_for_agents, ":cur_agent"),
##        (agent_get_team, ":agent_team", ":cur_agent"),
##        (eq, ":team_no", ":agent_team"),
##        (agent_is_human, ":cur_agent"),
##        (agent_is_alive, ":cur_agent"),
##
##        (agent_get_troop_id, ":cur_troop", ":cur_agent"),
##        (store_character_level, ":cur_level", ":cur_troop"),
##        (val_add, ":cur_level", 5),
##        (try_begin),
##          (troop_is_hero, ":cur_troop"),
##          (val_add, ":cur_level", 5),
##        (try_end),
##        (val_add, ":total_strength", ":cur_level"),
##      (try_end),
##      (assign, reg0, ":total_strength"),
##  ]),

  # script_check_friendly_kills
  # Input: none
  # Output: none (changes the morale of the player's party)
  ("check_friendly_kills",
    [(get_player_agent_own_troop_kill_count, ":count"),
     (try_begin),
       (neq, "$g_player_current_own_troop_kills", ":count"),
       (val_sub, ":count", "$g_player_current_own_troop_kills"),
       (val_add, "$g_player_current_own_troop_kills", ":count"),
       (val_mul, ":count", -1),
       (call_script, "script_change_player_party_morale", ":count"),
     (try_end),
   ]),

  # script_simulate_retreat
  # Input: arg1 = players_side_damage, arg2 = enemy_side_damage, arg3 = continue_battle s5 = title_string
  # Output: none
  ("simulate_retreat",
    [
      (call_script, "script_music_set_situation_with_culture", mtf_sit_killed),
      (set_show_messages, 0),
      (store_script_param, ":players_side_damage", 1),
      (store_script_param, ":enemy_side_damage", 2),
      (store_script_param, ":continue_battle", 3),

      (assign, ":players_side_strength", 0),
      (assign, ":enemy_side_strength", 0),

      (assign, ":do_calculate", 1),
      (try_begin),
        (try_for_agents, ":cur_agent"),
          (agent_is_human, ":cur_agent"),
          (agent_is_alive, ":cur_agent"),
          (agent_set_slot, ":cur_agent", slot_agent_is_alive_before_retreat, 1),#needed for simulation

          (agent_get_troop_id, ":cur_troop", ":cur_agent"),
          (store_character_level, ":cur_level", ":cur_troop"),
          (val_add, ":cur_level", 5),
          (try_begin),
            (troop_is_hero, ":cur_troop"),
            (val_add, ":cur_level", 5),
          (try_end),
          (try_begin),
            (agent_is_ally, ":cur_agent"),
            (val_add, ":players_side_strength", ":cur_level"),
          (else_try),
            (val_add, ":enemy_side_strength", ":cur_level"),
          (try_end),
        (try_end),
        (eq, "$pin_player_fallen", 0),
        (lt, ":enemy_side_strength", ":players_side_strength"),
        (eq, ":continue_battle", 1),
        (assign, ":do_calculate", 0),
      (try_end),

      (try_begin),
        (eq, ":do_calculate", 1),

        (assign, "$g_last_mission_player_damage", 0),
        (party_clear, "p_temp_party"),
        (party_clear, "p_temp_party_2"),
        (call_script, "script_simulate_battle_with_agents_aux", 0, ":players_side_damage"),
        (call_script, "script_simulate_battle_with_agents_aux", 1, ":enemy_side_damage"),

        (assign, ":display_casualties", 0),

        (try_begin),
          (gt, "$g_last_mission_player_damage", 0),
          (assign, ":display_casualties", 1),
          (assign, reg1, "$g_last_mission_player_damage"),
          (str_store_string, s12, "str_casualty_display_hp"),
        (else_try),
          (str_clear, s12),
        (try_end),

        (call_script, "script_print_casualties_to_s0", "p_temp_party", 1),
        (try_begin),
          (party_get_num_companion_stacks, ":num_stacks", "p_temp_party"),
          (gt, ":num_stacks", 0),
          (assign, ":display_casualties", 1),
        (try_end),
        (str_store_string_reg, s10, s0),

        (call_script, "script_print_casualties_to_s0", "p_temp_party_2", 1),
        (try_begin),
          (party_get_num_companion_stacks, ":num_stacks", "p_temp_party_2"),
          (gt, ":num_stacks", 0),
          (assign, ":display_casualties", 1),
        (try_end),
        (str_store_string_reg, s11, s0),
        (try_begin),
          (eq, ":display_casualties", 1),
          (dialog_box,"str_casualty_display", s5),
        (try_end),
      (try_end),
      (set_show_messages, 1),

      #Calculating morale penalty (can be between 0-30)
      (assign, ":ally_casualties", 0),
      (assign, ":enemy_casualties", 0),
      (assign, ":total_allies", 0),

      (try_for_agents, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (try_begin),
          (agent_is_ally, ":cur_agent"),
          (val_add, ":total_allies", 1),
          (try_begin),
            (neg|agent_is_alive, ":cur_agent"),
            (val_add, ":ally_casualties", 1),
          (try_end),
        (else_try),
          (neg|agent_is_alive, ":cur_agent"),
          (val_add, ":enemy_casualties", 1),
        (try_end),
      (try_end),
      (store_add, ":total_casualties", ":ally_casualties", ":enemy_casualties"),
      (try_begin),
        (gt, ":total_casualties", 0),
        (store_mul, ":morale_adder", ":ally_casualties", 100),
        (val_div, ":morale_adder", ":total_casualties"),
        (val_mul, ":morale_adder", ":ally_casualties"),
        (val_div, ":morale_adder", ":total_allies"),
        (val_mul, ":morale_adder", -30),
        (val_div, ":morale_adder", 100),
        (call_script, "script_change_player_party_morale", ":morale_adder"),
      (try_end),
  ]),



  # script_simulate_battle_with_agents_aux
  # For internal use only
  # Input: arg1 = attacker_side (0 = ally, 1 = enemy), arg2 = damage amount
  # Output: none
  ("simulate_battle_with_agents_aux",
    [
      (store_script_param_1, ":attacker_side"),
      (store_script_param_2, ":damage"),

      (get_player_agent_no, ":player_agent"),
      (try_for_agents, ":cur_agent"),
        (neq, ":player_agent", ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        #do not check agent_is_alive, check slot_agent_is_alive_before_retreat instead, so that dead agents can still hit enemies
        (agent_slot_eq, ":cur_agent", slot_agent_is_alive_before_retreat, 1),
        (try_begin),
          (agent_is_ally, ":cur_agent"),
          (assign, ":cur_agents_side", 0),
        (else_try),
          (assign, ":cur_agents_side", 1),
        (try_end),
        (eq, ":cur_agents_side", ":attacker_side"),
        (agent_get_position, pos2, ":cur_agent"),
        (assign, ":closest_agent", -1),
        (assign, ":min_distance", 100000),
        (try_for_agents, ":cur_agent_2"),
          (agent_is_human, ":cur_agent_2"),
          (agent_is_alive, ":cur_agent_2"),
          (try_begin),
            (agent_is_ally, ":cur_agent_2"),
            (assign, ":cur_agents_side_2", 0),
          (else_try),
            (assign, ":cur_agents_side_2", 1),
          (try_end),
          (this_or_next|neq, ":cur_agent_2", ":player_agent"),
          (eq, "$pin_player_fallen", 0),
          (neq, ":attacker_side", ":cur_agents_side_2"),
          (agent_get_position, pos3, ":cur_agent_2"),
          (get_distance_between_positions, ":cur_distance", pos2, pos3),
          (lt, ":cur_distance", ":min_distance"),
          (assign, ":min_distance", ":cur_distance"),
          (assign, ":closest_agent", ":cur_agent_2"),
        (try_end),
        (ge, ":closest_agent", 0),
        #Fight
        (agent_get_class, ":agent_class", ":cur_agent"),
        (assign, ":agents_speed", 1),
        (assign, ":agents_additional_hit", 0),
        (try_begin),
          (eq, ":agent_class", grc_archers),
          (assign, ":agents_additional_hit", 2),
        (else_try),
          (eq, ":agent_class", grc_cavalry),
          (assign, ":agents_speed", 2),
        (try_end),
        (agent_get_class, ":agent_class", ":closest_agent"),
        (assign, ":agents_speed_2", 1),
        (try_begin),
          (eq, ":agent_class", grc_cavalry),
          (assign, ":agents_speed_2", 2),
        (try_end),
        (assign, ":agents_hit", 18000),
        (val_add, ":min_distance", 3000),
        (val_div, ":agents_hit", ":min_distance"),
        (val_mul, ":agents_hit", 2),# max 10, min 2 hits within 150 meters

        (val_mul, ":agents_hit", ":agents_speed"),
        (val_div, ":agents_hit", ":agents_speed_2"),
        (val_add, ":agents_hit", ":agents_additional_hit"),

        (assign, ":cur_damage", ":damage"),
        (agent_get_troop_id, ":closest_troop", ":closest_agent"),
        (agent_get_troop_id, ":cur_troop", ":cur_agent"),
        (store_character_level, ":closest_level", ":closest_troop"),
        (store_character_level, ":cur_level", ":cur_troop"),
        (store_sub, ":level_dif", ":cur_level", ":closest_level"),
        (val_div, ":level_dif", 5),
        (val_add, ":cur_damage", ":level_dif"),

        (try_begin),
          (eq, ":closest_agent", ":player_agent"),
          (val_div, ":cur_damage", 2),
          (store_agent_hit_points, ":init_player_hit_points", ":player_agent", 1),
        (try_end),

        (try_for_range, ":unused", 0, ":agents_hit"),
          (store_random_in_range, ":random_damage", 0, 100),
          (lt, ":random_damage", ":cur_damage"),
          (agent_deliver_damage_to_agent, ":cur_agent", ":closest_agent"),
        (try_end),

        (try_begin),
          (eq, ":closest_agent", ":player_agent"),
          (store_agent_hit_points, ":final_player_hit_points", ":player_agent", 1),
          (store_sub, ":hit_points_difference", ":init_player_hit_points", ":final_player_hit_points"),
          (val_add, "$g_last_mission_player_damage", ":hit_points_difference"),
        (try_end),

        (neg|agent_is_alive, ":closest_agent"),
        (try_begin),
          (eq, ":attacker_side", 1),
          (party_add_members, "p_temp_party", ":closest_troop", 1),
          (try_begin),
            (agent_is_wounded, ":closest_agent"),
            (party_wound_members, "p_temp_party", ":closest_troop", 1),
          (try_end),
        (else_try),
          (party_add_members, "p_temp_party_2", ":closest_troop", 1),
          (try_begin),
            (agent_is_wounded, ":closest_agent"),
            (party_wound_members, "p_temp_party_2", ":closest_troop", 1),
          (try_end),
        (try_end),
      (try_end),
  ]),


  # script_map_get_random_position_around_position_within_range
  # Input: arg1 = minimum_distance in km, arg2 = maximum_distance in km, pos1 = origin position
  # Output: pos2 = result position
  ("map_get_random_position_around_position_within_range",
    [
      (store_script_param_1, ":min_distance"),
      (store_script_param_2, ":max_distance"),
      (val_mul, ":min_distance", 100),
      (assign, ":continue", 1),
      (try_for_range, ":unused", 0, 20),
        (eq, ":continue", 1),
        (map_get_random_position_around_position, pos2, pos1, ":max_distance"),
        (get_distance_between_positions, ":distance", pos2, pos1),
        (ge, ":distance", ":min_distance"),
        (assign, ":continue", 0),
      (try_end),
  ]),


  # script_get_number_of_unclaimed_centers_by_player
  # Input: none
  # Output: reg0 = number of unclaimed centers, reg1 = last unclaimed center_no
  ("get_number_of_unclaimed_centers_by_player",
    [
      (assign, ":unclaimed_centers", 0),
      (assign, reg1, -1),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (store_faction_of_party, ":faction_no", ":center_no"),
        (eq, ":faction_no", "fac_player_supporters_faction"),
        (party_slot_eq, ":center_no", slot_town_claimed_by_player, 0),
        (party_get_num_companion_stacks, ":num_stacks", ":center_no"),
        (ge, ":num_stacks", 1), #castle is garrisoned
        (assign, reg1, ":center_no"),
        (val_add, ":unclaimed_centers", 1),
      (try_end),
      (assign, reg0, ":unclaimed_centers"),
  ]),

  # script_troop_count_number_of_enemy_troops
  # Input: arg1 = troop_no
  # Output: reg0 = number_of_enemy_troops
#  ("troop_count_number_of_enemy_troops",
#    [
#      (store_script_param_1, ":troop_no"),
#      (assign, ":enemy_count", 0),
#      (try_for_range, ":i_enemy_slot", slot_troop_enemies_begin, slot_troop_enemies_end),
#        (troop_slot_ge, ":troop_no", ":i_enemy_slot", 1),
#        (val_add, ":enemy_count", 1),
#      (try_end),
#      (assign, reg0, ":enemy_count"),
#  ]),


  # script_cf_troop_check_troop_is_enemy
  # Input: arg1 = troop_no, arg2 = checked_troop_no
  # Output: none (Can fail)
  ("cf_troop_check_troop_is_enemy",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":checked_troop_no"),
	  (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":checked_troop_no"),
	  (lt, reg0, -10),
 ]),


  # script_troop_get_leaded_center_with_index
  # Input: arg1 = troop_no, arg2 = center index within range between zero and the number of centers that troop owns
  # Output: reg0 = center_no
  ("troop_get_leaded_center_with_index",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":random_center"),
      (assign, ":result", -1),
      (assign, ":center_count", 0),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (eq, ":result", -1),
        (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
        (val_add, ":center_count", 1),
        (gt, ":center_count", ":random_center"),
        (assign, ":result", ":center_no"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

  # script_cf_troop_get_random_leaded_walled_center_with_less_strength_priority
  # Input: arg1 = troop_no, arg2 = preferred_center_no
  # Output: reg0 = center_no (Can fail)
  ("cf_troop_get_random_leaded_walled_center_with_less_strength_priority",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":preferred_center_no", 2),

      (assign, ":num_centers", 0),
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
        (party_slot_eq, ":center_no", slot_center_is_besieged_by, -1),
        (val_add, ":num_centers", 1),
        (try_begin),
          (eq, ":center_no", ":preferred_center_no"),
          (val_add, ":num_centers", 99),
        (try_end),
##        (call_script, "script_party_calculate_regular_strength", ":center_no"),
##        (assign, ":strength", reg0),
##        (lt, ":strength", 80),
##        (store_sub, ":strength", 100, ":strength"),
##        (val_div, ":strength", 20),
##        (val_add, ":num_centers", ":strength"),
      (try_end),
      (gt, ":num_centers", 0),
      (store_random_in_range, ":random_center", 0, ":num_centers"),
      (assign, ":result", -1),
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (eq, ":result", -1),
        (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
        (party_slot_eq, ":center_no", slot_center_is_besieged_by, -1),
        (val_sub, ":random_center", 1),
        (try_begin),
          (eq, ":center_no", ":preferred_center_no"),
          (val_sub, ":random_center", 99),
        (try_end),
##        (try_begin),
##          (call_script, "script_party_calculate_regular_strength", ":center_no"),
##          (assign, ":strength", reg0),
##          (lt, ":strength", 80),
##          (store_sub, ":strength", 100, ":strength"),
##          (val_div, ":strength", 20),
##          (val_sub, ":random_center", ":strength"),
##        (try_end),
        (lt, ":random_center", 0),
        (assign, ":result", ":center_no"),
      (try_end),
      (assign, reg0, ":result"),
  ]),

  # script_cf_troop_get_random_leaded_town_or_village_except_center
  # Input: arg1 = troop_no, arg2 = except_center_no
  # Output: reg0 = center_no (Can fail)
  #SB : only called from checking qst_collect_taxes, apply condition as follows
  ## not close to arg2 (Native only checks if quest giver is inside town)
  ## not under siege/raided (arg3)
  ("cf_troop_get_random_leaded_town_or_village_except_center",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":except_center_no", 2), #unused I guess
      (store_script_param, ":center_state", 3), #pass in svs_normal

	  #SB : re-use except_center_no as a check
	  (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
	  (try_begin),
	    (le, ":party_no", 0),
		(assign, ":party_no", ":except_center_no"),
	  (try_end),
      (assign, ":num_centers", 0),
      (try_for_range, ":center_no", centers_begin, centers_end),

	    # (party_set_slot, ":center_no", slot_party_temp_slot_1, 0),
        (neg|party_slot_eq, ":center_no", slot_party_type, spt_castle),
        (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
        (neq, ":center_no", ":except_center_no"),
		(assign, ":dist", 9999),
		(try_begin),
		  (gt, ":party_no", 0),
		  (store_distance_to_party_from_party, ":dist", ":center_no", ":party_no"),
		(try_end),
		(gt, ":dist", 15), #can't be within a day's travel
		(party_slot_eq, ":center_no", slot_village_state, ":center_state"),
		# (party_set_slot, ":center_no", slot_party_temp_slot_1, 1),
		(troop_set_slot, "trp_random_town_sequence", ":num_centers", ":center_no"),
        (val_add, ":num_centers", 1),
      (try_end),

      (gt, ":num_centers", 0),
      (store_random_in_range, ":random_center", 0, ":num_centers"),
	  (troop_get_slot, reg0, "trp_random_town_sequence", ":random_center"),
      # (assign, ":end_cond", centers_end),
      # (try_for_range, ":center_no", centers_begin, ":end_cond"),
        # (neg|party_slot_eq, ":center_no", slot_party_type, spt_castle),
        # (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
        # (neq, ":center_no", ":except_center_no"),
        # (val_sub, ":random_center", 1),
        # (lt, ":random_center", 0),
        # (assign, ":target_center", ":center_no"),
        # (assign, ":end_cond", 0),
      # (try_end),
      # (assign, reg0, ":target_center"),
  ]),

  # script_troop_write_owned_centers_to_s2
  # Input: arg1 = troop_no
  # Output: none
  ("troop_write_owned_centers_to_s2",
    [
      (store_script_param_1, ":troop_no"),

      (call_script, "script_get_number_of_hero_centers", ":troop_no"),
      (assign, ":no_centers", reg0),

      (str_store_troop_name, s5, ":troop_no"),

      (try_begin),
        (gt, ":no_centers", 1),
        (try_for_range, ":i_center", 1, ":no_centers"),
          (call_script, "script_troop_get_leaded_center_with_index", ":troop_no", ":i_center"),
          (str_store_party_name_link, s50, reg0),
          (try_begin),
            (eq, ":i_center", 1),
            (call_script, "script_troop_get_leaded_center_with_index", ":troop_no", 0),
            (str_store_party_name_link, s51, reg0),
            (str_store_string, s51, "str_s50_and_s51"),
          (else_try),
            (str_store_string, s51, "str_s50_comma_s51"),
          (try_end),
        (try_end),
        (str_store_string, s2, "str_s5_is_the_ruler_of_s51"),
      (else_try),
        (eq, ":no_centers", 1),
        (call_script, "script_troop_get_leaded_center_with_index", ":troop_no", 0),
        (str_store_party_name_link, s51, reg0),
        (str_store_string, s2, "str_s5_is_the_ruler_of_s51"),
      (else_try),
        (store_troop_faction, ":faction_no", ":troop_no"),
        (str_store_faction_name_link, s6, ":faction_no"),
        ##diplomacy start+ make gender-correct
        #(troop_get_type, reg4, ":troop_no"),
        (assign, ":save_reg4", reg4),
        (call_script, "script_dplmc_store_troop_is_female_reg", ":troop_no", 4),
        (str_store_string, s2, "str_s5_is_a_nobleman_of_s6"),
        (assign, reg4, ":save_reg4"),
        ##diplomacy end+
      (try_end),
  ]),

  ("troop_write_family_relations_to_s1",
    [
    (str_clear, s1),
    #redo, possibly using base from update_troop_notes
    ]),

   # script_write_family_relation_as_s3s_s2_to_s4

  # Inputs: arg1 = troop_no, arg2 = family_no (valid slot no after slot_troop_family_begin)
  # Outputs: s11 = what troop_1 is to troop_2, reg0 = strength of relationship. Normally, "$g_talk_troop" should be troop_2

  ("troop_get_family_relation_to_troop",
    [
    (store_script_param_1, ":troop_1"),
    (store_script_param_2, ":troop_2"),

    ##diplomacy start+ use gender script
    #(troop_get_type, ":gender_1", ":troop_1"),
	(call_script, "script_dplmc_store_troop_is_female", ":troop_1"),
	(assign, ":gender_1", reg0),
	##diplomacy end+
	(assign, ":relation_strength", 0),

    (troop_get_slot, ":spouse_of_1", ":troop_1", slot_troop_spouse),
    (troop_get_slot, ":spouse_of_2", ":troop_2", slot_troop_spouse),

	(try_begin),
		(gt, ":spouse_of_1", -1),
		(troop_get_slot, ":father_of_spouse_of_1", ":spouse_of_1", slot_troop_father),
	(else_try),
		(assign, ":father_of_spouse_of_1", -1),
	(try_end),

	(try_begin),
		(gt, ":spouse_of_2", -1),
		(troop_get_slot, ":father_of_spouse_of_2", ":spouse_of_2", slot_troop_father),
	(else_try),
		(assign, ":father_of_spouse_of_2", -1),
	(try_end),

	(try_begin),
		(gt, ":spouse_of_2", -1),
		(troop_get_slot, ":mother_of_spouse_of_2", ":spouse_of_2", slot_troop_mother),
	(else_try),
		(assign, ":mother_of_spouse_of_2", -1),
	(try_end),

    (troop_get_slot, ":father_of_1", ":troop_1", slot_troop_father),
    (troop_get_slot, ":father_of_2", ":troop_2", slot_troop_father),

	#For the sake of simplicity, we can assume that all male aristocrats in prior generations either married commoners or procured their brides from the Old Country, thus discounting intermarriage
    (troop_get_slot, ":mother_of_1", ":troop_1", slot_troop_mother),
    (troop_get_slot, ":mother_of_2", ":troop_2", slot_troop_mother),

    ##diplomacy start+
	#Fix a native bug where daughters are their own mothers
        #(fixed in this mod, but still affects old saved games)
        #REMOVED - Instead this occurs once in simple triggers

	##Adding paternal grandmother (begin mostly-unaltered section)
	(try_begin),
		(this_or_next|eq, ":father_of_1", "trp_player"),#dplmc+ added
		(is_between, ":father_of_1", companions_begin, kingdom_ladies_end),
		(troop_get_slot, ":paternal_grandfather_of_1", ":father_of_1", slot_troop_father),
		(troop_get_slot, ":paternal_grandmother_of_1", ":father_of_1", slot_troop_mother),#added
	(else_try),
		(assign, ":paternal_grandfather_of_1", -1),
		(assign, ":paternal_grandmother_of_1", -1),#added
	(try_end),

	(try_begin),
		(this_or_next|eq, ":father_of_2", "trp_player"),#dplmc+ added
		(is_between, ":father_of_2", companions_begin, kingdom_ladies_end),
		(troop_get_slot, ":paternal_grandfather_of_2", ":father_of_2", slot_troop_father),
		(troop_get_slot, ":paternal_grandmother_of_2", ":father_of_2", slot_troop_mother),#added
	(else_try),
		(assign, ":paternal_grandfather_of_2", -1),
		(assign, ":paternal_grandmother_of_2", -1),#added
	(try_end),
	#(end mostly-unaltered section)

	##Adding maternal grandfather and maternal grandmother
	(try_begin),
		(this_or_next|eq, ":mother_of_1", "trp_player"),#dplmc+ added
		(is_between, ":mother_of_1", companions_begin, kingdom_ladies_end),
		(troop_get_slot, ":maternal_grandfather_of_1", ":mother_of_1", slot_troop_father),
		(troop_get_slot, ":maternal_grandmother_of_1", ":mother_of_1", slot_troop_mother),
	(else_try),
		(assign, ":maternal_grandfather_of_1", -1),
		(assign, ":maternal_grandmother_of_1", -1),
	(try_end),

	(try_begin),
		(this_or_next|eq, ":mother_of_2", "trp_player"),#dplmc+ added
		(is_between, ":mother_of_2", companions_begin, kingdom_ladies_end),
		(troop_get_slot, ":maternal_grandfather_of_2", ":mother_of_2", slot_troop_father),
		(troop_get_slot, ":maternal_grandmother_of_2", ":mother_of_2", slot_troop_mother),
	(else_try),
		(assign, ":maternal_grandfather_of_2", -1),
		(assign, ":maternal_grandmother_of_2", -1),
	(try_end),
	##diplomacy end+

    (troop_get_slot, ":guardian_of_1", ":troop_1", slot_troop_guardian),
    (troop_get_slot, ":guardian_of_2", ":troop_2", slot_troop_guardian),

	(str_store_string, s11, "str_no_relation"),

	(try_begin),
	  (eq, ":troop_1", ":troop_2"),
	  #self
	(else_try),
	  ##diplomacy start+
      (this_or_next|eq, ":spouse_of_2", ":troop_1"),#polygamy helper
	  ##diplomacy end+
	  (eq, ":spouse_of_1", ":troop_2"),
	  (assign, ":relation_strength", 20),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_wife"),
	  (else_try),
	    (str_store_string, s11, "str_husband"),
	  (try_end),
	(else_try),
	  (eq, ":father_of_2", ":troop_1"),
	  (assign, ":relation_strength", 15),
	  (str_store_string, s11, "str_father"),
	(else_try),
	  (eq, ":mother_of_2", ":troop_1"),
	  (assign, ":relation_strength", 15),
	  (str_store_string, s11, "str_mother"),
	(else_try),
	  (this_or_next|eq, ":father_of_1", ":troop_2"),
	  (eq, ":mother_of_1", ":troop_2"),
	  (assign, ":relation_strength", 15),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_daughter"),
	  (else_try),
	    (str_store_string, s11, "str_son"),
	  (try_end),
	##diplomacy start+
	(else_try),
	   #Check for half-siblings: sharing a father
	   (neq, ":father_of_1", -1),
	   (eq, ":father_of_1", ":father_of_2"),
	   (neq, ":mother_of_1", ":mother_of_2"),
	   (assign, ":relation_strength", 10),
	   (try_begin),
	     (eq, ":gender_1", tf_female),
	     (str_store_string, s11, "str_dplmc_half_sister"),
	   (else_try),
	     (str_store_string, s11, "str_dplmc_half_brother"),
	   (try_end),
   (else_try),
	   #Check for half-siblings: sharing a mother
	   (neq, ":mother_of_1", -1),
	   (eq, ":mother_of_1", ":mother_of_2"),
	   (neq, ":father_of_1", ":father_of_2"),
	   (assign, ":relation_strength", 10),
	   (try_begin),
	     (eq, ":gender_1", tf_female),
	     (str_store_string, s11, "str_dplmc_half_sister"),
	   (else_try),
	     (str_store_string, s11, "str_dplmc_half_brother"),
	   (try_end),
	##diplomacy end+
	(else_try),
	  #(gt, ":father_of_1", -1), #necessary, as some lords do not have the father registered #dplmc+ replaced
	  (neq, ":father_of_1", -1), #dplmc+ added
	  (eq, ":father_of_1", ":father_of_2"),
	  (assign, ":relation_strength", 10),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_sister"),
	  (else_try),
	    (str_store_string, s11, "str_brother"),
	  (try_end),
	(else_try),
	  (eq, ":guardian_of_2", ":troop_1"),
	  (assign, ":relation_strength", 10),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_sister"),
	  (else_try),
	    (str_store_string, s11, "str_brother"),
	  (try_end),
	(else_try),
	  (eq, ":guardian_of_1", ":troop_2"),
	  (assign, ":relation_strength", 10),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_sister"),
	  (else_try),
	    (str_store_string, s11, "str_brother"),
	  (try_end),
	##diplomacy start+
    (else_try),#polygamy, between two people married to the same person
	   (neq, ":spouse_of_1", -1),
	   (eq, ":spouse_of_2", ":spouse_of_1"),
	   (assign, ":relation_strength", 10),
	   (try_begin),
	      (eq, ":gender_1", tf_female),
	      (str_store_string, s11, "str_dplmc_sister_wife"),
	   (else_try),
	      (str_store_string, s11, "str_dplmc_co_husband"),
	   (try_end),
	##diplomacy end+
	(else_try),
	  #(gt, ":paternal_grandfather_of_1", -1),#dplmc+ replaced
	  (neq, ":father_of_2", -1),#dplmc+ added
	  (this_or_next|eq, ":maternal_grandfather_of_1", ":father_of_2"),#dplmc+ added
	  (eq, ":paternal_grandfather_of_1", ":father_of_2"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_niece"),
	  (else_try),
	    (str_store_string, s11, "str_nephew"),
	  (try_end),
	##diplomacy start+: add niece/nephew through mother
	(else_try),
	  (neq, ":mother_of_2", -1),
  	  (this_or_next|eq, ":maternal_grandmother_of_1", ":mother_of_2"),
	  (eq, ":paternal_grandmother_of_1", ":mother_of_2"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_niece"),
	  (else_try),
	    (str_store_string, s11, "str_nephew"),
	  (try_end),
	##diplomacy end+
	(else_try), #specifically aunt and uncle by blood -- i assume that in a medieval society with lots of internal family conflicts, they would not include aunts and uncles by marriage
	  #(gt, ":paternal_grandfather_of_2", -1),#dplmc+ replaced
	  (neq, ":father_of_1", -1),#dplmc+ added
	  (this_or_next|eq, ":maternal_grandfather_of_2", ":father_of_1"),#dplmc+ added
	  (eq, ":paternal_grandfather_of_2", ":father_of_1"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_aunt"),
	  (else_try),
	    (str_store_string, s11, "str_uncle"),
	  (try_end),
	##diplomacy start+
	#blood uncles & blood aunts, continued (via mother)
	(else_try),
	  (neq, ":mother_of_1", -1),
	  (this_or_next|eq, ":maternal_grandmother_of_2", ":mother_of_1"),
	  (eq, ":paternal_grandmother_of_2", ":mother_of_1"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_aunt"),
	  (else_try),
	    (str_store_string, s11, "str_uncle"),
	  (try_end),
	##diplomacy end+
	(else_try),
	  #(gt, ":paternal_grandfather_of_1", 0),#dplmc+ replaced (why was this one "gt 0" but the previous "gt -1"?)
	  (neq, ":paternal_grandfather_of_1", -1),#dplmc+ added
	  (this_or_next|eq, ":maternal_grandfather_of_2", ":paternal_grandfather_of_1"),#dplmc+ added
	  (eq, ":paternal_grandfather_of_2", ":paternal_grandfather_of_1"),
	  (assign, ":relation_strength", 2),
	  (str_store_string, s11, "str_cousin"),
	##diplomacy start+
	#Add cousin via paternal grandmother or maternal grandparents
	(else_try),
	  (neq, ":maternal_grandfather_of_1", -1),
	  (this_or_next|eq, ":maternal_grandfather_of_2", ":maternal_grandfather_of_1"),
	  (eq, ":paternal_grandfather_of_2", ":maternal_grandfather_of_1"),
	  (assign, ":relation_strength", 2),
	  (str_store_string, s11, "str_cousin"),
	(else_try),
	  (neq, ":paternal_grandmother_of_1", -1),
	  (this_or_next|eq, ":maternal_grandmother_of_2", ":paternal_grandmother_of_1"),
	  (eq, ":paternal_grandmother_of_2", ":paternal_grandmother_of_1"),
	  (assign, ":relation_strength", 2),
	  (str_store_string, s11, "str_cousin"),
	(else_try),
	  (neq, ":maternal_grandmother_of_1", -1),
	  (this_or_next|eq, ":maternal_grandmother_of_2", ":maternal_grandmother_of_1"),
	  (eq, ":paternal_grandmother_of_2", ":maternal_grandmother_of_1"),
	  (assign, ":relation_strength", 2),
	  (str_store_string, s11, "str_cousin"),
	##diplomacy end+
   	(else_try),
   	  (eq, ":father_of_spouse_of_1", ":troop_2"),
   	  (assign, ":relation_strength", 5),
   	  (try_begin),
   	    (eq, ":gender_1", tf_female),
   	    (str_store_string, s11, "str_daughterinlaw"),
   	  (else_try),
   	    (str_store_string, s11, "str_soninlaw"),
   	  (try_end),
	(else_try),
	  (eq, ":father_of_spouse_of_2", ":troop_1"),
	  (assign, ":relation_strength", 5),
	  (str_store_string, s11, "str_fatherinlaw"),
	(else_try),
	  (eq, ":mother_of_spouse_of_2", ":troop_1"),
	  (neq, ":mother_of_spouse_of_2", "trp_player"), #May be necessary if mother for troops not set to -1
	  (assign, ":relation_strength", 5),
	  (str_store_string, s11, "str_motherinlaw"),

	(else_try),
	  #(gt, ":father_of_spouse_of_1", -1), #necessary #dplmc+ replaced
	  (neq, ":father_of_spouse_of_1", -1), #dplmc+ added
	  (eq, ":father_of_spouse_of_1", ":father_of_2"),
	  (assign, ":relation_strength", 5),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_sisterinlaw"),
	  (else_try),
	    (str_store_string, s11, "str_brotherinlaw"),
	  (try_end),
	(else_try),
	  #(gt, ":father_of_spouse_of_2", -1), #necessary #dplmc+ replaced
	  (neq, ":father_of_spouse_of_2", -1), #dplmc+ added
	  (eq, ":father_of_spouse_of_2", ":father_of_1"),
	  (assign, ":relation_strength", 5),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_sisterinlaw"),
	  (else_try),
	    (str_store_string, s11, "str_brotherinlaw"),
	  (try_end),
	(else_try),
#	  (gt, ":spouse_of_2", -1), #necessary to avoid bug #dplmc+ replaced
	  (neq, ":spouse_of_2", -1), #dplmc+ added
	  (troop_slot_eq, ":spouse_of_2", slot_troop_guardian, ":troop_1"),
	  (assign, ":relation_strength", 5),
	  (try_begin),
	    #(eq, ":gender_1", tf_female),#dplmc+ replaced
	    (eq, ":gender_1", tf_female),#dplmc+ added
	    (str_store_string, s11, "str_sisterinlaw"),
	  (else_try),
	    (str_store_string, s11, "str_brotherinlaw"),
	  (try_end),
	(else_try),
	  #(gt, ":spouse_of_1", -1), #necessary to avoid bug #dplmc+ replaced
	  (neq, ":spouse_of_1", -1), #dplmc+ added
	  (troop_slot_eq, ":spouse_of_1", slot_troop_guardian, ":troop_2"),
	  (assign, ":relation_strength", 5),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_sisterinlaw"),
	  (else_try),
	    (str_store_string, s11, "str_brotherinlaw"),
	  (try_end),
	(else_try),
	  #grandchild
	  (neq, ":troop_2", -1),
	   (this_or_next|eq, ":paternal_grandfather_of_1", ":troop_2"),
	   (this_or_next|eq, ":maternal_grandfather_of_1", ":troop_2"),
	   (this_or_next|eq, ":paternal_grandmother_of_1", ":troop_2"),
		   (eq, ":maternal_grandmother_of_1", ":troop_2"),
	   (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_dplmc_granddaughter"),
	  (else_try),
	    (str_store_string, s11, "str_dplmc_grandson"),
	  (try_end),
	(else_try),
	   #grandparent
	   (neq, ":troop_1", -1),
	   (this_or_next|eq, ":paternal_grandfather_of_2", ":troop_1"),
	   (this_or_next|eq, ":maternal_grandfather_of_2", ":troop_1"),
	   (this_or_next|eq, ":paternal_grandmother_of_2", ":troop_1"),
		   (eq, ":maternal_grandmother_of_2", ":troop_1"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (str_store_string, s11, "str_dplmc_grandmother"),
	  (else_try),
	    (str_store_string, s11, "str_dplmc_grandfather"),
	  (try_end),
	(try_end),

	##diplomacy start+
	##Add relations for rulers not already encoded
	(try_begin),
		(eq, ":relation_strength", 0),
		(neq, ":troop_1", ":troop_2"),
		(try_begin),
			#Lady Isolla of Suno's father King Esterich was King Harlaus's cousin,
			#making them first cousins once removed.  Assign a weight of "1"
			#to this (for reference, the lowest value normally given in Native is 2).
			(this_or_next|eq, ":troop_1", "trp_kingdom_1_lord"),
			    (eq, ":troop_1", "trp_kingdom_1_pretender"),
			(this_or_next|eq, ":troop_2", "trp_kingdom_1_lord"),
			    (eq, ":troop_2", "trp_kingdom_1_pretender"),
			(assign, ":relation_strength", 1),
			(str_store_string, s11, "str_cousin"),
		(else_try),
			#Prince Valdym's uncle was Regent Burelek, father of King Yaroglek,
			#making the two of them first cousins.
			(this_or_next|eq, ":troop_1", "trp_kingdom_2_lord"),
			    (eq, ":troop_1", "trp_kingdom_2_pretender"),
			(this_or_next|eq, ":troop_2", "trp_kingdom_2_lord"),
				(eq, ":troop_2", "trp_kingdom_2_pretender"),
			(assign, ":relation_strength", 2),
			(str_store_string, s11, "str_cousin"),
		(else_try),
			#Sanjar Khan and Dustum Khan were both sons of Janakir Khan
			#(although by different mothers) making them half-brothers.
			(this_or_next|eq, ":troop_1", "trp_kingdom_3_lord"),
			    (eq, ":troop_1", "trp_kingdom_3_pretender"),
			(this_or_next|eq, ":troop_2", "trp_kingdom_3_lord"),
				(eq, ":troop_2", "trp_kingdom_3_pretender"),
			(assign, ":relation_strength", 10),
			(str_store_string, s11, "str_dplmc_half_brother"),
			#Adjust their parentage to make this work automatically
			(try_begin),
		      	(troop_slot_eq, ":troop_1", slot_troop_father, -1),
				(troop_slot_eq, ":troop_2", slot_troop_father, -1),
				#Set their "father" slot to a number guaranteed not to have spurious collisions
				(store_mul, ":janakir_khan", "trp_kingdom_3_lord", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),#defined in module_constants.py
				(val_add, ":janakir_khan", DPLMC_VIRTUAL_RELATIVE_FATHER_OFFSET),#defined in module_constants.py
				(troop_set_slot, ":troop_1", slot_troop_father, ":janakir_khan"),
				(troop_set_slot, ":troop_2", slot_troop_father, ":janakir_khan"),
				#Differentiate their mothers, so they are half-brothers instead of full-brothers
				(try_begin),
					(troop_slot_eq, ":troop_1", slot_troop_mother, -1),
					(store_mul, reg0, ":troop_1", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
					(val_add, reg0, DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
					(troop_set_slot, ":troop_1", slot_troop_mother, reg0),
				(try_end),
				(try_begin),
					(troop_slot_eq, ":troop_2", slot_troop_mother, -1),
					(store_mul, reg0, ":troop_2", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
					(val_add, reg0, DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
					(troop_set_slot, ":troop_2", slot_troop_mother, reg0),
				(try_end),
			(try_end),
		(try_end),
	(try_end),
	##Add uncles and aunts by marriage.
	##In Native, the relation strength for blood uncles/aunts is 4, and for cousins is 2.
	##In light of this I've decided to set the relation strength for aunts/uncles by marriage to 2.
	(try_begin),
		(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
		#Test if troop_1 is married to a sibling of one of troop_2's parents, pt. 1
		(ge, ":spouse_of_1", 0),
		(neg|troop_slot_eq, ":spouse_of_1", slot_troop_father, -1),
		(this_or_next|troop_slot_eq, ":spouse_of_1", slot_troop_father, ":paternal_grandfather_of_2"),
			(troop_slot_eq, ":spouse_of_1", slot_troop_father, ":maternal_grandfather_of_2"),
		(assign, ":relation_strength", 2),
		(try_begin),
			(eq, ":gender_1", tf_female),
			(str_store_string, s11, "str_aunt"),
		(else_try),
			(str_store_string, s11, "str_uncle"),
		(try_end),
	(else_try),
		(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
		#Test if troop_1 is married to a sibling of one of troop_2's parents, pt. 2
		(ge, ":spouse_of_1", 0),
		(neg|troop_slot_eq, ":spouse_of_1", slot_troop_mother, -1),
		(this_or_next|troop_slot_eq, ":spouse_of_1", slot_troop_mother, ":paternal_grandmother_of_2"),
			(troop_slot_eq, ":spouse_of_1", slot_troop_mother, ":maternal_grandmother_of_2"),
		(assign, ":relation_strength", 2),
		(try_begin),
			(eq, ":gender_1", tf_female),
			(str_store_string, s11, "str_aunt"),
		(else_try),
			(str_store_string, s11, "str_uncle"),
		(try_end),
	(else_try),
		(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
		#Test if troop_2 is married to a sibling of one of troop_1's parents, pt. 1
		(ge, ":spouse_of_2", 0),
		(neg|troop_slot_eq, ":spouse_of_2", slot_troop_father, -1),
		(this_or_next|troop_slot_eq, ":spouse_of_2", slot_troop_father, ":paternal_grandfather_of_1"),
			(troop_slot_eq, ":spouse_of_2", slot_troop_father, ":maternal_grandfather_of_1"),
		(assign, ":relation_strength", 2),
		(try_begin),
			(eq, ":gender_1", tf_female),
			(str_store_string, s11, "str_niece"),
		(else_try),
			(str_store_string, s11, "str_nephew"),
		(try_end),
	(else_try),
		(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
		#Test if troop_2 is married to a sibling of one of troop_1's parents, pt. 2
		(ge, ":spouse_of_2", 0),
		(neg|troop_slot_eq, ":spouse_of_2", slot_troop_mother, -1),
		(this_or_next|troop_slot_eq, ":spouse_of_2", slot_troop_mother, ":paternal_grandmother_of_1"),
			(troop_slot_eq, ":spouse_of_2", slot_troop_mother, ":maternal_grandmother_of_1"),
		(assign, ":relation_strength", 2),
		(try_begin),
			(eq, ":gender_1", tf_female),
			(str_store_string, s11, "str_niece"),
		(else_try),
			(str_store_string, s11, "str_nephew"),
		(try_end),
	(try_end),
	##diplomacy end+
    (assign, reg4, ":gender_1"),
	(assign, reg0, ":relation_strength"),
	]),


  # script_complete_family_relations
  # Inputs: none
  # Outputs: none

  #complete family relations removed

  # script_collect_friendly_parties
  # Fills the party p_collective_friends with the members of parties attached to main_party and ally_party_no
  ("collect_friendly_parties",
    [
      (party_collect_attachments_to_party, "p_main_party", "p_collective_friends"),
      (try_begin),
        (gt, "$g_ally_party", 0),
        (party_collect_attachments_to_party, "$g_ally_party", "p_temp_party"),
        (assign, "$g_move_heroes", 1),
        (call_script, "script_party_add_party", "p_collective_friends", "p_temp_party"),
      (try_end),
  ]),

  # script_encounter_calculate_fit
  # Input: arg1 = troop_no
  # Output: none
  ("encounter_calculate_fit",
    [
      #(assign, "$g_enemy_fit_for_battle_old",  "$g_enemy_fit_for_battle"),
      #(assign, "$g_friend_fit_for_battle_old", "$g_friend_fit_for_battle"),
      #(assign, "$g_main_party_fit_for_battle_old", "$g_main_party_fit_for_battle"),
      (call_script, "script_party_count_fit_for_battle", "p_main_party"),
      #(assign, "$g_main_party_fit_for_battle", reg(0)),
      (call_script, "script_collect_friendly_parties"),
      (call_script, "script_party_count_fit_for_battle", "p_collective_friends"),
      (assign, "$g_friend_fit_for_battle", reg(0)),

      (party_clear, "p_collective_ally"),
      (try_begin),
        (gt, "$g_ally_party", 0),
        (party_is_active, "$g_ally_party"),
        (party_collect_attachments_to_party, "$g_ally_party", "p_collective_ally"),
        #(call_script, "script_party_count_fit_for_battle", "p_collective_ally"),
        #(val_add, "$g_friend_fit_for_battle", reg(0)),
        #SB : pre-process command structure here
        (party_get_num_attached_parties, ":attached", "$g_ally_party"),
        (troop_get_slot, ":limit", "$g_player_troop", slot_troop_renown),
        (val_sub, ":limit", dplmc_command_renown_limit),
        (game_get_reduce_campaign_ai, ":bonus"),
        (val_mul, ":bonus", "$player_right_to_rule"),
        (val_add, ":limit", ":bonus"),

        (assign, reg0, ":attached"),
        (val_add, ":attached", 1),
        (try_for_range, ":rank", 0, ":attached"),
          (party_get_attached_party_with_rank, ":party_no", "$g_ally_party", ":rank"),
          (try_begin),
            (eq, ":party_no", -1),
            (assign, ":party_no", "$g_ally_party"),
          (try_end),
          (assign, ":continue", -1),

          (store_faction_of_party, ":party_faction", ":party_no"),
          (party_stack_get_troop_id, ":leader_troop_id", ":party_no", 0),

          (try_begin),
            (eq, ":party_no", "p_main_party"),
            (assign, ":continue", 0),
          (else_try),
            (assign, ":continue", -1), #by default, not under command
          (try_end),

          (try_begin), #under command if marshal
            (eq, ":party_faction", "$players_kingdom"),
            (troop_slot_eq, ":leader_troop_id", slot_troop_occupation, slto_kingdom_hero),

            (try_begin), #as marshal
               # (is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
               # (faction_slot_eq, "$players_kingdom", slot_faction_marshall, "trp_player"),
               # (assign, ":continue", 0),
            # (else_try), #as ruler/pretender marshal
               # (faction_slot_eq, ":party_faction", slot_faction_state, sfs_active),
               (call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", ":party_faction"),
               (ge, reg0, DPLMC_FACTION_STANDING_MARSHALL),
               # (this_or_next|faction_slot_eq, ":party_faction", slot_faction_marshall, "trp_player"),
               # (faction_slot_eq, ":party_faction", slot_faction_leader, "$g_player_troop"),
               (assign, ":continue", 0),
            (try_end),
            (eq, ":continue", -1), #If still not satisfied, check other conditions
          (else_try), #or high enough renown
            (troop_slot_eq, ":leader_troop_id", slot_troop_occupation, slto_kingdom_hero),
            (troop_get_slot, ":renown", ":leader_troop_id", slot_troop_renown),
            (call_script, "script_troop_get_relation_with_troop", ":leader_troop_id", "$g_player_troop"),
            (val_sub, ":renown", reg0), #higher relation means less renown needed.
            (le, ":renown", ":limit"),
            (assign, ":continue", 0),
          (else_try), #straggler parties - patrols, caravans, etc.
            (neg|troop_slot_eq, ":leader_troop_id", slot_troop_occupation, slto_kingdom_hero),
            (assign, ":continue", 0),
          (try_end),
          (party_set_slot, ":party_no", slot_party_temp_slot_1, ":continue"),
          (try_begin),
            (ge, "$cheat_mode", 1),
            (assign, reg0, ":continue"),
            # (str_store_party_name, s0, ":party_no"),
            (str_store_party_name, s0, ":party_no"),
            (faction_get_color, ":color", ":party_faction"),
            (display_message, "@{s0} will {reg0?not :} be under your command", ":color"),
          (try_end),
        (try_end),
      (try_end),

      (party_clear, "p_collective_enemy"),
      (try_begin),
        (party_is_active, "$g_enemy_party"),
        (party_collect_attachments_to_party, "$g_enemy_party", "p_collective_enemy"),
      (try_end),
      (call_script, "script_party_count_fit_for_battle", "p_collective_enemy"),
      (assign, "$g_enemy_fit_for_battle", reg(0)),
      (assign, reg11, "$g_enemy_fit_for_battle"),
      (assign, reg10, "$g_friend_fit_for_battle"),
  ]),

  # script_encounter_init_variables
  # Input: arg1 = troop_no
  # Output: none
  ("encounter_init_variables",
    [
      (assign, "$capture_screen_shown", 0),
      (assign, "$loot_screen_shown", 0),
      (assign, "$thanked_by_ally_leader", 0),
      (assign, "$g_battle_result", 0),
      (assign, "$cant_leave_encounter", 0),
      (assign, "$cant_talk_to_enemy", 0),
      (assign, "$last_defeated_hero", 0),
      (assign, "$last_freed_hero", 0),

      (call_script, "script_encounter_calculate_fit"),
      (call_script, "script_party_copy", "p_main_party_backup", "p_main_party"),
	  ##diplomacy start+
	  #If terrain advantage is enabled, use it to initialize the variables.
	  (assign, ":terrain_code", -1),
	  (try_begin),
	     (eq, "$g_dplmc_terrain_advantage", DPLMC_TERRAIN_ADVANTAGE_ENABLE),
		 (lt, "$g_encounter_is_in_village", 1),#Do not apply to village encounters
	     (try_begin),
	        (encountered_party_is_attacker),
		    (call_script, "script_dplmc_get_terrain_code_for_battle", "$g_encountered_party", "p_main_party"),
	     (else_try),
	        (call_script, "script_dplmc_get_terrain_code_for_battle", "p_main_party", "$g_encountered_party"),
		 (try_end),
		 (assign, ":terrain_code", reg0),
		 #calculate party strength with terrain
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_main_party", ":terrain_code", 0, 1),
		 (assign, "$g_starting_strength_main_party", reg0),
		 (try_begin),
			#Print debug Message
		    (ge, "$cheat_mode", 1),
		    (assign, reg2, ":terrain_code"),
			(display_message, "@{!}DEBUG - Main party raw strength {reg1}, terrain code {reg2}, modified strength {reg0}"),
		 (try_end),
		 #calculate enemy strength with terrain
		 (call_script, "script_party_copy", "p_encountered_party_backup", "p_collective_enemy"),
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_enemy", ":terrain_code", 0, 1),
		 (assign, "$g_starting_strength_enemy_party", reg0),
		 (assign, "$g_strength_contribution_of_player", 100),
		 (try_begin),
		    (ge, "$cheat_mode", 1),#debug
		    (assign, reg2, ":terrain_code"),
			(display_message, "@{!} DEBUG - Enemy party raw strength {reg1}, terrain code {reg2}, modified strength {reg0}"),
		 (try_end),
		 #calculate friends strength with terrain
		 (call_script, "script_party_copy", "p_collective_friends_backup", "p_collective_friends"),
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_friends", ":terrain_code", 0, 1),
		 (assign, "$g_starting_strength_friends", reg0),
	  (else_try),
	     ##Calculate all party strengths without terrain:
	     #calculate main party strength
         (call_script, "script_party_calculate_strength", "p_main_party", 0),
         (assign, "$g_starting_strength_main_party", reg0),
		 #calculate enemy strength
         (call_script, "script_party_copy", "p_encountered_party_backup", "p_collective_enemy"),
         (call_script, "script_party_calculate_strength", "p_collective_enemy", 0),
         (assign, "$g_starting_strength_enemy_party", reg0),
         (assign, "$g_strength_contribution_of_player", 100),
		 #calculate friends strength
         (call_script, "script_party_copy", "p_collective_friends_backup", "p_collective_friends"),
         (call_script, "script_party_calculate_strength", "p_collective_friends", 0),
         (assign, "$g_starting_strength_friends", reg0),
	  (try_end),
	  ##diplomacy end+

      (store_mul, "$g_strength_contribution_of_player","$g_starting_strength_main_party", 100), # reduce contribution if we are helping someone.

	  (try_begin),
		(gt, "$g_starting_strength_friends", 0), #this new to prevent occasional div by zero error
		(val_div, "$g_strength_contribution_of_player","$g_starting_strength_friends"),
	  (else_try),
		(assign, "$g_strength_contribution_of_player", 100), #Or zero, maybe
	  (try_end),

      (party_clear, "p_routed_enemies"), #new
      (assign, "$num_routed_us", 0),#newtoday
      (assign, "$num_routed_allies", 0),#newtoday
      (assign, "$num_routed_enemies", 0),#newtoday
      (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop_id", "p_main_party", ":i_stack"),
        (try_begin),
          (troop_set_slot, ":stack_troop_id", slot_troop_player_routed_agents, 0),
          #(troop_set_slot, ":stack_troop_id", slot_troop_enemy_routed_agents, 0),
          #(troop_set_slot, ":stack_troop_id", slot_troop_ally_routed_agents, 0),
        (try_end),
      (try_end),

      (party_get_num_companion_stacks, ":num_stacks", "p_collective_friends"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop_id", "p_collective_friends", ":i_stack"),
        (try_begin),
          #(troop_set_slot, ":stack_troop_id", slot_troop_player_routed_agents, 0),
          #(troop_set_slot, ":stack_troop_id", slot_troop_enemy_routed_agents, 0),
          (troop_set_slot, ":stack_troop_id", slot_troop_ally_routed_agents, 0),
        (try_end),
      (try_end),

      (party_get_num_companion_stacks, ":num_stacks", "p_collective_enemy"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop_id", "p_collective_enemy", ":i_stack"),
        (try_begin),
          #(troop_set_slot, ":stack_troop_id", slot_troop_player_routed_agents, 0),
          (troop_set_slot, ":stack_troop_id", slot_troop_enemy_routed_agents, 0),
          #(troop_set_slot, ":stack_troop_id", slot_troop_ally_routed_agents, 0),
        (try_end),
      (try_end),

      (try_for_range, ":cur_faction", npc_kingdoms_begin, npc_kingdoms_end),
        (faction_set_slot, ":cur_faction", slot_faction_num_routed_agents, 0),
      (try_end),

      (assign, "$routed_party_added", 0), #new
      (party_clear, "p_total_enemy_casualties"), #new

#      (try_begin),
#        (gt, "$g_ally_party", 0),
#        (call_script, "script_party_copy", "p_ally_party_backup", "p_collective_ally"),
#        (call_script, "script_party_calculate_strength", "p_collective_ally"),
#        (assign, "$g_starting_strength_ally_party", reg0),
#        (store_add, ":starting_strength_factor_combined","$g_starting_strength_ally_party","$g_starting_strength_main_party"),
#         (store_mul, "$g_strength_contribution_of_player","$g_starting_strength_main_party", 80), #reduce contribution if we are helping someone.
#        (val_div, "$g_strength_contribution_of_player",":starting_strength_factor_combined"),
#      (try_end),
  ]),

  # script_calculate_renown_value
  # Input: arg1 = troop_no
  # Output: fills $battle_renown_value
  ("calculate_renown_value",
   [
      ##diplomacy start+
	  #If terrain advantage is enabled, use it to avoid messing up cached
	  #strength values, but do not take it into consideration for renown
	  #granted.
	  (assign, ":main_party_strength", 1),
	  (assign, ":enemy_strength", 1),
	  (assign, ":friends_strength", 1),
	  (assign, ":terrain_code", -1),
	  (try_begin),
	     (eq, "$g_dplmc_terrain_advantage", DPLMC_TERRAIN_ADVANTAGE_ENABLE),
	     (try_begin),
	        (encountered_party_is_attacker),
		    (call_script, "script_dplmc_get_terrain_code_for_battle", "$g_encountered_party", "p_main_party"),
	     (else_try),
	        (call_script, "script_dplmc_get_terrain_code_for_battle", "p_main_party", "$g_encountered_party"),
		 (try_end),
		 (assign, ":terrain_code", reg0),
		 ##Alternate option: calculate with terrain, but don't use it for renown
		 #(but do use it to update the cached strength for the party)
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_main_party", ":terrain_code",0,1),
		 (assign, ":main_party_strength", reg1),#use non-terrain version!
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_enemy", ":terrain_code",0,1),
		 (assign, ":enemy_strength", reg1),#use non-terrain version!
		 (call_script, "script_dplmc_party_calculate_strength_in_terrain", "p_collective_friends", ":terrain_code",0,1),
		 (assign, ":friends_strength", reg1),#use non-terrain version!
	  (else_try),
	      ##Original option: calculate without terrain
		  (call_script, "script_party_calculate_strength", "p_main_party", 0),
		  (assign, ":main_party_strength", reg0),
		  (call_script, "script_party_calculate_strength", "p_collective_enemy", 0),
		  (assign, ":enemy_strength", reg0),
		  (call_script, "script_party_calculate_strength", "p_collective_friends", 0),
		  (assign, ":friends_strength", reg0),
	  (try_end),
	  ##diplomacy end+

      (val_add, ":friends_strength", 1),
      (store_mul, ":enemy_strength_ratio", ":enemy_strength", 100),
      (val_div, ":enemy_strength_ratio", ":friends_strength"),

      (assign, ":renown_val", ":enemy_strength"),
      (val_mul, ":renown_val", ":enemy_strength_ratio"),
      (val_div, ":renown_val", 100),

      (val_mul, ":renown_val", ":main_party_strength"),
      (val_div, ":renown_val",":friends_strength"),

      (store_div, "$battle_renown_value", ":renown_val", 5),
      (val_min, "$battle_renown_value", 2500),
      (convert_to_fixed_point, "$battle_renown_value"),
      (store_sqrt, "$battle_renown_value", "$battle_renown_value"),
      (convert_from_fixed_point, "$battle_renown_value"),
      (assign, reg8, "$battle_renown_value"),
      (display_message, "@Renown value for this battle is {reg8}.",0xFFFFFFFF),
  ]),


  ##  # script_calculate_weekly_wage_for_player
  ##  # Input: none
  ##  # Output: none
  ##  ("calculate_weekly_wage_for_player",
  ##    [
  ##        (call_script, "script_calculate_weekly_party_wage", "p_main_party"),
  ##        (assign, ":result", reg0),
  ##        (try_for_parties, ":party_no"),
  ##          (store_faction_of_party, ":party_faction", ":party_no"),
  ##          (eq, ":party_faction", "fac_player_supporters_faction"),
  ##          (call_script, "script_calculate_weekly_party_wage", ":party_no"),
  ##          (val_add, ":result", reg0),
  ##        (try_end),
  ##        (assign, reg0, ":result"),
  ##  ]),


  # script_get_first_agent_with_troop_id
  # Input: arg1 = troop_no
  # Output: agent_id
  ("cf_get_first_agent_with_troop_id",
    [
      (store_script_param_1, ":troop_no"),
      #      (store_script_param_2, ":agent_no_to_begin_searching_after"),
      (assign, ":result", -1),
      (try_for_agents, ":cur_agent"),
        (eq, ":result", -1),
        ##        (try_begin),
        ##          (eq, ":cur_agent", ":agent_no_to_begin_searching_after"),
        ##          (assign, ":agent_no_to_begin_searching_after", -1),
        ##        (try_end),
        ##        (eq, ":agent_no_to_begin_searching_after", -1),
        (agent_get_troop_id, ":cur_troop_no", ":cur_agent"),
        (eq, ":cur_troop_no", ":troop_no"),
        (assign, ":result", ":cur_agent"),
      (try_end),
      (assign, reg0, ":result"),
      (neq, reg0, -1),
  ]),


  # script_cf_team_get_average_position_of_agents_with_type_to_pos1
  # Input: arg1 = team_no, arg2 = class_no (grc_everyone, grc_infantry, grc_cavalry, grc_archers, grc_heroes)
  # Output: none, pos1 = average_position (0,0,0 if there are no matching agents)
  ("cf_team_get_average_position_of_agents_with_type_to_pos1",
    [
      (store_script_param_1, ":team_no"),
      (store_script_param_2, ":division_no"),
      (assign, ":total_pos_x", 0),
      (assign, ":total_pos_y", 0),
      (assign, ":total_pos_z", 0),
      (assign, ":num_agents", 0),
      (set_fixed_point_multiplier, 100),
      (try_for_agents, ":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_get_team, ":cur_team_no", ":cur_agent"),
        (eq, ":cur_team_no", ":team_no"),
        (agent_get_division, ":cur_agent_division", ":cur_agent"),
        (this_or_next|eq, ":division_no", grc_everyone),
        (eq, ":division_no", ":cur_agent_division"),
        (agent_get_position, pos1, ":cur_agent"),
        (position_get_x, ":cur_pos_x", pos1),
        (val_add, ":total_pos_x", ":cur_pos_x"),
        (position_get_y, ":cur_pos_y", pos1),
        (val_add, ":total_pos_y", ":cur_pos_y"),
        (position_get_z, ":cur_pos_z", pos1),
        (val_add, ":total_pos_z", ":cur_pos_z"),
        (val_add, ":num_agents", 1),
      (try_end),
      (gt, ":num_agents", 1),
      (val_div, ":total_pos_x", ":num_agents"),
      (val_div, ":total_pos_y", ":num_agents"),
      (val_div, ":total_pos_z", ":num_agents"),
      (init_position, pos1),
      (position_move_x, pos1, ":total_pos_x"),
      (position_move_y, pos1, ":total_pos_y"),
      (position_move_z, pos1, ":total_pos_z"),
  ]),

  # script_cf_turn_windmill_fans
  # Input: arg1 = instance_no (none = 0)
  # Output: none
  ("cf_turn_windmill_fans",
    [(store_script_param_1, ":instance_no"),
      (scene_prop_get_instance, ":windmill_fan_object", "spr_windmill_fan_turning", ":instance_no"),
      (ge, ":windmill_fan_object", 0),
      (prop_instance_get_position, pos1, ":windmill_fan_object"),
      (position_rotate_y, pos1, 10),
      (prop_instance_animate_to_position, ":windmill_fan_object", pos1, 100),
      (val_add, ":instance_no", 1),
      (call_script, "script_cf_turn_windmill_fans", ":instance_no"),
  ]),

  # script_print_party_members
  # Input: arg1 = party_no
  # Output: s51 = output string. "noone" if the party is empty
  ("print_party_members",
    [
      (store_script_param_1, ":party_no"),
      (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
      (assign, reg10, ":num_stacks"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
        (troop_is_hero, ":stack_troop"),
        (try_begin),
          (eq, ":i_stack", 0),
          (str_store_troop_name, s51, ":stack_troop"),
        (try_end),
        (str_store_troop_name, s52, ":stack_troop"),
        (try_begin),
          (eq, ":i_stack", 1),
          (str_store_string, s51, "str_s52_and_s51"),
        (else_try),
          (gt, ":i_stack", 1),
          (str_store_string, s51, "str_s52_comma_s51"),
        (try_end),
      (try_end),
      (try_begin),
        (eq, ":num_stacks", 0),
        (str_store_string, s51, "str_noone"),
      (try_end),
  ]),

  # script_round_value
  # Input: arg1 = value
  # Output: reg0 = rounded_value
  ("round_value",
    [
      (store_script_param_1, ":value"),
      (try_begin),
        (lt, ":value", 100),
        (neq, ":value", 0),
        (val_add, ":value", 5),
        (val_div, ":value", 10),
        (val_mul, ":value", 10),
        (try_begin),
          (eq, ":value", 0),
          (assign, ":value", 5),
        (try_end),
      (else_try),
        (lt, ":value", 300),
        (val_add, ":value", 25),
        (val_div, ":value", 50),
        (val_mul, ":value", 50),
      (else_try),
        (val_add, ":value", 50),
        (val_div, ":value", 100),
        (val_mul, ":value", 100),
      (try_end),
      (assign, reg0, ":value"),
  ]),


  # script_change_banners_and_chest
  # Input: none
  # Output: none
  ("change_banners_and_chest",
    [(party_get_slot, ":cur_leader", "$g_encountered_party", slot_town_lord),
     (try_begin),
       (ge, ":cur_leader", 0),
#normal_banner_begin
       (troop_get_slot, ":troop_banner_object", ":cur_leader", slot_troop_banner_scene_prop),
       (try_begin),
           (gt, ":troop_banner_object", 0),
           (replace_scene_props, banner_scene_props_begin, ":troop_banner_object"),
       (else_try),
           (eq, ":troop_banner_object", -1),
           (troop_get_slot, ":troop_custom_banner_object", ":cur_leader", slot_troop_custom_banner_flag_type),
           (ge, ":troop_custom_banner_object", 0),
           (val_add, ":troop_custom_banner_object", "spr_custom_banner_01"),
           (replace_scene_props, "spr_banner_a", ":troop_custom_banner_object"),
       (try_end),
     (else_try),
       (replace_scene_props, banner_scene_props_begin, "spr_empty"),
     (try_end),
     (try_begin),
       (neq, ":cur_leader", "trp_player"),
       (replace_scene_props, "spr_player_chest", "spr_locked_player_chest"),
     (try_end),
     ]),


  # script_remove_siege_objects
  # Input: none
  # Output: none
  ("remove_siege_objects",
    [
      (replace_scene_props, "spr_battlement_a_destroyed", "spr_battlement_a"),
      (replace_scene_props, "spr_snowy_castle_battlement_a_destroyed", "spr_snowy_castle_battlement_a"),
      (replace_scene_props, "spr_castle_e_battlement_a_destroyed", "spr_castle_e_battlement_a"),
      (replace_scene_props, "spr_castle_battlement_a_destroyed", "spr_castle_battlement_a"),
      (replace_scene_props, "spr_castle_battlement_b_destroyed", "spr_castle_battlement_b"),
      (replace_scene_props, "spr_earth_wall_a2", "spr_earth_wall_a"),
      (replace_scene_props, "spr_earth_wall_b2", "spr_earth_wall_b"),
      (replace_scene_props, "spr_belfry_platform_b", "spr_empty"),
      (replace_scene_props, "spr_belfry_platform_a", "spr_empty"),
      (replace_scene_props, "spr_belfry_a", "spr_empty"),
      (replace_scene_props, "spr_belfry_wheel", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_6m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_8m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_10m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_12m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_move_14m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_12m", "spr_empty"),
      (replace_scene_props, "spr_siege_ladder_14m", "spr_empty"),
      (replace_scene_props, "spr_mangonel", "spr_empty"),
      (replace_scene_props, "spr_trebuchet_old", "spr_empty"),
      (replace_scene_props, "spr_trebuchet_new", "spr_empty"),
      (replace_scene_props, "spr_stone_ball", "spr_empty"),
      (replace_scene_props, "spr_village_fire_big", "spr_empty"),
      ]),

  # script_describe_relation_to_s63
  # Input: arg1 = relation (-100 .. 100)
  # Output: none
  ("describe_relation_to_s63",
    [(store_script_param_1, ":relation"),
      (store_add, ":normalized_relation", ":relation", 100),
      (val_add, ":normalized_relation", 5),
      (store_div, ":str_offset", ":normalized_relation", 10),
      (val_clamp, ":str_offset", 0, 20),
      (store_add, ":str_id", "str_relation_mnus_100",  ":str_offset"),
      (str_store_string, s63, ":str_id"),
  ]),

  # script_describe_center_relation_to_s3
  # Input: arg1 = relation (-100 .. 100)
  # Output: none
  ("describe_center_relation_to_s3",
    [(store_script_param_1, ":relation"),
      (store_add, ":normalized_relation", ":relation", 100),
      (val_add, ":normalized_relation", 5),
      (store_div, ":str_offset", ":normalized_relation", 10),
      (val_clamp, ":str_offset", 0, 20),
      (store_add, ":str_id", "str_center_relation_mnus_100",  ":str_offset"),
      (str_store_string, s3, ":str_id"),
  ]),


  # script_center_ambiance_sounds
  # Input: none
  # Output: none
  # to be called every two seconds
  ("center_ambiance_sounds",
    [
        (assign, ":sound_1", -1),
        (assign, ":sound_2", -1),
        (assign, ":sound_3", -1),
        (assign, ":sound_4", -1),
        (assign, ":sound_5", -1),
        (try_begin),
          (party_slot_eq, "$g_encountered_party", slot_party_type, spt_village),
          (try_begin),
            (neg|is_currently_night),
            (assign, ":sound_3", "snd_distant_dog_bark"),
            (assign, ":sound_3", "snd_distant_chicken"),
          (else_try),
            (assign, ":sound_1", "snd_distant_dog_bark"),
            (assign, ":sound_2", "snd_distant_owl"),
          (try_end),
        (else_try),
          (party_slot_eq, "$g_encountered_party", slot_party_type, spt_town),
          (try_begin),
            (neg|is_currently_night),
            (assign, ":sound_1", "snd_distant_carpenter"),
            (assign, ":sound_2", "snd_distant_blacksmith"),
            (assign, ":sound_3", "snd_distant_dog_bark"),
          (else_try),
            (assign, ":sound_1", "snd_distant_dog_bark"),
          (try_end),
        (try_end),
        (try_begin),
          (store_random_in_range, ":r", 0, 7),
          (try_begin),
            (eq, ":r", 1),
            (ge, ":sound_1", 0),
            (play_sound, ":sound_1"),
          (else_try),
            (eq, ":r", 2),
            (ge, ":sound_2", 0),
            (play_sound, ":sound_2"),
          (else_try),
            (eq, ":r", 3),
            (ge, ":sound_3", 0),
            (play_sound, ":sound_3"),
          (else_try),
            (eq, ":r", 4),
            (ge, ":sound_4", 0),
            (play_sound, ":sound_4"),
          (else_try),
            (eq, ":r", 5),
            (ge, ":sound_5", 0),
            (play_sound, ":sound_5"),
          (try_end),
        (try_end),
  ]),

  # script_center_set_walker_to_type
  # Input: arg1 = center_no, arg2 = walker_no, arg3 = walker_type,
  # Output: none
  ("center_set_walker_to_type",
   [
       (store_script_param, ":center_no", 1),
       (store_script_param, ":walker_no", 2),
       (store_script_param, ":walker_type", 3),
       (store_add, ":type_slot", slot_center_walker_0_type, ":walker_no"),
       (party_set_slot, ":center_no", ":type_slot", ":walker_type"),
       (party_get_slot, ":center_faction", ":center_no", slot_center_original_faction),
       (faction_get_slot, ":center_culture", ":center_faction", slot_faction_culture),
       (store_random_in_range, ":walker_troop_slot", 0, 2),
       (try_begin),
         (party_slot_eq, ":center_no", slot_party_type, spt_village),
         (val_add, ":walker_troop_slot", slot_faction_village_walker_male_troop),
       (else_try),
         (val_add, ":walker_troop_slot", slot_faction_town_walker_male_troop),
       (try_end),
       (try_begin),
         (eq,":walker_type", walkert_spy),
         (assign,":original_walker_slot",":walker_troop_slot"),
         (val_add,":walker_troop_slot",4), # select spy troop id slot
       (try_end),
       (faction_get_slot, ":walker_troop_id", ":center_culture", ":walker_troop_slot"),
       (try_begin),
         (eq,":walker_type", walkert_spy),
         (faction_get_slot, ":original_walker", ":center_culture", ":original_walker_slot"),
         # restore spy inventory
         (try_for_range,":item_no","itm_horse_meat","itm_wooden_stick"),
            (store_item_kind_count,":num_items",":item_no",":original_walker"),
            (ge,":num_items",1),
            (store_item_kind_count,":num_items",":item_no",":walker_troop_id"),
            (lt,":num_items",1),
            (troop_add_items,":walker_troop_id",":item_no",1),
         (try_end),
         # determine spy recognition item
         (store_random_in_range,":spy_item_type",itp_type_head_armor,itp_type_hand_armor),
         (assign,":num",0),
         (try_for_range,":item_no","itm_horse_meat","itm_wooden_stick"),
            (store_item_kind_count,":num_items",":item_no",":walker_troop_id"),
            (ge,":num_items",1),
            (item_get_type, ":itp", ":item_no"),
            (eq,":itp",":spy_item_type"),
            (val_add,":num",1),
            (troop_remove_items,":walker_troop_id",":item_no",":num_items"),
         (try_end),
         (store_random_in_range,":random_item",0,":num"),
         (assign,":num",-1),
         (try_for_range,":item_no","itm_horse_meat","itm_wooden_stick"),
            (store_item_kind_count,":num_items",":item_no",":original_walker"),
            (ge,":num_items",1),
            (item_get_type, ":itp", ":item_no"),
            (eq,":itp",":spy_item_type"),
            (val_add,":num",1),
            (eq,":num",":random_item"),
            (troop_add_items,":walker_troop_id",":item_no",1),
            (assign,":spy_item",":item_no"),
         (try_end),
         (assign,"$spy_item_worn",":spy_item"),
         (assign,"$spy_quest_troop",":walker_troop_id"),
         (troop_equip_items,":walker_troop_id"),
       (try_end),
       (store_add, ":troop_slot", slot_center_walker_0_troop, ":walker_no"),
       (party_set_slot, ":center_no", ":troop_slot", ":walker_troop_id"),
       (store_random_in_range, ":walker_dna", 0, 1000000),
       (store_add, ":dna_slot", slot_center_walker_0_dna, ":walker_no"),
       (party_set_slot, ":center_no", ":dna_slot", ":walker_dna"),
     ]),


  # script_cf_center_get_free_walker
  # Input: arg1 = center_no
  # Output: reg0 = walker no (can fail)
  ("cf_center_get_free_walker",
   [
       (store_script_param, ":center_no", 1),
       (assign, ":num_free_walkers", 0),
       (try_for_range, ":walker_no", 0, num_town_walkers),
         (store_add, ":type_slot", slot_center_walker_0_type, ":walker_no"),
         (party_slot_eq, ":center_no", ":type_slot", walkert_default),
         (val_add, ":num_free_walkers", 1),
       (try_end),
       (gt, ":num_free_walkers", 0),
       (assign, reg0, -1),
       (store_random_in_range, ":random_rank", 0, ":num_free_walkers"),
       (try_for_range, ":walker_no", 0, num_town_walkers),
         (store_add, ":type_slot", slot_center_walker_0_type, ":walker_no"),
         (party_slot_eq, ":center_no", ":type_slot", walkert_default),
         (val_sub, ":num_free_walkers", 1),
         (eq, ":num_free_walkers", ":random_rank"),
         (assign, reg0, ":walker_no"),
       (try_end),
     ]),

  # script_center_remove_walker_type_from_walkers
  # Input: arg1 = center_no, arg2 = walker_type,
  # Output: reg0 = 1 if comment found, 0 otherwise; s61 will contain comment string if found
  ("center_remove_walker_type_from_walkers",
   [
       (store_script_param, ":center_no", 1),
       (store_script_param, ":walker_type", 2),
       (try_for_range, ":walker_no", 0, num_town_walkers),
         (store_add, ":type_slot", slot_center_walker_0_type, ":walker_no"),
         (party_slot_eq, ":center_no", ":type_slot", ":walker_type"),
         (call_script, "script_center_set_walker_to_type", ":center_no", ":walker_no", walkert_default),
       (try_end),
     ]),


  # script_init_town_walkers
  # Input: none
  # Output: none
  ("init_town_walkers",
  [
    (try_begin),
      (eq, "$town_nighttime", 0),
      (try_for_range, ":walker_no", 0, num_town_walkers),
        (store_add, ":troop_slot", slot_center_walker_0_troop, ":walker_no"),
        (party_get_slot, ":walker_troop_id", "$current_town", ":troop_slot"),
        (gt, ":walker_troop_id", 0),
        (store_add, ":entry_no", town_walker_entries_start, ":walker_no"),
        (set_visitor, ":entry_no", ":walker_troop_id"),
      (try_end),
    (try_end),
  ]),


  # script_cf_enter_center_location_bandit_check
  # Input: none
  # Output: none
  ("cf_enter_center_location_bandit_check",
    [
      (neq, "$town_nighttime", 0),
      (party_slot_ge, "$current_town", slot_center_has_bandits, 1),
      (eq, "$g_defending_against_siege", 0),#Skip if the center is under siege (because of resting)
      (eq, "$sneaked_into_town", disguise_none),#Skip if sneaked
      (try_begin),
        (party_slot_eq, "$current_town", slot_party_type, spt_village),
        (party_get_slot, ":cur_scene", "$current_town", slot_castle_exterior),
      (else_try),
        (party_get_slot, ":cur_scene", "$current_town", slot_town_center),
      (try_end),
      (modify_visitors_at_site, ":cur_scene"),
      (reset_visitors),
      (party_get_slot, ":bandit_troop", "$current_town", slot_center_has_bandits),
      (store_character_level, ":level", "trp_player"),

      (set_jump_mission, "mt_bandits_at_night"),
      (try_begin),
        (party_slot_eq, "$current_town", slot_party_type, spt_village),
        (assign, ":spawn_amount", 2),
        (store_div, ":level_fac",  ":level", 10),
        (val_add, ":spawn_amount", ":level_fac"),
        (try_for_range, ":unused", 0, 3),
          (gt, ":level", 10),
          (store_random_in_range, ":random_no", 0, 100),
          (lt, ":random_no", ":level"),
          (val_add, ":spawn_amount", 1),
        (try_end),
        (set_visitors, 4, ":bandit_troop", ":spawn_amount"),
        (assign, "$num_center_bandits", ":spawn_amount"),
        (set_jump_entry, 2),
      (else_try),
        (assign, ":spawn_amount", 1),
        (assign, "$num_center_bandits", 0),
        (try_begin),
          (gt, ":level", 15),
          (store_random_in_range, ":random_no", 0, 100),
          (lt, ":random_no", ":level"),
          (assign, ":spawn_amount", 2),
        (try_end),
        (val_add, "$num_center_bandits",  ":spawn_amount"),
        (set_visitors, 11, ":bandit_troop", ":spawn_amount"),
        (assign, ":spawn_amount", 1),
        (try_begin),
          (gt, ":level", 20),
          (store_random_in_range, ":random_no", 0, 100),
          (lt, ":random_no", ":level"),
          (assign, ":spawn_amount", 2),
        (try_end),
        (set_visitors, 27, ":bandit_troop", ":spawn_amount"),
        (val_add, "$num_center_bandits",  ":spawn_amount"),
        (try_begin),
          (gt, ":level", 9),
          (assign, ":spawn_amount", 1),
          (try_begin),
            (gt, ":level", 25),
            (store_random_in_range, ":random_no", 0, 100),
            (lt, ":random_no", ":level"),
            (assign, ":spawn_amount", 2),
          (try_end),
          (set_visitors, 28, ":bandit_troop", ":spawn_amount"),
          (val_add, "$num_center_bandits",  ":spawn_amount"),
        (try_end),
        (assign, "$town_entered", 1),
        (assign, "$all_doors_locked", 1),
      (try_end),

      (display_message, "@You have run into a trap!", message_negative),
      #SB : store actual bandit names
      (str_store_troop_name_plural, s1, ":bandit_troop"),
      (display_message, "@You are attacked by a group of {s1}!", message_negative),
      (play_sound, "snd_encounter_looters"), #more generic than bandit sounds
      (jump_to_scene, ":cur_scene"),
      (change_screen_mission),
      ]),

  # script_init_town_agent
  # Input: none
  # Output: none
  ("init_town_agent",
    [
      (store_script_param, ":agent_no", 1),
      (agent_get_troop_id, ":troop_no", ":agent_no"),
      (set_fixed_point_multiplier, 100),
      (assign, ":stand_animation", -1),
      (try_begin),
        (this_or_next|is_between, ":troop_no", armor_merchants_begin, armor_merchants_end),
        (is_between, ":troop_no", weapon_merchants_begin, weapon_merchants_end),
        (try_begin),
          (troop_get_type, ":cur_troop_gender", ":troop_no"),
          (eq, ":cur_troop_gender", 0),
          (agent_set_animation, ":agent_no", "anim_stand_townguard"),
        (else_try),
          (agent_set_animation, ":agent_no", "anim_stand_townguard"),
        (end_try),
      (else_try),
        (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
        (assign, ":stand_animation", "anim_stand_lady"),
      (else_try),
        (is_between, ":troop_no", active_npcs_begin, active_npcs_end),
        (assign, ":stand_animation", "anim_stand_lord"),
      (else_try),
        (is_between, ":troop_no", soldiers_begin, soldiers_end),
        (assign, ":stand_animation", "anim_stand_townguard"),
      (try_end),
      (try_begin),
        (ge, ":stand_animation", 0),
        (agent_set_stand_animation, ":agent_no", ":stand_animation"),
        (agent_set_animation, ":agent_no", ":stand_animation"),
        (store_random_in_range, ":random_no", 0, 100),
        (agent_set_animation_progress, ":agent_no", ":random_no"),
      (try_end),
      ]),

  # script_init_town_walker_agents
  # Input: none
  # Output: none
  ("init_town_walker_agents",
    [(assign, ":num_walkers", 0),
     (try_for_agents, ":cur_agent"),
       (agent_get_troop_id, ":cur_troop", ":cur_agent"),
       (is_between, ":cur_troop", walkers_begin, walkers_end),
       (val_add, ":num_walkers", 1),
       (agent_get_position, pos1, ":cur_agent"),
       (try_for_range, ":i_e_p", 9, 40),#Entry points
         (entry_point_get_position, pos2, ":i_e_p"),
         (get_distance_between_positions, ":distance", pos1, pos2),
         (lt, ":distance", 200),
         (agent_set_slot, ":cur_agent", 0, ":i_e_p"),
       (try_end),
       (call_script, "script_set_town_walker_destination", ":cur_agent"),
     (try_end),
  ]),

  # script_agent_get_town_walker_details
  # This script assumes this is one of town walkers.
  # Input: agent_id
  # Output: reg0: town_walker_type, reg1: town_walker_dna
  ("agent_get_town_walker_details",
    [(store_script_param, ":agent_no", 1),
     (agent_get_entry_no, ":entry_no", ":agent_no"),
     (store_sub, ":walker_no", ":entry_no", town_walker_entries_start),

     (store_add, ":type_slot", slot_center_walker_0_type, ":walker_no"),
     (party_get_slot, ":walker_type", "$current_town", ":type_slot"),
     (store_add, ":dna_slot", slot_center_walker_0_dna,  ":walker_no"),
     (party_get_slot, ":walker_dna", "$current_town", ":dna_slot"),
     (assign, reg0, ":walker_type"),
     (assign, reg1, ":walker_dna"),
     (assign, reg2, ":walker_no"),
  ]),


  ##diplomacy start+
  ##WARNING: this will also clobber s0 now
  ##diplomacy end+
  ("town_walker_occupation_string_to_s14",
    [
	(store_script_param, ":agent_no", 1),

	#Cairo, approx 1799:
	#adult males = 114,000
	#military, 10,400
	#civil, including religious 5,000
	#commerce 3,500
	#merchants 4,500
	#coffee shops, 1,500 (maybe broaden to inns and taverns)
	#artisans 21,800
	#workmen 4,300
	#itinerants 8,600
	#servants (inc water carriers) 26,400
	(assign, ":check_for_good_price", 0),
    ##diplomacy start+ escalate "sir/madame" to "my lord/lady" or "your highness" if appropriate
    (call_script, "script_dplmc_print_subordinate_says_sir_madame_to_s0"),
    ##diplomacy end+
	(str_store_string, s14, "str_i_take_what_work_i_can_sirmadame_i_carry_water_or_help_the_merchants_with_their_loads_or_help_build_things_if_theres_things_to_be_built"),

	(call_script, "script_agent_get_town_walker_details", ":agent_no"),
	(assign, ":type", reg0),
	(assign, ":walker_dna", reg1),

	(assign, ":item", -1),
	(assign, ":total_item_production", 0),
	(try_for_range, ":trade_good", trade_goods_begin, trade_goods_end),
		(call_script, "script_center_get_production", "$g_encountered_party", ":trade_good"),
		(val_add, ":total_item_production", reg0),
	(try_end),

	(val_max, ":total_item_production", 1),

	(store_mod, ":semi_random_number", ":walker_dna", ":total_item_production"),


	(try_begin),
		(eq, "$cheat_mode", 1),
		(assign, reg4, ":walker_dna"),
		(assign, reg5, ":total_item_production"),
		(assign, reg7, ":semi_random_number"),
		(display_message, "str_dna_reg4_total_production_reg5_modula_reg7"),
	(try_end),

    (try_for_range, ":trade_good", trade_goods_begin, trade_goods_end),
        (gt, ":semi_random_number", -1),
        (call_script, "script_center_get_production", "$g_encountered_party", ":trade_good"),
        (val_sub, ":semi_random_number", reg0),
        (lt, ":semi_random_number", 0),
        (try_begin),
          (eq, "$cheat_mode", 1),
          (str_store_item_name, s9, ":trade_good"),
          (display_message, "str_agent_produces_s9"),
        (try_end),
        (assign, ":item", ":trade_good"),
    (try_end),


	(try_begin),
		(eq, ":type", walkert_needs_money),
		(is_between, "$g_encountered_party", towns_begin, towns_end),
		(str_store_string, s14, "str_im_not_doing_anything_sirmadame_theres_no_work_to_be_had_around_here_these_days"),
	(else_try),
		(eq, ":type", walkert_needs_money),
		(str_store_string, s14, "str_im_not_doing_anything_sirmadame_i_have_no_land_of_my_own_and_theres_no_work_to_be_had_around_here_these_days"),
	(else_try),
		(eq, ":type", walkert_needs_money_helped),
		(str_store_string, s14, "str_why_im_still_living_off_of_your_kindness_and_goodness_sirmadame_hopefully_there_will_be_work_shortly"),
	(else_try),
		(eq, ":item", "itm_grain"),
        #SB : refactor
        (try_begin),
		  (is_between, "$g_encountered_party", towns_begin, towns_end),
		  (str_store_string, s14, "str_i_work_in_the_fields_just_outside_the_walls_where_they_grow_grain_we_dont_quite_grow_enough_to_meet_our_needs_though_and_have_to_import_grain_from_the_surrounding_countryside"),
		(else_try),
		  (str_store_string, s14, "str_i_work_mostly_in_the_fields_growing_grain_in_the_town_they_grind_it_to_make_bread_or_ale_and_we_can_also_boil_it_as_a_porridge"),
        (try_end),
		(assign, ":check_for_good_price", 1),
	(else_try),
		(eq, ":item", "itm_ale"),
		(str_store_string, s14, "str_i_work_in_the_breweries_making_ale_the_poor_folk_drink_a_lot_of_it_as_its_cheaper_than_wine_we_make_it_with_grain_brought_in_from_the_countryside"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_bread"),
		(str_store_string, s14, "str_i_work_in_a_mill_grinding_flour_to_make_bread_bread_is_cheap_keeps_well_and_fills_the_stomach"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_dried_meat"),
		(str_store_string, s14, "str_i_tend_cattle_we_dry_and_salt_meat_to_preserve_it_and_make_cheese_from_the_milk"),
		(assign, ":check_for_good_price", 1),

	(else_try),  #SB : combine two strings
		(this_or_next|eq, ":item", "itm_cheese"),
		(eq, ":item", "itm_butter"),
		# (str_store_string, s14, "str_i_tend_cattle_we_dry_and_salt_meat_to_preserve_it_and_make_cheese_from_the_milk_so_it_doesnt_spoil"),
		# (assign, ":check_for_good_price", 1),

	# (else_try),
		(str_store_string, s14, "str_i_tend_cattle_we_dry_and_salt_meat_to_preserve_it_and_make_cheese_from_the_milk_so_it_doesnt_spoil"),
		(assign, ":check_for_good_price", 1),

	(else_try), #SB : combine two strings
		(this_or_next|eq, ":item", "itm_wool"),
		(eq, ":item", "itm_sausages"),
		# (str_store_string, s14, "str_i_tend_sheep_we_send_the_wool_to_the_cities_to_be_woven_into_cloth_and_make_mutton_sausage_when_we_cull_the_herds"),
		# (assign, ":check_for_good_price", 1),

	# (else_try),
		# (eq, ":item", "itm_sausages"),
		(str_store_string, s14, "str_i_tend_sheep_we_send_the_wool_to_the_cities_to_be_woven_into_cloth_and_make_mutton_sausage_when_we_cull_the_herds"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_wool_cloth"),
		(str_store_string, s14, "str_i_work_at_a_loom_spinning_cloth_from_wool_wool_is_some_of_the_cheapest_cloth_you_can_buy_but_it_will_still_keep_you_warm"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_smoked_fish"),
		(str_store_string, s14, "str_i_crew_a_fishing_boat_we_salt_and_smoke_the_flesh_to_sell_it_far_inland"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_salt"),
		(str_store_string, s14, "str_i_sift_salt_from_a_nearby_flat_they_need_salt_everywhere_to_preserve_meat_and_fish"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_iron"),
		(str_store_string, s14, "str_i_mine_iron_from_a_vein_in_a_nearby_cliffside_they_use_it_to_make_tools_arms_and_other_goods"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_pottery"),
		(str_store_string, s14, "str_i_make_pottery_which_people_use_to_store_grain_and_carry_water"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_tools"),
		(str_store_string, s14, "str_trade_explanation_tools"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_oil"),
		(str_store_string, s14, "str_trade_explanation_oil"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_linen"),
		(str_store_string, s14, "str_trade_explanation_linen"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_velvet"),
		(str_store_string, s14, "str_trade_explanation_velvet"),
		(assign, ":check_for_good_price", 1),

	(else_try),
		(eq, ":item", "itm_spice"),
		(str_store_string, s14, "str_trade_explanation_spice"),
		(assign, ":check_for_good_price", 1),
    #SB : add missing explanation strings
	(else_try),
		(eq, ":item", "itm_apples"),
		(str_store_string, s14, "str_trade_explanation_apples"),
		(assign, ":check_for_good_price", 1),
    (else_try),
        (eq, ":item", "itm_raw_grapes"),
        (str_store_string, s14, "str_trade_explanation_grapes"),
        (assign, ":check_for_good_price", 1),
	(else_try),
		(eq, ":item", "itm_raw_dyes"),
		(str_store_string, s14, "str_trade_explanation_dyes"),
		(assign, ":check_for_good_price", 1),
    (else_try),
        (this_or_next|eq, ":item", "itm_raw_leather"),
        (eq, ":item", "itm_leatherwork"),
        (str_store_string, s14, "str_trade_explanation_leatherwork"),
        (assign, ":check_for_good_price", 1),
    (else_try),
        (eq, ":item", "itm_raw_flax"),
        (str_store_string, s14, "str_trade_explanation_flax"),
        (assign, ":check_for_good_price", 1),
    (else_try),
        (eq, ":item", "itm_raw_date_fruit"),
        (try_begin),
          (is_between, "$g_encountered_party", towns_begin, towns_end),
          (str_store_string, s14, "str_trade_explanation_dates_town"),
        (else_try),
          (str_store_string, s14, "str_trade_explanation_dates_village"),
        (try_end),
        (assign, ":check_for_good_price", 1),
    (else_try),
        (eq, ":item", "itm_raw_olives"),
        (str_store_string, s14, "str_trade_explanation_olives"),
        (assign, ":check_for_good_price", 1),
	(try_end),


	(try_begin),
		(eq, ":check_for_good_price", 1),

		(assign, ":trade_destination", -1),
		(store_skill_level, ":trade_skill", "skl_trade", "trp_player"),

		(try_begin),
			(is_between, "$g_encountered_party", villages_begin, villages_end),
			(party_get_slot, ":trade_town", "$g_encountered_party", slot_village_market_town),
		(else_try),
			(assign, ":trade_town", "$g_encountered_party"),
		(try_end),

		(store_sub, ":item_to_price_slot", slot_town_trade_good_prices_begin, trade_goods_begin),
		(store_add, ":cur_good_price_slot", ":item", ":item_to_price_slot"),
		(party_get_slot, ":score_to_beat", ":trade_town", ":cur_good_price_slot"),
		(val_add, ":score_to_beat", 400),
		(store_mul, ":deduction_for_trade_skill", ":trade_skill", 35),
		(try_begin),
			(is_between, "$g_encountered_party", villages_begin, villages_end),
			(val_add, ":score_to_beat", 200),
		(try_end),
		(val_sub, ":score_to_beat", ":deduction_for_trade_skill"),

		(try_for_range, ":trade_route_slot", slot_town_trade_routes_begin, slot_town_trade_routes_end),
			(party_get_slot, ":other_town", ":trade_town", ":trade_route_slot"),
			(is_between, ":other_town", towns_begin, towns_end), #SB: add condition for valid town
			(party_get_slot, ":price_in_other_town", ":other_town", ":cur_good_price_slot"),


			(try_begin),
				(eq, "$cheat_mode", 1),
				(assign, reg4, ":price_in_other_town"),
				(assign, reg5, ":score_to_beat"),
				(str_store_party_name, s10, ":other_town"),
				(display_message, "str_s10_has_reg4_needs_reg5"),
			(try_end),

			(gt, ":price_in_other_town", ":score_to_beat"),

			(assign, ":trade_destination", ":other_town"),
			(assign, ":score_to_beat", ":price_in_other_town"),
		(try_end),

		(is_between, ":trade_destination", centers_begin, centers_end),

		(str_store_party_name, s15, ":trade_destination"),
		(str_store_string, s14, "str_s14_i_hear_that_you_can_find_a_good_price_for_it_in_s15"),

		#Reasons -- raw material
		#Reason -- road cut
		#Reason -- villages looted

	(try_end),


	]),







  # script_tick_town_walkers
  # Input: none
  # Output: none
  ("tick_town_walkers",
    [(try_for_agents, ":cur_agent"),
       (agent_get_troop_id, ":cur_troop", ":cur_agent"),
       (is_between, ":cur_troop", walkers_begin, walkers_end),
       (agent_get_slot, ":target_entry_point", ":cur_agent", 0),
       (entry_point_get_position, pos1, ":target_entry_point"),
       (try_begin),
         (lt, ":target_entry_point", 32),
         (init_position, pos2),
         (position_set_y, pos2, 250),
         (position_transform_position_to_parent, pos1, pos1, pos2),
       (try_end),
       (agent_get_position, pos2, ":cur_agent"),
       (get_distance_between_positions, ":distance", pos1, pos2),
       (lt, ":distance", 400),
       (assign, ":random_no", 0),
       (try_begin),
         (lt, ":target_entry_point", 32),
         (store_random_in_range, ":random_no", 0, 100),
       (try_end),
       (lt, ":random_no", 20),
       (call_script, "script_set_town_walker_destination", ":cur_agent"),
     (try_end),
  ]),


  # script_set_town_walker_destination
  # Input: arg1 = agent_no
  # Output: none
  ("set_town_walker_destination",
    [(store_script_param_1, ":agent_no"),
     (assign, reg0, 9),
     (assign, reg1, 10),
     (assign, reg2, 12),
     (assign, reg3, 32),
     (assign, reg4, 33),
     (assign, reg5, 34),
     (assign, reg6, 35),
     (assign, reg7, 36),
     (assign, reg8, 37),
     (assign, reg9, 38),
     (assign, reg10, 39),
     (try_for_agents, ":cur_agent"),
       (agent_get_troop_id, ":cur_troop", ":cur_agent"),
       (is_between, ":cur_troop", walkers_begin, walkers_end),
       (agent_get_slot, ":target_entry_point", ":cur_agent", 0),
       (try_begin),
         (eq, ":target_entry_point", 9),
         (assign, reg0, 0),
       (else_try),
         (eq, ":target_entry_point", 10),
         (assign, reg1, 0),
       (else_try),
         (eq, ":target_entry_point", 12),
         (assign, reg2, 0),
       (else_try),
         (eq, ":target_entry_point", 32),
         (assign, reg3, 0),
       (else_try),
         (eq, ":target_entry_point", 33),
         (assign, reg4, 0),
       (else_try),
         (eq, ":target_entry_point", 34),
         (assign, reg5, 0),
       (else_try),
         (eq, ":target_entry_point", 35),
         (assign, reg6, 0),
       (else_try),
         (eq, ":target_entry_point", 36),
         (assign, reg7, 0),
       (else_try),
         (eq, ":target_entry_point", 37),
         (assign, reg8, 0),
       (else_try),
         (eq, ":target_entry_point", 38),
         (assign, reg9, 0),
       (else_try),
         (eq, ":target_entry_point", 39),
         (assign, reg10, 0),
       (try_end),
     (try_end),
     (assign, ":try_limit", 100),
     (assign, ":target_entry_point", 0),
     (try_for_range, ":unused", 0, ":try_limit"),
       (shuffle_range, 0, 11),
       (gt, reg0, 0),
       (assign, ":target_entry_point", reg0),
       (assign, ":try_limit", 0),
     (try_end),
     (try_begin),
       (gt, ":target_entry_point", 0),
       (agent_set_slot, ":agent_no", 0, ":target_entry_point"),
       (entry_point_get_position, pos1, ":target_entry_point"),
       (try_begin),
         (lt, ":target_entry_point", 32),
         (init_position, pos2),
         (position_set_y, pos2, 250),
         (position_transform_position_to_parent, pos1, pos1, pos2),
       (try_end),
       (agent_set_scripted_destination, ":agent_no", pos1, 0),
       (agent_set_speed_limit, ":agent_no", 5),
     (try_end),
  ]),

  # script_town_init_doors
  # Input: door_state (-1 = closed, 1 = open, 0 = use $town_nighttime)
  # Output: none (required for siege mission templates)
  ("town_init_doors",
   [(store_script_param, ":door_state", 1),
    (try_begin),
      (assign, ":continue", 0),
      (try_begin),
        (eq, ":door_state", 1),
        (assign, ":continue", 1),
      (else_try),
        (eq, ":door_state", 0),
        (eq, "$town_nighttime", 0),
        (assign, ":continue", 1),
      (try_end),
      (eq, ":continue", 1),# open doors
      (assign, ":end_cond", 1),
      (try_for_range, ":i_instance", 0, ":end_cond"),
        (scene_prop_get_instance, ":object", "spr_towngate_door_left", ":i_instance"),
        (ge, ":object", 0),
        (val_add, ":end_cond", 1),
        (prop_instance_get_position, pos1, ":object"),
        (position_rotate_z, pos1, -100),
        (prop_instance_animate_to_position, ":object", pos1, 1),
      (try_end),
      (assign, ":end_cond", 1),
      (try_for_range, ":i_instance", 0, ":end_cond"),
        (scene_prop_get_instance, ":object", "spr_towngate_rectangle_door_left", ":i_instance"),
        (ge, ":object", 0),
        (val_add, ":end_cond", 1),
        (prop_instance_get_position, pos1, ":object"),
        (position_rotate_z, pos1, -80),
        (prop_instance_animate_to_position, ":object", pos1, 1),
      (try_end),
      (assign, ":end_cond", 1),
      (try_for_range, ":i_instance", 0, ":end_cond"),
        (scene_prop_get_instance, ":object", "spr_towngate_door_right", ":i_instance"),
        (ge, ":object", 0),
        (val_add, ":end_cond", 1),
        (prop_instance_get_position, pos1, ":object"),
        (position_rotate_z, pos1, 100),
        (prop_instance_animate_to_position, ":object", pos1, 1),
      (try_end),
      (assign, ":end_cond", 1),
      (try_for_range, ":i_instance", 0, ":end_cond"),
        (scene_prop_get_instance, ":object", "spr_towngate_rectangle_door_right", ":i_instance"),
        (ge, ":object", 0),
        (val_add, ":end_cond", 1),
        (prop_instance_get_position, pos1, ":object"),
        (position_rotate_z, pos1, 80),
        (prop_instance_animate_to_position, ":object", pos1, 1),
      (try_end),
    (try_end),
  ]),

  # script_siege_init_ai_and_belfry
  # Input: none
  # Output: none (required for siege mission templates)
  ("siege_init_ai_and_belfry",
   [(assign, "$cur_belfry_pos", 50),
    (assign, ":cur_belfry_object_pos", slot_scene_belfry_props_begin),
    (store_current_scene, ":cur_scene"),
    #Collecting belfry objects
    (try_for_range, ":i_belfry_instance", 0, 3),
      (scene_prop_get_instance, ":belfry_object", "spr_belfry_a", ":i_belfry_instance"),
      (ge, ":belfry_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_belfry_object_pos", ":belfry_object"),
      (val_add, ":cur_belfry_object_pos", 1),
    (try_end),
    (try_for_range, ":i_belfry_instance", 0, 3),
      (scene_prop_get_instance, ":belfry_object", "spr_belfry_platform_a", ":i_belfry_instance"),
      (ge, ":belfry_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_belfry_object_pos", ":belfry_object"),
      (val_add, ":cur_belfry_object_pos", 1),
    (try_end),
    (try_for_range, ":i_belfry_instance", 0, 3),
      (scene_prop_get_instance, ":belfry_object", "spr_belfry_platform_b", ":i_belfry_instance"),
      (ge, ":belfry_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_belfry_object_pos", ":belfry_object"),
      (val_add, ":cur_belfry_object_pos", 1),
    (try_end),
    (assign, "$belfry_rotating_objects_begin", ":cur_belfry_object_pos"),
    (try_for_range, ":i_belfry_instance", 0, 5),
      (scene_prop_get_instance, ":belfry_object", "spr_belfry_wheel", ":i_belfry_instance"),
      (ge, ":belfry_object", 0),
      (scene_set_slot, ":cur_scene", ":cur_belfry_object_pos", ":belfry_object"),
      (val_add, ":cur_belfry_object_pos", 1),
    (try_end),
    (assign, "$last_belfry_object_pos", ":cur_belfry_object_pos"),

    #Lifting up the platform  at the beginning
    (try_begin),
      (scene_prop_get_instance, ":belfry_object_to_rotate", "spr_belfry_platform_a", 0),
    (try_end),

    #Moving the belfry objects to their starting position
    (entry_point_get_position,pos1,55),
    (entry_point_get_position,pos3,50),
    (try_for_range, ":i_belfry_object_pos", slot_scene_belfry_props_begin, "$last_belfry_object_pos"),
      (assign, ":pos_no", pos_belfry_begin),
      (val_add, ":pos_no", ":i_belfry_object_pos"),
      (val_sub, ":pos_no", slot_scene_belfry_props_begin),
      (scene_get_slot, ":cur_belfry_object", ":cur_scene", ":i_belfry_object_pos"),
      (prop_instance_get_position, pos2, ":cur_belfry_object"),
      (try_begin),
        (eq, ":cur_belfry_object", ":belfry_object_to_rotate"),
        (position_rotate_x, pos2, 90),
      (try_end),
      (position_transform_position_to_local, ":pos_no", pos1, pos2),
      (position_transform_position_to_parent, pos4, pos3, ":pos_no"),
      (prop_instance_animate_to_position, ":cur_belfry_object", pos4, 1),
    (try_end),
    (assign, "$belfry_positioned", 0),
    (assign, "$belfry_num_slots_positioned", 0),
    (assign, "$belfry_num_men_pushing", 0),

    (set_show_messages, 0),
    (team_give_order, "$attacker_team", grc_everyone, mordr_stand_ground),
    (team_give_order, "$attacker_team_2", grc_everyone, mordr_stand_ground),
    (set_show_messages, 1),
  ]),

  # script_cf_siege_move_belfry
  # Input: none
  # Output: none (required for siege mission templates)
  ("cf_siege_move_belfry",
   [(neq, "$last_belfry_object_pos", slot_scene_belfry_props_begin),
    (entry_point_get_position,pos1,50),
    (entry_point_get_position,pos4,55),
    (get_distance_between_positions, ":total_distance", pos4, pos1),
    (store_current_scene, ":cur_scene"),
    (scene_get_slot, ":first_belfry_object", ":cur_scene", slot_scene_belfry_props_begin),
    (prop_instance_get_position, pos2, ":first_belfry_object"),
    (entry_point_get_position,pos1,"$cur_belfry_pos"),
    (position_transform_position_to_parent, pos3, pos1, pos_belfry_begin),
    (position_transform_position_to_parent, pos5, pos4, pos_belfry_begin),
    (get_distance_between_positions, ":cur_distance", pos2, pos3),
    (get_distance_between_positions, ":distance_left", pos2, pos5),
    (try_begin),
      (le, ":cur_distance", 10),
      (val_add, "$cur_belfry_pos", 1),
      (entry_point_get_position,pos1,"$cur_belfry_pos"),
      (position_transform_position_to_parent, pos3, pos1, pos_belfry_begin),
      (get_distance_between_positions, ":cur_distance", pos2, pos3),
    (try_end),
    (neq, "$cur_belfry_pos", 50),

    (assign, ":base_speed", 20),
    (store_div, ":slow_range", ":total_distance", 60),
    (store_sub, ":distance_moved", ":total_distance", ":distance_left"),

    (try_begin),
      (lt, ":distance_moved", ":slow_range"),
      (store_mul, ":base_speed", ":distance_moved", -60),
      (val_div, ":base_speed", ":slow_range"),
      (val_add, ":base_speed", 80),
    (else_try),
      (lt, ":distance_left", ":slow_range"),
      (store_mul, ":base_speed", ":distance_left", -60),
      (val_div, ":base_speed", ":slow_range"),
      (val_add, ":base_speed", 80),
    (try_end),
    (store_mul, ":belfry_speed", ":cur_distance", ":base_speed"),
    (try_begin),
      (eq, "$belfry_num_men_pushing", 0),
      (assign, ":belfry_speed", 1000000),
    (else_try),
      (val_div, ":belfry_speed", "$belfry_num_men_pushing"),
    (try_end),

    (try_begin),
      (le, "$cur_belfry_pos", 55),
      (init_position, pos3),
      (position_rotate_x, pos3, ":distance_moved"),
      (scene_get_slot, ":base_belfry_object", ":cur_scene", slot_scene_belfry_props_begin),
      (prop_instance_get_position, pos4, ":base_belfry_object"),
      (entry_point_get_position,pos1,"$cur_belfry_pos"),
      (try_for_range, ":i_belfry_object_pos", slot_scene_belfry_props_begin, "$last_belfry_object_pos"),
        (scene_get_slot, ":cur_belfry_object", ":cur_scene", ":i_belfry_object_pos"),
        (try_begin),
          (ge, ":i_belfry_object_pos", "$belfry_rotating_objects_begin"),
          (prop_instance_get_starting_position, pos5, ":base_belfry_object"),
          (prop_instance_get_starting_position, pos6, ":cur_belfry_object"),
          (position_transform_position_to_local, pos7, pos5, pos6),
          (position_transform_position_to_parent, pos5, pos4, pos7),
          (position_transform_position_to_parent, pos6, pos5, pos3),
          (prop_instance_set_position, ":cur_belfry_object", pos6),
        (else_try),
          (assign, ":pos_no", pos_belfry_begin),
          (val_add, ":pos_no", ":i_belfry_object_pos"),
          (val_sub, ":pos_no", slot_scene_belfry_props_begin),
          (position_transform_position_to_parent, pos2, pos1, ":pos_no"),
          (prop_instance_animate_to_position, ":cur_belfry_object", pos2, ":belfry_speed"),
        (try_end),
      (try_end),
    (try_end),
    (gt, "$cur_belfry_pos", 55),
    (assign, "$belfry_positioned", 1),
  ]),

  # script_cf_siege_rotate_belfry_platform
  # Input: none
  # Output: none (required for siege mission templates)
  ("cf_siege_rotate_belfry_platform",
   [(eq, "$belfry_positioned", 1),
    (scene_prop_get_instance, ":belfry_object", "spr_belfry_platform_a", 0),
    (prop_instance_get_position, pos1, ":belfry_object"),
    (position_rotate_x, pos1, -90),
    (prop_instance_animate_to_position, ":belfry_object", pos1, 400),
    (assign, "$belfry_positioned", 2),
  ]),

  # script_cf_siege_assign_men_to_belfry
  # Input: none
  # Output: none (required for siege mission templates)
  ("cf_siege_assign_men_to_belfry",
   [
##    (store_mission_timer_a, ":cur_seconds"),
    (neq, "$last_belfry_object_pos", slot_scene_belfry_props_begin),
    (assign, ":end_trigger", 0),
    (try_begin),
      (lt, "$belfry_positioned", 3),
      (get_player_agent_no, ":player_agent"),
      (store_current_scene, ":cur_scene"),
      (scene_get_slot, ":first_belfry_object", ":cur_scene", slot_scene_belfry_props_begin),
      (prop_instance_get_position, pos2, ":first_belfry_object"),
      (assign, ":slot_1_positioned", 0),
      (assign, ":slot_2_positioned", 0),
      (assign, ":slot_3_positioned", 0),
      (assign, ":slot_4_positioned", 0),
      (assign, ":slot_5_positioned", 0),
      (assign, ":slot_6_positioned", 0),
      (assign, "$belfry_num_slots_positioned", 0),
      (assign, "$belfry_num_men_pushing", 0),
      (try_for_agents, ":cur_agent"),
        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (try_begin),
          (agent_get_slot, ":x_pos", ":cur_agent", slot_agent_target_x_pos),
          (neq, ":x_pos", 0),
          (agent_get_slot, ":y_pos", ":cur_agent", slot_agent_target_y_pos),
          (try_begin),
            (eq, ":x_pos", -600),
            (try_begin),
              (eq, ":y_pos", 0),
              (assign, ":slot_1_positioned", 1),
            (else_try),
              (eq, ":y_pos", -200),
              (assign, ":slot_2_positioned", 1),
            (else_try),
              (assign, ":slot_3_positioned", 1),
            (try_end),
          (else_try),
            (try_begin),
              (eq, ":y_pos", 0),
              (assign, ":slot_4_positioned", 1),
            (else_try),
              (eq, ":y_pos", -200),
              (assign, ":slot_5_positioned", 1),
            (else_try),
              (assign, ":slot_6_positioned", 1),
            (try_end),
          (try_end),
          (val_add, "$belfry_num_slots_positioned", 1),
          (init_position, pos1),
          (position_move_x, pos1, ":x_pos"),
          (position_move_y, pos1, ":y_pos"),
          (init_position, pos3),
          (position_move_x, pos3, ":x_pos"),
          (position_move_y, pos3, -1000),
          (position_transform_position_to_parent, pos4, pos2, pos1),
          (position_transform_position_to_parent, pos5, pos2, pos3),
          (agent_get_position, pos6, ":cur_agent"),
          (get_distance_between_positions, ":target_distance", pos6, pos4),
          (get_distance_between_positions, ":waypoint_distance", pos6, pos5),
          (try_begin),
            (this_or_next|lt, ":target_distance", ":waypoint_distance"),
            (lt, ":waypoint_distance", 600),
            (agent_set_scripted_destination, ":cur_agent", pos4, 1),
          (else_try),
            (agent_set_scripted_destination, ":cur_agent", pos5, 1),
          (try_end),
          (try_begin),
            (le, ":target_distance", 300),
            (val_add, "$belfry_num_men_pushing", 1),
          (try_end),
##        (else_try),
##          (agent_get_team, ":cur_agent_team", ":cur_agent"),
##          (this_or_next|eq, "$attacker_team", ":cur_agent_team"),
##          (             eq, "$attacker_team_2", ":cur_agent_team"),
##          (try_begin),
##            (gt, ":cur_seconds", 20),
##            (agent_get_position, pos1, ":cur_agent"),
##            (agent_set_scripted_destination, ":cur_agent", pos1, 0),
##          (else_try),
##            (try_begin),
##              (team_get_movement_order, ":order1", "$attacker_team", grc_infantry),
##              (team_get_movement_order, ":order2", "$attacker_team", grc_cavalry),
##              (team_get_movement_order, ":order3", "$attacker_team", grc_archers),
##              (this_or_next|neq, ":order1", mordr_stand_ground),
##              (this_or_next|neq, ":order2", mordr_stand_ground),
##              (neq, ":order3", mordr_stand_ground),
##              (set_show_messages, 0),
##              (team_give_order, "$attacker_team", grc_everyone, mordr_stand_ground),
##              (set_show_messages, 1),
##            (try_end),
##          (try_end),
        (try_end),
      (try_end),
      (try_begin),
        (lt, "$belfry_num_slots_positioned", 6),
        (try_for_agents, ":cur_agent"),
          (agent_is_alive, ":cur_agent"),
          (agent_get_team, ":cur_agent_team", ":cur_agent"),
          (this_or_next|eq, "$attacker_team", ":cur_agent_team"),
          (eq, "$attacker_team_2", ":cur_agent_team"),
          (neq, ":player_agent", ":cur_agent"),
          (agent_get_class, ":agent_class", ":cur_agent"),
          (this_or_next|eq, ":agent_class", grc_infantry),
          (eq, ":agent_class", grc_cavalry),
          (agent_get_slot, ":x_pos", ":cur_agent", 1),
          (eq, ":x_pos", 0),
          (assign, ":y_pos", 0),
          (try_begin),
            (eq, ":slot_1_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_1_positioned", 1),
          (else_try),
            (eq, ":slot_2_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_2_positioned", 1),
          (else_try),
            (eq, ":slot_3_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_3_positioned", 1),
          (else_try),
            (eq, ":slot_4_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_4_positioned", 1),
          (else_try),
            (eq, ":slot_5_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_5_positioned", 1),
          (else_try),
            (eq, ":slot_6_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_6_positioned", 1),
          (try_end),
          (val_add, "$belfry_num_slots_positioned", 1),
          (agent_set_slot, ":cur_agent", 1, ":x_pos"),
          (agent_set_slot, ":cur_agent", 2, ":y_pos"),
        (try_end),
      (try_end),
      (try_begin),
        (store_mission_timer_a, ":cur_timer"),
        (gt, ":cur_timer", 20),
        (lt, "$belfry_num_slots_positioned", 6),
        (try_for_agents, ":cur_agent"),
          (agent_is_alive, ":cur_agent"),
          (agent_get_team, ":cur_agent_team", ":cur_agent"),
          (this_or_next|eq, "$attacker_team", ":cur_agent_team"),
          (             eq, "$attacker_team_2", ":cur_agent_team"),
          (neq, ":player_agent", ":cur_agent"),
          (agent_get_slot, ":x_pos", ":cur_agent", 1),
          (eq, ":x_pos", 0),
          (assign, ":y_pos", 0),
          (try_begin),
            (eq, ":slot_1_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_1_positioned", 1),
          (else_try),
            (eq, ":slot_2_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_2_positioned", 1),
          (else_try),
            (eq, ":slot_3_positioned", 0),
            (assign, ":x_pos", -600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_3_positioned", 1),
          (else_try),
            (eq, ":slot_4_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", 0),
            (val_add, ":slot_4_positioned", 1),
          (else_try),
            (eq, ":slot_5_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -200),
            (val_add, ":slot_5_positioned", 1),
          (else_try),
            (eq, ":slot_6_positioned", 0),
            (assign, ":x_pos", 600),
            (assign, ":y_pos", -400),
            (val_add, ":slot_6_positioned", 1),
          (try_end),
          (val_add, "$belfry_num_slots_positioned", 1),
          (agent_set_slot, ":cur_agent", 1, ":x_pos"),
          (agent_set_slot, ":cur_agent", 2, ":y_pos"),
        (try_end),
      (try_end),
    (else_try),
      (assign, ":end_trigger", 1),
      (try_for_agents, ":cur_agent"),
        (agent_clear_scripted_mode, ":cur_agent"),
      (try_end),
      (set_show_messages, 0),
      (team_give_order, "$attacker_team", grc_everyone, mordr_charge),
      (set_show_messages, 1),
    (try_end),
    (eq, ":end_trigger", 1),
  ]),

  # script_siege_move_archers_to_archer_positions
  # Input: none
  # Output: none
  ("siege_move_archers_to_archer_positions",
   [
     (try_for_agents, ":agent_no"),
       (agent_is_alive, ":agent_no"),
       (agent_slot_eq, ":agent_no", slot_agent_is_not_reinforcement, 0),
       (agent_is_defender, ":agent_no"),
       (agent_get_class, ":agent_class", ":agent_no"),
       (agent_get_troop_id, ":agent_troop", ":agent_no"),
       (eq, ":agent_class", grc_archers),
       (try_begin),
         (agent_slot_eq, ":agent_no", slot_agent_target_entry_point, 0),
         (store_random_in_range, ":random_entry_point", 40, 44), #40, 48? dckplmc
         (agent_set_slot, ":agent_no", slot_agent_target_entry_point, ":random_entry_point"),
       (try_end),
       (try_begin),
         (agent_get_position, pos0, ":agent_no"),
         (entry_point_get_position, pos1, ":random_entry_point"),
         (get_distance_between_positions, ":dist", pos0, pos1),
         (lt, ":dist", 300),
         (agent_clear_scripted_mode, ":agent_no"),
         (agent_set_slot, ":agent_no", slot_agent_is_in_scripted_mode, 0),
         (agent_set_slot, ":agent_no", slot_agent_is_not_reinforcement, 1),
         (str_store_troop_name, s1, ":agent_troop"),
         (assign, reg0, ":agent_no"),
#         (display_message, "@{s1} ({reg0}) reached pos"),
       (else_try),
         (agent_get_simple_behavior, ":agent_sb", ":agent_no"),
         (agent_get_combat_state, ":agent_cs", ":agent_no"),
         (this_or_next|eq, ":agent_sb", aisb_ranged),
         (eq, ":agent_sb", aisb_go_to_pos),#scripted mode
         (eq, ":agent_cs", 7), # 7 = no visible targets (state for ranged units)
         (try_begin),
           (agent_slot_eq, ":agent_no", slot_agent_is_in_scripted_mode, 0),
           (agent_set_scripted_destination, ":agent_no", pos1, 0),
           (agent_set_slot, ":agent_no", slot_agent_is_in_scripted_mode, 1),
           (str_store_troop_name, s1, ":agent_troop"),
           (assign, reg0, ":agent_no"),
#           (display_message, "@{s1} ({reg0}) moving to pos"),
         (try_end),
       (else_try),
         (try_begin),
           (agent_slot_eq, ":agent_no", slot_agent_is_in_scripted_mode, 1),
           (agent_clear_scripted_mode, ":agent_no"),
           (agent_set_slot, ":agent_no", slot_agent_is_in_scripted_mode, 0),
           (str_store_troop_name, s1, ":agent_troop"),
           (assign, reg0, ":agent_no"),
#           (display_message, "@{s1} ({reg0}) seeing target or changed mode"),
         (try_end),
       (try_end),
     (try_end),
     ]),


  # script_store_movement_order_name_to_s1
  # Input: arg1 = team_no, arg2 = class_no
  # Output: s1 = order_name
  ("store_movement_order_name_to_s1",
   [(store_script_param_1, ":team_no"),
    (store_script_param_2, ":class_no"),
    (team_get_movement_order, ":cur_order", ":team_no", ":class_no"),
    (try_begin),
      (eq, ":cur_order", mordr_hold),
      (str_store_string, s1, "@Holding"),
    (else_try),
      (eq, ":cur_order", mordr_follow),
      (str_store_string, s1, "@Following"),
    (else_try),
      (eq, ":cur_order", mordr_charge),
      (str_store_string, s1, "@Charging"),
    (else_try),
      (eq, ":cur_order", mordr_advance),
      (str_store_string, s1, "@Advancing"),
    (else_try),
      (eq, ":cur_order", mordr_fall_back),
      (str_store_string, s1, "@Falling Back"),
    (else_try),
      (eq, ":cur_order", mordr_stand_closer),
      (str_store_string, s1, "@Standing Closer"),
    (else_try),
      (eq, ":cur_order", mordr_spread_out),
      (str_store_string, s1, "@Spreading Out"),
    (else_try),
      (eq, ":cur_order", mordr_stand_ground),
      (str_store_string, s1, "@Standing"),
    (else_try),
      (str_store_string, s1, "@N/A"),
    (try_end),
  ]),

  # script_store_riding_order_name_to_s1
  # Input: arg1 = team_no, arg2 = class_no
  # Output: s1 = order_name
  ("store_riding_order_name_to_s1",
   [(store_script_param_1, ":team_no"),
    (store_script_param_2, ":class_no"),
    (team_get_riding_order, ":cur_order", ":team_no", ":class_no"),
    (try_begin),
      (eq, ":cur_order", rordr_free),
      (str_store_string, s1, "@Free"),
    (else_try),
      (eq, ":cur_order", rordr_mount),
      (str_store_string, s1, "@Mount"),
    (else_try),
      (eq, ":cur_order", rordr_dismount),
      (str_store_string, s1, "@Dismount"),
    (else_try),
      (str_store_string, s1, "@N/A"),
    (try_end),
  ]),

  # script_store_weapon_usage_order_name_to_s1
  # Input: arg1 = team_no, arg2 = class_no
  # Output: s1 = order_name
  ("store_weapon_usage_order_name_to_s1",
   [(store_script_param_1, ":team_no"),
    (store_script_param_2, ":class_no"),
    (team_get_weapon_usage_order, ":cur_order", ":team_no", ":class_no"),
    (team_get_hold_fire_order, ":cur_hold_fire", ":team_no", ":class_no"),
    (try_begin),
      (eq, ":cur_order", wordr_use_any_weapon),
      (eq, ":cur_hold_fire", aordr_fire_at_will),
      (str_store_string, s1, "@Any Weapon"),
    (else_try),
      (eq, ":cur_order", wordr_use_blunt_weapons),
      (eq, ":cur_hold_fire", aordr_fire_at_will),
      (str_store_string, s1, "@Blunt Weapons"),
    (else_try),
      (eq, ":cur_order", wordr_use_any_weapon),
      (eq, ":cur_hold_fire", aordr_hold_your_fire),
      (str_store_string, s1, "str_hold_fire"),
    (else_try),
      (eq, ":cur_order", wordr_use_blunt_weapons),
      (eq, ":cur_hold_fire", aordr_hold_your_fire),
      (str_store_string, s1, "str_blunt_hold_fire"),
    (else_try),
      (str_store_string, s1, "@N/A"),
    (try_end),
  ]),

  # script_team_give_order_from_order_panel
  # Input: arg1 = leader_agent_no, arg2 = class_no
  # Output: none
  ("team_give_order_from_order_panel",
   [(store_script_param_1, ":leader_agent_no"),
    (store_script_param_2, ":order"),
    (agent_get_team, ":team_no", ":leader_agent_no"),
    #(set_show_messages, 0),
    (try_begin),
      (eq, "$g_formation_group0_selected", 1),
      (team_give_order, ":team_no", 0, ":order"),
    (try_end),
    (try_begin),
      (eq, "$g_formation_group1_selected", 1),
      (team_give_order, ":team_no", 1, ":order"),
    (try_end),
    (try_begin),
      (eq, "$g_formation_group2_selected", 1),
      (team_give_order, ":team_no", 2, ":order"),
    (try_end),
    (try_begin),
      (eq, "$g_formation_group3_selected", 1),
      (team_give_order, ":team_no", 3, ":order"),
    (try_end),
    (try_begin),
      (eq, "$g_formation_group4_selected", 1),
      (team_give_order, ":team_no", 4, ":order"),
    (try_end),
    (try_begin),
      (eq, "$g_formation_group5_selected", 1),
      (team_give_order, ":team_no", 5, ":order"),
    (try_end),
    (try_begin),
      (eq, "$g_formation_group6_selected", 1),
      (team_give_order, ":team_no", 6, ":order"),
    (try_end),
    (try_begin),
      (eq, "$g_formation_group7_selected", 1),
      (team_give_order, ":team_no", 7, ":order"),
    (try_end),
    (try_begin),
      (eq, "$g_formation_group8_selected", 1),
      (team_give_order, ":team_no", 8, ":order"),
    (try_end),

    (try_begin),
      (eq, ":order", mordr_hold),
      (agent_get_position, pos1, ":leader_agent_no"),
      (try_begin),
        (eq, "$g_formation_group0_selected", 1),
        (team_set_order_position, ":team_no", 0, pos1),
      (try_end),
      (try_begin),
        (eq, "$g_formation_group1_selected", 1),
        (team_set_order_position, ":team_no", 1, pos1),
      (try_end),
      (try_begin),
        (eq, "$g_formation_group2_selected", 1),
        (team_set_order_position, ":team_no", 2, pos1),
      (try_end),
      (try_begin),
        (eq, "$g_formation_group3_selected", 1),
        (team_set_order_position, ":team_no", 3, pos1),
      (try_end),
      (try_begin),
        (eq, "$g_formation_group4_selected", 1),
        (team_set_order_position, ":team_no", 4, pos1),
      (try_end),
      (try_begin),
        (eq, "$g_formation_group5_selected", 1),
        (team_set_order_position, ":team_no", 5, pos1),
      (try_end),
      (try_begin),
        (eq, "$g_formation_group6_selected", 1),
        (team_set_order_position, ":team_no", 6, pos1),
      (try_end),
      (try_begin),
        (eq, "$g_formation_group7_selected", 1),
        (team_set_order_position, ":team_no", 7, pos1),
      (try_end),
      (try_begin),
        (eq, "$g_formation_group8_selected", 1),
        (team_set_order_position, ":team_no", 8, pos1),
      (try_end),
    (try_end),
    (call_script, "script_player_order_formations", ":order"),
    #(set_show_messages, 1),
  ]),


  # script_update_order_panel
  # Input: arg1 = team_no
  # Output: none
  ("update_order_panel",
   [(store_script_param_1, ":team_no"),
    (set_fixed_point_multiplier, 1000),

    #ozan added
    (try_begin),
      (eq, "$group0_has_troops", 1),
      (call_script, "script_store_movement_order_name_to_s1", ":team_no", 0),
      (overlay_set_text, "$g_presentation_but0_movement", s1),
      (call_script, "script_store_riding_order_name_to_s1", ":team_no", 0),
      (overlay_set_text, "$g_presentation_but0_riding", s1),
      (call_script, "script_store_weapon_usage_order_name_to_s1", ":team_no", 0),
      (overlay_set_text, "$g_presentation_but0_weapon_usage", s1),
    (try_end),
    (try_begin),
      (eq, "$group1_has_troops", 1),
      (call_script, "script_store_movement_order_name_to_s1", ":team_no", 1),
      (overlay_set_text, "$g_presentation_but1_movement", s1),
      (call_script, "script_store_riding_order_name_to_s1", ":team_no", 1),
      (overlay_set_text, "$g_presentation_but1_riding", s1),
      (call_script, "script_store_weapon_usage_order_name_to_s1", ":team_no", 1),
      (overlay_set_text, "$g_presentation_but1_weapon_usage", s1),
    (try_end),
    (try_begin),
      (eq, "$group2_has_troops", 1),
      (call_script, "script_store_movement_order_name_to_s1", ":team_no", 2),
      (overlay_set_text, "$g_presentation_but2_movement", s1),
      (call_script, "script_store_riding_order_name_to_s1", ":team_no", 2),
      (overlay_set_text, "$g_presentation_but2_riding", s1),
      (call_script, "script_store_weapon_usage_order_name_to_s1", ":team_no", 2),
      (overlay_set_text, "$g_presentation_but2_weapon_usage", s1),
    (try_end),
    (try_begin),
      (eq, "$group3_has_troops", 1),
      (call_script, "script_store_movement_order_name_to_s1", ":team_no", 3),
      (overlay_set_text, "$g_presentation_but3_movement", s1),
      (call_script, "script_store_riding_order_name_to_s1", ":team_no", 3),
      (overlay_set_text, "$g_presentation_but3_riding", s1),
      (call_script, "script_store_weapon_usage_order_name_to_s1", ":team_no", 3),
      (overlay_set_text, "$g_presentation_but3_weapon_usage", s1),
    (try_end),
    (try_begin),
      (eq, "$group4_has_troops", 1),
      (call_script, "script_store_movement_order_name_to_s1", ":team_no", 4),
      (overlay_set_text, "$g_presentation_but4_movement", s1),
      (call_script, "script_store_riding_order_name_to_s1", ":team_no", 4),
      (overlay_set_text, "$g_presentation_but4_riding", s1),
      (call_script, "script_store_weapon_usage_order_name_to_s1", ":team_no", 4),
      (overlay_set_text, "$g_presentation_but4_weapon_usage", s1),
    (try_end),
    (try_begin),
      (eq, "$group5_has_troops", 1),
      (call_script, "script_store_movement_order_name_to_s1", ":team_no", 5),
      (overlay_set_text, "$g_presentation_but5_movement", s1),
      (call_script, "script_store_riding_order_name_to_s1", ":team_no", 5),
      (overlay_set_text, "$g_presentation_but5_riding", s1),
      (call_script, "script_store_weapon_usage_order_name_to_s1", ":team_no", 5),
      (overlay_set_text, "$g_presentation_but5_weapon_usage", s1),
    (try_end),
    (try_begin),
      (eq, "$group6_has_troops", 1),
      (call_script, "script_store_movement_order_name_to_s1", ":team_no", 6),
      (overlay_set_text, "$g_presentation_but6_movement", s1),
      (call_script, "script_store_riding_order_name_to_s1", ":team_no", 6),
      (overlay_set_text, "$g_presentation_but6_riding", s1),
      (call_script, "script_store_weapon_usage_order_name_to_s1", ":team_no", 6),
      (overlay_set_text, "$g_presentation_but6_weapon_usage", s1),
    (try_end),
    (try_begin),
      (eq, "$group7_has_troops", 1),
      (call_script, "script_store_movement_order_name_to_s1", ":team_no", 7),
      (overlay_set_text, "$g_presentation_but7_movement", s1),
      (call_script, "script_store_riding_order_name_to_s1", ":team_no", 7),
      (overlay_set_text, "$g_presentation_but7_riding", s1),
      (call_script, "script_store_weapon_usage_order_name_to_s1", ":team_no", 7),
      (overlay_set_text, "$g_presentation_but7_weapon_usage", s1),
    (try_end),
    (try_begin),
      (eq, "$group8_has_troops", 1),
      (call_script, "script_store_movement_order_name_to_s1", ":team_no", 8),
      (overlay_set_text, "$g_presentation_but8_movement", s1),
      (call_script, "script_store_riding_order_name_to_s1", ":team_no", 8),
      (overlay_set_text, "$g_presentation_but8_riding", s1),
      (call_script, "script_store_weapon_usage_order_name_to_s1", ":team_no", 8),
      (overlay_set_text, "$g_presentation_but8_weapon_usage", s1),
    (try_end),

    #ozan added
    (assign, ":stat_position_y", 660),
    (try_begin),
      (position_set_y, pos1, ":stat_position_y"),
      (eq, "$group0_has_troops", 1),
      (position_set_x, pos1, 270),
      (overlay_set_position, "$g_presentation_but0_movement", pos1),
      (position_set_x, pos1, 410),
      (overlay_set_position, "$g_presentation_but0_riding", pos1),
      (position_set_x, pos1, 550),
      (overlay_set_position, "$g_presentation_but0_weapon_usage", pos1),
      (val_add, ":stat_position_y", -40),
    (try_end),
    (try_begin),
      (position_set_y, pos1, ":stat_position_y"),
      (eq, "$group1_has_troops", 1),
      (position_set_x, pos1, 270),
      (overlay_set_position, "$g_presentation_but1_movement", pos1),
      (position_set_x, pos1, 410),
      (overlay_set_position, "$g_presentation_but1_riding", pos1),
      (position_set_x, pos1, 550),
      (overlay_set_position, "$g_presentation_but1_weapon_usage", pos1),
      (val_add, ":stat_position_y", -40),
    (try_end),
    (try_begin),
      (position_set_y, pos1, ":stat_position_y"),
      (eq, "$group2_has_troops", 1),
      (position_set_x, pos1, 270),
      (overlay_set_position, "$g_presentation_but2_movement", pos1),
      (position_set_x, pos1, 410),
      (overlay_set_position, "$g_presentation_but2_riding", pos1),
      (position_set_x, pos1, 550),
      (overlay_set_position, "$g_presentation_but2_weapon_usage", pos1),
      (val_add, ":stat_position_y", -40),
    (try_end),
    (try_begin),
      (position_set_y, pos1, ":stat_position_y"),
      (eq, "$group3_has_troops", 1),
      (position_set_x, pos1, 270),
      (overlay_set_position, "$g_presentation_but3_movement", pos1),
      (position_set_x, pos1, 410),
      (overlay_set_position, "$g_presentation_but3_riding", pos1),
      (position_set_x, pos1, 550),
      (overlay_set_position, "$g_presentation_but3_weapon_usage", pos1),
      (val_add, ":stat_position_y", -40),
    (try_end),
    (try_begin),
      (position_set_y, pos1, ":stat_position_y"),
      (eq, "$group4_has_troops", 1),
      (position_set_x, pos1, 270),
      (overlay_set_position, "$g_presentation_but4_movement", pos1),
      (position_set_x, pos1, 410),
      (overlay_set_position, "$g_presentation_but4_riding", pos1),
      (position_set_x, pos1, 550),
      (overlay_set_position, "$g_presentation_but4_weapon_usage", pos1),
      (val_add, ":stat_position_y", -40),
    (try_end),
    (try_begin),
      (position_set_y, pos1, ":stat_position_y"),
      (eq, "$group5_has_troops", 1),
      (position_set_x, pos1, 270),
      (overlay_set_position, "$g_presentation_but5_movement", pos1),
      (position_set_x, pos1, 410),
      (overlay_set_position, "$g_presentation_but5_riding", pos1),
      (position_set_x, pos1, 550),
      (overlay_set_position, "$g_presentation_but5_weapon_usage", pos1),
      (val_add, ":stat_position_y", -40),
    (try_end),
    (try_begin),
      (position_set_y, pos1, ":stat_position_y"),
      (eq, "$group6_has_troops", 1),
      (position_set_x, pos1, 270),
      (overlay_set_position, "$g_presentation_but6_movement", pos1),
      (position_set_x, pos1, 410),
      (overlay_set_position, "$g_presentation_but6_riding", pos1),
      (position_set_x, pos1, 550),
      (overlay_set_position, "$g_presentation_but6_weapon_usage", pos1),
      (val_add, ":stat_position_y", -40),
    (try_end),
    (try_begin),
      (position_set_y, pos1, ":stat_position_y"),
      (eq, "$group7_has_troops", 1),
      (position_set_x, pos1, 270),
      (overlay_set_position, "$g_presentation_but7_movement", pos1),
      (position_set_x, pos1, 410),
      (overlay_set_position, "$g_presentation_but7_riding", pos1),
      (position_set_x, pos1, 550),
      (overlay_set_position, "$g_presentation_but7_weapon_usage", pos1),
      (val_add, ":stat_position_y", -40),
    (try_end),
    (try_begin),
      (position_set_y, pos1, ":stat_position_y"),
      (eq, "$group8_has_troops", 1),
      (position_set_x, pos1, 270),
      (overlay_set_position, "$g_presentation_but8_movement", pos1),
      (position_set_x, pos1, 410),
      (overlay_set_position, "$g_presentation_but8_riding", pos1),
      (position_set_x, pos1, 550),
      (overlay_set_position, "$g_presentation_but8_weapon_usage", pos1),
      (val_add, ":stat_position_y", -40),
    (try_end),
  ]),

  # script_update_agent_position_on_map
  # Input: arg1 = agent_no, pos2 = map_size_pos
  # Output: none
  ("update_agent_position_on_map",
   [(store_script_param_1, ":agent_no"),
    (agent_get_slot, ":agent_overlay", ":agent_no", slot_agent_map_overlay_id),

    (get_player_agent_no, ":player_agent"),
    (try_begin),
      (le, ":agent_overlay", 0),
      (set_fixed_point_multiplier, 1000),
      (try_begin),
        (eq, ":agent_no", ":player_agent"),
        (create_mesh_overlay, reg1, "mesh_player_dot"),
        (position_set_x, pos1, 500),
        (position_set_y, pos1, 500),
        (overlay_set_size, reg1, pos1),
      (else_try),
        (create_mesh_overlay, reg1, "mesh_white_dot"),
        (position_set_x, pos1, 200),
        (position_set_y, pos1, 200),
        (overlay_set_size, reg1, pos1),
      (try_end),
      (overlay_set_alpha, reg1, 0x88),
      (agent_set_slot, ":agent_no", slot_agent_map_overlay_id, reg1),
      (assign, ":agent_overlay", reg1),
    (try_end),

    (try_begin),
      (neq, ":agent_no", ":player_agent"),
      (agent_get_party_id, ":agent_party", ":agent_no"),
      (try_begin),
        (eq, ":agent_party", "p_main_party"),
        (agent_get_division, ":agent_division", ":agent_no"),
        (try_begin),
          (eq, ":agent_division", 0),
          (overlay_set_color, ":agent_overlay", 0x8d5220),
        (else_try),
          (eq, ":agent_division", 1),
          (overlay_set_color, ":agent_overlay", 0x34c6e4),
        (else_try),
          (eq, ":agent_division", 2),
          (overlay_set_color, ":agent_overlay", 0x569619),
        (else_try),
          (eq, ":agent_division", 3),
          (overlay_set_color, ":agent_overlay", 0xFFE500),
        (else_try),
          (eq, ":agent_division", 4),
          (overlay_set_color, ":agent_overlay", 0x990099),
        (else_try),
          (eq, ":agent_division", 5),
          (overlay_set_color, ":agent_overlay", 0x99FE80),
        (else_try),
          (eq, ":agent_division", 6),
          (overlay_set_color, ":agent_overlay", 0x9DEFFE),
        (else_try),
          (eq, ":agent_division", 7),
          (overlay_set_color, ":agent_overlay", 0xFECB9D),
        (else_try),
          (eq, ":agent_division", 8),
          (overlay_set_color, ":agent_overlay", 0xB19C9C),
        (try_end),
      (else_try),
        (agent_is_ally, ":agent_no"),
        (overlay_set_color, ":agent_overlay", 0x5555FF),
      (else_try),
        (overlay_set_color, ":agent_overlay", 0xFF0000),
      (try_end),
    (try_end),

    (try_begin),
      (eq, ":agent_no", ":player_agent"),
      (agent_get_look_position, pos1, ":agent_no"),
      (position_get_rotation_around_z, ":rot", pos1),
      (init_position, pos10),
      (position_rotate_z, pos10, ":rot"),
      (overlay_set_mesh_rotation, ":agent_overlay", pos10),
      (call_script, "script_convert_3d_pos_to_map_pos"),
    (else_try),
      (agent_get_position, pos1, ":agent_no"),
      (call_script, "script_convert_3d_pos_to_map_pos"),
    (try_end),
    (overlay_set_position, ":agent_overlay", pos0),
  ]),

  # script_convert_3d_pos_to_map_pos
  # Input: pos1 = 3d_pos, pos2 = map_size_pos
  # Output: pos0 = map_pos
  ("convert_3d_pos_to_map_pos",
   [(set_fixed_point_multiplier, 1000),
    (position_transform_position_to_local, pos3, pos2, pos1),
    (position_get_x, ":agent_x_pos", pos3),
    (position_get_y, ":agent_y_pos", pos3),
    (val_div, ":agent_x_pos", "$g_battle_map_scale"),
    (val_div, ":agent_y_pos", "$g_battle_map_scale"),
    (set_fixed_point_multiplier, 1000),
    (store_sub, ":map_x", 980, "$g_battle_map_width"),
    (store_sub, ":map_y", 730, "$g_battle_map_height"),
    (val_add, ":agent_x_pos", ":map_x"),
    (val_add, ":agent_y_pos", ":map_y"),
    (position_set_x, pos0, ":agent_x_pos"),
    (position_set_y, pos0, ":agent_y_pos"),
  ]),

  # script_update_order_flags_on_map
  # Input: none
  # Output: none
  ("update_order_flags_on_map",
   [(set_fixed_point_multiplier, 1000),
    (get_player_agent_no, ":player_agent"),
    (agent_get_team, ":player_team", ":player_agent"),

    (get_scene_boundaries, pos2, pos3),

    (team_get_movement_order, ":cur_order", ":player_team", grc_infantry),
    (try_begin),
      (eq, "$group0_has_troops", 1),
      (eq, ":cur_order", mordr_hold),
      (team_get_order_position, pos1, ":player_team", grc_infantry),
      (call_script, "script_convert_3d_pos_to_map_pos"),
      (overlay_set_alpha, "$g_battle_map_infantry_order_flag", 0xFF),
      (overlay_set_position, "$g_battle_map_infantry_order_flag", pos0),
    (else_try),
      (overlay_set_alpha, "$g_battle_map_infantry_order_flag", 0),
    (try_end),
    (team_get_movement_order, ":cur_order", ":player_team", grc_archers),
    (try_begin),
      (eq, "$group1_has_troops", 1),
      (eq, ":cur_order", mordr_hold),
      (team_get_order_position, pos1, ":player_team", grc_archers),
      (call_script, "script_convert_3d_pos_to_map_pos"),
      (overlay_set_alpha, "$g_battle_map_archers_order_flag", 0xFF),
      (overlay_set_position, "$g_battle_map_archers_order_flag", pos0),
    (else_try),
      (overlay_set_alpha, "$g_battle_map_archers_order_flag", 0),
    (try_end),
    (team_get_movement_order, ":cur_order", ":player_team", grc_cavalry),
    (try_begin),
      (eq, "$group2_has_troops", 1),
      (eq, ":cur_order", mordr_hold),
      (team_get_order_position, pos1, ":player_team", grc_cavalry),
      (call_script, "script_convert_3d_pos_to_map_pos"),
      (overlay_set_alpha, "$g_battle_map_cavalry_order_flag", 0xFF),
      (overlay_set_position, "$g_battle_map_cavalry_order_flag", pos0),
    (else_try),
      (overlay_set_alpha, "$g_battle_map_cavalry_order_flag", 0),
    (try_end),
    (team_get_movement_order, ":cur_order", ":player_team", 3), ######
    (try_begin),
      (eq, "$group3_has_troops", 1),
      (eq, ":cur_order", mordr_hold),
      (team_get_order_position, pos1, ":player_team", 3),
      (call_script, "script_convert_3d_pos_to_map_pos"),
      (overlay_set_alpha, "$g_battle_map_spears_order_flag", 0xFF),
      (overlay_set_position, "$g_battle_map_spears_order_flag", pos0),
    (else_try),
      (overlay_set_alpha, "$g_battle_map_spears_order_flag", 0),
    (try_end),
    (team_get_movement_order, ":cur_order", ":player_team", 4),
    (try_begin),
      (eq, "$group4_has_troops", 1),
      (eq, ":cur_order", mordr_hold),
      (team_get_order_position, pos1, ":player_team", 4),
      (call_script, "script_convert_3d_pos_to_map_pos"),
      (overlay_set_alpha, "$g_battle_map_skirmishers_order_flag", 0xFF),
      (overlay_set_position, "$g_battle_map_skirmishers_order_flag", pos0),
    (else_try),
      (overlay_set_alpha, "$g_battle_map_skirmishers_order_flag", 0),
    (try_end),
    (team_get_movement_order, ":cur_order", ":player_team", 5),
    (try_begin),
      (eq, "$group5_has_troops", 1),
      (eq, ":cur_order", mordr_hold),
      (team_get_order_position, pos1, ":player_team", 5),
      (call_script, "script_convert_3d_pos_to_map_pos"),
      (overlay_set_alpha, "$g_battle_map_horsemen_order_flag", 0xFF),
      (overlay_set_position, "$g_battle_map_horsemen_order_flag", pos0),
    (else_try),
      (overlay_set_alpha, "$g_battle_map_horsemen_order_flag", 0),
    (try_end),
    (team_get_movement_order, ":cur_order", ":player_team", 6),
    (try_begin),
      (eq, "$group6_has_troops", 1),
      (eq, ":cur_order", mordr_hold),
      (team_get_order_position, pos1, ":player_team", 6),
      (call_script, "script_convert_3d_pos_to_map_pos"),
      (overlay_set_alpha, "$g_battle_map_d7_order_flag", 0xFF),
      (overlay_set_position, "$g_battle_map_d7_order_flag", pos0),
    (else_try),
      (overlay_set_alpha, "$g_battle_map_d7_order_flag", 0),
    (try_end),
    (team_get_movement_order, ":cur_order", ":player_team", 7),
    (try_begin),
      (eq, "$group7_has_troops", 1),
      (eq, ":cur_order", mordr_hold),
      (team_get_order_position, pos1, ":player_team", 7),
      (call_script, "script_convert_3d_pos_to_map_pos"),
      (overlay_set_alpha, "$g_battle_map_d8_order_flag", 0xFF),
      (overlay_set_position, "$g_battle_map_d8_order_flag", pos0),
    (else_try),
      (overlay_set_alpha, "$g_battle_map_d8_order_flag", 0),
    (try_end),
    (team_get_movement_order, ":cur_order", ":player_team", 8),
    (try_begin),
      (eq, "$group8_has_troops", 1),
      (eq, ":cur_order", mordr_hold),
      (team_get_order_position, pos1, ":player_team", 8),
      (call_script, "script_convert_3d_pos_to_map_pos"),
      (overlay_set_alpha, "$g_battle_map_d9_order_flag", 0xFF),
      (overlay_set_position, "$g_battle_map_d9_order_flag", pos0),
    (else_try),
      (overlay_set_alpha, "$g_battle_map_d9_order_flag", 0),
    (try_end),
  ]),

  # script_update_order_panel_checked_classes
  # Input: none
  # Output: none
  ("update_order_panel_checked_classes",
   [(get_player_agent_no, ":player_agent"),
    (agent_get_team, ":player_team", ":player_agent"),

    (try_begin),
      (eq, "$group0_has_troops", 1),
      (class_is_listening_order, ":player_team", 0),
      (overlay_set_val, "$g_presentation_obj_battle_check0", 1),
      (assign, "$g_formation_group0_selected", 1),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but0", 250, 0x44),
    (else_try),
      (eq, "$group0_has_troops", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check0", 0),
      (assign, "$g_formation_group0_selected", 0),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but0", 250, 0),
    (try_end),
    (try_begin),
      (eq, "$group1_has_troops", 1),
      (class_is_listening_order, ":player_team", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check1", 1),
      (assign, "$g_formation_group1_selected", 1),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but1", 250, 0x44),
    (else_try),
      (eq, "$group1_has_troops", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check1", 0),
      (assign, "$g_formation_group1_selected", 0),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but1", 250, 0),
    (try_end),
    (try_begin),
      (eq, "$group2_has_troops", 1),
      (class_is_listening_order, ":player_team", 2),
      (overlay_set_val, "$g_presentation_obj_battle_check2", 1),
      (assign, "$g_formation_group2_selected", 1),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but2", 250, 0x44),
    (else_try),
      (eq, "$group2_has_troops", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check2", 0),
      (assign, "$g_formation_group2_selected", 0),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but2", 250, 0),
    (try_end),
    (try_begin),
      (eq, "$group3_has_troops", 1),
      (class_is_listening_order, ":player_team", 3),
      (overlay_set_val, "$g_presentation_obj_battle_check3", 1),
      (assign, "$g_formation_group3_selected", 1),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but3", 250, 0x44),
    (else_try),
      (eq, "$group3_has_troops", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check3", 0),
      (assign, "$g_formation_group3_selected", 0),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but3", 250, 0),
    (try_end),
    (try_begin),
      (eq, "$group4_has_troops", 1),
      (class_is_listening_order, ":player_team", 4),
      (overlay_set_val, "$g_presentation_obj_battle_check4", 1),
      (assign, "$g_formation_group4_selected", 1),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but4", 250, 0x44),
    (else_try),
      (eq, "$group4_has_troops", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check4", 0),
      (assign, "$g_formation_group4_selected", 0),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but4", 250, 0),
    (try_end),
    (try_begin),
      (eq, "$group5_has_troops", 1),
      (class_is_listening_order, ":player_team", 5),
      (overlay_set_val, "$g_presentation_obj_battle_check5", 1),
      (assign, "$g_formation_group5_selected", 1),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but5", 250, 0x44),
    (else_try),
      (eq, "$group5_has_troops", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check5", 0),
      (assign, "$g_formation_group5_selected", 0),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but5", 250, 0),
    (try_end),
    (try_begin),
      (eq, "$group6_has_troops", 1),
      (class_is_listening_order, ":player_team", 6),
      (overlay_set_val, "$g_presentation_obj_battle_check6", 1),
      (assign, "$g_formation_group6_selected", 1),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but6", 250, 0x44),
    (else_try),
      (eq, "$group6_has_troops", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check6", 0),
      (assign, "$g_formation_group6_selected", 0),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but6", 250, 0),
    (try_end),
    (try_begin),
      (eq, "$group7_has_troops", 1),
      (class_is_listening_order, ":player_team", 7),
      (overlay_set_val, "$g_presentation_obj_battle_check7", 1),
      (assign, "$g_formation_group7_selected", 1),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but7", 250, 0x44),
    (else_try),
      (eq, "$group7_has_troops", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check7", 0),
      (assign, "$g_formation_group7_selected", 0),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but7", 250, 0),
    (try_end),
    (try_begin),
      (eq, "$group8_has_troops", 1),
      (class_is_listening_order, ":player_team", 8),
      (overlay_set_val, "$g_presentation_obj_battle_check8", 1),
      (assign, "$g_formation_group8_selected", 1),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but8", 250, 0x44),
    (else_try),
      (eq, "$group8_has_troops", 1),
      (overlay_set_val, "$g_presentation_obj_battle_check8", 0),
      (assign, "$g_formation_group8_selected", 0),
      (overlay_animate_to_alpha, "$g_presentation_obj_battle_but8", 250, 0),
    (try_end),
  ]),

  # script_update_order_panel_statistics_and_map
  # Input: none
  # Output: none
  ("update_order_panel_statistics_and_map", #TODO: Call this in every battle mission template, once per second
   [(set_fixed_point_multiplier, 1000),

    (assign, ":num_us_ready_group0", 0),
    (assign, ":num_us_ready_group1", 0),
    (assign, ":num_us_ready_group2", 0),
    (assign, ":num_us_ready_group3", 0),
    (assign, ":num_us_ready_group4", 0),
    (assign, ":num_us_ready_group5", 0),
    (assign, ":num_us_ready_group6", 0),
    (assign, ":num_us_ready_group7", 0),
    (assign, ":num_us_ready_group8", 0),

    (assign, ":num_us_ready_men", 0),
    (assign, ":num_us_wounded_men", 0),
    (assign, ":num_us_routed_men", 0),
    (assign, ":num_us_dead_men", 0),
    (assign, ":num_allies_ready_men", 0),
    (assign, ":num_allies_wounded_men", 0),
    (assign, ":num_allies_routed_men", 0),
    (assign, ":num_allies_dead_men", 0),
    (assign, ":num_enemies_ready_men", 0),
    (assign, ":num_enemies_wounded_men", 0),
    (assign, ":num_enemies_routed_men", 0),
    (assign, ":num_enemies_dead_men", 0),

    (get_scene_boundaries, pos2, pos3),

    (try_for_agents,":cur_agent"),
      (agent_is_human, ":cur_agent"),
      (agent_get_division, ":agent_division", ":cur_agent"),
      (agent_get_party_id, ":agent_party", ":cur_agent"),
      (agent_get_slot, ":agent_overlay", ":cur_agent", slot_agent_map_overlay_id),
      (try_begin),
        (eq, ":agent_party", "p_main_party"),
        (try_begin),
          (agent_is_alive, ":cur_agent"),
          (call_script, "script_update_agent_position_on_map", ":cur_agent"),
          (try_begin),
            (eq, ":agent_division", 0),
            (val_add, ":num_us_ready_group0", 1),
            (eq, "$group0_has_troops", 1), #added to solve problem. test this.
          (else_try),
            (eq, ":agent_division", 1),
            (val_add, ":num_us_ready_group1", 1),
            (eq, "$group1_has_troops", 1), #added to solve problem.
          (else_try),
            (eq, ":agent_division", 2),
            (val_add, ":num_us_ready_group2", 1),
            (eq, "$group2_has_troops", 1), #added to solve problem.
          (else_try),
            (eq, ":agent_division", 3),
            (val_add, ":num_us_ready_group3", 1),
            (eq, "$group3_has_troops", 1), #added to solve problem.
          (else_try),
            (eq, ":agent_division", 4),
            (val_add, ":num_us_ready_group4", 1),
            (eq, "$group4_has_troops", 1), #added to solve problem.
          (else_try),
            (eq, ":agent_division", 5),
            (val_add, ":num_us_ready_group5", 1),
            (eq, "$group5_has_troops", 1), #added to solve problem.
          (else_try),
            (eq, ":agent_division", 6),
            (val_add, ":num_us_ready_group6", 1),
            (eq, "$group6_has_troops", 1), #added to solve problem.
          (else_try),
            (eq, ":agent_division", 7),
            (val_add, ":num_us_ready_group7", 1),
            (eq, "$group7_has_troops", 1), #added to solve problem.
          (else_try),
            (eq, ":agent_division", 8),
            (val_add, ":num_us_ready_group8", 1),
            (eq, "$group8_has_troops", 1), #added to solve problem.
          (try_end),
          (val_add, ":num_us_ready_men", 1),
        (else_try),
          (overlay_set_alpha, ":agent_overlay", 0),
          (agent_is_wounded, ":cur_agent"),
          (val_add, ":num_us_wounded_men", 1),
        (else_try),
          (agent_is_routed, ":cur_agent"),
          (val_add, ":num_us_routed_men", 1),
        (else_try),
          (val_add, ":num_us_dead_men", 1),
        (try_end),
      (else_try),
        (agent_is_ally, ":cur_agent"),
        (try_begin),
          (agent_is_alive, ":cur_agent"),
          (call_script, "script_update_agent_position_on_map", ":cur_agent"),
          (val_add, ":num_allies_ready_men", 1),
        (else_try),
          (overlay_set_alpha, ":agent_overlay", 0),
          (agent_is_wounded, ":cur_agent"),
          (val_add, ":num_allies_wounded_men", 1),
        (else_try),
          (agent_is_routed, ":cur_agent"),
          (val_add, ":num_allies_routed_men", 1),
        (else_try),
          (val_add, ":num_allies_dead_men", 1),
        (try_end),
      (else_try),
        (try_begin),
          (agent_is_alive, ":cur_agent"),
          (call_script, "script_update_agent_position_on_map", ":cur_agent"),
          (val_add, ":num_enemies_ready_men", 1),
        (else_try),
          (overlay_set_alpha, ":agent_overlay", 0),
          (agent_is_wounded, ":cur_agent"),
          (val_add, ":num_enemies_wounded_men", 1),
        (else_try),
          (agent_is_routed, ":cur_agent"),
          (val_add, ":num_enemies_routed_men", 1),
        (else_try),
          (val_add, ":num_enemies_dead_men", 1),
        (try_end),
      (try_end),
    (try_end),

    (assign, reg1, ":num_us_ready_group0"),
    (assign, reg2, ":num_us_ready_group1"),
    (assign, reg3, ":num_us_ready_group2"),
    (assign, reg4, ":num_us_ready_group3"),
    (assign, reg5, ":num_us_ready_group4"),
    (assign, reg6, ":num_us_ready_group5"),
    (assign, reg7, ":num_us_ready_group6"),
    (assign, reg8, ":num_us_ready_group7"),
    (assign, reg9, ":num_us_ready_group8"),
    (assign, reg10, ":num_us_ready_men"),
    (assign, reg11, ":num_us_wounded_men"),
    (assign, reg12, ":num_us_routed_men"),
    (assign, reg13, ":num_us_dead_men"),
    (assign, reg14, ":num_allies_ready_men"),
    (assign, reg15, ":num_allies_wounded_men"),
    (assign, reg16, ":num_allies_routed_men"),
    (assign, reg17, ":num_allies_dead_men"),
    (assign, reg18, ":num_enemies_ready_men"),
    (assign, reg19, ":num_enemies_wounded_men"),
    (assign, reg20, ":num_enemies_routed_men"),
    (assign, reg21, ":num_enemies_dead_men"),

    (try_begin),
      (eq, "$group0_has_troops", 1),
      (str_store_class_name, s1, 0),
      (overlay_set_text, "$g_presentation_obj_battle_name0", "str_s1_reg1"),
    (try_end),
    (try_begin),
      (eq, "$group1_has_troops", 1),
      (str_store_class_name, s1, 1),
      (overlay_set_text, "$g_presentation_obj_battle_name1", "str_s1_reg2"),
    (try_end),
    (try_begin),
      (eq, "$group2_has_troops", 1),
      (str_store_class_name, s1, 2),
      (overlay_set_text, "$g_presentation_obj_battle_name2", "str_s1_reg3"),
    (try_end),
    (try_begin),
      (eq, "$group3_has_troops", 1),
      (str_store_class_name, s1, 3),
      (overlay_set_text, "$g_presentation_obj_battle_name3", "str_s1_reg4"),
    (try_end),
    (try_begin),
      (eq, "$group4_has_troops", 1),
      (str_store_class_name, s1, 4),
      (overlay_set_text, "$g_presentation_obj_battle_name4", "str_s1_reg5"),
    (try_end),
    (try_begin),
      (eq, "$group5_has_troops", 1),
      (str_store_class_name, s1, 5),
      (overlay_set_text, "$g_presentation_obj_battle_name5", "str_s1_reg6"),
    (try_end),
    (try_begin),
      (eq, "$group6_has_troops", 1),
      (str_store_class_name, s1, 6),
      (overlay_set_text, "$g_presentation_obj_battle_name6", "str_s1_reg7"),
    (try_end),
    (try_begin),
      (eq, "$group7_has_troops", 1),
      (str_store_class_name, s1, 7),
      (overlay_set_text, "$g_presentation_obj_battle_name7", "str_s1_reg8"),
    (try_end),
    (try_begin),
      (eq, "$group8_has_troops", 1),
      (str_store_class_name, s1, 8),
      (overlay_set_text, "$g_presentation_obj_battle_name8", "str_s1_reg9"),
    (try_end),

    (overlay_set_text, "$g_battle_us_ready", "@{!}{reg10}"),
    (overlay_set_text, "$g_battle_us_wounded", "@{!}{reg11}"),
    (overlay_set_text, "$g_battle_us_routed", "@{!}{reg12}"),
    (overlay_set_text, "$g_battle_us_dead", "str_reg13"),
    (overlay_set_text, "$g_battle_allies_ready", "str_reg14"),
    (overlay_set_text, "$g_battle_allies_wounded", "str_reg15"),
    (overlay_set_text, "$g_battle_allies_routed", "str_reg16"),
    (overlay_set_text, "$g_battle_allies_dead", "str_reg17"),
    (overlay_set_text, "$g_battle_enemies_ready", "str_reg18"),
    (overlay_set_text, "$g_battle_enemies_wounded", "str_reg19"),
    (overlay_set_text, "$g_battle_enemies_routed", "str_reg20"),
    (overlay_set_text, "$g_battle_enemies_dead", "str_reg21"),

    (assign, ":stat_position_x", 675),
    (assign, ":stat_position_y", 280),
    (val_add, ":stat_position_x", 70),
    (val_add, ":stat_position_y", 60),
    (position_set_x, pos1, ":stat_position_x"),
    (position_set_y, pos1, ":stat_position_y"),
    (overlay_set_position, "$g_battle_us_ready", pos1),
    (val_add, ":stat_position_x", 70),
    (position_set_x, pos1, ":stat_position_x"),
    (overlay_set_position, "$g_battle_us_wounded", pos1),
    (val_add, ":stat_position_x", 70),
    (position_set_x, pos1, ":stat_position_x"),
    (overlay_set_position, "$g_battle_us_routed", pos1),
    (val_add, ":stat_position_x", 70),
    (position_set_x, pos1, ":stat_position_x"),
    (overlay_set_position, "$g_battle_us_dead", pos1),
    (val_add, ":stat_position_x", -210),
    (val_add, ":stat_position_y", -30),
    (position_set_x, pos1, ":stat_position_x"),
    (position_set_y, pos1, ":stat_position_y"),
    (overlay_set_position, "$g_battle_allies_ready", pos1),
    (val_add, ":stat_position_x", 70),
    (position_set_x, pos1, ":stat_position_x"),
    (overlay_set_position, "$g_battle_allies_wounded", pos1),
    (val_add, ":stat_position_x", 70),
    (position_set_x, pos1, ":stat_position_x"),
    (overlay_set_position, "$g_battle_allies_routed", pos1),
    (val_add, ":stat_position_x", 70),
    (position_set_x, pos1, ":stat_position_x"),
    (overlay_set_position, "$g_battle_allies_dead", pos1),
    (val_add, ":stat_position_x", -210),
    (val_add, ":stat_position_y", -30),
    (position_set_x, pos1, ":stat_position_x"),
    (position_set_y, pos1, ":stat_position_y"),
    (overlay_set_position, "$g_battle_enemies_ready", pos1),
    (val_add, ":stat_position_x", 70),
    (position_set_x, pos1, ":stat_position_x"),
    (overlay_set_position, "$g_battle_enemies_wounded", pos1),
    (val_add, ":stat_position_x", 70),
    (position_set_x, pos1, ":stat_position_x"),
    (overlay_set_position, "$g_battle_enemies_routed", pos1),
    (val_add, ":stat_position_x", 70),
    (position_set_x, pos1, ":stat_position_x"),
    (overlay_set_position, "$g_battle_enemies_dead", pos1),

    (call_script, "script_update_order_flags_on_map"),
  ]),

 # script_set_town_picture
  # Input: none
  # Output: none
  ("set_town_picture",
   [
        (try_begin),
          (party_get_current_terrain, ":cur_terrain", "$current_town"),
          (party_slot_eq,"$current_town",slot_party_type, spt_town),
          (try_begin),
            (this_or_next|eq, ":cur_terrain", rt_steppe),
            (this_or_next|eq, ":cur_terrain", rt_steppe_forest),
            (this_or_next|eq, ":cur_terrain", rt_desert),
            (             eq, ":cur_terrain", rt_desert_forest),
            (set_background_mesh, "mesh_pic_towndes"),
          (else_try),
            (this_or_next|eq, ":cur_terrain", rt_snow),
            (             eq, ":cur_terrain", rt_snow_forest),
            (set_background_mesh, "mesh_pic_townsnow"),
          (else_try),
            (set_background_mesh, "mesh_pic_town1"),
          (try_end),
        (else_try),
          (party_slot_eq,"$current_town",slot_party_type, spt_castle),
          (try_begin),
            (this_or_next|eq, ":cur_terrain", rt_steppe),
            (this_or_next|eq, ":cur_terrain", rt_steppe_forest),
            (this_or_next|eq, ":cur_terrain", rt_desert),
            (             eq, ":cur_terrain", rt_desert_forest),
            (set_background_mesh, "mesh_pic_castledes"),
          (else_try),
            (this_or_next|eq, ":cur_terrain", rt_snow),
            (             eq, ":cur_terrain", rt_snow_forest),
            (set_background_mesh, "mesh_pic_castlesnow"),
          (else_try),
            (set_background_mesh, "mesh_pic_castle1"),
          (try_end),
        (else_try), #SB : enable for villages
          (party_slot_eq,"$current_town",slot_party_type, spt_village),
          (try_begin),
            (this_or_next|eq, ":cur_terrain", rt_steppe),
            (this_or_next|eq, ":cur_terrain", rt_steppe_forest),
            (this_or_next|eq, ":cur_terrain", rt_desert),
            (             eq, ":cur_terrain", rt_desert_forest),
            (set_background_mesh, "mesh_pic_village_s"),
          (else_try),
            (this_or_next|eq, ":cur_terrain", rt_snow),
            (             eq, ":cur_terrain", rt_snow_forest),
            (set_background_mesh, "mesh_pic_village_w"),
          (else_try),
            (set_background_mesh, "mesh_pic_village_p"),
          (try_end),
        (try_end),
    ]),


  # script_consume_food
  # Input: arg1: order of the food to be consumed
  # Output: none
  ("consume_food",
   [(store_script_param, ":selected_food", 1),
    (troop_get_inventory_capacity, ":capacity", "trp_player"),
    (try_for_range, ":cur_slot", 0, ":capacity"),
      (troop_get_inventory_slot, ":cur_item", "trp_player", ":cur_slot"),
      (is_between, ":cur_item", itm_raw_date_fruit, food_end),
      (neq, ":cur_item", "itm_furs"),
      (item_slot_eq, ":cur_item", slot_item_edible, 1),
      (troop_get_inventory_slot_modifier, ":item_modifier", "trp_player", ":cur_slot"),
      (neq, ":item_modifier", imod_rotten),
      #SB : TODO check for qst_deliver_wine items and prevent consumption
      (item_slot_eq, ":cur_item", slot_item_is_checked, 0),
      (item_set_slot, ":cur_item", slot_item_is_checked, 1),
      (val_sub, ":selected_food", 1),
      (lt, ":selected_food", 0),
      (assign, ":capacity", 0),
      (troop_inventory_slot_get_item_amount, ":cur_amount", "trp_player", ":cur_slot"),
      (val_sub, ":cur_amount", 1),
      (troop_inventory_slot_set_item_amount, "trp_player", ":cur_slot", ":cur_amount"),
    (try_end),
    ]),



  # script_calculate_troop_score_for_center
  # Input: arg1 = troop_no, arg2 = center_no
  # Output: reg0 = score
  ("calculate_troop_score_for_center",
   [(store_script_param, ":troop_no", 1),
    (store_script_param, ":center_no", 2),
    (assign, ":num_center_points", 1),
    (try_for_range, ":cur_center", centers_begin, centers_end),
      (assign, ":center_owned", 0),
      (try_begin),
        (eq, ":troop_no", "trp_player"),
        (party_slot_eq, ":cur_center", slot_town_lord, stl_reserved_for_player),
        (assign, ":center_owned", 1),
      (try_end),
      (this_or_next|party_slot_eq, ":cur_center", slot_town_lord, ":troop_no"),
      (eq, ":center_owned", 1),
      (try_begin),
        (party_slot_eq, ":cur_center", slot_party_type, spt_town),
        (val_add, ":num_center_points", 4),
      (else_try),
        (party_slot_eq, ":cur_center", slot_party_type, spt_castle),
        (val_add, ":num_center_points", 2),
      (else_try),
        (val_add, ":num_center_points", 1),
      (try_end),
    (try_end),
    (troop_get_slot, ":troop_renown", ":troop_no", slot_troop_renown),
    (store_add, ":score", 500, ":troop_renown"),
    (val_div, ":score", ":num_center_points"),
    (store_random_in_range, ":random", 50, 100),
    (val_mul, ":score", ":random"),
    (try_begin),
      (party_slot_eq, ":center_no", slot_center_last_taken_by_troop, ":troop_no"),
      (val_mul, ":score", 3),
      (val_div, ":score", 2),
  	##diplomacy start+
	#Take into account original/most-recent lord and home slots.
	#Fief allocations during rebellions are an example of when this would apply.
	(else_try),
	#Bonus for original owner
 		(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		(party_slot_ge, ":center_no", dplmc_slot_center_original_lord, 1),
		(party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":troop_no"),
		(val_mul, ":score", 3),
		(val_div, ":score", 2),
	(else_try),
	#Bonus for previous owner
 		(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		(party_slot_ge, ":center_no", dplmc_slot_center_ex_lord, 1),
		(party_slot_eq, ":center_no", dplmc_slot_center_ex_lord, ":troop_no"),
		(val_mul, ":score", 3),
		(val_div, ":score", 2),
	(else_try),
	#Bonus for lord claiming the center as home
 		(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		(troop_slot_eq, ":troop_no", slot_troop_home, ":center_no"),
		(val_mul, ":score", 3),
		(val_div, ":score", 2),
	##diplomacy end+
    (try_end),
    (try_begin),
      (eq, ":troop_no", "trp_player"),
       ##diplomacy start+ xxx Replaced next line (slot 0 is not the faction leader slot):
      #(faction_get_slot, ":faction_leader", "$players_kingdom"),
      (faction_get_slot, ":faction_leader", "$players_kingdom", slot_faction_leader),
      ##diplomacy end+
      (call_script, "script_troop_get_player_relation", ":faction_leader"),
      (assign, ":leader_relation", reg0),
      #(troop_get_slot, ":leader_relation", ":faction_leader", slot_troop_player_relation),
      (val_mul, ":leader_relation", 2),
      (val_add, ":score", ":leader_relation"),
    (try_end),
    (assign, reg0, ":score"),
    ]),


  # script_assign_lords_to_empty_centers
  # Input: none
  # Output: none
  #Now ONLY called from the start
  ("assign_lords_to_empty_centers",
   [

    (try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "str_assigning_lords_to_empty_centers"),
		(str_store_string, s65, "str_assign_lords_to_empty_centers_just_happened"),
		(call_script, "script_add_notification_menu", "mnu_debug_alert_from_s65", 0, 0),
    (try_end),

	(try_for_range, ":faction", kingdoms_begin, kingdoms_end),
		(faction_set_slot, ":faction", slot_faction_temp_slot, 0),
    (try_end),

	(try_for_range, ":active_npc", 0, active_npcs_end),
		(troop_set_slot, ":active_npc", slot_troop_temp_slot, 0),
    (try_end),

    #Factions will keep one unassigned center in reserve, unless they have landless lords
    (try_for_range, ":cur_center", centers_begin, centers_end),
	    (party_get_slot, ":center_lord", ":cur_center", slot_town_lord),
		(try_begin),
			(this_or_next|eq, ":center_lord", stl_unassigned),
				(eq, ":center_lord", stl_rejected_by_player),
			(store_faction_of_party, ":center_faction", ":cur_center"),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_party_name, s4, ":cur_center"),
				(str_store_faction_name, s5, ":center_faction"),
				(display_message, "str_s4_of_the_s5_is_unassigned"),
			(try_end),

			(faction_get_slot, ":number_of_unassigned_centers_plus_landless_lords", ":center_faction", slot_faction_temp_slot),
			(val_add, ":number_of_unassigned_centers_plus_landless_lords", 1),
			(faction_set_slot,  ":center_faction", slot_faction_temp_slot, ":number_of_unassigned_centers_plus_landless_lords"),
		(else_try),
			(eq, ":center_lord", stl_reserved_for_player),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_party_name, s4, ":cur_center"),
				(str_store_faction_name, s5, ":center_faction"),
				(display_message, "str_s4_of_the_s5_is_reserved_for_player"),
			(try_end),

		(else_try),
			(ge, ":center_lord", 0),
			(troop_set_slot, ":center_lord", slot_troop_temp_slot, 1),
		(try_end),
	(try_end),

	(try_for_range, ":active_npc", 0, active_npcs_end),
		(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),
		(this_or_next|gt, ":active_npc", "trp_player"),
			(eq, "$player_has_homage", 1),

		(troop_slot_eq, ":active_npc", slot_troop_temp_slot, 0),
		(store_faction_of_troop, ":npc_faction", ":active_npc"),

		(is_between, ":npc_faction", npc_kingdoms_begin, npc_kingdoms_end),

		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":active_npc"),
			(str_store_faction_name, s5, ":npc_faction"),
			(display_message, "str_s4_of_the_s5_has_no_fiefs"),
		(try_end),

		(faction_get_slot, ":number_of_unassigned_centers_plus_landless_lords", ":npc_faction", slot_faction_temp_slot),
		(val_add, ":number_of_unassigned_centers_plus_landless_lords", 1),
		(faction_set_slot,  ":npc_faction", slot_faction_temp_slot, ":number_of_unassigned_centers_plus_landless_lords"),
	(try_end),

   	(try_begin),
	  (eq, "$cheat_mode", 1),
 	  (try_for_range, ":faction", kingdoms_begin, kingdoms_end),
		(faction_get_slot, reg4, ":faction", slot_faction_temp_slot),
		(str_store_faction_name, s4, ":faction"),
		(display_message, "str_s4_unassigned_centers_plus_landless_lords_=_reg4"),
	  (try_end),
    (try_end),

	(try_for_range, ":cur_center", centers_begin, centers_end),
		(party_get_slot, ":center_lord", ":cur_center", slot_town_lord),
        (this_or_next|eq, ":center_lord", stl_unassigned),
			(eq, ":center_lord", stl_rejected_by_player),

        (store_faction_of_party, ":center_faction", ":cur_center"),
        (is_between, ":center_faction", kingdoms_begin, kingdoms_end),
        (neg|faction_slot_eq, ":center_faction", slot_faction_leader, "trp_player"),

        (try_begin),
	      (eq, "$cheat_mode", 1),
		  (str_store_party_name, s5, ":cur_center"),
	      (try_begin),
			(neg|faction_slot_ge, ":center_faction", slot_faction_temp_slot, 2),
			(str_store_faction_name, s4, ":center_faction"),
			(display_message, "str_s4_holds_s5_in_reserve"),
		  (try_end),
        (try_end),

		(faction_slot_ge, ":center_faction", slot_faction_temp_slot, 2),

		#(display_message, "@Considering grant of {s5}"),

		(assign, ":best_lord", -1),
		(assign, ":best_lord_score", -1),
		(try_begin),
			(eq, ":center_lord", stl_unassigned),
			(try_begin),
				(eq, "$players_kingdom", ":center_faction"),
				(eq, "$player_has_homage", 1),
				(assign, ":best_lord", stl_reserved_for_player),
				(call_script, "script_calculate_troop_score_for_center", "trp_player", ":cur_center"),
				(assign, ":best_lord_score", reg0),
			(try_end),
		(try_end),

		(try_for_range, ":cur_troop", active_npcs_begin, active_npcs_end),
			(troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
			(store_troop_faction, ":troop_faction", ":cur_troop"),
			(eq, ":troop_faction", ":center_faction"),

			(call_script, "script_calculate_troop_score_for_center", ":cur_troop", ":cur_center"),
			(assign, ":score", reg0),

			#This prioritizes granting of centers for troops which do not already have one
			(try_begin),
				(troop_slot_eq, ":cur_troop", slot_troop_temp_slot, 0),
				(is_between, ":cur_center", villages_begin, villages_end),
				(val_mul, ":score", 10),
			(try_end),

			(gt, ":score", ":best_lord_score"),
			(assign, ":best_lord_score", ":score"),
			(assign, ":best_lord", ":cur_troop"),
		(try_end),

	    #Adjust count of centers and lords
 		(try_begin),
			(this_or_next|ge, ":best_lord", 0),
				(eq, ":best_lord", stl_reserved_for_player),

			(faction_get_slot, ":landless_lords_plus_unassigned_centers", ":center_faction", slot_faction_temp_slot),
			(val_sub, ":landless_lords_plus_unassigned_centers", 1),

			(try_begin),
				(eq, ":best_lord", stl_reserved_for_player),
				(troop_slot_eq, "trp_player", slot_troop_temp_slot, 0),
				(troop_set_slot, "trp_player", slot_troop_temp_slot, 1),
				(val_sub, ":landless_lords_plus_unassigned_centers", 1),
			(else_try),
				(troop_slot_eq, ":best_lord", slot_troop_temp_slot, 0),
				(troop_set_slot, ":best_lord", slot_troop_temp_slot, 1),
				(val_sub, ":landless_lords_plus_unassigned_centers", 1),
			(try_end),

			(faction_set_slot, ":center_faction", slot_faction_temp_slot, ":landless_lords_plus_unassigned_centers"),
		(try_end),

	    #Give the center to the lord
		(try_begin),
			(ge, ":best_lord", 0),
			(call_script, "script_give_center_to_lord", ":cur_center", ":best_lord", 1),
		(else_try),
			(eq, ":best_lord", stl_reserved_for_player),
			(party_set_slot, ":cur_center", slot_town_lord, stl_reserved_for_player),
			(try_begin), #grant bound villages to player, if granting a castle
				(party_slot_eq, ":cur_center", slot_party_type, spt_castle),
#				(assign, ":give_at_least_one_village", 0),
				(try_for_range, ":cur_village", villages_begin, villages_end),
#					(eq, ":give_at_least_one_village", 0),
					(party_slot_eq, ":cur_village", slot_village_bound_center, ":cur_center"),
					(party_slot_eq, ":cur_village", slot_town_lord, stl_unassigned),
					(party_set_slot, ":cur_village", slot_town_lord, stl_reserved_for_player),
#					(assign, ":give_at_least_one_village", 1),
				(try_end),
			(try_end),
		(try_end),
    (try_end),
    ]),


  # script_create_village_farmer_party
  # Input: arg1 = village_no
  # Output: reg0 = party_no
  ("create_village_farmer_party",
   [(store_script_param, ":village_no", 1),
    (party_get_slot, ":town_no", ":village_no", slot_village_market_town),
    (store_faction_of_party, ":party_faction", ":town_no"),


#    (store_faction_of_party, ":town_faction", ":town_no"),
#    (try_begin),
#		(neq, ":town_faction", ":party_faction"),
#		(assign, ":town_no", -1),
#		(assign, ":score_to_beat", 9999),
#		(try_for_range, ":other_town", towns_begin, towns_end),
#			(store_faction_of_party, ":other_town_faction", ":town_no"),
#			(store_relation, ":relation", ":other_town_faction", ":party_faction"),
#			(ge, ":relation", 0),

#			(store_distance_to_party_from_party, ":distance", ":village_no", ":other_town"),
#			(lt, ":distance", ":score_to_beat"),
#			(assign, ":town_no", ":other_town"),
#			(assign, ":score_to_beat", ":distance"),
#		(try_end),
#	(try_end),

	(try_begin),
		(is_between, ":town_no", towns_begin, towns_end),
	    (set_spawn_radius, 0),
	    (spawn_around_party, ":village_no", "pt_village_farmers"),
	    (assign, ":new_party", reg0),

	    (party_set_faction, ":new_party", ":party_faction"),
	    (party_set_slot, ":new_party", slot_party_home_center, ":village_no"),
	    (party_set_slot, ":new_party", slot_party_last_traded_center, ":village_no"),

	    (party_set_slot, ":new_party", slot_party_type, spt_village_farmer),
	    (party_set_slot, ":new_party", slot_party_ai_state, spai_trading_with_town),
	    (party_set_slot, ":new_party", slot_party_ai_object, ":town_no"),
	    (party_set_ai_behavior, ":new_party", ai_bhvr_travel_to_party),
	    (party_set_ai_object, ":new_party", ":town_no"),
	    (party_set_flags, ":new_party", pf_default_behavior, 0),
	    (store_sub, ":item_to_price_slot", slot_town_trade_good_prices_begin, trade_goods_begin),
	    (try_for_range, ":cur_goods", trade_goods_begin, trade_goods_end),
	      (store_add, ":cur_good_price_slot", ":cur_goods", ":item_to_price_slot"),
	      (party_get_slot, ":cur_village_price", ":village_no", ":cur_good_price_slot"),
	      (party_set_slot, ":new_party", ":cur_good_price_slot", ":cur_village_price"),
	    (try_end),
	    (assign, reg0, ":new_party"),
	(try_end),

    ]),

  #script_do_party_center_trade
  # INPUT: arg1 = party_no, arg2 = center_no, arg3 = percentage_change_in_center
  # OUTPUT: reg0 = total_change
  ("do_party_center_trade",
    [
      (store_script_param, ":party_no", 1),
      (store_script_param, ":center_no", 2),
      (store_script_param, ":percentage_change", 3), #this should probably always be a constant. Currently it is 25
	  (assign, ":percentage_change", 30),
	  ##diplomacy start+
	  (party_get_slot, ":origin", ":party_no", slot_party_last_traded_center),
	  #If optional economic changes are enabled, reduce the percentage change in order
	  #to make prices feel less static.
	  (try_begin),
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		#Only apply lessened price movements to towns.
		(this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_town),
			(is_between, ":center_no", towns_begin, towns_end),
		#This halves the average impact as well as making it more variable.
		(val_add, ":percentage_change", 1),
		(store_random_in_range, ":percentage_change", 0, ":percentage_change"),
		#Display economics diagnostic
		(ge, "$cheat_mode", 3),
		(str_store_party_name, s3, ":origin"),
		(str_store_party_name, s4, ":center_no"),
		(assign, reg4, ":percentage_change"),
		(display_message, "@{!}DEBUG -- Trade from {s3} to {s4}: rolled random impact of {reg4}"),
	  (try_end),
	  ##diplomacy end+

	  (party_get_slot, ":origin", ":party_no", slot_party_last_traded_center),
	  (party_set_slot, ":party_no", slot_party_last_traded_center, ":center_no"),
	  ##diplomacy start+
	  #Update the record of trade route arrival times
      (try_begin),
         (ge, ":origin", centers_begin),
    	 ##zerilius changes begin
    	 # (this_or_next|party_slot_eq, ":origin", villages_begin, villages_end),
    	 (this_or_next|party_slot_eq, ":origin", slot_party_type, spt_village),
    	 ##zerilius changes end
         (is_between, ":origin", villages_begin, villages_end),
         (store_current_hours, ":cur_hours"),
         (party_set_slot, ":origin", dplmc_slot_village_trade_last_arrived_to_market, ":cur_hours"),
      (try_end),
      (try_begin),
	     (ge, ":origin", centers_begin),
		 (this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_town),
			(is_between, ":center_no", towns_begin, towns_end),
		 (store_current_hours, ":cur_hours"),
		 (try_for_range, ":trade_route_slot", slot_town_trade_routes_begin, slot_town_trade_routes_end),
            (party_slot_eq,  ":center_no", ":trade_route_slot", ":origin"),
			(store_sub, ":trade_route_arrival_slot", ":trade_route_slot", slot_town_trade_routes_begin),
			(val_add, ":trade_route_arrival_slot", dplmc_slot_town_trade_route_last_arrivals_begin),
			(is_between, ":trade_route_arrival_slot", dplmc_slot_town_trade_route_last_arrivals_begin, dplmc_slot_town_trade_route_last_arrivals_end),#this will always be true unless a modder increased the number of trade route slots without increasing the number of last arrival slots
			(party_set_slot, ":center_no", ":trade_route_arrival_slot", ":cur_hours"),
         (try_end),
         (else_try),
            (this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_village),
               (is_between, ":center_no", villages_begin, villages_end),
         (store_current_hours, ":cur_hours"),
         (party_set_slot, ":center_no", dplmc_slot_village_trade_last_returned_from_market, ":cur_hours"),
	  (try_end),
      #SB : drop off prisoners
      (try_begin),
        (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_HIGH),
        (is_between, ":center_no", walled_centers_begin, walled_centers_end),
        (store_faction_of_party, ":town_faction", ":center_no"),
        (store_faction_of_party, ":party_faction", ":party_no"),
        (eq, ":town_faction", ":party_faction"),
        (call_script, "script_party_prisoners_add_party_prisoners", ":center_no", ":party_no"),
        (call_script, "script_party_remove_all_prisoners", ":party_no"),
      (else_try), #sell off looted items
        (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_MEDIUM),
        (is_between, ":center_no", towns_begin, towns_end),
        (party_get_slot, ":num_items", ":party_no", slot_party_next_looted_item_slot),
        (is_between, ":num_items", 1, num_party_loot_slots + 1), #has any loot
         # (this_or_next|eq, ":num_items", 0),
        (party_get_slot, ":town_merchant", ":center_no", slot_town_merchant),
        (party_get_slot, ":town_weapon", ":center_no", slot_town_weaponsmith),
        (party_get_slot, ":town_armor", ":center_no", slot_town_armorer),
        (party_get_slot, ":town_horse", ":center_no", slot_town_horse_merchant),

        #apply penalty with 0 trade skill for farmer, 2 for caravan masters
        (assign, ":seller_troop", -1), #0 skill
        (try_begin),
          (party_get_slot, ":spt", ":party_no", slot_party_type),
          # (eq, ":spt", spt_village_farmer),
          # (assign, ":seller_troop", -1), #0 skill
        # (else_try),
          (eq, ":spt", spt_kingdom_caravan),
          (assign, ":seller_troop", "trp_caravan_master"), #knows_common, 2 skill
        (else_try),
          (eq, ":spt", spt_kingdom_hero_party),
          (party_stack_get_troop_id, ":seller_troop", ":party_no", 0),
        (try_end),
        (val_add, ":num_items", slot_party_looted_item_1),
        (try_for_range, ":slot_no", slot_party_looted_item_1, ":num_items"),
          (party_get_slot, ":item_no", ":party_no", ":slot_no"),
          (gt, ":item_no", 0),
          (item_get_type, ":itp", ":item_no"),
          (store_add, ":imod_slot", ":slot_no", num_party_loot_slots),
          (party_get_slot, ":imod_no", ":party_no", ":imod_slot"),
          (item_get_type, ":itp", ":item_no"),
          (try_begin),
            (this_or_next|is_between, ":itp", itp_type_one_handed_wpn, itp_type_goods),
            (is_between, ":itp", itp_type_pistol, itp_type_animal),
            (assign, ":merchant", ":town_weapon"),
          (else_try),
            (is_between, ":itp", itp_type_head_armor, itp_type_pistol),
            (assign, ":merchant", ":town_armor"),
          (else_try),
            (eq, ":itp", itp_type_horse),
            (assign, ":merchant", ":town_horse"),
          (else_try),
            (assign, ":merchant", ":town_merchant"),
          (try_end),
          (gt, ":merchant", 0),
          (store_troop_gold, ":merchant_gold", ":merchant"),
          (call_script, "script_dplmc_get_item_value_with_imod", ":item_no", ":imod_no"),
          (store_div, ":price", reg0, 4), #or some other factor

          (call_script, "script_dplmc_get_trade_penalty", ":item_no", ":center_no", ":seller_troop", ":merchant"),
          (val_mul, ":price", reg0),
          (val_div, ":price", 100),
          (val_max, ":price", 1),
          (gt, ":merchant_gold", ":price"), #can afford
          (troop_remove_gold, ":merchant", ":price"),
          (troop_add_item, ":merchant", ":item_no", ":imod_no"),
          # (party_set_slot, ":party_no", ":slot_no", -1), #clear off later
          # (party_set_slot, ":party_no", ":imod_slot", -1),
        (try_end),

        #any unsold item at this point are cleared
        (try_for_range, ":slot_no", slot_party_next_looted_item_slot, slot_party_looted_item_1_modifier + num_party_loot_slots),
          (party_set_slot, ":party_no", ":slot_no", 0),
        (try_end),

      (try_end),
	  ##diplomacy end+

      (assign, ":total_change", 0),
      (store_sub, ":item_to_price_slot", slot_town_trade_good_prices_begin, trade_goods_begin),
      (try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
        (store_add, ":cur_good_price_slot", ":cur_good", ":item_to_price_slot"),
        (party_get_slot, ":cur_merchant_price", ":party_no", ":cur_good_price_slot"),
        (party_get_slot, ":cur_center_price", ":center_no", ":cur_good_price_slot"),
        (store_sub, ":price_dif", ":cur_merchant_price", ":cur_center_price"),
        (assign, ":cur_change", ":price_dif"),
        (val_abs, ":cur_change"),
        (val_add, ":total_change", ":cur_change"),
        (val_mul, ":cur_change", ":percentage_change"),
        (val_div, ":cur_change", 100),

		#This is to reconvert from absolute value
        (try_begin),
          (lt, ":price_dif", 0),
          (val_mul, ":cur_change", -1),
        (try_end),

		(assign, ":initial_price", ":cur_center_price"),

		#The new price for the caravan or peasant is set before the change, so the prices in the trading town have full effect on the next center
        (party_set_slot, ":party_no", ":cur_good_price_slot", ":cur_center_price"),

        (val_add, ":cur_center_price", ":cur_change"),
        (party_set_slot, ":center_no", ":cur_good_price_slot", ":cur_center_price"),

		(try_begin),
			(eq, "$cheat_mode", 3),
			(str_store_party_name, s3, ":origin"),
			(str_store_party_name, s4, ":center_no"),
			(str_store_item_name, s5, ":cur_good"),
			(assign, reg4, ":initial_price"),
			(assign, reg5, ":cur_center_price"),
			(display_log_message, "@{!}DEBUG -- Trade of {s5} from {s3} to {s4} brings price from {reg4} to {reg5}"),
		(try_end),

      (try_end),
      (assign, reg0, ":total_change"),
  ]),

  #script_player_join_faction
  # INPUT: arg1 = faction_no
  # OUTPUT: none
  ("player_join_faction",
    [
      (store_script_param, ":faction_no", 1),
      (assign,"$players_kingdom",":faction_no"),
      (faction_set_slot, "fac_player_supporters_faction", slot_faction_ai_state, sfai_default),
      (assign, "$players_oath_renounced_against_kingdom", 0),
      (assign, "$players_oath_renounced_given_center", 0),
      (assign, "$players_oath_renounced_begin_time", 0),

      (try_for_range,":other_kingdom",kingdoms_begin,kingdoms_end),
        (faction_slot_eq, ":other_kingdom", slot_faction_state, sfs_active),
        (neq, ":other_kingdom", "fac_player_supporters_faction"),
        (try_begin),
          (neq, ":other_kingdom", ":faction_no"),
          (store_relation, ":other_kingdom_reln", ":other_kingdom", ":faction_no"),
        (else_try),
          (store_relation, ":other_kingdom_reln", "fac_player_supporters_faction", ":other_kingdom"),
          (val_max, ":other_kingdom_reln", 12),
        (try_end),
        (call_script, "script_set_player_relation_with_faction", ":other_kingdom", ":other_kingdom_reln"),
      (try_end),

      (try_for_range, ":cur_center", centers_begin, centers_end),
        #Give center to kingdom if player is the owner
        (party_slot_eq, ":cur_center", slot_town_lord, "trp_player"),
        (call_script, "script_give_center_to_faction_while_maintaining_lord", ":cur_center", ":faction_no"),
	  (else_try),
        #Give center to kingdom if part of player faction
     	(store_faction_of_party, ":cur_center_faction", ":cur_center"),
		(eq, ":cur_center_faction", "fac_player_supporters_faction"),
        (call_script, "script_give_center_to_faction_while_maintaining_lord", ":cur_center", ":faction_no"),
      (try_end),

      (try_for_range, ":quest_no", lord_quests_begin, lord_quests_end),
        (check_quest_active, ":quest_no"),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
        (store_troop_faction, ":quest_giver_faction", ":quest_giver_troop"),
        (store_relation, ":quest_giver_faction_relation", "fac_player_supporters_faction", ":quest_giver_faction"),
        (lt, ":quest_giver_faction_relation", 0),
        (call_script, "script_abort_quest", ":quest_no", 0),
      (try_end),
      (try_for_range, ":quest_no", lord_quests_begin_2, lord_quests_end_2),
        (check_quest_active, ":quest_no"),
        (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
        (store_troop_faction, ":quest_giver_faction", ":quest_giver_troop"),
        (store_relation, ":quest_giver_faction_relation", "fac_player_supporters_faction", ":quest_giver_faction"),
        (lt, ":quest_giver_faction_relation", 0),
        (call_script, "script_abort_quest", ":quest_no", 0),
      (try_end),
      (try_begin),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (faction_set_slot, "fac_player_supporters_faction", slot_faction_state, sfs_inactive),
        (faction_set_slot, "fac_player_supporters_faction", slot_faction_leader, "trp_player"),
      (try_end),

	  (try_begin),
		(troop_get_slot, ":spouse", "trp_player", slot_troop_spouse),
	    (is_between, ":spouse", kingdom_ladies_begin, kingdom_ladies_end),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":spouse"),
			(display_message, "@{!}DEBUG - {s4} faction changed by marriage, case 1"),
		(try_end),

	    (troop_set_faction, ":spouse", "$players_kingdom"),
        (call_script, "script_troop_set_title_according_to_faction", ":spouse", "$players_kingdom"),
	  (try_end),
	  ##diplomacy start+
	  #Make other vassals follow the player.
	  ##(There are other possibilities that we might want to explore, but
	  ##what happens now is that they remain members of the defunct faction.)
	  (try_begin),
		(neq, ":faction_no", "fac_player_supporters_faction"),
		  (try_for_range, ":troop_no", heroes_begin, heroes_end),
			 (store_troop_faction, ":other_troop_faction", ":troop_no"),
			 (eq, ":other_troop_faction", "fac_player_supporters_faction"),

			 (this_or_next|neg|is_between, ":troop_no", companions_begin, companions_end),
			 (this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
			 (this_or_next|troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_granted_fief),
				(troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_lord_rejoined),
			 (this_or_next|neq, ":troop_no", ":spouse"),
				(neg|is_between, ":spouse", kingdom_ladies_begin, kingdom_ladies_end),
			(try_begin),
				(ge, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":troop_no"),
				(display_message, "@{!} DEBUG - {s4} changed by player's defection"),
			(try_end),
			(troop_set_faction, ":troop_no", "$players_kingdom"),
			#Clear troop slots
			(troop_set_slot, ":troop_no", slot_troop_stance_on_faction_issue, -1),
			(troop_set_slot, ":troop_no", slot_troop_recruitment_random, 0),
			(troop_set_slot, ":troop_no", slot_lord_recruitment_argument, 0),
			(troop_set_slot, ":troop_no", slot_lord_recruitment_candidate, 0),
			(troop_set_slot, ":troop_no", slot_troop_promised_fief, 0),
			#Give new title
			(try_begin),
				(this_or_next|neg|is_between,":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
					(troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
				(call_script, "script_troop_set_title_according_to_faction", ":troop_no", ":faction_no"),
			(try_end),
			#Change led party
			(try_begin),
				(troop_get_slot, ":troop_leaded_party", ":troop_no", slot_troop_leaded_party),
				(gt, ":troop_leaded_party", 0),
				(party_is_active, ":troop_leaded_party"),
				(party_set_faction, ":troop_leaded_party", ":faction_no"),
			(try_end),
		  (try_end),
	  (try_end),
	  ##diplomacy end+

	  # (try_for_range, ":center", centers_begin, centers_end),
	    # (store_faction_of_party, ":center_faction", ":faction_no"),
		# (neq, ":center_faction", "$players_kingdom"),
		# (party_slot_eq, ":center", slot_town_lord, stl_reserved_for_player),
# #		(party_set_slot, ":center", slot_town_lord, stl_unassigned),
	  # (try_end),

	  (troop_set_slot, "trp_player", slot_troop_stance_on_faction_issue, -1),

	  #remove prisoners of player's faction if he was member of his own faction. And free companions which is prisoned in that faction.
      (try_for_parties, ":party_no"),
        (store_faction_of_party, ":party_faction", ":party_no"),
        (eq, ":party_faction", ":faction_no"),

        (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
        (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
          (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":party_no", ":troop_iterator"),
          (store_troop_faction, ":cur_faction", ":cur_troop_id"),

          (this_or_next|eq, ":cur_faction", "fac_player_supporters_faction"),
          (this_or_next|eq, ":cur_faction", ":faction_no"),
          (is_between, ":cur_troop_id", companions_begin, companions_end),

          (try_begin),
            (troop_is_hero, ":cur_troop_id"),
            (call_script, "script_remove_troop_from_prison", ":cur_troop_id"),
          (try_end),

          (party_prisoner_stack_get_size, ":stack_size", ":party_no", ":troop_iterator"),
          (party_remove_prisoners, ":party_no", ":cur_troop_id", ":stack_size"),

          (try_begin),
            (is_between, ":cur_troop_id", companions_begin, companions_end),

            (try_begin),
              (is_between, ":party_no", towns_begin, towns_end),
              (troop_set_slot, ":cur_troop_id", slot_troop_cur_center, ":party_no"),
            (else_try),
              (store_random_in_range, ":random_town_no", towns_begin, towns_end),
              (troop_set_slot, ":cur_troop_id", slot_troop_cur_center, ":random_town_no"),
            (try_end),
          (try_end),
        (try_end),
      (try_end),
      #remove prisoners end.

      #(call_script, "script_store_average_center_value_per_faction"),
      (call_script, "script_update_all_notes"),
      (assign, "$g_recalculate_ais", 1),
      ]),

  #script_player_leave_faction
  # INPUT: arg1 = give_back_fiefs
  # OUTPUT: none
  ("player_leave_faction",
    [
      (store_script_param, ":give_back_fiefs", 1),

      (call_script, "script_check_and_finish_active_army_quests_for_faction", "$players_kingdom"),
      (assign, ":old_kingdom", "$players_kingdom"),
      (assign, ":old_has_homage", "$player_has_homage"),
      (assign, "$players_kingdom", 0),
      (assign, "$player_has_homage", 0),

      (try_begin),
        (neq, ":give_back_fiefs", 0), #ie, give back fiefs = 1, thereby do it
        (try_for_range, ":cur_center", centers_begin, centers_end),
          (party_slot_eq, ":cur_center", slot_town_lord, "trp_player"),
          ##diplomacy begin
          #native bug fix when giving back fiefs
          (call_script, "script_give_center_to_faction", ":cur_center", "fac_neutral"),
          ##diplomacy end
          (call_script, "script_give_center_to_faction", ":cur_center", ":old_kingdom"),

          #The following line also occurs when a lord is stripped of his fiefs by an indictment
          (party_set_slot, ":cur_center", slot_town_lord, stl_unassigned),
        (try_end),
      (else_try),
        #If you retain the fiefs
        (try_for_range, ":cur_center", centers_begin, centers_end),
          (party_slot_eq, ":cur_center", slot_town_lord, "trp_player"),
          (call_script, "script_give_center_to_faction", ":cur_center", "fac_player_supporters_faction"),
          (party_set_slot, ":cur_center", slot_town_lord, "trp_player"),
          (troop_get_slot, ":cur_banner", "trp_player", slot_troop_banner_scene_prop),
          #custom_banner_begin
          (try_begin),
              (gt, ":cur_banner", 0),
              (val_sub, ":cur_banner", banner_scene_props_begin),
              (val_add, ":cur_banner", banner_map_icons_begin),
              (party_set_banner_icon, ":cur_center", ":cur_banner"),
          (else_try),
            (eq, ":cur_banner", -1),
            (troop_get_slot, ":flag_icon", "trp_player", slot_troop_custom_banner_map_flag_type),
            (try_begin),
               (ge, ":flag_icon", 0),
               (val_add, ":flag_icon", custom_banner_map_icons_begin),
               (party_set_banner_icon, ":cur_center", ":flag_icon"),
            (try_end),
          (try_end),
        (try_end),

        (try_for_range, ":cur_center", villages_begin, villages_end),
          (party_get_slot, ":cur_bound_center", ":cur_center", slot_village_bound_center),
          (party_slot_eq, ":cur_center", slot_town_lord, "trp_player"),
          (neg|party_slot_eq, ":cur_bound_center", slot_town_lord, "trp_player"),
          (call_script, "script_give_center_to_faction", ":cur_center", ":old_kingdom"),
        (try_end),

        (is_between, ":old_kingdom", kingdoms_begin, kingdoms_end),
        (neq, ":old_kingdom", "fac_player_supporters_faction"),
        (store_relation, ":reln", "fac_player_supporters_faction", ":old_kingdom"),
        (store_sub, ":req_dif", -40, ":reln"),
        (call_script, "script_change_player_relation_with_faction", ":old_kingdom", ":req_dif"),
      (try_end),

      (try_begin),
        (eq, ":old_has_homage", 1),
        (faction_get_slot, ":faction_leader", ":old_kingdom", slot_faction_leader),
        (call_script, "script_change_player_relation_with_troop", ":faction_leader", -20),
      (try_end),

      (try_begin),
        (troop_get_slot, ":spouse", "trp_player", slot_troop_spouse),
        (is_between, ":spouse", kingdom_ladies_begin, kingdom_ladies_end),

        (try_begin),
            (ge, "$cheat_mode", 1),
            (str_store_troop_name, s4, ":spouse"),
            (display_message, "@{!}DEBUG - {s4} faction changed by marriage, case 3"),
        (try_end),


        (troop_set_faction, ":spouse", "fac_player_supporters_faction"),
        (call_script, "script_troop_set_title_according_to_faction", ":spouse", "fac_player_supporters_faction"),
      (try_end),

      #Change relations with players_kingdom when player changes factions
      (try_for_range, ":kingdom", kingdoms_begin, kingdoms_end),
        (neq, ":kingdom", "fac_player_supporters_faction"),
        (store_relation, ":relation_with_old_faction", ":old_kingdom", ":kingdom"),
        (store_relation, ":relation_with_player_faction", "fac_player_faction", ":kingdom"),

        (try_begin),
          (eq, ":old_kingdom", ":kingdom"),
          (val_min, ":relation_with_player_faction", 0),
        (else_try),
          (lt, ":relation_with_old_faction", 0),
          (val_max, ":relation_with_player_faction", 0),
       ##diplomacy start+ do not retain allies of former kingdom
       (else_try),
         (gt, ":relation_with_old_faction", 0),
         (val_min, ":relation_with_player_faction", 0),
       ##diplomacy end+
        (try_end),
        (set_relation, "fac_player_faction", ":kingdom", ":relation_with_player_faction"),
        (set_relation, "fac_player_supporters_faction", ":kingdom", ":relation_with_player_faction"),
      (try_end),

      (call_script, "script_update_all_notes"),
      (assign, "$g_recalculate_ais", 1),

        ##diplomacy begin
        ##disband player patrols
      #SB : build one string instead of one for each party
      (try_begin),
        (str_clear, s6),
        (assign, ":num_parties", 0),
        # (ge, ":give_back_fiefs", 1),
        (try_for_parties, ":party_no"),
          (party_is_active, ":party_no"),
          (party_slot_eq,":party_no", slot_party_type, spt_patrol),
          #SB : add other checks such as faction and home center ownership
          (store_faction_of_party, ":party_faction", ":party_no"),
          (eq, ":party_faction", ":old_kingdom"),
          (party_slot_eq, ":party_no", dplmc_slot_party_mission_diplomacy, "trp_player"),
          # (party_slot_eq, ":home_center", slot_town_lord, "trp_player"), #this may no longer be true

          #build string
          (party_get_slot, ":target_party", ":party_no", slot_party_ai_object),
          (str_store_party_name, s50, ":target_party"),
          (try_begin),
            (eq, ":num_parties", 0),
            (str_store_string_reg, s51, s50),
          (else_try),
            (eq, ":num_parties", 1),
            (str_store_string, s51, "str_s50_and_s51"),
          (else_try),
            (str_store_string, s51, "str_s50_comma_s51"),
          (try_end),
          # (display_log_message, "@Your soldiers patrolling {s6} disbanded because you left the faction!", message_defeated),
          (try_begin), #do not give back fiefs, keep the patrols
            (party_get_slot, ":home_center", ":party_no", slot_party_home_center),
            # (eq, ":give_back_fiefs", 0),
            (party_get_slot, ":town_lord", ":home_center", slot_town_lord),
            (eq, ":town_lord", "trp_player"),
            (party_set_faction, ":party_no", "fac_player_supporters_faction"),
            # (remove_party, ":party_no"),
          (else_try), #we assume ":give_back_fiefs" also returns patrols
            (party_set_slot, ":party_no", dplmc_slot_party_mission_diplomacy, ":town_lord"),
            (party_set_faction, ":party_no", ":old_kingdom"),
            (party_set_flags, ":party_no", pf_default_behavior,1),
          (try_end),
        (try_end),
        (try_begin),
          (gt, ":num_parties", 0),
          (faction_get_color, ":color", ":old_kingdom"),
          (assign, reg6, ":give_back_fiefs"),
          (display_log_message, "@Your soldiers patrolling {s51} {reg6?returned:disbanded} because you left the faction!", ":color"),
        (try_end),
      (try_end),
        ##diplomacy end
    ]),


    ("deactivate_player_faction",
    [
    (faction_set_slot, "fac_player_supporters_faction", slot_faction_state, sfs_inactive),
    (faction_set_slot, "fac_player_supporters_faction", slot_faction_leader, "trp_player"),
    (assign, "$players_kingdom", 0),
    (assign, "$players_oath_renounced_against_kingdom", 0),
    (assign, "$players_oath_renounced_given_center", 0),
    (assign, "$players_oath_renounced_begin_time", 0),
    #(call_script, "script_store_average_center_value_per_faction"),
    (call_script, "script_update_all_notes"),

    (try_begin),
        (is_between, "$g_player_minister", companions_begin, companions_end),
        (assign, "$npc_to_rejoin_party", "$g_player_minister"),
    (try_end),
    (assign, "$g_player_minister", -1),

    (call_script, "script_add_notification_menu", "mnu_notification_player_faction_deactive", 0, 0),
    ]),


  #script_activate_player_faction
  # INPUT: arg1 = last_interaction_with_faction
  # OUTPUT: none

  #When a player convinces her husband to rebel
  #When a player proclaims herself queen
  #When a player seizes control of a center
  #When a player recruits a lord through intrigue
  #When a player
    ("activate_player_faction",
    [
    (store_script_param, ":liege", 1),

	#This moved to top, so that mnu_notification does not occur twice
	(try_begin),
		(faction_slot_eq, "fac_player_supporters_faction", slot_faction_state, sfs_inactive),
		(neg|is_between, ":liege", pretenders_begin, pretenders_end),
		(call_script, "script_add_notification_menu", "mnu_notification_player_faction_active", 0, 0),
		##diplomacy begin
		(call_script, "script_add_notification_menu", "mnu_dplmc_domestic_policy", 0, 0),
		##diplomacy end
	(try_end),


    (faction_set_slot, "fac_player_supporters_faction", slot_faction_state, sfs_active),
    (faction_set_slot, "fac_player_supporters_faction", slot_faction_leader, ":liege"),

	(assign, ":original_kingdom", "$players_kingdom"),

	(try_begin),
		(is_between, ":original_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
		(call_script, "script_player_leave_faction", 0), #Ends quests, transfers control of centers
	(try_end),

	#Name faction
	(try_begin),
		(is_between, ":liege", active_npcs_begin, active_npcs_end),
		(store_faction_of_troop, ":liege_faction"),
		(is_between, ":liege_faction", npc_kingdoms_begin, npc_kingdoms_end),
		(faction_get_slot, ":adjective_string", ":liege_faction", slot_faction_adjective),
		(str_store_string, s1, ":adjective_string"),
		(faction_set_name, "fac_player_supporters_faction", "@{s1} Rebels"),
        #SB : opposite faction color
        (faction_get_color, ":color", ":liege_faction"),
        (store_sub, ":color", 0xFFFFFF, ":color"),#we get the opposite color
        (faction_set_color, "fac_player_supporters_faction", ":color"),
	(else_try),
		(str_store_troop_name, s2, ":liege"),
        (str_store_string, s1, "str_s2s_rebellion"),
	(try_end),


    (assign, "$players_kingdom", "fac_player_supporters_faction"),
    (assign, "$g_player_banner_granted", 1),



	#Any oaths renounced?
	(try_begin),
		(is_between, ":original_kingdom", npc_kingdoms_begin, npc_kingdoms_end),

        (faction_get_slot, ":old_leader", ":original_kingdom", slot_faction_leader),
        (call_script, "script_add_log_entry", logent_renounced_allegiance,   "trp_player",  -1, ":old_leader", "$players_kingdom"),

        #Initializing renounce war variables
        (assign, "$players_oath_renounced_against_kingdom", ":original_kingdom"),
        (assign, "$players_oath_renounced_given_center", 0),
        (store_current_hours, "$players_oath_renounced_begin_time"),

        (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
          (store_faction_of_party, ":cur_center_faction", ":cur_center"),
          (party_set_slot, ":cur_center", slot_center_faction_when_oath_renounced, ":cur_center_faction"),
        (try_end),
        (party_set_slot, "$g_center_to_give_to_player", slot_center_faction_when_oath_renounced, "$players_oath_renounced_against_kingdom"),

		(store_relation, ":relation", ":original_kingdom", "fac_player_supporters_faction"),
		(ge, ":relation", 0),
		(call_script, "script_diplomacy_start_war_between_kingdoms", ":original_kingdom", "fac_player_supporters_faction", 1),
	(try_end),


	(try_begin),
		(troop_get_slot, ":spouse", "trp_player", slot_troop_spouse),
	    (is_between, ":spouse", kingdom_ladies_begin, kingdom_ladies_end),


		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":spouse"),
			(display_message, "@{!}DEBUG - {s4} faction changed by marriage, case 2"),
		(try_end),

	    (troop_set_faction, ":spouse", "fac_player_supporters_faction"),
        (call_script, "script_troop_set_title_according_to_faction", ":spouse", "fac_player_supporters_faction"),
	(try_end),


    #(call_script, "script_store_average_center_value_per_faction"),
    (call_script, "script_update_all_notes"),
	(assign, "$g_recalculate_ais", 1),

    ]),



  #script_agent_reassign_team
  # INPUT: arg1 = agent_no
  # OUTPUT: none
  ("agent_reassign_team",
    [
      (store_script_param, ":agent_no", 1),
      (get_player_agent_no, ":player_agent"),
      (try_begin),
        (ge, ":player_agent", 0),
        (agent_is_human, ":agent_no"),
        (agent_is_ally, ":agent_no"),
        (agent_get_party_id, ":party_no", ":agent_no"),
        #SB : pre-process this instead of calculating per agent
        (party_slot_eq, ":party_no", slot_party_temp_slot_1, -1),
        # (neq, ":party_no", "p_main_party"),
        # (assign, ":continue", 1),
        # (store_faction_of_party, ":party_faction", ":party_no"),
        # (try_begin),
          # (eq, ":party_faction", "$players_kingdom"),
          # (is_between, "$players_kingdom", kingdoms_begin, kingdoms_end),
          # (faction_slot_eq, "$players_kingdom", slot_faction_marshall, "trp_player"),
          # (assign, ":continue", 0),
        # (else_try),
          # (party_stack_get_troop_id, ":leader_troop_id", ":party_no", 0),
          # (neg|is_between, ":leader_troop_id", active_npcs_begin, active_npcs_end),
          # (assign, ":continue", 0),
        # (try_end),
        # (eq, ":continue", 1),
        (agent_get_team, ":player_team", ":player_agent"),
        (val_add, ":player_team", 2),
        (agent_set_team, ":agent_no", ":player_team"),
      (try_end),
      ]),

  #script_start_quest
  # INPUT: arg1 = quest_no, arg2 = giver_troop_no, s2 = description_text
  # OUTPUT: none
  ("start_quest",
    [(store_script_param, ":quest_no", 1),
     (store_script_param, ":giver_troop_no", 2),

     (quest_set_slot, ":quest_no", slot_quest_giver_troop, ":giver_troop_no"),

     (try_begin),
       (eq, ":giver_troop_no", -1),
       (str_store_string, s63, "str_political_suggestion"),
     (else_try), #SB : extend range
       (is_between, ":giver_troop_no", active_npcs_begin, heroes_end),
       (str_store_troop_name_link, s62, ":giver_troop_no"),
       (str_store_string, s63, "@Given by: {s62}"),
     (else_try),
       (str_store_troop_name, s62, ":giver_troop_no"),
       (str_store_string, s63, "@Given by: {s62}"),
     (try_end),
     (store_current_hours, ":cur_hours"),
     (str_store_date, s60, ":cur_hours"),
     (str_store_string, s60, "@Given on: {s60}"),
     (add_quest_note_from_sreg, ":quest_no", 0, s60, 0),
     (add_quest_note_from_sreg, ":quest_no", 1, s63, 0),
     (add_quest_note_from_sreg, ":quest_no", 2, s2, 0),

     (try_begin),
       (quest_slot_ge, ":quest_no", slot_quest_expiration_days, 1),
       (quest_get_slot, reg0, ":quest_no", slot_quest_expiration_days),
       (add_quest_note_from_sreg, ":quest_no", 7, "@You have {reg0} days to finish this quest.", 0),
     (try_end),

     #Adding dont_give_again_for_days value
     (try_begin),
       (quest_slot_ge, ":quest_no", slot_quest_dont_give_again_period, 1),
       (quest_get_slot, ":dont_give_again_period", ":quest_no", slot_quest_dont_give_again_period),
       (quest_set_slot, ":quest_no", slot_quest_dont_give_again_remaining_days, ":dont_give_again_period"),
     (try_end),
     (start_quest, ":quest_no", ":giver_troop_no"),

     (try_begin),
       (eq, ":quest_no", "qst_report_to_army"),
       (assign, "$number_of_report_to_army_quest_notes", 8),
       (faction_get_slot, ":faction_ai_state", "$players_kingdom", slot_faction_ai_state),
       (call_script, "script_update_report_to_army_quest_note", "$players_kingdom", ":faction_ai_state", -1),
     (try_end),

     (display_message, "str_quest_log_updated"),
   ]),

  #script_conclude_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("conclude_quest",
    [
      (store_script_param, ":quest_no", 1),
      (conclude_quest, ":quest_no"),
      (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
      (str_store_troop_name, s59, ":quest_giver_troop"),
      (add_quest_note_from_sreg, ":quest_no", 7, "@This quest has been concluded. Talk to {s59} to finish it.", 0),
    ]),

  #script_succeed_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("succeed_quest",
    [
      (store_script_param, ":quest_no", 1),
      (succeed_quest, ":quest_no"),
      (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
      (str_store_troop_name, s59, ":quest_giver_troop"),
      (add_quest_note_from_sreg, ":quest_no", 7, "@This quest has been successfully completed. Talk to {s59} to claim your reward.", 0),
    ]),

  #script_fail_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("fail_quest",
    [
      (store_script_param, ":quest_no", 1),
      (fail_quest, ":quest_no"),
      (quest_get_slot, ":quest_giver_troop", ":quest_no", slot_quest_giver_troop),
      (str_store_troop_name, s59, ":quest_giver_troop"),
      (add_quest_note_from_sreg, ":quest_no", 7, "@This quest has failed. Talk to {s59} to explain the situation.", 0),
    ]),

  #script_report_quest_troop_positions
  # INPUT: arg1 = quest_no, arg2 = troop_no, arg3 = note_index
  # OUTPUT: none
  ("report_quest_troop_positions",
    [
      (store_script_param, ":quest_no", 1),
      (store_script_param, ":troop_no", 2),
      (store_script_param, ":note_index", 3),
      (call_script, "script_get_information_about_troops_position", ":troop_no", 1),
      (str_store_string, s5, "@At the time quest was given:^{s1}"),
      (add_quest_note_from_sreg, ":quest_no", ":note_index", s5, 1),
      (call_script, "script_update_troop_location_notes", ":troop_no", 1),
    ]),

  #script_end_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("end_quest",
    [
      (store_script_param, ":quest_no", 1),
      (str_clear, s1),
      (add_quest_note_from_sreg, ":quest_no", 0, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 1, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 2, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 3, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 4, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 5, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 6, s1, 0),
      (add_quest_note_from_sreg, ":quest_no", 7, s1, 0),
      (try_begin),
        (neg|check_quest_failed, ":quest_no"),
        (val_add, "$g_total_quests_completed", 1),
      (try_end),
      (complete_quest, ":quest_no"),
      (try_begin),
        (eq, ":quest_no", "qst_consult_with_minister"),
        (assign, "$g_minister_notification_quest", 0),
      (else_try), #SB : finish clearing ransom debts
        (eq, ":quest_no", "qst_rescue_prisoner"),
        (try_for_range, ":troop_no", heroes_begin, heroes_end),
          (troop_slot_ge, ":troop_no", slot_troop_player_debt, dplmc_ransom_debt_mask),
          (troop_set_slot, ":troop_no", slot_troop_player_debt, 0),
        (try_end),
      # (else_try), #SB : clean up fugitive troop
        # (eq, ":quest_no", "qst_hunt_down_fugitive"),
        # (try_for_parties, ":party_no"),
          # (party_is_active, ":party_no"),
          # (party_remove_prisoners, ":party_no", "trp_fugitive", 1),
          # (party_remove_members, ":party_no", "trp_fugitive", 1),
        # (try_end),
      (else_try),
        (is_between, ":quest_no", mayor_quests_begin, mayor_quests_end),
        (assign, "$merchant_quest_last_offerer", -1),
        (assign, "$merchant_offered_quest", -1),
      (try_end),
    ]),

  #script_cancel_quest
  # INPUT: arg1 = quest_no
  # OUTPUT: none
  ("cancel_quest",
    [(store_script_param, ":quest_no", 1),
     (str_clear, s1),
     (add_quest_note_from_sreg, ":quest_no", 0, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 1, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 2, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 3, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 4, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 5, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 6, s1, 0),
     (add_quest_note_from_sreg, ":quest_no", 7, s1, 0),
     (cancel_quest, ":quest_no"),
     (try_begin),
       (is_between, ":quest_no", mayor_quests_begin, mayor_quests_end),
       (assign, "$merchant_quest_last_offerer", -1),
       (assign, "$merchant_offered_quest", -1),
     (try_end),
     ]),

##  #script_get_available_mercenary_troop_and_amount_of_center
##  # INPUT: arg1 = center_no
##  # OUTPUT: reg0 = mercenary_troop_type, reg1 = amount
##  ("get_available_mercenary_troop_and_amount_of_center",
##    [(store_script_param, ":center_no", 1),
##     (party_get_slot, ":mercenary_troop", ":center_no", slot_center_mercenary_troop_type),
##     (party_get_slot, ":mercenary_amount", ":center_no", slot_center_mercenary_troop_amount),
##     (party_get_free_companions_capacity, ":free_capacity", "p_main_party"),
##     (val_min, ":mercenary_amount", ":free_capacity"),
##     (store_troop_gold, ":cur_gold", "trp_player"),
##     (call_script, "script_game_get_join_cost", ":mercenary_troop"),
##     (assign, ":join_cost", reg0),
##     (try_begin),
##       (gt, ":join_cost", 0),
##       (val_div, ":cur_gold", ":join_cost"),
##       (val_min, ":mercenary_amount", ":cur_gold"),
##     (try_end),
##     (assign, reg0, ":mercenary_troop"),
##     (assign, reg1, ":mercenary_amount"),
##     ]),
##

  #script_update_village_market_towns
  # INPUT: none
  # OUTPUT: none
  ("update_village_market_towns",
    [(try_for_range, ":cur_village", villages_begin, villages_end),
       (store_faction_of_party, ":village_faction", ":cur_village"),
       (assign, ":min_dist", 999999),
       (assign, ":min_dist_town", -1),
       (try_for_range, ":cur_town", towns_begin, towns_end),
         (store_faction_of_party, ":town_faction", ":cur_town"),
         (eq, ":town_faction", ":village_faction"),
         (store_distance_to_party_from_party, ":cur_dist", ":cur_village", ":cur_town"),
         (lt, ":cur_dist", ":min_dist"),
         (assign, ":min_dist", ":cur_dist"),
         (assign, ":min_dist_town", ":cur_town"),
       (try_end),

	   (try_begin),
		(gt, ":min_dist_town", -1),
		(party_set_slot, ":cur_village", slot_village_market_town, ":min_dist_town"),
	   (else_try),
		(assign, ":min_dist", 999999),
		(assign, ":min_dist_town", -1),
		(try_for_range, ":cur_town", towns_begin, towns_end),
			(store_faction_of_party, ":town_faction", ":cur_town"),
			(store_relation, ":relation", ":town_faction", ":village_faction"),
			(ge, ":relation", 0),
			(store_distance_to_party_from_party, ":cur_dist", ":cur_village", ":cur_town"),
			(lt, ":cur_dist", ":min_dist"),
			(assign, ":min_dist", ":cur_dist"),
			(assign, ":min_dist_town", ":cur_town"),
		(try_end),
		(gt, ":min_dist_town", -1),
		(party_set_slot, ":cur_village", slot_village_market_town, ":min_dist_town"),
	   (try_end),
     (try_end),
     ]),



  #script_update_mercenary_units_of_towns
  # INPUT: none
  # OUTPUT: none
  ("update_mercenary_units_of_towns",
    [(try_for_range, ":town_no", towns_begin, towns_end),
      (store_random_in_range, ":troop_no", mercenary_troops_begin, mercenary_troops_end),
      (party_set_slot, ":town_no", slot_center_mercenary_troop_type, ":troop_no"),
      (store_random_in_range, ":amount", 3, 8),
	  ##diplomacy start+
	  #OPTIONAL CHANGE: The same way that lord party sizes increase as the player
	  #progresses, also increase mercenary party sizes to maintain their relevance.
	  (try_begin),
	     (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_HIGH),
		 (store_character_level, ":level", "trp_player"), #increase limits a little bit as the game progresses.
		 (store_add, ":level_factor", 80, ":level"),
         (val_mul, ":amount", ":level_factor"),
         (val_div, ":amount", 80),
	  (try_end),
	  ##diplomacy end+
      (party_set_slot, ":town_no", slot_center_mercenary_troop_amount, ":amount"),
    (try_end),
     ]),

  #script_update_volunteer_troops_in_village
  # INPUT: arg1 = center_no
  # OUTPUT: none
  ("update_volunteer_troops_in_village",
    [
       (store_script_param, ":center_no", 1),
       (party_get_slot, ":player_relation", ":center_no", slot_center_player_relation),
       (party_get_slot, ":center_culture", ":center_no", slot_center_culture),


##	   (try_begin),
##		(eq, "$cheat_mode", 2),
##	    (str_store_party_name, s4, ":center_no"),
##	    (str_store_faction_name, s5, ":center_culture"),
##	    (display_message, "str_updating_volunteers_for_s4_faction_is_s5"),
##	   (try_end),

       (faction_get_slot, ":volunteer_troop", ":center_culture", slot_faction_tier_1_troop),
       (assign, ":volunteer_troop_tier", 1),
       (store_div, ":tier_upgrades", ":player_relation", 10),
       (try_for_range, ":unused", 0, ":tier_upgrades"),
         (store_random_in_range, ":random_no", 0, 100),
         (lt, ":random_no", 10),
         (store_random_in_range, ":random_no", 0, 2),
         (troop_get_upgrade_troop, ":upgrade_troop_no", ":volunteer_troop", ":random_no"),
         (try_begin),
           (le, ":upgrade_troop_no", 0),
           (troop_get_upgrade_troop, ":upgrade_troop_no", ":volunteer_troop", 0),
         (try_end),
         (gt, ":upgrade_troop_no", 0),
         (val_add, ":volunteer_troop_tier", 1),
         (assign, ":volunteer_troop", ":upgrade_troop_no"),
       (try_end),

       (assign, ":upper_limit", 8),
       (try_begin),
         (ge, ":player_relation", 4),
         (assign, ":upper_limit", ":player_relation"),
         (val_div, ":upper_limit", 2),
         (val_add, ":upper_limit", 6),
       (else_try),
         (lt, ":player_relation", 0),
         (assign, ":upper_limit", 0),
       (try_end),


##diplomacy begin
      (assign, ":percent", 100),
      (try_begin), #-30% if not owner
        (neg|party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
        (val_sub, ":percent", 30),
      (try_end),
      (try_begin), #1%/4 renown
        (troop_get_slot, ":player_renown", "trp_player", slot_troop_renown),
        (val_div, ":player_renown", 4),
        (val_add, ":percent", ":player_renown"),
      (try_end),
      (try_begin), #1%/3 honour
        (assign, ":player_honour", "$player_honor"),
        (val_div, ":player_honour", 3),
        (val_add, ":percent", ":player_honour"),
      (try_end),
      (try_begin), #+5% if king
        (faction_get_slot, ":faction_leader", "fac_player_supporters_faction", slot_faction_leader),
        (eq, ":faction_leader", "trp_player"),
        (val_add, ":percent", 5),

        (try_begin), #-5% for each point of serfdom
          (faction_get_slot, ":serfdom", "fac_player_supporters_faction", dplmc_slot_faction_serfdom),
          (neq, ":serfdom", 0),
          (val_mul, ":serfdom", 5),
          (val_sub, ":percent", ":serfdom"),
        (try_end),

        (try_begin),  #+5% if king of village
          (store_faction_of_party, ":faction", ":center_no"),
          (eq, ":faction", "fac_player_supporters_faction"),
          (val_add, ":percent", 5),
        (try_end),
      (try_end),

      (try_begin),
        (gt, ":upper_limit", 0),
        (val_clamp, ":percent", 0, 201),
        (val_mul, ":upper_limit", ":percent"),
        (val_div, ":upper_limit", 100),
      (try_end),

##diplomacy end


       (val_mul, ":upper_limit", 3),
       (store_add, ":amount_random_divider", 2, ":volunteer_troop_tier"),
       (val_div, ":upper_limit", ":amount_random_divider"),

       (store_random_in_range, ":amount", 0, ":upper_limit"),
       (party_set_slot, ":center_no", slot_center_volunteer_troop_type, ":volunteer_troop"),
       (party_set_slot, ":center_no", slot_center_volunteer_troop_amount, ":amount"),
     ]),

  #script_update_npc_volunteer_troops_in_village
  # INPUT: arg1 = center_no
  # OUTPUT: none
  ("update_npc_volunteer_troops_in_village",
    [
       (store_script_param, ":center_no", 1),
       (party_get_slot, ":center_culture", ":center_no", slot_center_culture),
       (faction_get_slot, ":volunteer_troop", ":center_culture", slot_faction_tier_1_troop),
       (assign, ":volunteer_troop_tier", 1),
       (try_for_range, ":unused", 0, 5),
         (store_random_in_range, ":random_no", 0, 100),
         (lt, ":random_no", 10),
         (store_random_in_range, ":random_no", 0, 2),
         (troop_get_upgrade_troop, ":upgrade_troop_no", ":volunteer_troop", ":random_no"),
         (try_begin),
           (le, ":upgrade_troop_no", 0),
           (troop_get_upgrade_troop, ":upgrade_troop_no", ":volunteer_troop", 0),
         (try_end),
         (gt, ":upgrade_troop_no", 0),
         (val_add, ":volunteer_troop_tier", 1),
         (assign, ":volunteer_troop", ":upgrade_troop_no"),
       (try_end),

       (assign, ":upper_limit", 12),

       (store_add, ":amount_random_divider", 2, ":volunteer_troop_tier"),
       (val_div, ":upper_limit", ":amount_random_divider"),

       (store_random_in_range, ":amount", 0, ":upper_limit"),
       (party_set_slot, ":center_no", slot_center_npc_volunteer_troop_type, ":volunteer_troop"),
       (party_set_slot, ":center_no", slot_center_npc_volunteer_troop_amount, ":amount"),
     ]),

  #script_update_companion_candidates_in_taverns
  # INPUT: none
  # OUTPUT: none
("update_companion_candidates_in_taverns",
    [
      (try_begin),
        (eq, "$cheat_mode", 1),
        (display_message, "str_shuffling_companion_locations"),
      (try_end),

      (try_for_range, ":troop_no", companions_begin, companions_end),
	    ##diplomacy start+ Move this *after* the checks!
        #  (troop_set_slot, ":troop_no", slot_troop_cur_center, -1),
		##diplomacy end+
        (troop_slot_eq, ":troop_no", slot_troop_days_on_mission, 0),
        (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_inactive),

        (neg|troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0),
		##diplomacy start+
		(troop_get_slot, ":town_no", ":troop_no", slot_troop_cur_center),
		(try_begin),
			(is_between, ":town_no", towns_begin, towns_end),
			(party_get_slot, ":town_lord", ":town_no", slot_town_lord),
			##zerilius changes begin
			##bug fix for red text
			(ge, ":town_lord", 0),
			##zerilius changes end
			(this_or_next|eq, ":town_lord", "trp_player"),
			(this_or_next|troop_slot_eq, "trp_player", slot_troop_spouse, ":town_lord"),
				(troop_slot_eq, ":town_lord", slot_troop_spouse, "trp_player"),
		(else_try),
			#Moved from above:
			(troop_set_slot, ":troop_no", slot_troop_cur_center, -1),
		(try_end),
		(neg|troop_slot_ge, ":troop_no", slot_troop_cur_center, 1),
		##diplomacy end+
        (store_random_in_range, ":town_no", towns_begin, towns_end),
        (try_begin),
		  ##diplomacy start+ Remove the "you can't go home again" condition if the player owns the town
		  (assign, ":veto", 0),
		  (try_begin),
			(store_faction_of_party, ":town_faction", ":town_no"),
			(eq, ":town_faction", "fac_player_supporters_faction"),
		  (else_try),
			(party_get_slot, ":town_lord", ":town_no", slot_town_lord),
			(ge, ":town_lord", 0),
			(this_or_next|eq, ":town_lord", "trp_player"),
			(this_or_next|troop_slot_eq, "trp_player", slot_troop_spouse, ":town_lord"),
				(troop_slot_eq, ":town_lord", slot_troop_spouse, "trp_player"),
		  (else_try),
			#Native veto:
			(this_or_next|troop_slot_eq, ":troop_no", slot_troop_home, ":town_no"),
				(troop_slot_eq, ":troop_no", slot_troop_first_encountered, ":town_no"),
			(assign, ":veto", 1),
		  (try_end),
		  (eq, ":veto", 0),
                  ##diplomacy end+
          (troop_set_slot, ":troop_no", slot_troop_cur_center, ":town_no"),
          (try_begin),
            (eq, "$cheat_mode", 1),
            (str_store_troop_name, 4, ":troop_no"),
            (str_store_party_name, 5, ":town_no"),
            (display_message, "@{!}{s4} is in {s5}"),
          (try_end),
        (try_end),
      (try_end),
     ]),

  #script_update_ransom_brokers
  # INPUT: none
  # OUTPUT: none
  ("update_ransom_brokers",
    [(try_for_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", slot_center_ransom_broker, 0),
     (try_end),

     (try_for_range, ":troop_no", ransom_brokers_begin, ransom_brokers_end),
       #SB : random-brokers prefer towns with actual prisoners
       (assign, ":limit", 20),
       (try_for_range, ":unused", 0, ":limit"), #also exclude Tihr since it has Ramun
          (store_random_in_range, ":town_no", towns_begin, towns_end),
          (neq, ":town_no", "p_town_2"),
          (neq, ":town_no", "p_town_19"),
          #also exclude centers under siege
          (neg|party_slot_ge, ":town_no", slot_center_is_besieged_by, 1),
          (party_get_num_prisoners, ":prisoner_count", ":town_no"),
          (gt, ":prisoner_count", 0),
          (party_set_slot, ":town_no", slot_center_ransom_broker, ":troop_no"),
          (assign, ":limit", 0), #loop breaker
       (try_end),
       (eq, ":limit", 20), #none found
       (store_random_in_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", slot_center_ransom_broker, ":troop_no"),
     (try_end),

     (party_set_slot,"p_town_2",slot_center_ransom_broker,"trp_ramun_the_slave_trader"),
     (party_set_slot,"p_town_19",slot_center_ransom_broker,"trp_galeas"),
     ]),

  #script_update_tavern_travellers
  # INPUT: none
  # OUTPUT: none
  ("update_tavern_travellers",
    [
    (try_for_range, ":town_no", towns_begin, towns_end),
      (neg|party_slot_ge, ":town_no", slot_center_is_besieged_by, 1), #keep in center
      (party_set_slot, ":town_no", slot_center_tavern_traveler, 0),
    (try_end),

    (try_for_range, ":troop_no", tavern_travelers_begin, tavern_travelers_end),
      (store_random_in_range, ":town_no", towns_begin, towns_end),
      (troop_get_slot, ":cur_center", ":troop_no", slot_troop_cur_center),
      (assign, ":end_cond", 15), #default tries to set info faction slot
      (try_begin), #not landed, skip condition
        (le, ":cur_center", 0),
        (party_set_slot, ":town_no", slot_center_tavern_traveler, ":troop_no"),
        (troop_set_slot, ":troop_no", slot_troop_cur_center, ":town_no"),
      (else_try),
        (is_between, ":cur_center", walled_centers_begin, walled_centers_end),
        (neg|party_slot_ge, ":cur_center", slot_center_is_besieged_by, 1), #can't travel
        (party_set_slot, ":town_no", slot_center_tavern_traveler, ":troop_no"),
        (troop_set_slot, ":troop_no", slot_troop_cur_center, ":town_no"), #SB : set troop slot
        (store_faction_of_party, ":cur_faction", ":cur_center"),
        (neq, ":cur_faction", "$players_kingdom"),
        (party_set_slot, ":town_no", slot_center_traveler_info_faction, ":cur_faction"),
        (assign, ":end_cond", 0), #we set this above
      (try_end),

      #info faction
      (try_for_range, ":unused", 0, ":end_cond"),
        (store_random_in_range, ":info_faction", npc_kingdoms_begin, kingdoms_end),
        (faction_slot_eq, ":info_faction", slot_faction_state, sfs_active),
        (neq, ":info_faction", "$players_kingdom"),
        # (neq, ":info_faction", "fac_player_supporters_faction"),
        (party_set_slot, ":town_no", slot_center_traveler_info_faction, ":info_faction"),
        (assign, ":end_cond", 0),
      (try_end),
    (try_end),

     #SB : let its own script update every 24 hours
	 # (troop_set_slot, "trp_belligerent_drunk", slot_troop_cur_center, "p_town_1"),
     ]),

  #script_update_villages_infested_by_bandits
  # INPUT: none
  # OUTPUT: none
  ("update_villages_infested_by_bandits",
    [
    #SB : duration tweaks, remember that this is in a 72 hour slot
     (options_get_campaign_ai, ":reduce"),
     (val_add, ":reduce", 2), #default is 3
     (try_for_range, ":village_no", villages_begin, villages_end),
       (try_begin),
         (check_quest_active, "qst_eliminate_bandits_infesting_village"),
         (quest_slot_eq, "qst_eliminate_bandits_infesting_village", slot_quest_target_center, ":village_no"),
         (quest_get_slot, ":cur_state", "qst_eliminate_bandits_infesting_village", slot_quest_current_state),
         (val_add, ":cur_state", 1),
         (try_begin),
           (lt, ":cur_state", ":reduce"),
           (quest_set_slot, "qst_eliminate_bandits_infesting_village", slot_quest_current_state, ":cur_state"),
         (else_try),
           (party_set_slot, ":village_no", slot_village_infested_by_bandits, 0),
           (call_script, "script_abort_quest", "qst_eliminate_bandits_infesting_village", 2),
         (try_end),
       (else_try),
         (check_quest_active, "qst_deal_with_bandits_at_lords_village"),
         (neg|check_quest_succeeded, "qst_deal_with_bandits_at_lords_village"), #prevent failing after succeeding
         (quest_slot_eq, "qst_deal_with_bandits_at_lords_village", slot_quest_target_center, ":village_no"),
         (quest_get_slot, ":cur_state", "qst_deal_with_bandits_at_lords_village", slot_quest_current_state),
         (val_add, ":cur_state", 1),
         (try_begin),
           (lt, ":cur_state", ":reduce"),
           (quest_set_slot, "qst_deal_with_bandits_at_lords_village", slot_quest_current_state, ":cur_state"),
         (else_try),
           (party_set_slot, ":village_no", slot_village_infested_by_bandits, 0),
           (call_script, "script_abort_quest", "qst_deal_with_bandits_at_lords_village", 2),
         (try_end),
       (else_try),
         (party_set_slot, ":village_no", slot_village_infested_by_bandits, 0),
         #SB : prosperity linked infestation
         (try_begin),
           (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_MEDIUM),
           (party_get_slot, ":prosperity", ":village_no", slot_town_prosperity),
           (val_div, ":prosperity", 2), #0 to 50
           (val_add, ":prosperity", 75), #75 to 125
           (store_random_in_range, ":random_no", 0, ":prosperity"),
         (else_try),
           (store_random_in_range, ":random_no", 0, 100),
         (try_end),
         # (assign, ":continue", 1),
         (try_begin),
           (check_quest_active, "qst_collect_taxes"),
           (quest_slot_eq, "qst_collect_taxes", slot_quest_target_center, ":village_no"),
           (assign, ":random_no", 100),
         (else_try),
           (check_quest_active, "qst_train_peasants_against_bandits"),
           (quest_slot_eq, "qst_train_peasants_against_bandits", slot_quest_target_center, ":village_no"),
           (assign, ":random_no", 100),
         (try_end),
         # (eq, ":continue", 1),
         ## SB : update bandit creation parameters
         (lt, ":random_no", 3),
         (call_script, "script_center_get_bandits", ":village_no", 0),
         (assign, ":bandit_troop", reg0),
         (party_set_slot, ":village_no", slot_village_infested_by_bandits, ":bandit_troop"),
         #Reduce prosperity of the village by 3: reduce to -1
         (call_script, "script_change_center_prosperity", ":village_no", -1),
         (val_add, "$newglob_total_prosperity_from_bandits", -1),
         (try_begin),
           (eq, "$cheat_mode", 2),
           (str_store_party_name, s1, ":village_no"),
           (display_message, "@{!}DEBUG --{s1} is infested by bandits."),
         (try_end),
       (try_end),
     (try_end),
     ]),

  #script_update_booksellers
  # INPUT: none
  # OUTPUT: none
  ("update_booksellers",
    [(try_for_range, ":town_no", towns_begin, towns_end),
       (neg|party_slot_ge, ":town_no", slot_center_is_besieged_by, 1), #keep them there
       (party_set_slot, ":town_no", slot_center_tavern_bookseller, 0),
     (try_end),

     (try_for_range, ":troop_no", tavern_booksellers_begin, tavern_booksellers_end),
       (troop_get_slot, ":cur_center", ":troop_no", slot_troop_cur_center),
       (neg|party_slot_ge, ":cur_center", slot_center_is_besieged_by, 1), #can't travel
       (store_random_in_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", slot_center_tavern_bookseller, ":troop_no"),
       (troop_set_slot, ":troop_no", slot_troop_cur_center, ":town_no"), #SB : set troop slot
     (try_end),



     ]),

  #script_update_tavern_minstels
  # INPUT: none
  # OUTPUT: none
  ("update_tavern_minstrels",
    [(try_for_range, ":town_no", towns_begin, towns_end),
       (party_set_slot, ":town_no", slot_center_tavern_minstrel, 0),
     (try_end),

     #SB : remove restriction on travel, add preference for feasts
     (try_for_range, ":troop_no", tavern_minstrels_begin, tavern_minstrels_end),
       (store_random_in_range, ":town_no", towns_begin, towns_end),
       (store_faction_of_party, ":faction_no", ":town_no"),
       #feasts can be in castles, we haven't added code to put minstrels in
       (try_begin),
         (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_feast),
         (faction_get_slot, ":center_no", ":faction_no", slot_faction_ai_object),
         (is_between, ":center_no", towns_begin, towns_end),
         (neg|party_slot_ge, ":center_no", slot_center_tavern_minstrel, tavern_minstrels_begin),
         (assign, ":town_no", ":center_no"),
       (try_end),
       (party_set_slot, ":town_no", slot_center_tavern_minstrel, ":troop_no"),
       (troop_set_slot, ":troop_no", slot_troop_cur_center, ":town_no"), #SB : set troop slot
       (try_begin),
        (eq, "$cheat_mode", 1),
        (str_store_troop_name, s4, ":troop_no"),
        (str_store_party_name, s5, ":town_no"),

        (display_message, "str_s4_is_at_s5"),
       (try_end),
     (try_end),


     ]),

  ("update_other_taverngoers",
  [
	(store_random_in_range, ":fight_promoter_tavern", towns_begin, towns_end),
	(troop_set_slot, "trp_fight_promoter", slot_troop_cur_center, ":fight_promoter_tavern"),

	(store_random_in_range, ":belligerent_drunk_tavern", towns_begin, towns_end),
	(troop_set_slot, "trp_belligerent_drunk", slot_troop_cur_center, ":belligerent_drunk_tavern"),
	]),


  #script_update_faction_notes
  # INPUT: faction_no
  # OUTPUT: none
  ("update_faction_notes",
    [
      (store_script_param, ":faction_no", 1),

      (try_begin),
        (this_or_next|faction_slot_eq, ":faction_no", slot_faction_state, sfs_inactive),
        (eq, ":faction_no", "fac_player_faction"),
        (faction_set_note_available, ":faction_no", 0),
      (else_try),
        (faction_set_note_available, ":faction_no", 1),
      (try_end),
##
##	(try_begin),
##		(eq, 2, 1),
##		(str_store_faction_name, s14, ":faction_no"),
##		(assign, reg4, "$temp"),
##		(display_message, "str_updating_faction_notes_for_s14_temp_=_reg4"),
##	(try_end),
##
##    (try_begin),
##       (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
##       (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
##       (faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),
##       (str_store_faction_name, s5, ":faction_no"),
##       (str_store_troop_name_link, s6, ":faction_leader"),
##       (assign, ":num_centers", 0),
##       (str_store_string, s8, "@nowhere"),
##       (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
##         (store_faction_of_party, ":center_faction", ":cur_center"),
##         (eq, ":center_faction", ":faction_no"),
##         (try_begin),
##           (eq, ":num_centers", 0),
##           (str_store_party_name_link, s8, ":cur_center"),
##         (else_try),
##           (eq, ":num_centers", 1),
##           (str_store_party_name_link, s7, ":cur_center"),
##           (str_store_string, s8, "@{s7} and {s8}"),
##         (else_try),
##           (str_store_party_name_link, s7, ":cur_center"),
##           (str_store_string, s8, "@{!}{s7}, {s8}"),
##         (try_end),
##         (val_add, ":num_centers", 1),
##       (try_end),
##       (assign, ":num_members", 0),
##       (str_store_string, s10, "@noone"),
##       (try_for_range_backwards, ":loop_var", "trp_kingdom_heroes_including_player_begin", active_npcs_end),
##         (assign, ":cur_troop", ":loop_var"),
##         (try_begin),
##           (eq, ":loop_var", "trp_kingdom_heroes_including_player_begin"),
##           (assign, ":cur_troop", "trp_player"),
##           (assign, ":troop_faction", "$players_kingdom"),
##         (else_try),
##           (store_troop_faction, ":troop_faction", ":cur_troop"),
##         (try_end),
##         (eq, ":troop_faction", ":faction_no"),
##         (neq, ":cur_troop", ":faction_leader"),
##         (troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
##         (try_begin),
##           (eq, ":num_members", 0),
##           (str_store_troop_name_link, s10, ":cur_troop"),
##         (else_try),
##           (eq, ":num_members", 1),
##           (str_store_troop_name_link, s9, ":cur_troop"),
##           (str_store_string, s10, "@{s9} and {s10}"),
##         (else_try),
##           (str_store_troop_name_link, s9, ":cur_troop"),
##           (str_store_string, s10, "@{!}{s9}, {s10}"),
##         (try_end),
##         (val_add, ":num_members", 1),
##       (try_end),
##
##	   #wars
##       (str_store_string, s12, "@noone"),
###       (assign, ":num_enemies", 0),
###       (try_for_range_backwards, ":cur_faction", kingdoms_begin, kingdoms_end),
###         (faction_slot_eq, ":cur_faction", slot_faction_state, sfs_active),
###         (store_relation, ":cur_relation", ":cur_faction", ":faction_no"),
###         (lt, ":cur_relation", 0),
###         (try_begin),
###           (eq, ":num_enemies", 0),
###           (str_store_faction_name_link, s12, ":cur_faction"),
###         (else_try),
###           (eq, ":num_enemies", 1),
###           (str_store_faction_name_link, s11, ":cur_faction"),
###           (str_store_string, s12, "@the {s11} and the {s12}"),
###         (else_try),
###           (str_store_faction_name_link, s11, ":cur_faction"),
###           (str_store_string, s12, "@the {s11}, the {s12}"),
###         (try_end),
###         (val_add, ":num_enemies", 1),
###       (try_end),
##
##       (str_store_string, s21, "str_foreign_relations__"),
##
##	   #other foreign relations
##       (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
##         (faction_slot_eq, ":cur_faction", slot_faction_state, sfs_active),
##		 (neq, ":faction_no", ":cur_faction"),
##		 (str_store_faction_name_link, s14, ":cur_faction"),
##         (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":faction_no", ":cur_faction"),
##		 (assign, ":diplomatic_status", reg0),
##		 (assign, reg2, reg1), #length of events
##		 (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":cur_faction", ":faction_no"),
##		 (assign, ":reverse_diplomatic_status", reg0),
##
##
##		 (try_begin),
##			(eq, ":diplomatic_status", -2),
##			(str_store_string, s21, "str_s21__the_s5_is_at_war_with_the_s14"),
##
##			(store_add, ":slot_war_damage_inflicted", ":cur_faction", slot_faction_war_damage_inflicted_on_factions_begin),
##			(val_sub, ":slot_war_damage_inflicted", kingdoms_begin),
##			(faction_get_slot, ":war_damage_inflicted", ":faction_no", ":slot_war_damage_inflicted"),
##			(store_mul, ":war_damage_inflicted_x_2", ":war_damage_inflicted", 2),
##
##			(store_add, ":slot_war_damage_suffered", ":faction_no", slot_faction_war_damage_inflicted_on_factions_begin),
##			(val_sub, ":slot_war_damage_suffered", kingdoms_begin),
##			(faction_get_slot, ":war_damage_suffered", ":cur_faction", ":slot_war_damage_suffered"),
##			(store_mul, ":war_damage_suffered_x_2", ":war_damage_suffered", 2),
##
##			(try_begin),
##				(gt, ":war_damage_inflicted", ":war_damage_suffered_x_2"),
##				(str_store_string, s21, "str_s21_the_s5_has_had_the_upper_hand_in_the_fighting"),
##			(else_try),
##				(gt, ":war_damage_suffered", ":war_damage_inflicted_x_2"),
##				(str_store_string, s21, "@{s21}. The {s14} has gotten the worst of the fighting."),
##			(else_try),
##				(gt, ":war_damage_inflicted", 100),
##				(gt, ":war_damage_inflicted", 100),
##				(str_store_string, s21, "str_s21_the_fighting_has_gone_on_for_some_time_and_the_war_may_end_soon_with_a_truce"),
##			(else_try),
##				(str_store_string, s21, "str_s21_the_fighting_has_begun_relatively_recently_and_the_war_may_continue_for_some_time"),
##			(try_end),
##
##			(try_begin),
##				(eq, "$cheat_mode", 1),
##				(assign, reg4, ":war_damage_inflicted"),
##				(assign, reg5, ":war_damage_suffered"),
##				(str_store_string, s21, "str_s21_reg4reg5"),
##			(try_end),
##		 (else_try),
##			(eq, ":diplomatic_status", 1),
##			(str_clear, s18),
##
##			(try_begin),
##				(neq, reg0, 1),
##				(str_store_string, s18, "str__however_the_truce_is_no_longer_binding_on_the_s14"),
##			(try_end),
##			(str_store_string, s21, "str_s21__the_s5_is_bound_by_truce_not_to_attack_the_s14s18_the_truce_will_expire_in_reg1_days"),
##
##		 (else_try),
##			(eq, ":diplomatic_status", -1),
##			(str_store_string, s21, "str_s21__the_s5_has_recently_suffered_provocation_by_subjects_of_the_s14_and_there_is_a_risk_of_war"),
##		 (else_try),
##			(eq, ":diplomatic_status", 0),
##			(str_store_string, s21, "str_s21__the_s5_has_no_outstanding_issues_with_the_s14"),
##		 (try_end),
##
##
##		 (try_begin),
##			(eq, ":reverse_diplomatic_status", -1),
##			(str_store_string, s21, "str_s21_the_s14_was_recently_provoked_by_subjects_of_the_s5_and_there_is_a_risk_of_war_"),
##		 (try_end),
##
##		 (try_begin),
##			(eq, "$cheat_mode", 1),
##			(call_script, "script_diplomacy_faction_assess_faction_to_s14", ":faction_no", ":cur_faction", -1),
##			(str_store_string, s21, "str_s21_cheat_mode_assessment_s14_"),
##	     (try_end),
##	  (try_end),
##
##
##	  (add_faction_note_from_sreg, ":faction_no", 0, "str_the_s5_is_ruled_by_s6_it_occupies_s8_its_vassals_are_s10__s21", 0),
##
##
##
##    (else_try),
##       (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
##       (faction_slot_eq, ":faction_no", slot_faction_state, sfs_defeated),
##       (str_store_faction_name, s5, ":faction_no"),
##       (add_faction_note_from_sreg, ":faction_no", 0, "@{s5} has been defeated!", 0),
##       (str_clear, s1),
##       (add_faction_note_from_sreg, ":faction_no", 1, s1, 0),
##    (else_try),
##       (str_clear, s1),
##       (add_faction_note_from_sreg, ":faction_no", 0, s1, 0),
##       (add_faction_note_from_sreg, ":faction_no", 1, s1, 0),
##    (try_end),
##
##    (try_begin),
##       (is_between, ":faction_no", "fac_kingdom_1", kingdoms_end), #Excluding player kingdom
##       (add_faction_note_tableau_mesh, ":faction_no", "tableau_faction_note_mesh"),
##    (else_try),
##       (add_faction_note_tableau_mesh, ":faction_no", "tableau_faction_note_mesh_banner"),
##    (try_end),
     ]),

  ("update_faction_political_notes",
    [(store_script_param, ":faction_no", 1),

	(call_script, "script_evaluate_realm_stability", ":faction_no"),
    (add_faction_note_from_sreg, ":faction_no", 2, "str_instability_reg0_of_lords_are_disgruntled_reg1_are_restless", 0),
	]),



  #script_update_faction_traveler_notes
  # INPUT: faction_no
  # OUTPUT: none
  ("update_faction_traveler_notes",
    [(store_script_param, ":faction_no", 1),
     (assign, ":total_men", 0),
     (try_for_parties, ":cur_party"),
       (store_faction_of_party, ":center_faction", ":cur_party"),
       (eq, ":center_faction", ":faction_no"),
       (party_get_num_companions, ":num_men", ":cur_party"),
       (val_add, ":total_men", ":num_men"),
     (try_end),
     (str_store_faction_name, s5, ":faction_no"),
     (assign, reg1, ":total_men"),
     (add_faction_note_from_sreg, ":faction_no", 1, "@{s5} has a strength of {reg1} men in total.", 1),
     ]),


  #script_update_troop_notes
  # INPUT: troop_no
  # OUTPUT: none
  ("update_troop_notes",
    [
##      (store_script_param, ":troop_no", 1),
##     (str_store_troop_name, s54, ":troop_no"),
##     (try_begin),
##       (eq, ":troop_no", "trp_player"),
##       (this_or_next|eq, "$player_has_homage", 1),
##		(eq, "$players_kingdom", "fac_player_supporters_faction"),
##       (assign, ":troop_faction", "$players_kingdom"),
##     (else_try),
##       (store_troop_faction, ":troop_faction", ":troop_no"),
##     (try_end),
##
##	 (str_clear, s49),
##	 (try_begin),
##		(is_between, ":troop_no", lords_begin, kingdom_ladies_end),
##		(troop_get_slot, reg1, ":troop_no", slot_troop_age),
##		(str_store_string, s49, "str__age_reg1_family_"),
##
##		(try_for_range, ":aristocrat", lords_begin, kingdom_ladies_end),
##			(call_script, "script_troop_get_family_relation_to_troop", ":aristocrat", ":troop_no"),
##			(gt, reg0, 0),
##
##			(try_begin),
##				(neg|is_between, ":aristocrat", kingdom_ladies_begin, kingdom_ladies_end),
##				(str_store_troop_name_link, s12, ":aristocrat"),
##				(call_script, "script_troop_get_relation_with_troop", ":aristocrat", ":troop_no"),
##				(str_store_string, s49, "str_s49_s12_s11_rel_reg0"),
##			(else_try),
##				(str_store_troop_name, s12, ":aristocrat"),
##				(str_store_string, s49, "str_s49_s12_s11"),
##			(try_end),
##
##		(try_end),
##	 (try_end),
##
##     (try_begin),
##       (neq, ":troop_no", "trp_player"),
##       (neg|is_between, ":troop_faction", kingdoms_begin, kingdoms_end),
##       (str_clear, s54),
##       (add_troop_note_from_sreg, ":troop_no", 0, s54, 0),
##       (add_troop_note_from_sreg, ":troop_no", 1, s54, 0),
##       (add_troop_note_from_sreg, ":troop_no", 2, s54, 0),
###     (else_try),
###       (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
###       (str_clear, s54),
###       (add_troop_note_from_sreg, ":troop_no", 0, s54, 0),
###       (add_troop_note_from_sreg, ":troop_no", 1, s54, 0),
###       (add_troop_note_from_sreg, ":troop_no", 2, s54, 0),
##     (else_try),
##       (is_between, ":troop_no", pretenders_begin, pretenders_end),
##       (neg|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
##       (neq, ":troop_no", "$supported_pretender"),
##       (troop_get_slot, ":orig_faction", ":troop_no", slot_troop_original_faction),
##       (try_begin),
##         (faction_slot_eq, ":orig_faction", slot_faction_state, sfs_active),
##         (faction_slot_eq, ":orig_faction", slot_faction_has_rebellion_chance, 1),
##         (str_store_faction_name_link, s56, ":orig_faction"),
##         (add_troop_note_from_sreg, ":troop_no", 0, "@{s54} is a claimant to the throne of {s56}.", 0),
##         (add_troop_note_tableau_mesh, ":troop_no", "tableau_troop_note_mesh"),
##       (else_try),
##         (str_clear, s54),
##         (add_troop_note_from_sreg, ":troop_no", 0, s54, 0),
##         (add_troop_note_from_sreg, ":troop_no", 1, s54, 0),
##         (add_troop_note_from_sreg, ":troop_no", 2, s54, 0),
##       (try_end),
##     (else_try),
##       (faction_get_slot, ":faction_leader", ":troop_faction", slot_faction_leader),
##       (str_store_troop_name_link, s55, ":faction_leader"),
##       (str_store_faction_name_link, s56, ":troop_faction"),
##       (assign, ":troop_is_player_faction", 0),
##       (assign, ":troop_is_faction_leader", 0),
##       (try_begin),
##         (eq, ":troop_faction", "fac_player_faction"),
##         (assign, ":troop_is_player_faction", 1),
##       (else_try),
##         (eq, ":faction_leader", ":troop_no"),
##         (assign, ":troop_is_faction_leader", 1),
##       (try_end),
##       (assign, ":num_centers", 0),
##       (str_store_string, s58, "@nowhere"),
##       (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
##         (party_slot_eq, ":cur_center", slot_town_lord, ":troop_no"),
##         (try_begin),
##           (eq, ":num_centers", 0),
##           (str_store_party_name_link, s58, ":cur_center"),
##         (else_try),
##           (eq, ":num_centers", 1),
##           (str_store_party_name_link, s57, ":cur_center"),
##           (str_store_string, s58, "@{s57} and {s58}"),
##         (else_try),
##           (str_store_party_name_link, s57, ":cur_center"),
##           (str_store_string, s58, "@{!}{s57}, {s58}"),
##         (try_end),
##         (val_add, ":num_centers", 1),
##       (try_end),
##       (troop_get_type, reg3, ":troop_no"),
##       (troop_get_slot, reg5, ":troop_no", slot_troop_renown),
##       (str_clear, s59),
##       (try_begin),
###         (troop_get_slot, ":relation", ":troop_no", slot_troop_player_relation),
##         (call_script, "script_troop_get_player_relation", ":troop_no"),
##         (assign, ":relation", reg0),
##         (store_add, ":normalized_relation", ":relation", 100),
##         (val_add, ":normalized_relation", 5),
##         (store_div, ":str_offset", ":normalized_relation", 10),
##         (val_clamp, ":str_offset", 0, 20),
##         (store_add, ":str_id", "str_relation_mnus_100_ns",  ":str_offset"),
##         (neq, ":str_id", "str_relation_plus_0_ns"),
##         (str_store_string, s60, "@{reg3?She:He}"),
##         (str_store_string, s59, ":str_id"),
##         (str_store_string, s59, "@{!}^{s59}"),
##       (try_end),
##
##	#lord recruitment changes begin
##	#This sends a bunch of political information to s47.
##
##
##
##
##	    #refresh registers
##        (assign, reg9, ":num_centers"),
##        (troop_get_type, reg3, ":troop_no"),
##        (troop_get_slot, reg5, ":troop_no", slot_troop_renown),
##		(assign, reg4, ":troop_is_faction_leader"),
##		(assign, reg6, ":troop_is_player_faction"),
##
##        (add_troop_note_from_sreg, ":troop_no", 0, "str_reg6reg4s54_is_the_ruler_of_s56_s54_is_a_vassal_of_s55_of_s56_renown_reg5_reg9reg3shehe_is_the_reg3ladylord_of_s58reg3shehe_has_no_fiefss59_s49", 0),
##	#lord recruitment changes end
##
##        (add_troop_note_tableau_mesh, ":troop_no", "tableau_troop_note_mesh"),
##     (try_end),
     ]),

  #script_update_troop_location_notes
  # INPUT: troop_no
  # OUTPUT: none
  ("update_troop_location_notes",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":see_or_hear", 2),
      (try_begin),
        (call_script, "script_get_information_about_troops_position", ":troop_no", 1),
        (neq, reg0, 0),

        (call_script, "script_search_troop_prisoner_of_party", ":troop_no"),
        (eq, reg0, -1),
        ##diplomacy start+ use gender script
	    #(troop_get_type, reg1, ":troop_no"),
		(call_script, "script_dplmc_store_troop_is_female", ":troop_no"),
		(assign, reg1, reg0),
		##diplomacy end+
        (try_begin),
          (eq, ":see_or_hear", 0),
          (add_troop_note_from_sreg, ":troop_no", 2, "@The last time you saw {reg1?her:him}, {s1}", 1),
        (else_try),
          (add_troop_note_from_sreg, ":troop_no", 2, "@The last time you heard about {reg1?her:him}, {s1}", 1),
        (try_end),
      (try_end),
     ]),

  #script_update_troop_location_notes_prisoned
  # INPUT: troop_no
  # OUTPUT: none
  ("update_troop_location_notes_prisoned",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":capturer_faction_no", 2),
      ##diplomacy start+ use gender script
      #(troop_get_type, reg1, ":troop_no"),
	  (call_script, "script_dplmc_store_troop_is_female", ":troop_no"),
      (assign, reg1, reg0),
	  ##diplomacy end+
      (str_store_faction_name_link, s1, ":capturer_faction_no"),

      (add_troop_note_from_sreg, ":troop_no", 2, "str_reg1shehe_is_prisoner_of_s1", 1),
    ]),

  ("update_troop_political_notes",
      [
		(store_script_param, ":troop_no", 1),
		(try_begin),
		    (str_clear, s47),

			(store_faction_of_troop, ":troop_faction", ":troop_no"),

		    (faction_get_slot, ":faction_leader", ":troop_faction", slot_faction_leader),

		    (str_clear, s40),
		    (assign, ":logged_a_rivalry", 0),
		    (try_for_range, ":kingdom_hero", active_npcs_begin, active_npcs_end),
				(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":kingdom_hero"),
				(lt, reg0, -10),

		   		(str_store_troop_name_link, s39, ":kingdom_hero"),
				(try_begin),
					(eq, ":logged_a_rivalry", 0),
					(str_store_string, s40, "str_s39_rival"),
					(assign, ":logged_a_rivalry", 1),
				(else_try),
					(str_store_string, s41, "str_s40"),
					(str_store_string, s40, "str_s41_s39_rival"),
				(try_end),

		    (try_end),

		    (str_clear, s46),
		    (try_begin),
				(ge, "$cheat_mode", 1),
				(try_begin),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_martial),
					(str_store_string, s46, "str_reputation_cheat_mode_only_martial_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
					(str_store_string, s46, "str_reputation_cheat_mode_only_debauched_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_selfrighteous),
					(str_store_string, s46, "str_reputation_cheat_mode_only_pitiless_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),
					(str_store_string, s46, "str_reputation_cheat_mode_only_calculating_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_quarrelsome),
					(str_store_string, s46, "str_reputation_cheat_mode_only_quarrelsome_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),
					(str_store_string, s46, "str_reputation_cheat_mode_only_goodnatured_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
					(str_store_string, s46, "str_reputation_cheat_mode_only_upstanding_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_conventional),
					(str_store_string, s46, "str_reputation_cheat_mode_only_conventional_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_adventurous),
					(str_store_string, s46, "str_reputation_cheat_mode_only_adventurous_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_otherworldly),
					(str_store_string, s46, "str_reputation_cheat_mode_only_romantic_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_moralist),
					(str_store_string, s46, "str_reputation_cheat_mode_only_moralist_"),
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_ambitious),
					(str_store_string, s46, "str_reputation_cheat_mode_only_ambitious_"),
				(else_try),
					(troop_get_slot, reg11, ":troop_no", slot_lord_reputation_type),
					(str_store_string, s46, "str_reputation_cheat_mode_only_reg11_"),
				(try_end),

				(try_begin),
					(eq, "$cheat_mode", 1),
					(try_for_range, ":love_interest_slot", slot_troop_love_interest_1, slot_troop_love_interests_end),
						(troop_get_slot, ":love_interest", ":troop_no", ":love_interest_slot"),
						(is_between, ":love_interest", kingdom_ladies_begin, kingdom_ladies_end),
						(str_store_troop_name_link, s39, ":love_interest"),
						(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":love_interest"),
						(str_store_string, s2, "str_love_interest"),
						(try_begin),
							(troop_slot_eq, ":troop_no", slot_troop_betrothed, ":love_interest"),
							(str_store_string, s2, "str_betrothed"),
						(try_end),
						(str_store_string, s40, "str_s40_s39_s2_reg0"),
					(try_end),
				(try_end),

		    (try_end),

		    (str_store_string, s45, "str_other_relations_s40_"),

		    (str_clear, s44),
		    (try_begin),
				(neq, ":troop_no", ":faction_leader"),
				(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_leader"),
				(str_store_string, s44, "str_relation_with_liege_reg0_"),
		    (try_end),

			(str_clear, s48),

		    (try_begin),
				(eq, "$cheat_mode", 1),
				(store_current_hours, ":hours"),
				(gt, ":hours", 0),
#				(display_message, "@{!}Updating political factors"),
				(call_script, "script_calculate_troop_political_factors_for_liege", ":troop_no", ":faction_leader"),
				(str_store_string, s48, "str_sense_of_security_military_reg1_court_position_reg3_"),
			(try_end),
			(str_store_string, s47, "str_s46s45s44s48"),

			(add_troop_note_from_sreg, ":troop_no", 3, "str_political_details_s47_", 1),

		(try_end),
    ]),

  #script_update_center_notes
  # INPUT: center_no
  # OUTPUT: none
  ("update_center_notes",
    [
##      (store_script_param, ":center_no", 1),
##
##     (party_get_slot, ":lord_troop", ":center_no", slot_town_lord),
##     (try_begin),
##       (ge, ":lord_troop", 0),
##       (store_troop_faction, ":lord_faction", ":lord_troop"),
##       (str_store_troop_name_link, s1, ":lord_troop"),
##       (try_begin),
##         (eq, ":lord_troop", "trp_player"),
##         (gt, "$players_kingdom", 0),
##         (str_store_faction_name_link, s2, "$players_kingdom"),
##       (else_try),
##         (str_store_faction_name_link, s2, ":lord_faction"),
##       (try_end),
##       (str_store_party_name, s50, ":center_no"),
##       (try_begin),
##         (party_slot_eq, ":center_no", slot_party_type, spt_town),
##         (str_store_string, s51, "@The town of {s50}"),
##       (else_try),
##         (party_slot_eq, ":center_no", slot_party_type, spt_village),
##         (party_get_slot, ":bound_center", ":center_no", slot_village_bound_center),
##         (str_store_party_name_link, s52, ":bound_center"),
##         (str_store_string, s51, "@The village of {s50} near {s52}"),
##       (else_try),
##         (str_store_string, s51, "@{!}{s50}"),
##       (try_end),
##       (str_store_string, s2, "@{s51} belongs to {s1} of {s2}.^"),
##     (else_try),
##       (str_clear, s2),
##     (try_end),
##     (try_begin),
##       (is_between, ":center_no", villages_begin, villages_end),
##     (else_try),
##       (assign, ":num_villages", 0),
##       (try_for_range_backwards, ":village_no", villages_begin, villages_end),
##         (party_slot_eq, ":village_no", slot_village_bound_center, ":center_no"),
##         (try_begin),
##           (eq, ":num_villages", 0),
##           (str_store_party_name_link, s8, ":village_no"),
##         (else_try),
##           (eq, ":num_villages", 1),
##           (str_store_party_name_link, s7, ":village_no"),
##           (str_store_string, s8, "@{s7} and {s8}"),
##         (else_try),
##           (str_store_party_name_link, s7, ":village_no"),
##           (str_store_string, s8, "@{!}{s7}, {s8}"),
##         (try_end),
##         (val_add, ":num_villages", 1),
##       (try_end),
##       (try_begin),
##         (eq, ":num_villages", 0),
##         (str_store_string, s2, "@{s2}It has no villages.^"),
##       (else_try),
##         (store_sub, reg0, ":num_villages", 1),
##         (str_store_string, s2, "@{s2}{reg0?Its villages are:Its village is} {s8}.^"),
##       (try_end),
##     (try_end),
##     (call_script, "script_get_prosperity_text_to_s50", ":center_no"),
##     (add_party_note_from_sreg, ":center_no", 0, "@{s2}Its prosperity is: {s50}", 0),
##     (add_party_note_tableau_mesh, ":center_no", "tableau_center_note_mesh"),
     ]),


  #script_update_center_recon_notes
  # INPUT: center_no
  # OUTPUT: none
  ("update_center_recon_notes",
    [(store_script_param, ":center_no", 1),
     (try_begin),
       (this_or_next|is_between, ":center_no", towns_begin, towns_end),
       (is_between, ":center_no", castles_begin, castles_end),
       (party_get_slot, ":center_food_store", ":center_no", slot_party_food_store),
       (call_script, "script_center_get_food_consumption", ":center_no"),
       (assign, ":food_consumption", reg0),
       (store_div, reg6, ":center_food_store", ":food_consumption"),
       (party_collect_attachments_to_party, ":center_no", "p_collective_ally"),
       (party_get_num_companions, reg5, "p_collective_ally"),
       (add_party_note_from_sreg, ":center_no", 1, "@Current garrison consists of {reg5} men.^Has food stock for {reg6} days.", 1),
     (try_end),
     ]),

  #script_update_all_notes
  # INPUT: none
  # OUTPUT: none
  ("update_all_notes",
    [
      (call_script, "script_update_troop_notes", "trp_player"),
      (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
	    (this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
	    (this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_lady),
			(troop_slot_eq, ":troop_no", slot_troop_occupation, slto_inactive_pretender),
        (call_script, "script_update_troop_notes", ":troop_no"),
      (try_end),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (call_script, "script_update_center_notes", ":center_no"),
      (try_end),
      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
        (call_script, "script_update_faction_notes", ":faction_no"),
      (try_end),
    ]),

  #script_agent_troop_get_banner_mesh
  # INPUT: agent_no, troop_no
  # OUTPUT: banner_mesh
  ("agent_troop_get_banner_mesh",
    [
       (store_script_param, ":agent_no", 1),
       (store_script_param, ":troop_no", 2),
       (assign, ":banner_mesh", "mesh_banners_default_b"),

        (try_begin),
            (eq, "$g_is_quick_battle", 1),
            (try_begin),
                (eq, ":troop_no", -2),
                (assign, ":banner_mesh", "$g_quick_battle_team_0_banner"),
                (val_sub, ":banner_mesh", banner_meshes_begin),
                (val_add, ":banner_mesh", arms_meshes_begin),
            (else_try),
                (eq, ":troop_no", -3),
                (assign, ":banner_mesh", "$g_quick_battle_team_1_banner"),
                (val_sub, ":banner_mesh", banner_meshes_begin),
                (val_add, ":banner_mesh", arms_meshes_begin),
            (try_end),
        (else_try),
            (game_in_multiplayer_mode),
            (ge, ":troop_no", 0),
            (try_begin),
                (is_between, ":troop_no", arms_meshes_begin, arms_meshes_end_minus_one),
                (assign, ":banner_mesh", ":troop_no"),
            (try_end),
            # (store_faction_of_troop, ":faction_of_troop_script_param_1", ":troop_no"),
            # (is_between, ":faction_of_troop_script_param_1", "fac_kingdom_1", "fac_kingdoms_end"),
            # (faction_get_slot, ":banner_mesh", ":faction_of_troop_script_param_1", slot_faction_banner),
            # (val_sub, ":banner_mesh", banner_meshes_begin),
            # (val_add, ":banner_mesh", arms_meshes_begin),
        (else_try),
            (ge, ":troop_no", 0),
            (try_begin),
               (troop_slot_ge, ":troop_no", slot_troop_banner_scene_prop, 1),
               (troop_get_slot, ":banner_spr", ":troop_no", slot_troop_banner_scene_prop),
               (store_add, ":banner_scene_props_end", banner_scene_props_end_minus_one, 1),
               (is_between, ":banner_spr", banner_scene_props_begin, ":banner_scene_props_end"),
               (val_sub, ":banner_spr", banner_scene_props_begin),
               (store_add, ":banner_mesh", ":banner_spr", arms_meshes_begin),
            (try_end),
        (else_try),
            (eq, ":troop_no", -1),
            (assign, ":banner_mesh", "mesh_banners_default_a"),
        (else_try),
            (eq, ":troop_no", -2),
            (assign, ":banner_mesh", "mesh_banners_default_b"),
        (else_try),
            (eq, ":troop_no", -3),
            (assign, ":banner_mesh", "mesh_banners_default_c"),
        (else_try),
            (eq, ":troop_no", -4),
            (assign, ":banner_mesh", "mesh_banners_default_d"),
        (else_try),
            (eq, ":troop_no", -5),
            (assign, ":banner_mesh", "mesh_banners_default_e"),
        (try_end),
        (assign, reg0, ":banner_mesh"),
        #(display_message, "@banner mesh: {reg0}"),


       # (try_begin),
         # (lt, ":agent_no", 0),
         # (try_begin),
           # (ge, ":troop_no", 0),
           # (this_or_next|troop_slot_ge, ":troop_no", slot_troop_banner_scene_prop, 1),
           # (eq, ":troop_no", "trp_player"),
           # (assign, ":banner_troop", ":troop_no"),
         # (else_try),
           # (is_between, ":troop_no", companions_begin, companions_end),
           # (assign, ":banner_troop", "trp_player"),
         # (else_try),
           # (assign, ":banner_mesh", "mesh_banners_default_a"),
         # (try_end),
       # (else_try),
         # (eq, "$g_is_quick_battle", 1),
         # (agent_get_team, ":agent_team", ":agent_no"),
         # (try_begin),
           # (eq, ":agent_team", 0),
           # (assign, ":banner_mesh", "$g_quick_battle_team_0_banner"),
         # (else_try),
           # (assign, ":banner_mesh", "$g_quick_battle_team_1_banner"),
         # (try_end),
         # (try_begin),
            # (is_between, ":banner_mesh", banner_meshes_begin, arms_meshes_begin), #dckplmc - back colors
            # (store_sub, ":banner_offset", ":banner_mesh", banner_meshes_begin),
            # (store_add, ":banner_mesh", ":banner_offset", arms_meshes_begin),
         # (try_end),
       # (else_try),
         # (game_in_multiplayer_mode),
         # (agent_get_group, ":agent_group", ":agent_no"),
         # (try_begin),
           # (neg|player_is_active, ":agent_group"),
           # (agent_get_player_id, ":agent_group", ":agent_no"),
         # (try_end),
         # (try_begin),
           # #if player banners are not allowed, use the default banner mesh
           # (eq, "$g_multiplayer_allow_player_banners", 1),
           # (player_is_active, ":agent_group"),
           # (player_get_banner_id, ":player_banner", ":agent_group"),
           # (ge, ":player_banner", 0),
           # (store_add, ":banner_mesh", ":player_banner", arms_meshes_begin),
           # (assign, ":already_used", 0),
           # (try_for_range, ":cur_faction", npc_kingdoms_begin, npc_kingdoms_end), #wrong client data check
             # (faction_slot_eq, ":cur_faction", slot_faction_banner, ":banner_mesh"),
             # (assign, ":already_used", 1),
           # (try_end),
           # (eq, ":already_used", 0), #otherwise use the default banner mesh
         # (else_try),
           # (agent_get_team, ":agent_team", ":agent_no"),
           # (team_get_faction, ":team_faction_no", ":agent_team"),

           # (try_begin),
             # (agent_is_human, ":agent_no"),
             # (faction_get_slot, ":banner_mesh", ":team_faction_no", slot_faction_banner),
           # (else_try),
             # (agent_get_rider, ":rider_agent_no", ":agent_no"),
             # #(agent_get_position, pos1, ":agent_no"),
             # #(position_get_x, ":pos_x", pos1),
             # #(position_get_y, ":pos_y", pos1),
             # #(assign, reg0, ":pos_x"),
             # #(assign, reg1, ":pos_y"),
             # #(assign, reg2, ":agent_no"),
             # #(display_message, "@{!}agent_no:{reg2}, pos_x:{reg0} , posy:{reg1}"),
             # (try_begin),
               # (ge, ":rider_agent_no", 0),
               # (agent_is_active, ":rider_agent_no"),
               # (agent_get_team, ":rider_agent_team", ":rider_agent_no"),
               # (team_get_faction, ":rider_team_faction_no", ":rider_agent_team"),
               # (faction_get_slot, ":banner_mesh", ":rider_team_faction_no", slot_faction_banner),
             # (else_try),
               # (assign, ":banner_mesh", "mesh_banners_default_c"),
             # (try_end),
           # (try_end),
         # (try_end),
       # (else_try),
         # #(agent_get_troop_id, ":troop_id", ":agent_no"),
         # #(this_or_next|troop_slot_ge,  ":troop_id", slot_troop_banner_scene_prop, 1),
         # (this_or_next|troop_slot_ge,  ":troop_no", slot_troop_banner_scene_prop, 1),
         # (eq, ":troop_no", "trp_player"),
         # (assign, ":banner_troop", ":troop_no"),

       # (else_try),
         # (agent_get_troop_id, ":troop_id", ":agent_no"),
         # (agent_get_party_id, ":agent_party", ":agent_no"),
         # (try_begin),
           # (lt, ":agent_party", 0),
           # (is_between, ":troop_id", companions_begin, companions_end),
           # (main_party_has_troop, ":troop_id"),
           # (assign, ":agent_party", "p_main_party"),
         # (try_end),
         # (ge, ":agent_party", 0),
         # (party_get_template_id, ":party_template", ":agent_party"),
         # (try_begin),
           # (eq, ":party_template", "pt_deserters"),
           # (assign, ":banner_mesh", "mesh_banners_default_c"),
         # (else_try),
           # (is_between, ":agent_party", centers_begin, centers_end),
           # (is_between, ":troop_id", companions_begin, companions_end),
           # (neg|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero), #dckplmc
           # (neq, "$talk_context", tc_tavern_talk),
           # #this should be a captured companion in prison
           # (assign, ":banner_troop", "trp_player"),
         # (else_try),
           # (is_between, ":agent_party", centers_begin, centers_end),
           # (party_get_slot, ":town_lord", "$g_encountered_party", slot_town_lord),
           # (ge, ":town_lord", 0),
           # (assign, ":banner_troop", ":town_lord"),
         # (else_try),
           # (this_or_next|party_slot_eq, ":agent_party", slot_party_type, spt_kingdom_hero_party),
           # (eq, ":agent_party", "p_main_party"),
           # (party_get_num_companion_stacks, ":num_stacks", ":agent_party"),
           # (gt, ":num_stacks", 0),
           # (party_stack_get_troop_id, ":leader_troop_id", ":agent_party", 0),
           # (this_or_next|troop_slot_ge,  ":leader_troop_id", slot_troop_banner_scene_prop, 1),
           # (eq, ":leader_troop_id", "trp_player"),
           # (assign, ":banner_troop", ":leader_troop_id"),
         # (try_end),
       # (else_try), #Check if we are in a tavern
         # (eq, "$talk_context", tc_tavern_talk),
         # (neq, ":troop_no", "trp_player"),
         # (assign, ":banner_mesh", "mesh_banners_default_d"),
       # (else_try), #camp
         # (eq, "$talk_context", tc_camp_talk),
         # (assign, ":banner_troop", "trp_player"),
       # (else_try), #can't find party, this can be a town guard
         # (neq, ":troop_no", "trp_player"),
         # (is_between, "$g_encountered_party", walled_centers_begin, walled_centers_end),
         # (party_get_slot, ":town_lord", "$g_encountered_party", slot_town_lord),
         # (ge, ":town_lord", 0),
         # (assign, ":banner_troop", ":town_lord"),
       # (try_end),
       # (try_begin),
         # (ge, ":banner_troop", 0),
         # (try_begin),
           # (neg|troop_slot_ge, ":banner_troop", slot_troop_banner_scene_prop, 1),
           # (assign, ":banner_mesh", "mesh_banners_default_b"),
         # (else_try),
           # (troop_get_slot, ":banner_spr", ":banner_troop", slot_troop_banner_scene_prop),
           # (store_add, ":banner_scene_props_end", banner_scene_props_end_minus_one, 1),
           # (is_between, ":banner_spr", banner_scene_props_begin, ":banner_scene_props_end"),
           # (val_sub, ":banner_spr", banner_scene_props_begin),
           # (store_add, ":banner_mesh", ":banner_spr", arms_meshes_begin),
         # (try_end),
       # (try_end),

       # (assign, reg0, ":banner_mesh"),
       # (display_message, "@banner mesh: {reg0}")
     ]),
  #script_shield_item_set_banner
  # INPUT: agent_no
  # OUTPUT: none
  ("shield_item_set_banner",
    [
       (store_script_param, ":tableau_no",1),
       (store_script_param, ":agent_no", 2),
       (store_script_param, ":troop_no", 3),
       #(call_script, "script_agent_troop_get_banner_mesh", ":agent_no", ":troop_no"),
       #(cur_item_set_tableau_material, ":tableau_no", reg0),

       (assign, ":banner_troop", -1),
       #(assign, ":banner_mesh", 0),

       (try_begin),
           (agent_is_active, ":agent_no"),
           (agent_get_rider, ":rider_agent_no", ":agent_no"),
           (gt, ":rider_agent_no", -1),
           (assign, ":agent_no", ":rider_agent_no"),
           (agent_get_troop_id, ":troop_no", ":rider_agent_no"),
       (try_end),

       (try_begin),
         (lt, ":agent_no", 0),
         (try_begin),
           (ge, ":troop_no", 0),
           (this_or_next|troop_slot_ge, ":troop_no", slot_troop_banner_scene_prop, 1),
           (eq, ":troop_no", "trp_player"),
           (assign, ":banner_troop", ":troop_no"),
         (else_try),
           (ge, ":troop_no", 0),
           (troop_slot_eq, ":troop_no", slot_troop_banner_scene_prop, -1),
           (troop_slot_ge, ":troop_no", slot_troop_custom_banner_map_flag_type, 0),
           (assign, ":banner_troop", ":troop_no"),
         (else_try),
           (is_between, ":troop_no", companions_begin, companions_end),
           (assign, ":banner_troop", "trp_player"),
         (else_try),
           (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
           (neg|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
           (troop_slot_eq, ":troop_no", slot_troop_spouse, "trp_player"),
           (assign, ":banner_troop", "trp_player"),
         (else_try),
           (assign, ":banner_troop", -2),
         (try_end),
       (else_try),
         (eq, "$g_is_quick_battle", 1),
         (agent_get_team, ":agent_team", ":agent_no"),
         (try_begin),
           (eq, ":agent_team", 0),
           (assign, ":banner_troop", -2),
         (else_try),
           (assign, ":banner_troop", -3),
         (try_end),
         # (try_begin),
            # (is_between, ":banner_mesh", banner_meshes_begin, arms_meshes_begin), #dckplmc - back colors
            # (store_sub, ":banner_offset", ":banner_mesh", banner_meshes_begin),
            # (store_add, ":banner_mesh", ":banner_offset", arms_meshes_begin),
         # (try_end),
       (else_try),
         (game_in_multiplayer_mode),
         (agent_get_group, ":agent_group", ":agent_no"),
         (try_begin),
           (neg|player_is_active, ":agent_group"),
           (agent_get_player_id, ":agent_group", ":agent_no"),
         (try_end),
         (try_begin),
           #if player banners are not allowed, use the default banner mesh
           (eq, "$g_multiplayer_allow_player_banners", 1),
           (player_is_active, ":agent_group"),
           (player_get_banner_id, ":player_banner", ":agent_group"),
           (ge, ":player_banner", 0),
           (store_add, ":banner_troop", ":player_banner", arms_meshes_begin),
           (assign, ":already_used", 0),
           (try_for_range, ":cur_faction", npc_kingdoms_begin, npc_kingdoms_end), #wrong client data check
             (faction_slot_eq, ":cur_faction", slot_faction_banner, ":banner_troop"),
             (assign, ":already_used", 1),
           (try_end),
           (eq, ":already_used", 0), #otherwise use the default banner mesh
         (else_try),
           (agent_get_team, ":agent_team", ":agent_no"),
           (team_get_faction, ":team_faction_no", ":agent_team"),

           (try_begin),
             (agent_is_human, ":agent_no"),
             (faction_get_slot, ":banner_troop", ":team_faction_no", slot_faction_banner),
           (else_try),
             (agent_get_rider, ":rider_agent_no", ":agent_no"),
             #(agent_get_position, pos1, ":agent_no"),
             #(position_get_x, ":pos_x", pos1),
             #(position_get_y, ":pos_y", pos1),
             #(assign, reg0, ":pos_x"),
             #(assign, reg1, ":pos_y"),
             #(assign, reg2, ":agent_no"),
             #(display_message, "@{!}agent_no:{reg2}, pos_x:{reg0} , posy:{reg1}"),
             (try_begin),
               (ge, ":rider_agent_no", 0),
               (agent_is_active, ":rider_agent_no"),
               (agent_get_team, ":rider_agent_team", ":rider_agent_no"),
               (team_get_faction, ":rider_team_faction_no", ":rider_agent_team"),
               (faction_get_slot, ":banner_troop", ":rider_team_faction_no", slot_faction_banner),
             (else_try),
               (assign, ":banner_troop", -4),
             (try_end),
           (try_end),
         (try_end),
       (else_try),
         #(agent_get_troop_id, ":troop_id", ":agent_no"),
         #(this_or_next|troop_slot_ge,  ":troop_id", slot_troop_banner_scene_prop, 1),
         (this_or_next|troop_slot_ge,  ":troop_no", slot_troop_banner_scene_prop, 1),
         (eq, ":troop_no", "trp_player"),
         (assign, ":banner_troop", ":troop_no"),
       (else_try),
         (troop_slot_eq,  ":troop_no", slot_troop_banner_scene_prop, -1),
         (troop_slot_ge, ":troop_no", slot_troop_custom_banner_map_flag_type, 0),
         (assign, ":banner_troop", ":troop_no"),

       (else_try),
         (agent_get_troop_id, ":troop_id", ":agent_no"),
         (agent_get_party_id, ":agent_party", ":agent_no"),
         (try_begin),
           (lt, ":agent_party", 0),
           (is_between, ":troop_id", companions_begin, companions_end),
           (main_party_has_troop, ":troop_id"),
           (assign, ":agent_party", "p_main_party"),
         (try_end),
         (ge, ":agent_party", 0),
         (party_get_template_id, ":party_template", ":agent_party"),
         (try_begin),
           (eq, ":party_template", "pt_deserters"),
           (assign, ":banner_troop", -3),
         (else_try),
           (is_between, ":agent_party", centers_begin, centers_end),
           (is_between, ":troop_id", companions_begin, companions_end),
           (neg|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero), #dckplmc
           (neq, "$talk_context", tc_tavern_talk),
           #this should be a captured companion in prison
           (assign, ":banner_troop", "trp_player"),
         (else_try),
           (is_between, ":agent_party", centers_begin, centers_end),
           (party_get_slot, ":town_lord", "$g_encountered_party", slot_town_lord),
           (ge, ":town_lord", 0),
           (assign, ":banner_troop", ":town_lord"),
         (else_try),
           (this_or_next|party_slot_eq, ":agent_party", slot_party_type, spt_kingdom_hero_party),
           (eq, ":agent_party", "p_main_party"),
           (party_get_num_companion_stacks, ":num_stacks", ":agent_party"),
           (gt, ":num_stacks", 0),
           (party_stack_get_troop_id, ":leader_troop_id", ":agent_party", 0),
           (this_or_next|troop_slot_ge,  ":leader_troop_id", slot_troop_banner_scene_prop, 1),
           (eq, ":leader_troop_id", "trp_player"),
           (assign, ":banner_troop", ":leader_troop_id"),
         (else_try),
           (party_slot_eq, ":agent_party", slot_party_type, spt_kingdom_hero_party),
           (party_get_num_companion_stacks, ":num_stacks", ":agent_party"),
           (gt, ":num_stacks", 0),
           (party_stack_get_troop_id, ":leader_troop_id", ":agent_party", 0),
           (troop_slot_eq,  ":leader_troop_id", slot_troop_banner_scene_prop, -1),
           (troop_slot_ge, ":leader_troop_id", slot_troop_custom_banner_map_flag_type, 0),
           (assign, ":banner_troop", ":leader_troop_id"),
         (try_end),
       (else_try), #Check if we are in a tavern
         (eq, "$talk_context", tc_tavern_talk),
         (neq, ":troop_no", "trp_player"),
         (assign, ":banner_troop", -4),
       (else_try), #camp
         (eq, "$talk_context", tc_camp_talk),
         (assign, ":banner_troop", "trp_player"),
       (else_try), #can't find party, this can be a town guard
         (neq, ":troop_no", "trp_player"),
         (is_between, "$g_encountered_party", walled_centers_begin, walled_centers_end),
         (party_get_slot, ":town_lord", "$g_encountered_party", slot_town_lord),
         (ge, ":town_lord", 0),
         (assign, ":banner_troop", ":town_lord"),
       (try_end),

       # (str_store_troop_name, s0, ":troop_no"),
       # (display_message, s0),
       #(cur_item_set_banner_tableau_material, ":tableau_no", ":troop_no"),
       (cur_item_set_tableau_material, ":tableau_no", ":banner_troop"),
     ]),


  #script_troop_agent_set_banner
  # INPUT: agent_no
  # OUTPUT: none
  ("troop_agent_set_banner",
    [
       (store_script_param, ":tableau_no",1),
       (store_script_param, ":agent_no", 2),
       (store_script_param, ":troop_no", 3),
       # (call_script, "script_agent_troop_get_banner_mesh", ":agent_no", ":troop_no"),
       # (cur_agent_set_banner_tableau_material, ":tableau_no", reg0),

       (assign, ":banner_troop", -1),
       #(assign, ":banner_mesh", 0),

       (try_begin),
         (lt, ":agent_no", 0),
         (try_begin),
           (ge, ":troop_no", 0),
           (this_or_next|troop_slot_ge, ":troop_no", slot_troop_banner_scene_prop, 1),
           (eq, ":troop_no", "trp_player"),
           (assign, ":banner_troop", ":troop_no"),
         (else_try),
           (ge, ":troop_no", 0),
           (troop_slot_eq, ":troop_no", slot_troop_banner_scene_prop, -1),
           (troop_slot_ge, ":troop_no", slot_troop_custom_banner_map_flag_type, 0),
           (assign, ":banner_troop", ":troop_no"),
         (else_try),
           (is_between, ":troop_no", companions_begin, companions_end),
           (assign, ":banner_troop", "trp_player"),
         (else_try),
           (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
           (neg|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
           (troop_slot_eq, ":troop_no", slot_troop_spouse, "trp_player"),
           (assign, ":banner_troop", "trp_player"),
         (else_try),
           (assign, ":banner_troop", -2),
         (try_end),
       (else_try),
         (eq, "$g_is_quick_battle", 1),
         (agent_get_team, ":agent_team", ":agent_no"),
         (try_begin),
           (eq, ":agent_team", 0),
           (assign, ":banner_troop", -2),
         (else_try),
           (assign, ":banner_troop", -3),
         (try_end),
         # (try_begin),
            # (is_between, ":banner_mesh", banner_meshes_begin, arms_meshes_begin), #dckplmc - back colors
            # (store_sub, ":banner_offset", ":banner_mesh", banner_meshes_begin),
            # (store_add, ":banner_mesh", ":banner_offset", arms_meshes_begin),
         # (try_end),
       (else_try),
         (game_in_multiplayer_mode),
         (agent_get_group, ":agent_group", ":agent_no"),
         (try_begin),
           (neg|player_is_active, ":agent_group"),
           (agent_get_player_id, ":agent_group", ":agent_no"),
         (try_end),
         (try_begin),
           #if player banners are not allowed, use the default banner mesh
           (eq, "$g_multiplayer_allow_player_banners", 1),
           (player_is_active, ":agent_group"),
           (player_get_banner_id, ":player_banner", ":agent_group"),
           (ge, ":player_banner", 0),
           (store_add, ":banner_troop", ":player_banner", arms_meshes_begin),
           (assign, ":already_used", 0),
           (try_for_range, ":cur_faction", npc_kingdoms_begin, npc_kingdoms_end), #wrong client data check
             (faction_slot_eq, ":cur_faction", slot_faction_banner, ":banner_troop"),
             (assign, ":already_used", 1),
           (try_end),
           (eq, ":already_used", 0), #otherwise use the default banner mesh
         (else_try),
           (agent_get_team, ":agent_team", ":agent_no"),
           (team_get_faction, ":team_faction_no", ":agent_team"),

           (try_begin),
             (agent_is_human, ":agent_no"),
             (faction_get_slot, ":banner_troop", ":team_faction_no", slot_faction_banner),
           (else_try),
             (agent_get_rider, ":rider_agent_no", ":agent_no"),
             #(agent_get_position, pos1, ":agent_no"),
             #(position_get_x, ":pos_x", pos1),
             #(position_get_y, ":pos_y", pos1),
             #(assign, reg0, ":pos_x"),
             #(assign, reg1, ":pos_y"),
             #(assign, reg2, ":agent_no"),
             #(display_message, "@{!}agent_no:{reg2}, pos_x:{reg0} , posy:{reg1}"),
             (try_begin),
               (ge, ":rider_agent_no", 0),
               (agent_is_active, ":rider_agent_no"),
               (agent_get_team, ":rider_agent_team", ":rider_agent_no"),
               (team_get_faction, ":rider_team_faction_no", ":rider_agent_team"),
               (faction_get_slot, ":banner_troop", ":rider_team_faction_no", slot_faction_banner),
             (else_try),
               (assign, ":banner_troop", -4),
             (try_end),
           (try_end),
         (try_end),
       (else_try),
         #(agent_get_troop_id, ":troop_id", ":agent_no"),
         #(this_or_next|troop_slot_ge,  ":troop_id", slot_troop_banner_scene_prop, 1),
         (this_or_next|troop_slot_ge,  ":troop_no", slot_troop_banner_scene_prop, 1),
         (eq, ":troop_no", "trp_player"),
         (assign, ":banner_troop", ":troop_no"),
       (else_try),
         (troop_slot_eq,  ":troop_no", slot_troop_banner_scene_prop, -1),
         (troop_slot_ge, ":troop_no", slot_troop_custom_banner_map_flag_type, 0),
         (assign, ":banner_troop", ":troop_no"),

       (else_try),
         (agent_get_troop_id, ":troop_id", ":agent_no"),
         (agent_get_party_id, ":agent_party", ":agent_no"),
         (try_begin),
           (lt, ":agent_party", 0),
           (is_between, ":troop_id", companions_begin, companions_end),
           (main_party_has_troop, ":troop_id"),
           (assign, ":agent_party", "p_main_party"),
         (try_end),
         (ge, ":agent_party", 0),
         (party_get_template_id, ":party_template", ":agent_party"),
         (try_begin),
           (eq, ":party_template", "pt_deserters"),
           (assign, ":banner_troop", -3),
         (else_try),
           (is_between, ":agent_party", centers_begin, centers_end),
           (is_between, ":troop_id", companions_begin, companions_end),
           (neg|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero), #dckplmc
           (neq, "$talk_context", tc_tavern_talk),
           #this should be a captured companion in prison
           (assign, ":banner_troop", "trp_player"),
         (else_try),
           (is_between, ":agent_party", centers_begin, centers_end),
           (party_get_slot, ":town_lord", "$g_encountered_party", slot_town_lord),
           (ge, ":town_lord", 0),
           (assign, ":banner_troop", ":town_lord"),
         (else_try),
           (this_or_next|party_slot_eq, ":agent_party", slot_party_type, spt_kingdom_hero_party),
           (eq, ":agent_party", "p_main_party"),
           (party_get_num_companion_stacks, ":num_stacks", ":agent_party"),
           (gt, ":num_stacks", 0),
           (party_stack_get_troop_id, ":leader_troop_id", ":agent_party", 0),
           (this_or_next|troop_slot_ge,  ":leader_troop_id", slot_troop_banner_scene_prop, 1),
           (eq, ":leader_troop_id", "trp_player"),
           (assign, ":banner_troop", ":leader_troop_id"),
         (else_try),
           (party_slot_eq, ":agent_party", slot_party_type, spt_kingdom_hero_party),
           (party_get_num_companion_stacks, ":num_stacks", ":agent_party"),
           (gt, ":num_stacks", 0),
           (party_stack_get_troop_id, ":leader_troop_id", ":agent_party", 0),
           (troop_slot_eq,  ":leader_troop_id", slot_troop_banner_scene_prop, -1),
           (troop_slot_ge, ":leader_troop_id", slot_troop_custom_banner_map_flag_type, 0),
           (assign, ":banner_troop", ":leader_troop_id"),
         (try_end),
       (else_try), #Check if we are in a tavern
         (eq, "$talk_context", tc_tavern_talk),
         (neq, ":troop_no", "trp_player"),
         (assign, ":banner_troop", -4),
       (else_try), #camp
         (eq, "$talk_context", tc_camp_talk),
         (assign, ":banner_troop", "trp_player"),
       (else_try), #can't find party, this can be a town guard
         (neq, ":troop_no", "trp_player"),
         (is_between, "$g_encountered_party", walled_centers_begin, walled_centers_end),
         (party_get_slot, ":town_lord", "$g_encountered_party", slot_town_lord),
         (ge, ":town_lord", 0),
         (assign, ":banner_troop", ":town_lord"),
       (try_end),

       # (str_store_troop_name, s0, ":troop_no"),
       # (display_message, s0),
       #(cur_agent_set_banner_tableau_material, ":tableau_no", ":troop_no"),
       (cur_agent_set_banner_tableau_material, ":tableau_no", ":banner_troop"),

     ]),

##  #script_shield_item_set_banner
##  # INPUT: agent_no
##  # OUTPUT: none
##  ("shield_item_set_banner",
##    [
##       (store_script_param, ":tableau_no",1),
##       (store_script_param, ":agent_no", 2),
##       (store_script_param, ":troop_no", 3),
##       (assign, ":banner_troop", -1),
##       (try_begin),
##         (lt, ":agent_no", 0),
##         (try_begin),
##           (ge, ":troop_no", 0),
##           (troop_slot_ge, ":troop_no", slot_troop_banner_scene_prop, 0),
##           (assign, ":banner_troop", ":troop_no"),
##         (else_try),
##           (assign, ":banner_troop", -2),
##         (try_end),
##       (else_try),
##         (agent_get_troop_id, ":troop_id", ":agent_no"),
##         (troop_slot_ge,  ":troop_id", slot_troop_custom_banner_flag_type, 0),
##         (assign, ":banner_troop", ":troop_id"),
##       (else_try),
##         (agent_get_party_id, ":agent_party", ":agent_no"),
##         (try_begin),
##           (lt, ":agent_party", 0),
##           (is_between, ":troop_id", companions_begin, companions_end),
##           (main_party_has_troop, ":troop_id"),
##           (assign, ":agent_party", "p_main_party"),
##         (try_end),
##         (ge, ":agent_party", 0),
##         (party_get_template_id, ":party_template", ":agent_party"),
##         (try_begin),
##           (eq, ":party_template", "pt_deserters"),
##           (assign, ":banner_troop", -3),
##         (else_try),
##           (is_between, ":agent_party", centers_begin, centers_end),
##           (party_get_slot, ":town_lord", "$g_encountered_party", slot_town_lord),
##           (ge, ":town_lord", 0),
##           (assign, ":banner_troop", ":town_lord"),
##         (else_try),
##           (this_or_next|party_slot_eq, ":agent_party", slot_party_type, spt_kingdom_hero_party),
##           (             eq, ":agent_party", "p_main_party"),
##           (party_get_num_companion_stacks, ":num_stacks", ":agent_party"),
##           (gt, ":num_stacks", 0),
##           (party_stack_get_troop_id, ":leader_troop_id", ":agent_party", 0),
##           (troop_slot_ge,  ":leader_troop_id", slot_troop_banner_scene_prop, 1),
##           (assign, ":banner_troop", ":leader_troop_id"),
##         (try_end),
##       (else_try), #Check if we are in a tavern
##         (eq, "$talk_context", tc_tavern_talk),
##         (neq, ":troop_no", "trp_player"),
##         (assign, ":banner_troop", -4),
##       (else_try), #can't find party, this can be a town guard
##         (neq, ":troop_no", "trp_player"),
##         (is_between, "$g_encountered_party", walled_centers_begin, walled_centers_end),
##         (party_get_slot, ":town_lord", "$g_encountered_party", slot_town_lord),
##         (ge, ":town_lord", 0),
##         (assign, ":banner_troop", ":town_lord"),
##       (try_end),
##       (cur_item_set_tableau_material, ":tableau_no", ":banner_troop"),
##     ]),

  #script_add_troop_to_cur_tableau
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau",
    [
       (store_script_param, ":troop_no",1),

       (cur_tableau_clear_override_items),

#       (cur_tableau_set_override_flags, af_override_fullhelm),
       (cur_tableau_set_override_flags, af_override_head|af_override_weapons),

       (set_fixed_point_multiplier, 100),
       (assign, ":banner_mesh", -1),
       (troop_get_slot, ":banner_spr", ":troop_no", slot_troop_banner_scene_prop),
       (try_begin),
           (eq, ":banner_spr", -1),
           (try_begin),
              # (this_or_next|eq, ":troop_no", "trp_player"),
              # (is_between, ":troop_no", npcs_begin, npcs_end),
              (troop_get_slot, ":flag_icon", ":troop_no", slot_troop_custom_banner_map_flag_type),
              (ge, ":flag_icon", 0),
              (troop_get_slot, ":banner", ":troop_no", slot_troop_custom_banner_flag_type),
              (ge, ":banner", 0),
              (val_add, ":banner", "itm_banner_background1"),
              (cur_tableau_add_override_item, ":banner"),
           (try_end),
       (else_try),
           (gt, ":banner_spr", 0),
           (store_add, ":banner_scene_props_end", banner_scene_props_end_minus_one, 1),
           (try_begin),
             (is_between, ":banner_spr", banner_scene_props_begin, ":banner_scene_props_end"),
             (val_sub, ":banner_spr", banner_scene_props_begin),
             (store_add, ":banner_mesh", ":banner_spr", banner_meshes_begin),
           (try_end),
       (try_end),



       (init_position, pos2),
       (cur_tableau_set_camera_parameters, 1, 6, 6, 10, 10000),

       (init_position, pos5),
       (assign, ":eye_height", 162),
       (store_mul, ":camera_distance", ":troop_no", 87323),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 139),
       (store_mul, ":camera_yaw", ":troop_no", 124337),
       (val_mod, ":camera_yaw", 50),
       (val_add, ":camera_yaw", -25),
       (store_mul, ":camera_pitch", ":troop_no", 98123),
       (val_mod, ":camera_pitch", 20),
       (val_add, ":camera_pitch", -14),
       (assign, ":animation", "anim_stand_man"),

##       (troop_get_inventory_slot, ":horse_item", ":troop_no", ek_horse),
##       (try_begin),
##         (gt, ":horse_item", 0),
##         (assign, ":eye_height", 210),
##         (cur_tableau_add_horse, ":horse_item", pos2, anim_horse_stand, 0),
##         (assign, ":animation", anim_ride_0),
##         (position_set_z, pos5, 125),
##         (try_begin),
##           (is_between, ":camera_yaw", -10, 10), #make sure horse head doesn't obstruct face.
##           (val_min, ":camera_pitch", -5),
##         (try_end),
##       (try_end),
       (position_set_z, pos5, ":eye_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (try_begin),
         (ge, ":banner_mesh", 0),
         (eq, "$black_jack",0),#plus blackjack 21


         (init_position, pos1),
         (position_set_z, pos1, -1500),
         (position_set_x, pos1, 265),
         (position_set_y, pos1, 400),
         (position_transform_position_to_parent, pos3, pos5, pos1),
         (cur_tableau_add_mesh, ":banner_mesh", pos3, 400, 0),
       (try_end),
       (cur_tableau_add_troop, ":troop_no", pos2, ":animation" , 0),

       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30),
       (position_rotate_x, pos8, -60),
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #script_add_troop_to_cur_tableau_for_character
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_character",
    [
       (store_script_param, ":troop_no",1),

       (set_fixed_point_multiplier, 100),

       (cur_tableau_clear_override_items),
       (cur_tableau_set_override_flags, af_override_fullhelm),
##       (cur_tableau_set_override_flags, af_override_head|af_override_weapons),

       (init_position, pos2),
       (cur_tableau_set_camera_parameters, 1, 4, 8, 10, 10000),

       (init_position, pos5),
       (assign, ":cam_height", 150),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 360),
       (assign, ":camera_yaw", -15),
       (assign, ":camera_pitch", -18),
       (assign, ":animation", anim_stand_man),

       (position_set_z, pos5, ":cam_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (try_begin),
         (troop_is_hero, ":troop_no"),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (else_try),
         (store_mul, ":random_seed", ":troop_no", 126233),
         (val_mod, ":random_seed", 1000),
         (val_add, ":random_seed", 1),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
       (try_end),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30),
       (position_rotate_x, pos8, -60),
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #script_add_troop_to_cur_tableau_for_inventory
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_inventory",
    [
       (store_script_param, ":troop_no",1),
       (store_mod, ":side", ":troop_no", 4), #side flag is inside troop_no value
       (val_div, ":troop_no", 4), #removing the flag bit
       (val_mul, ":side", 90), #to degrees

       (set_fixed_point_multiplier, 100),

       (cur_tableau_clear_override_items),
       #SB : override appearance while disguised and buying stuff
       (try_begin),
         (gt, "$sneaked_into_town", disguise_none),
         (cur_tableau_set_override_flags, af_override_everything),
         (try_begin),
           (eq, "$sneaked_into_town", disguise_pilgrim),
           (cur_tableau_add_override_item, "itm_pilgrim_hood"),
           (cur_tableau_add_override_item, "itm_pilgrim_disguise"),
           (cur_tableau_add_override_item, "itm_wrapping_boots"),
         (else_try),
           (eq, "$sneaked_into_town", disguise_farmer),
           (cur_tableau_add_override_item, "itm_felt_hat"),
           (cur_tableau_add_override_item, "itm_coarse_tunic"),
           (cur_tableau_add_override_item, "itm_nomad_boots"),
         (else_try),
           (eq, "$sneaked_into_town", disguise_hunter),
           (cur_tableau_add_override_item, "itm_black_hood"),
           (cur_tableau_add_override_item, "itm_leather_gloves"),
           (cur_tableau_add_override_item, "itm_light_leather"),
           (cur_tableau_add_override_item, "itm_light_leather_boots"),
         (else_try),
           (eq, "$sneaked_into_town", disguise_merchant),
           (cur_tableau_add_override_item, "itm_leather_jacket"),
           (cur_tableau_add_override_item, "itm_woolen_hose"),
           (cur_tableau_add_override_item, "itm_felt_steppe_cap"),
         (else_try),
           (eq, "$sneaked_into_town", disguise_guard),
           (cur_tableau_add_override_item, "itm_footman_helmet"),
           (cur_tableau_add_override_item, "itm_mail_mittens"),
           (cur_tableau_add_override_item, "itm_mail_shirt"),
           (cur_tableau_add_override_item, "itm_leather_jerkin"),
           (cur_tableau_add_override_item, "itm_mail_chausses"),
         (else_try),
           (eq, "$sneaked_into_town", disguise_bard),
           (cur_tableau_add_override_item, "itm_linen_tunic"),
           (cur_tableau_add_override_item, "itm_leather_boots"),
         (try_end),
       (try_end),
       (init_position, pos2),
       (position_rotate_z, pos2, ":side"),
       (cur_tableau_set_camera_parameters, 1, 4, 6, 10, 10000),

       (init_position, pos5),
       (assign, ":cam_height", 105),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 380),
       (assign, ":camera_yaw", -15),
       (assign, ":camera_pitch", -18),
       (assign, ":animation", anim_stand_man),

       (position_set_z, pos5, ":cam_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (try_begin),
         (troop_is_hero, ":troop_no"),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (else_try),
         (store_mul, ":random_seed", ":troop_no", 126233),
         (val_mod, ":random_seed", 1000),
         (val_add, ":random_seed", 1),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
       (try_end),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30),
       (position_rotate_x, pos8, -60),
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #script_add_troop_to_cur_tableau_for_profile
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_profile",
    [
       (store_script_param, ":troop_no",1),

       (set_fixed_point_multiplier, 100),

       (cur_tableau_clear_override_items),

       (cur_tableau_set_camera_parameters, 1, 4, 6, 10, 10000),

       (init_position, pos5),
       (assign, ":cam_height", 105),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 380),
       (assign, ":camera_yaw", -15),
       (assign, ":camera_pitch", -18),
       (assign, ":animation", anim_stand_man),

       (position_set_z, pos5, ":cam_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (profile_get_banner_id, ":profile_banner"),
       (try_begin),
         (ge, ":profile_banner", 0),
         (init_position, pos2),
         (val_add, ":profile_banner", banner_meshes_begin),
         (position_set_x, pos2, -175),
         (position_set_y, pos2, -300),
         (position_set_z, pos2, 180),
         (position_rotate_x, pos2, 90),
         (position_rotate_y, pos2, -15),
         (cur_tableau_add_mesh, ":profile_banner", pos2, 0, 0),
       (try_end),

       (init_position, pos2),
       (try_begin),
         (troop_is_hero, ":troop_no"),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (else_try),
         (store_mul, ":random_seed", ":troop_no", 126233),
         (val_mod, ":random_seed", 1000),
         (val_add, ":random_seed", 1),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
       (try_end),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30),
       (position_rotate_x, pos8, -60),
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #SB : duplicate of script_add_troop_to_cur_tableau_for_profile for single-player kingdom heroes
  #script_add_troop_to_cur_tableau_for_presentation
  # INPUT: troop_no, kingdom hero or lady
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_presentation",
    [
        (store_script_param, ":troop_no",1),

        (set_fixed_point_multiplier, 100),

        (cur_tableau_clear_override_items),

        (cur_tableau_set_camera_parameters, 1, 4, 6, 10, 10000),

        (init_position, pos5),
        (assign, ":cam_height", 105),
        #       (val_mod, ":camera_distance", 5),
        (assign, ":camera_distance", 380),
        (assign, ":camera_yaw", -15),
        (assign, ":camera_pitch", -18),
        #transient pose seeds
        (troop_get_xp, ":random_seed", ":troop_no"),
        (val_add, ":random_seed", ":troop_no"),
        (val_mod, ":random_seed", 5),
        (store_add, ":animation", "anim_pose_1", ":random_seed"),

        (position_set_z, pos5, ":cam_height"),

        # camera looks towards -z axis

        (position_rotate_x, pos5, -90),
        (position_rotate_z, pos5, 180),
        # now apply yaw and pitch
        (position_rotate_y, pos5, ":camera_yaw"),
        (position_rotate_x, pos5, ":camera_pitch"),
        (position_move_z, pos5, ":camera_distance", 0),
        (position_move_x, pos5, 5, 0),

        #honestly we can just draw this in the presentation
       # (troop_get_slot, ":banner", ":troop_no", slot_troop_banner_scene_prop),
       # (try_begin), #default slot val = 0, exclude placeholders since we don't want to touch their slots
         # (ge, ":banner", 0),
         # (is_between, ":troop_no", heroes_begin, heroes_end),
         # (init_position, pos2),
         # (val_sub, ":banner", banner_scene_props_begin),
         # (val_add, ":banner", banner_meshes_begin),
         # (position_set_x, pos2, -175),
         # (position_set_y, pos2, -300),
         # (position_set_z, pos2, 180),
         # (position_rotate_x, pos2, 90),
         # (position_rotate_y, pos2, -15),
         # (cur_tableau_add_mesh, ":banner", pos2, 0, 0),
       # (try_end),

       (init_position, pos2),
       (try_begin),
         (troop_is_hero, ":troop_no"),
         (try_begin), #rotate character, not flag
           (call_script, "script_cf_dplmc_troop_is_female", ":troop_no"),
           (position_rotate_z, pos2, -45),
         (try_end),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (else_try),
         (store_mul, ":random_seed", ":troop_no", 126233),
         (val_mod, ":random_seed", 1000),
         (val_add, ":random_seed", 1),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
       (try_end),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30),
       (position_rotate_x, pos8, -60),
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),


  #script_add_troop_to_cur_tableau_for_retirement
  # INPUT: type
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_retirement", [
    (store_script_param, ":type", 1),
    (try_begin),
      (is_between, ":type", 0, 10),
      (cur_tableau_set_override_flags, af_override_everything),
    (try_end),

    (try_begin),
      (eq, ":type", 0),
      (cur_tableau_add_override_item, "itm_pilgrim_hood"),
      (cur_tableau_add_override_item, "itm_pilgrim_disguise"),
      (cur_tableau_add_override_item, "itm_wrapping_boots"),
      (assign, ":animation", "anim_pose_1"),
    (else_try),
      (eq, ":type", 1),
      (cur_tableau_add_override_item, "itm_pilgrim_hood"),
      (cur_tableau_add_override_item, "itm_red_tunic"),
      (cur_tableau_add_override_item, "itm_wrapping_boots"),
      (cur_tableau_add_override_item, "itm_dagger"),
      (assign, ":animation", "anim_pose_1"),
    (else_try),
      (eq, ":type", 2),
      (cur_tableau_add_override_item, "itm_linen_tunic"),
      (cur_tableau_add_override_item, "itm_wrapping_boots"),
      (assign, ":animation", "anim_pose_2"),
    (else_try),
      (eq, ":type", 3),
      (cur_tableau_add_override_item, "itm_nomad_vest"),
      (cur_tableau_add_override_item, "itm_nomad_boots"),
      (assign, ":animation", "anim_pose_2"),
    (else_try),
      (eq, ":type", 4),
      (cur_tableau_add_override_item, "itm_leather_apron"),
      (cur_tableau_add_override_item, "itm_leather_boots"),
      (assign, ":animation", "anim_pose_3"),
    (else_try),
      (eq, ":type", 5),
      (cur_tableau_add_override_item, "itm_red_shirt"),
      (cur_tableau_add_override_item, "itm_woolen_hose"),
      (cur_tableau_add_override_item, "itm_fur_hat"),
      (assign, ":animation", "anim_pose_3"),
    (else_try),
      (eq, ":type", 6),
      (cur_tableau_add_override_item, "itm_red_gambeson"),
      (cur_tableau_add_override_item, "itm_leather_boots"),
      (cur_tableau_add_override_item, "itm_sword_medieval_c"),
      (assign, ":animation", "anim_pose_4"),
    (else_try),
      (eq, ":type", 7),
      (cur_tableau_add_override_item, "itm_nobleman_outfit"),
      (cur_tableau_add_override_item, "itm_blue_hose"),
      (cur_tableau_add_override_item, "itm_sword_medieval_c"),
      (assign, ":animation", "anim_pose_4"),
    (else_try),
      (eq, ":type", 8),
      (cur_tableau_add_override_item, "itm_courtly_outfit"),
      (cur_tableau_add_override_item, "itm_woolen_hose"),
      (cur_tableau_add_override_item, "itm_sword_medieval_c"),
      (assign, ":animation", "anim_pose_4"),
    (else_try),
      (eq, ":type", 9),
      (cur_tableau_add_override_item, "itm_heraldic_mail_with_surcoat_for_tableau"),
      (cur_tableau_add_override_item, "itm_mail_boots_for_tableau"),
      (cur_tableau_add_override_item, "itm_sword_medieval_c"),
      (assign, ":animation", "anim_pose_5"),
    (try_end),

##    (set_fixed_point_multiplier, 100),
##    (cur_tableau_set_background_color, 0x00000000),
##    (cur_tableau_set_ambient_light, 10,11,15),

##     (init_position, pos8),
##     (position_set_x, pos8, -210),
##     (position_set_y, pos8, 200),
##     (position_set_z, pos8, 300),
##     (cur_tableau_add_point_light, pos8, 550,500,450),


    (set_fixed_point_multiplier, 100),
    (cur_tableau_set_camera_parameters, 1, 6, 6, 10, 10000),
    (assign, ":cam_height", 155),
    (assign, ":camera_distance", 575),
    (assign, ":camera_yaw", -5),
    (assign, ":camera_pitch", 10),

    (init_position, pos5),
    (position_set_z, pos5, ":cam_height"),
    # camera looks towards -z axis
    (position_rotate_x, pos5, -90),
    (position_rotate_z, pos5, 180),
    # now apply yaw and pitch
    (position_rotate_y, pos5, ":camera_yaw"),
    (position_rotate_x, pos5, ":camera_pitch"),
    (position_move_z, pos5, ":camera_distance", 0),
    (position_move_x, pos5, 60, 0),

    (init_position, pos2),
    (cur_tableau_add_troop, "trp_player", pos2, ":animation", 0),
    (cur_tableau_set_camera_position, pos5),

    (copy_position, pos8, pos5),
    (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
    (position_rotate_z, pos8, 30),
    (position_rotate_x, pos8, -60),
    (cur_tableau_add_sun_light, pos8, 175,150,125),
    ]),

  #script_add_troop_to_cur_tableau_for_party
  # INPUT: troop_no
  # OUTPUT: none
  ("add_troop_to_cur_tableau_for_party",
    [
       (store_script_param, ":troop_no",1),
       (store_mod, ":hide_weapons", ":troop_no", 2), #hide_weapons flag is inside troop_no value
       (val_div, ":troop_no", 2), #removing the flag bit

       (set_fixed_point_multiplier, 100),

       (cur_tableau_clear_override_items),
       (try_begin),
         (eq, ":hide_weapons", 1),
         (cur_tableau_set_override_flags, af_override_fullhelm|af_override_head|af_override_weapons),
       (try_end),

       (init_position, pos2),
       (cur_tableau_set_camera_parameters, 1, 6, 6, 10, 10000),

       (init_position, pos5),
       (assign, ":cam_height", 105),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 450),
       (assign, ":camera_yaw", 15),
       (assign, ":camera_pitch", -18),
       (assign, ":animation", anim_stand_man),

       (troop_get_inventory_slot, ":horse_item", ":troop_no", ek_horse),
       (try_begin),
         (gt, ":horse_item", 0),
         (eq, ":hide_weapons", 0),
         (cur_tableau_add_horse, ":horse_item", pos2, "anim_horse_stand", 0),
         (assign, ":animation", "anim_ride_0"),
         (assign, ":camera_yaw", 23),
         (assign, ":cam_height", 150),
         (assign, ":camera_distance", 550),
       (try_end),
       (position_set_z, pos5, ":cam_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

       (try_begin),
         (troop_is_hero, ":troop_no"),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (else_try),
         (store_mul, ":random_seed", ":troop_no", 126233),
         (val_mod, ":random_seed", 1000),
         (val_add, ":random_seed", 1),
         (cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
       (try_end),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30),
       (position_rotate_x, pos8, -60),
       (cur_tableau_add_sun_light, pos8, 175,150,125),
     ]),

  #script_get_prosperity_text_to_s50
  # INPUT: center_no
  # OUTPUT: none
  ("get_prosperity_text_to_s50",
    [(store_script_param, ":center_no", 1),
     (party_get_slot, ":prosperity", ":center_no", slot_town_prosperity),
     (val_div, ":prosperity", 20),
     (try_begin),
       (eq, ":prosperity", 0), #0..19
       (str_store_string, s50, "@Very Poor"),
     (else_try),
       (eq, ":prosperity", 1), #20..39
       (str_store_string, s50, "@Poor"),
     (else_try),
       (eq, ":prosperity", 2), #40..59
       (str_store_string, s50, "@Average"),
     (else_try),
       (eq, ":prosperity", 3), #60..79
       (str_store_string, s50, "@Rich"),
     (else_try),
       (str_store_string, s50, "@Very Rich"), #80..99
     (try_end),
     ]),

  #script_spawn_bandits
  # INPUT: none
  # OUTPUT: none
  ("spawn_bandits",
    [
     (set_spawn_radius,1),

	 (try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "@{!}DEBUG : Doing spawn bandit script"),
	 (try_end),

	 (party_template_set_slot, "pt_steppe_bandits", slot_party_template_lair_type, "pt_steppe_bandit_lair"),
	 (party_template_set_slot, "pt_taiga_bandits", slot_party_template_lair_type, "pt_taiga_bandit_lair"),
	 (party_template_set_slot, "pt_mountain_bandits", slot_party_template_lair_type, "pt_mountain_bandit_lair"),
	 (party_template_set_slot, "pt_forest_bandits", slot_party_template_lair_type, "pt_forest_bandit_lair"),
	 (party_template_set_slot, "pt_sea_raiders", slot_party_template_lair_type, "pt_sea_raider_lair"),
	 (party_template_set_slot, "pt_desert_bandits", slot_party_template_lair_type, "pt_desert_bandit_lair"),

	 (party_template_set_slot, "pt_steppe_bandits", slot_party_template_lair_spawnpoint, "p_steppe_bandit_spawn_point"),
	 (party_template_set_slot, "pt_taiga_bandits", slot_party_template_lair_spawnpoint, "p_taiga_bandit_spawn_point"),
	 (party_template_set_slot, "pt_mountain_bandits", slot_party_template_lair_spawnpoint, "p_mountain_bandit_spawn_point"),
	 (party_template_set_slot, "pt_forest_bandits", slot_party_template_lair_spawnpoint, "p_forest_bandit_spawn_point"),
	 (party_template_set_slot, "pt_sea_raiders", slot_party_template_lair_spawnpoint, "p_sea_raider_spawn_point_1"),
	 (party_template_set_slot, "pt_desert_bandits", slot_party_template_lair_spawnpoint, "p_desert_bandit_spawn_point"),

     (try_begin),
       (party_template_get_slot, ":bandit_lair_party", "pt_mountain_bandits", slot_party_template_lair_party),
	   (gt, ":bandit_lair_party", 1),

       (store_num_parties_of_template, ":num_parties", "pt_mountain_bandits"),
       (lt,":num_parties",16), #was 14 at mount&blade, 18 in warband, 16 last decision
       (store_random,":spawn_point",num_mountain_bandit_spawn_points),
       (val_add,":spawn_point","p_mountain_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_mountain_bandits"),
     (try_end),
     (try_begin),

       (party_template_get_slot, ":bandit_lair_party", "pt_forest_bandits", slot_party_template_lair_party),
	   (gt, ":bandit_lair_party", 1),

       (store_num_parties_of_template, ":num_parties", "pt_forest_bandits"),
       (lt,":num_parties",16), #was 14 at mount&blade, 18 in warband, 16 last decision
       (store_random,":spawn_point",num_forest_bandit_spawn_points),
       (val_add,":spawn_point","p_forest_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_forest_bandits"),
     (try_end),
     (try_begin),

       (party_template_get_slot, ":bandit_lair_party", "pt_sea_raiders", slot_party_template_lair_party),
	   (gt, ":bandit_lair_party", 1),

       (store_num_parties_of_template, ":num_parties", "pt_sea_raiders"),
       (lt,":num_parties",16), #was 14 at mount&blade, 18 in warband, 16 last decision
       (store_random,":spawn_point",num_sea_raider_spawn_points),
       (val_add,":spawn_point","p_sea_raider_spawn_point_1"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_sea_raiders"),
     (try_end),
     (try_begin),

       (party_template_get_slot, ":bandit_lair_party", "pt_steppe_bandits", slot_party_template_lair_party),
	   (gt, ":bandit_lair_party", 1),

       (store_num_parties_of_template, ":num_parties", "pt_steppe_bandits"),
       (lt,":num_parties",16), #was 14 at mount&blade, 18 in warband, 16 last decision
       (store_random,":spawn_point",num_steppe_bandit_spawn_points),
       (val_add,":spawn_point","p_steppe_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_steppe_bandits"),
     (try_end),
     (try_begin),

       (party_template_get_slot, ":bandit_lair_party", "pt_taiga_bandits", slot_party_template_lair_party),
	   (gt, ":bandit_lair_party", 1),

       (store_num_parties_of_template, ":num_parties", "pt_taiga_bandits"),
       (lt,":num_parties",16), #was 14 at mount&blade, 18 in warband, 16 last decision
       (store_random,":spawn_point",num_taiga_bandit_spawn_points),
       (val_add,":spawn_point","p_taiga_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_taiga_bandits"),
     (try_end),
     (try_begin),

       (party_template_get_slot, ":bandit_lair_party", "pt_desert_bandits", slot_party_template_lair_party),
	   (gt, ":bandit_lair_party", 1),

       (store_num_parties_of_template, ":num_parties", "pt_desert_bandits"),
       (lt,":num_parties",16), #was 14 at mount&blade, 18 in warband, 16 last decision
       (store_random,":spawn_point",num_desert_bandit_spawn_points),
       (val_add,":spawn_point","p_desert_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_desert_bandits"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_looters"),
       (lt,":num_parties",42), #was 33 at mount&blade, 50 in warband, 42 last decision
       (store_random_in_range,":spawn_point",villages_begin,villages_end), #spawn looters twice to have lots of them at the beginning
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_looters"),
       (assign, ":spawned_party_id", reg0),
       (try_begin),
         (check_quest_active, "qst_deal_with_looters"),
         (party_set_flags, ":spawned_party_id", pf_quest_party, 1),
       (else_try),
         (party_set_flags, ":spawned_party_id", pf_quest_party, 0),
       (try_end),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_deserters"),
       (lt,":num_parties",15),
       (set_spawn_radius, 4),
       (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
	     (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
         (store_random_in_range, ":random_no", 0, 100),
         (lt, ":random_no", 5),
         (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
         (store_troop_faction, ":troop_faction", ":troop_no"),
         (neq, ":troop_faction", "fac_player_supporters_faction"),
         (gt, ":party_no", 0),
         (neg|party_is_in_any_town, ":party_no"),
##         (party_get_attached_to, ":attached_party_no", ":party_no"),
##         (lt, ":attached_party_no", 0),#in wilderness
         (spawn_around_party, ":party_no", "pt_deserters"),
         (assign, ":new_party", reg0),

         ##dckplmc
         (try_begin),
          (is_between, ":troop_faction", npc_kingdoms_begin, kingdoms_end),
          (store_sub, ":fac_offset", ":troop_faction", npc_kingdoms_begin),
          (store_add, ":icon", "icon_kingdom_1_soldier_a", ":fac_offset"),
          (party_set_icon, ":new_party", ":icon"),
         (try_end),
         ##

         (store_troop_faction, ":faction_no", ":troop_no"),
         (faction_get_slot, ":tier_1_troop", ":faction_no", slot_faction_tier_1_troop),
         (store_character_level, ":level", "trp_player"),
         (store_mul, ":max_number_to_add", ":level", 2),
         (val_add, ":max_number_to_add", 11),
         (store_random_in_range, ":number_to_add", 10, ":max_number_to_add"),
         (party_add_members, ":new_party", ":tier_1_troop", ":number_to_add"),
         (store_random_in_range, ":random_no", 1, 4),
         (try_for_range, ":unused", 0, ":random_no"),
           (party_upgrade_with_xp, ":new_party", 1000000, 0),
         (try_end),
##         (str_store_party_name, s1, ":party_no"),
##         (call_script, "script_get_closest_center", ":party_no"),
##         (try_begin),
##           (gt, reg0, 0),
##           (str_store_party_name, s2, reg0),
##         (else_try),
##           (str_store_string, s2, "@unknown place"),
##         (try_end),
##         (assign, reg1, ":number_to_add"),
##         (display_message, "@{reg1} Deserters spawned from {s1}, near {s2}."),
       (try_end),
     (try_end), #deserters ends

	 # AC : Dark Hunters, Black Khergits, NPC Ships
     (try_begin),
       (eq, "$g_dark_hunters_enabled", 1),
       (store_num_parties_of_template, ":num_parties", "pt_dark_hunters"),
       (lt,":num_parties",4),
		(store_random_in_range, ":selected_town", towns_begin, towns_end),
		(set_spawn_radius, 25),
		(spawn_around_party, ":selected_town", "pt_dark_hunters"),
     (try_end),
     (try_begin),
       (eq, "$g_dark_hunters_enabled", 1),
       (store_num_parties_of_template, ":num_parties", "pt_black_khergit_raiders"),
       (lt,":num_parties",4),
       (store_random,":spawn_point",num_steppe_bandit_spawn_points),
       (val_add,":spawn_point","p_steppe_bandit_spawn_point"),
       (set_spawn_radius, 25),
       (spawn_around_party,":spawn_point","pt_black_khergit_raiders"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_sea_raiders_ship"),
       (lt,":num_parties",17),
       (set_spawn_radius, 25),
       (spawn_around_party,"p_reserved_1","pt_sea_raiders_ship"),
       (assign, ":party_no", reg0),
       (party_set_slot, ":party_no", slot_party_ship_type, 1),
       # (party_get_position, pos1, "p_town_19"),
       # (map_get_water_position_around_position, pos1, pos0, 10),
       # (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_point),
       # (party_set_ai_target_position, ":party_no", pos1),
       # (party_set_flags, ":party_no", pf_default_behavior, 0),
       # (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_party),
       # (party_set_ai_object, ":party_no", "p_main_party"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_corsair_ship"),
       (lt,":num_parties",17),
       (set_spawn_radius, 25),
       (spawn_around_party,"p_reserved_3","pt_corsair_ship"),
       (assign, ":party_no", reg0),
       (party_set_slot, ":party_no", slot_party_ship_type, 2),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_merchant_ship"),
       (lt,":num_parties",8),
       (set_spawn_radius, 1),
       (store_random_in_range, ":origin_port", "p_port_1", "p_ports_end"),
       (spawn_around_party,":origin_port","pt_merchant_ship"),
       (assign, ":party_no", reg0),
       (party_set_slot, ":party_no", slot_party_ship_type, 3),
       (party_set_flags, ":party_no", pf_default_behavior, 0),
       (party_set_ai_behavior, ":party_no", ai_bhvr_travel_to_party),
       # (party_get_slot, ":port_town", ":origin_port", slot_port_town),
       # (store_faction_of_party, ":town_faction", ":port_town"),
       # (faction_get_slot, ":reinforcements_b", ":town_faction", slot_faction_reinforcements_b),
       # (try_begin),
         # (eq, ":town_faction", "fac_player_supporters_faction"),
         # (party_get_slot, ":reinforcement_faction", ":port_town", slot_center_original_faction),
         # (faction_get_slot, ":reinforcements_b", ":reinforcement_faction", slot_faction_reinforcements_b),
       # (try_end),
       # (party_add_template, ":party_no", ":reinforcements_b"),
       # (party_add_template, ":party_no", ":reinforcements_b"),
       # (party_set_faction, ":party_no", ":town_faction"),
       (store_random_in_range, ":dest_port", "p_port_1", "p_ports_end"),
       (party_set_ai_object, ":party_no", ":dest_port"),
     (try_end),
     (try_begin),
       (store_num_parties_of_template, ":num_parties", "pt_pirate_ship"),
       (lt,":num_parties",17),
       (set_spawn_radius, 25),
       (spawn_around_party,"p_reserved_2","pt_pirate_ship"),
       (assign, ":party_no", reg0),
       (party_set_slot, ":party_no", slot_party_ship_type, 4),
     (try_end),


	 #Spawn bandit lairs
	(try_for_range, ":bandit_template", bandit_party_templates_begin, bandit_party_templates_end), #SB : template range
		(party_template_get_slot, ":bandit_lair_party", ":bandit_template", slot_party_template_lair_party),
		(le, ":bandit_lair_party", 1),

        #dckplmc
        (party_template_get_slot, ":next_spawn", ":bandit_template", slot_party_template_lair_next_spawn),
        (val_max, ":next_spawn", 0), #in case -1
        (store_current_hours, ":cur_hours"),
    (val_max, ":cur_hours", 0), #in case -1
        (store_sub, ":time_left", ":cur_hours", ":next_spawn"),
    (ge, ":time_left", 0), #1 week

		(party_template_get_slot, ":bandit_lair_template", ":bandit_template", slot_party_template_lair_type),
		(party_template_get_slot, ":bandit_lair_template_spawnpoint", ":bandit_template", slot_party_template_lair_spawnpoint),

		(set_spawn_radius, 20),

        (spawn_around_party, ":bandit_lair_template_spawnpoint", ":bandit_lair_template"),
		(assign, ":new_camp", reg0),

		(party_set_slot, ":new_camp", slot_party_type, spt_bandit_lair),

		(str_store_party_name, s4, ":new_camp"),

		(party_get_position, pos4, ":new_camp"),
        #(party_set_flags, ":new_camp", pf_icon_mask, 1),

		(party_get_current_terrain, ":new_camp_terrain", ":new_camp"),
		(position_get_z, ":elevation", pos4),
		(position_get_y, ":lair_y", pos4),

		(assign, ":center_too_close", 0),
		(try_for_range, ":center", centers_begin, centers_end),
			(eq, ":center_too_close", 0),
			(store_distance_to_party_from_party, ":distance", ":new_camp", ":center"),
			(lt, ":distance", 3),
			(assign, ":center_too_close", 1),
		(try_end),

		(try_begin),
			(eq, ":center_too_close", 1),
			(party_is_active, ":new_camp"),
			(remove_party, ":new_camp"),
			(party_template_set_slot, ":bandit_template", slot_party_template_lair_party, 0),
		(else_try),
			(eq, ":bandit_template", "pt_sea_raiders"),
			(eq, ":new_camp_terrain", 3),
			(map_get_water_position_around_position, pos5, pos4, 4),
			(party_template_set_slot, ":bandit_template", slot_party_template_lair_party, ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),
		(else_try),
			(eq, ":bandit_template", "pt_mountain_bandits"),
			(eq, ":new_camp_terrain", 3),
			(gt, ":elevation", 250),
			(party_template_set_slot, ":bandit_template", slot_party_template_lair_party, ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),
		(else_try),
			(eq, ":bandit_template", "pt_desert_bandits"),
			(eq, ":new_camp_terrain", 5),
			(gt, ":lair_y", -9000),
			(gt, ":elevation", 125),
			(party_template_set_slot, ":bandit_template", slot_party_template_lair_party, ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),
		(else_try),
			(eq, ":bandit_template", "pt_steppe_bandits"),
			(this_or_next|eq, ":new_camp_terrain", 2),
			(eq, ":new_camp_terrain", 10),
			(this_or_next|eq, ":new_camp_terrain", 10),
			(gt, ":elevation", 200),
			(party_template_set_slot, ":bandit_template", slot_party_template_lair_party, ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),
		(else_try),
			(eq, ":bandit_template", "pt_taiga_bandits"),
			(eq, ":new_camp_terrain", 12),
			(party_template_set_slot, ":bandit_template", slot_party_template_lair_party, ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),
		(else_try),
			(eq, ":bandit_template", "pt_forest_bandits"),
			(eq, ":new_camp_terrain", 11),
			(party_template_set_slot, ":bandit_template", slot_party_template_lair_party, ":new_camp"),
			(party_set_flags, ":new_camp", pf_disabled, 1),
		(else_try),
			(party_is_active, ":new_camp"),
			(str_store_party_name, s4, ":new_camp"),
			(remove_party, ":new_camp"),
			(party_template_set_slot, ":bandit_template", slot_party_template_lair_party, 0),
		(else_try),
		(try_end),
	(try_end),
     ]),

  #script_count_mission_casualties_from_agents
  # INPUT: none
  # OUTPUT: none
  ("count_mission_casualties_from_agents",
    [(party_clear, "p_player_casualties"),
     (party_clear, "p_enemy_casualties"),
     (party_clear, "p_ally_casualties"),
     (assign, "$any_allies_at_the_last_battle", 0),
     #(assign, "$num_routed_us", 0), #these should not assign to 0 here to protect routed agents to spawn again in next turns.
     #(assign, "$num_routed_allies", 0),
     #(assign, "$num_routed_enemies", 0),

     #initialize all routed counts of troops
     (try_for_agents, ":cur_agent"),
       (agent_is_human, ":cur_agent"),
       (agent_get_party_id, ":agent_party", ":cur_agent"),
       (agent_get_troop_id, ":agent_troop_id", ":cur_agent"),
       (troop_set_slot, ":agent_troop_id", slot_troop_player_routed_agents, 0),
       (troop_set_slot, ":agent_troop_id", slot_troop_ally_routed_agents, 0),
       (troop_set_slot, ":agent_troop_id", slot_troop_enemy_routed_agents, 0),
     (try_end),

     (try_for_agents, ":cur_agent"),
       (agent_is_human, ":cur_agent"),
       (agent_get_party_id, ":agent_party", ":cur_agent"),
       (try_begin),
         (neq, ":agent_party", "p_main_party"),
         (agent_is_ally, ":cur_agent"),
         (assign, "$any_allies_at_the_last_battle", 1),
       (try_end),
       #count routed agents in player party, ally parties and enemy parties
       (try_begin),
         #(agent_is_routed, ":cur_agent"), #dckplmc
         (assign, ":continue", 0),
         (agent_get_slot, ":agent_was_running_away", ":cur_agent", slot_agent_is_running_away),
         (try_begin),
             (agent_is_routed, ":cur_agent"),
             (eq, ":agent_was_running_away", 1),
             (assign, ":continue", 1),
         (else_try),
            (agent_is_alive, ":cur_agent"),
            (eq, ":agent_was_running_away", 1),
            (assign, ":continue", 1),
         (try_end),
         (eq, ":continue", 1),
         (try_begin),
           (agent_get_troop_id, ":routed_ag_troop_id", ":cur_agent"),
           (agent_get_party_id, ":routed_ag_party_id", ":cur_agent"),
           #only enemies
           #only regulars

           (try_begin),
             (eq, ":agent_party", "p_main_party"),
             (val_add, "$num_routed_us", 1),
           (else_try),
             (agent_is_ally, ":cur_agent"),
             (val_add, "$num_routed_allies", 1),
           (else_try),
             #for now only count and include routed enemy agents in new routed party.
             (val_add, "$num_routed_enemies", 1),

             (gt, ":routed_ag_party_id", -1),
             (store_faction_of_party, ":faction_of_routed_agent_party", ":routed_ag_party_id"),

             (faction_get_slot, ":num_routed_agents_in_this_faction", ":faction_of_routed_agent_party", slot_faction_num_routed_agents),
             (val_add, ":num_routed_agents_in_this_faction", 1),
             (faction_set_slot, ":faction_of_routed_agent_party", slot_faction_num_routed_agents, ":num_routed_agents_in_this_faction"),
             (party_add_members, "p_routed_enemies", ":routed_ag_troop_id", 1),
           (try_end),
         (try_end),
         (agent_get_troop_id, ":agent_troop_id", ":cur_agent"),
         (try_begin),
           (eq, ":agent_party", "p_main_party"),
           (troop_get_slot, ":player_routed_agents", ":agent_troop_id", slot_troop_player_routed_agents),
           (val_add, ":player_routed_agents", 1),
           (troop_set_slot, ":agent_troop_id", slot_troop_player_routed_agents, ":player_routed_agents"),

         (else_try),
           (agent_is_ally, ":cur_agent"),
           (troop_get_slot, ":ally_routed_agents", ":agent_troop_id", slot_troop_ally_routed_agents),
           (val_add, ":ally_routed_agents", 1),
           (troop_set_slot, ":agent_troop_id", slot_troop_ally_routed_agents, ":ally_routed_agents"),

         (else_try),
           (troop_get_slot, ":enemy_routed_agents", ":agent_troop_id", slot_troop_enemy_routed_agents),
           (val_add, ":enemy_routed_agents", 1),
           (troop_set_slot, ":agent_troop_id", slot_troop_enemy_routed_agents, ":enemy_routed_agents"),

         (try_end),
       (try_end),
       #count and save killed agents in player party, ally parties and enemy parties
       (assign, ":continue", 0),
       (agent_get_slot, ":agent_was_running_away", ":cur_agent", slot_agent_is_running_away),
       (try_begin),
         (neg|agent_is_alive, ":cur_agent"),
         (assign, ":continue", 1),
       (else_try),
        (eq, ":agent_was_running_away", 1),
        (assign, ":continue", 1),
       (try_end),
       (eq, ":continue", 1),
       #(neg|agent_is_alive, ":cur_agent"),
       (agent_get_troop_id, ":agent_troop_id", ":cur_agent"),
       (try_begin),
         (eq, ":agent_party", "p_main_party"),
         (party_add_members, "p_player_casualties", ":agent_troop_id", 1),
         (try_begin),
           (agent_is_wounded, ":cur_agent"),
           (party_wound_members, "p_player_casualties", ":agent_troop_id", 1),
         (try_end),
       (else_try),
         (agent_is_ally, ":cur_agent"),
         (party_add_members, "p_ally_casualties", ":agent_troop_id", 1),
         (try_begin),
           (agent_is_wounded, ":cur_agent"),
           (party_wound_members, "p_ally_casualties", ":agent_troop_id", 1),
         (try_end),
       (else_try),
         (party_add_members, "p_enemy_casualties", ":agent_troop_id", 1),
         (try_begin),
           (agent_is_wounded, ":cur_agent"),
           (party_wound_members, "p_enemy_casualties", ":agent_troop_id", 1),
         (try_end),
       (try_end),
     (try_end),
     ]),

  #script_get_max_skill_of_player_party
  # INPUT: arg1 = skill_no
  # OUTPUT: reg0 = max_skill, reg1 = skill_owner_troop_no
  ("get_max_skill_of_player_party",
    [(store_script_param, ":skill_no", 1),
     (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
     (store_skill_level, ":max_skill", ":skill_no", "trp_player"),
     (assign, ":skill_owner", "trp_player"),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop","p_main_party",":i_stack"),
       (troop_is_hero, ":stack_troop"),
       (neg|troop_is_wounded, ":stack_troop"),
       (store_skill_level, ":cur_skill", ":skill_no", ":stack_troop"),
       (gt, ":cur_skill", ":max_skill"),
       (assign, ":max_skill", ":cur_skill"),
       (assign, ":skill_owner", ":stack_troop"),
     (try_end),
     (party_get_skill_level, reg0, "p_main_party", ":skill_no"),
##     (assign, reg0, ":max_skill"),
     (assign, reg1, ":skill_owner"),
     ]),

  #script_upgrade_hero_party
  # INPUT: arg1 = party_id, arg2 = xp_amount
  ("upgrade_hero_party",
    [
      (store_script_param, ":party_no", 1),
      (store_script_param, ":xp_amount", 2),
      ##diplomacy start+
      #Take into account faction quality/quantity settings.  Do not apply this
      #to the player party or to special parties.
      (try_begin),
        (ge, ":party_no", spawn_points_begin),
        (store_faction_of_party, ":var1", ":party_no"),
        (faction_get_slot, ":var1", ":var1", dplmc_slot_faction_quality),
        (val_add, ":var1", 100),
        (val_clamp, ":var1", 97, 104),#100 plus or minus three percent
        (val_mul, ":xp_amount", ":var1"),
        (val_div, ":xp_amount", 100),
      (try_end),
       ##diplomacy end+
      (party_upgrade_with_xp, ":party_no", ":xp_amount", 0),
    ]),

  #script_get_improvement_details
  # INPUT: arg1 = improvement
  # OUTPUT: reg0 = base_cost
  ("get_improvement_details",
    [(store_script_param, ":improvement_no", 1),
     (try_begin),
       (eq, ":improvement_no", slot_center_has_manor),
       (str_store_string, s0, "@Manor"),
       (str_store_string, s1, "@A manor lets you rest at the village and pay your troops half wages while you rest."),
       (assign, reg0, 8000),
     (else_try),
       (eq, ":improvement_no", slot_center_has_fish_pond),
       (str_store_string, s0, "@Mill"),
       (str_store_string, s1, "@A mill increases village prosperity by 5%."),
       (assign, reg0, 6000),
     (else_try),
       (eq, ":improvement_no", slot_center_has_watch_tower),
       (str_store_string, s0, "@Watch Tower"),
       (str_store_string, s1, "@A watch tower lets the villagers raise alarm earlier. The time it takes for enemies to loot the village increases by 50%."),
       (assign, reg0, 5000),
     (else_try),
       (eq, ":improvement_no", slot_center_has_school),
       (str_store_string, s0, "@School"),
       (str_store_string, s1, "@A shool increases the loyality of the villagers to you by +1 every month."),
       (assign, reg0, 9000),
     (else_try),
       (eq, ":improvement_no", slot_center_has_messenger_post),
       (str_store_string, s0, "@Messenger Post"),
       (str_store_string, s1, "@A messenger post lets the inhabitants send you a message whenever enemies are nearby, even if you are far away from here."),
       (assign, reg0, 4000),
     (else_try),
       (eq, ":improvement_no", slot_center_has_prisoner_tower),
       (str_store_string, s0, "@Prison Tower"),
       (str_store_string, s1, "@A prison tower reduces the chance of captives held here running away successfully."),
       (assign, reg0, 7000),
     (try_end),
     ]),

  #script_cf_troop_agent_is_alive
  # INPUT: arg1 = troop_id
  ("cf_troop_agent_is_alive",
    [(store_script_param, ":troop_no", 1),
     (assign, ":alive_count", 0),
     (try_for_agents, ":cur_agent"),
       (agent_get_troop_id, ":cur_agent_troop", ":cur_agent"),
       (eq, ":troop_no", ":cur_agent_troop"),
       (agent_is_alive, ":cur_agent"),
       (val_add, ":alive_count", 1),
     (try_end),
     (gt, ":alive_count", 0),
     ]),

  ("cf_village_recruit_volunteers_cond",
    [

	 (try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "str_checking_volunteer_availability_script"),
	 (try_end),

	 # (neg|party_slot_eq, "$current_town", slot_village_state, svs_looted),
	 # (neg|party_slot_eq, "$current_town", slot_village_state, svs_deserted),
     # (neg|party_slot_eq, "$current_town", slot_village_state, svs_being_raided),
     # (neg|party_slot_ge, "$current_town", slot_village_infested_by_bandits, 1),
     (call_script, "script_cf_village_normal_cond", "$current_town"),
     (store_faction_of_party, ":village_faction", "$current_town"),
     (party_get_slot, ":center_relation", "$current_town", slot_center_player_relation),
     (store_relation, ":village_faction_relation", ":village_faction", "fac_player_faction"),

     (ge, ":center_relation", 0),
	 (try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "str_center_relation_at_least_zero"),
	 (try_end),




     (this_or_next|ge, ":center_relation", 5),
     (this_or_next|eq, ":village_faction", "$players_kingdom"),
     (this_or_next|ge, ":village_faction_relation", 0),
     (this_or_next|eq, ":village_faction", "$supported_pretender_old_faction"),
		(eq, "$players_kingdom", 0),

	 (try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "str_relationfaction_conditions_met"),
	 (try_end),


     (party_slot_ge, "$current_town", slot_center_volunteer_troop_amount, 1), #SB : ge 1, not 0
     (party_slot_ge, "$current_town", slot_center_volunteer_troop_type, 1),

	 (try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "str_troops_available"),
	 (try_end),


     (party_get_free_companions_capacity, ":free_capacity", "p_main_party"),
     (ge, ":free_capacity", 1),

	 (try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "str_party_has_capacity"),
	 (try_end),


     ]),

  #script_village_recruit_volunteers_recruit
  # INPUT: none
  # OUTPUT: none
  ("village_recruit_volunteers_recruit",
    [(party_get_slot, ":volunteer_troop", "$current_town", slot_center_volunteer_troop_type),
     (party_get_slot, ":volunteer_amount", "$current_town", slot_center_volunteer_troop_amount),
     (party_get_free_companions_capacity, ":free_capacity", "p_main_party"),
     (val_min, ":volunteer_amount", ":free_capacity"),
     (store_troop_gold, ":gold", "trp_player"),
     (store_div, ":gold_capacity", ":gold", 10),#10 denars per man
     (val_min, ":volunteer_amount", ":gold_capacity"),
     (party_add_members, "p_main_party", ":volunteer_troop", ":volunteer_amount"),
     (party_set_slot, "$current_town", slot_center_volunteer_troop_amount, -1),
     (store_mul, ":cost", ":volunteer_amount", 10),#10 denars per man
     (troop_remove_gold, "trp_player", ":cost"),
     ]),

  #script_get_troop_item_amount
  # INPUT: arg1 = troop_no, arg2 = item_no
  # OUTPUT: reg0 = item_amount
  ("get_troop_item_amount",
    [(store_script_param, ":troop_no", 1),
     (store_script_param, ":item_no", 2),
     (troop_get_inventory_capacity, ":inv_cap", ":troop_no"),
     (assign, ":count", 0),
     (try_for_range, ":i_slot", 0, ":inv_cap"),
       (troop_get_inventory_slot, ":cur_item", ":troop_no", ":i_slot"),
       (eq, ":cur_item", ":item_no"),
       (val_add, ":count", 1),
     (try_end),
     (assign, reg0, ":count"),
     ]),

  #script_get_name_from_dna_to_s50
  # INPUT: arg1 = dna
  # OUTPUT: s50 = name
  ("get_name_from_dna_to_s50",
    [(store_script_param, ":dna", 1),
     (store_sub, ":num_names", names_end, names_begin),
     (store_sub, ":num_surnames", surnames_end, surnames_begin),
     (assign, ":selected_name", ":dna"),
     (val_mod, ":selected_name", ":num_names"),
     (assign, ":selected_surname", ":dna"),
     (val_div, ":selected_surname", ":num_names"),
     (val_mod, ":selected_surname", ":num_surnames"),
     (val_add, ":selected_name", names_begin),
     (val_add, ":selected_surname", surnames_begin),
     (str_store_string, s50, ":selected_name"),
     (str_store_string, s50, ":selected_surname"),
     ]),

  #script_change_center_prosperity
  # INPUT: arg1 = center_no, arg2 = difference
  # OUTPUT: none
  ("change_center_prosperity",
    [(store_script_param, ":center_no", 1),
     (store_script_param, ":difference", 2),
     (party_get_slot, ":old_prosperity", ":center_no", slot_town_prosperity),
     (store_add, ":new_prosperity", ":old_prosperity", ":difference"),
     (val_clamp, ":new_prosperity", 0, 100),
     (store_div, ":old_state", ":old_prosperity", 20),
     (store_div, ":new_state", ":new_prosperity", 20),

     (try_begin),
       (neq, ":old_state", ":new_state"),
	   (neg|is_between, ":center_no", castles_begin, castles_end),

       (str_store_party_name_link, s2, ":center_no"),
       (call_script, "script_get_prosperity_text_to_s50", ":center_no"),
       (str_store_string, s3, s50),
       (party_set_slot, ":center_no", slot_town_prosperity, ":new_prosperity"),
       (call_script, "script_get_prosperity_text_to_s50", ":center_no"),
       (str_store_string, s4, s50),
       (try_begin),
         (party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
         (display_message, "@Prosperity of {s2} has changed from {s3} to {s4}."),
       (try_end),
       (call_script, "script_update_center_notes", ":center_no"),
     (else_try),
       (party_set_slot, ":center_no", slot_town_prosperity, ":new_prosperity"),
     (try_end),

	 (try_begin),
		(store_current_hours, ":hours"),
		(gt, ":hours", 1),
		(store_sub, ":actual_difference", ":new_prosperity", ":old_prosperity"),
		(try_begin),
			(lt, ":actual_difference", 0),
			(val_add, "$newglob_total_prosperity_losses", ":actual_difference"),
	    (else_try),
			(gt, ":actual_difference", 0),
			(val_add, "$newglob_total_prosperity_gains", ":actual_difference"),
		(try_end),
	 (try_end),

	 #This will add up all non-trade prosperity
	 (try_begin),
		(eq, "$cheat_mode", 3),
		(assign, reg4, "$newglob_total_prosperity_from_bandits"),
		(assign, reg5, "$newglob_total_prosperity_from_caravan_trade"),
	    (assign, reg7, "$newglob_total_prosperity_from_villageloot"),
	    (assign, reg8, "$newglob_total_prosperity_from_townloot"),
	    (assign, reg9, "$newglob_total_prosperity_from_village_trade"),
	    (assign, reg10, "$newglob_total_prosperity_from_convergence"),
	    (assign, reg11, "$newglob_total_prosperity_losses"),
	    (assign, reg12, "$newglob_total_prosperity_gains"),
		(display_message, "@{!}DEBUG: Total prosperity actual losses: {reg11}"),
		(display_message, "@{!}DEBUG: Total prosperity actual gains: {reg12}"),

		(display_message, "@{!}DEBUG: Prosperity changes from random bandits: {reg4}"),
		(display_message, "@{!}DEBUG: Prosperity changes from caravan trades: {reg5}"),
		(display_message, "@{!}DEBUG: Prosperity changes from farmer trades: {reg9}"),
		(display_message, "@{!}DEBUG: Prosperity changes from looted villages: {reg7}"),
		(display_message, "@{!}DEBUG: Prosperity changes from sieges: {reg8}"),
		(display_message, "@{!}DEBUG: Theoretical prosperity changes from convergence: {reg10}"),
	 (try_end),

     ]),

  #script_get_center_ideal_prosperity
  # INPUT: arg1 = center_no
  # OUTPUT: reg0 = ideal_prosperity
  ("get_center_ideal_prosperity",
    [(store_script_param, ":center_no", 1),
     (assign, ":ideal", 65),

	 (call_script, "script_center_get_goods_availability", ":center_no"),
     (store_mul, ":hardship_index", reg0, 2),
	 (val_sub, ":ideal", ":hardship_index"),

     (try_begin),
       (is_between, ":center_no", villages_begin, villages_end),
       (party_slot_eq, ":center_no", slot_center_has_fish_pond, 1),
       (val_add, ":ideal", 5),
     (try_end),

     (val_max, ":ideal", 0),

     (assign, reg0, ":ideal"),
     ]),

  ("good_price_affects_good_production",
	[
	(store_script_param, ":center", 1),
	(store_script_param, ":input_item_no", 2),
	(store_script_param, ":production", 3),
	(store_script_param, ":impact_divisor", 4),

	(assign, reg4, ":production"),

	(try_begin),
		(gt, ":production", 0), #let's take -20 as the zero production rate, although in actuality production can go lower, representing increased demand

		(store_sub, ":input_good_price_slot", ":input_item_no", trade_goods_begin),
		(val_add, ":input_good_price_slot", slot_town_trade_good_prices_begin),
		(party_get_slot, ":input_price", ":center", ":input_good_price_slot"),

		(try_begin),
		  (is_between, ":center", towns_begin, towns_end),

		  (val_mul, ":input_price", 4),
		  (assign, ":number_of_villages", 4),
		  (try_for_range, ":village_no", villages_begin, villages_end),
		    (party_slot_eq, ":village_no", slot_village_bound_center, ":center"),
		    (party_get_slot, ":input_price_at_village", ":village_no", ":input_good_price_slot"),
			(val_add, ":input_price", ":input_price_at_village"),
			(val_add, ":number_of_villages", 1),
		  (try_end),

		  (val_div, ":input_price", ":number_of_villages"),
		(try_end),

		(try_begin), #1/2 impact for low prices
			##diplomacy start+
			(lt, ":input_price", average_price_factor),#Replace 1000 with average_price_factor
			##diplomacy end+
			(val_mul, ":impact_divisor", 2),
		(try_end),

		(try_begin),
			(gt, ":impact_divisor", 1),
			##diplomacy start+
			(val_sub, ":input_price", average_price_factor),#Replace 1000 with average_price_factor
			(val_div, ":input_price", ":impact_divisor"),#<- unchanged
			(val_add, ":input_price", average_price_factor),#Replace 1000 with average_price_factor
			##diplomacy end+
		(try_end),

		##diplomacy start+
		(val_mul, ":production", average_price_factor),#Replace 1000 with average_price_factor
		##diplomacy end+
		(val_div, ":production", ":input_price"),

#		(assign, reg5, ":production"),
		#(assign, reg3, ":input_price"),
#		(str_store_item_name, s4, ":input_item_no"),
#		(display_message, "@{s4} price of {reg3} reduces production from {reg4} to {reg5}"),

	(try_end),


	(assign, reg0, ":production"),

	]),




  #script_get_poorest_village_of_faction
  # INPUT: arg1 = center_no
  # OUTPUT: reg0 = ideal_prosperity
  ("get_poorest_village_of_faction",
    [(store_script_param, ":faction_no", 1),
     (assign, ":min_prosperity_village", -1),
     (assign, ":min_prosperity", 101),
     (try_for_range, ":village_no", villages_begin, villages_end),
       (store_faction_of_party, ":village_faction", ":village_no"),
       (eq, ":village_faction", ":faction_no"),
       (party_get_slot, ":prosperity", ":village_no", slot_town_prosperity),
       (lt, ":prosperity", ":min_prosperity"),
       (assign, ":min_prosperity", ":prosperity"),
       (assign, ":min_prosperity_village", ":village_no"),
     (try_end),
     (assign, reg0, ":min_prosperity_village"),
     ]),

  #script_troop_add_gold
  # INPUT: arg1 = troop_no, arg2 = amount
  # OUTPUT: none
  ("troop_add_gold",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":amount", 2),

      (troop_add_gold, ":troop_no", ":amount"),
      (try_begin),
        (eq, ":troop_no", "trp_player"),
        (play_sound, "snd_money_received"),
      (try_end),
     ]),

#NPC companion changes begin
  ("initialize_npcs",
    [

# set strings

        (troop_set_slot, "trp_npc1", slot_troop_morality_type, tmt_egalitarian),  #borcha
        (troop_set_slot, "trp_npc1", slot_troop_morality_value, 4),  #borcha
        (troop_set_slot, "trp_npc1", slot_troop_2ary_morality_type, tmt_aristocratic),  #borcha
        (troop_set_slot, "trp_npc1", slot_troop_2ary_morality_value, -1),
        (troop_set_slot, "trp_npc1", slot_troop_personalityclash_object, "trp_npc7"),  #borcha - deshavi
        (troop_set_slot, "trp_npc1", slot_troop_personalityclash2_object, "trp_npc16"),  #borcha - klethi
        (troop_set_slot, "trp_npc1", slot_troop_personalitymatch_object, "trp_npc2"),  #borcha - marnid
        (troop_set_slot, "trp_npc1", slot_troop_home, "p_village_25"), #Dashbiga
        (troop_set_slot, "trp_npc1", slot_troop_payment_request, 300),
		(troop_set_slot, "trp_npc1", slot_troop_kingsupport_argument, argument_ruler),
		(troop_set_slot, "trp_npc1", slot_troop_kingsupport_opponent, "trp_npc14"), #lezalit
		(troop_set_slot, "trp_npc1", slot_troop_town_with_contacts, "p_town_17"),
		(troop_set_slot, "trp_npc1", slot_troop_original_faction, 0),
		(troop_set_slot, "trp_npc1", slot_lord_reputation_type, lrep_roguish), #



        (troop_set_slot, "trp_npc2", slot_troop_morality_type, tmt_humanitarian), #marnid
        (troop_set_slot, "trp_npc2", slot_troop_morality_value, 2),
        (troop_set_slot, "trp_npc2", slot_troop_2ary_morality_type, tmt_honest),
        (troop_set_slot, "trp_npc2", slot_troop_2ary_morality_value, 1),
        (troop_set_slot, "trp_npc2", slot_troop_personalityclash_object, "trp_npc5"), #marnid - beheshtur
        (troop_set_slot, "trp_npc2", slot_troop_personalityclash2_object, "trp_npc9"), #marnid - alayen
        (troop_set_slot, "trp_npc2", slot_troop_personalitymatch_object, "trp_npc1"),  #marnid - borcha
        (troop_set_slot, "trp_npc2", slot_troop_home, "p_town_1"), #Sargoth
        (troop_set_slot, "trp_npc2", slot_troop_payment_request, 0),
		(troop_set_slot, "trp_npc2", slot_troop_kingsupport_argument, argument_victory),
		(troop_set_slot, "trp_npc2", slot_troop_kingsupport_opponent, "trp_npc16"), #klethi
		(troop_set_slot, "trp_npc2", slot_troop_town_with_contacts, "p_town_1"), #Sargoth
		(troop_set_slot, "trp_npc2", slot_troop_original_faction, 0),
		(troop_set_slot, "trp_npc2", slot_lord_reputation_type, lrep_custodian), #

#
        (troop_set_slot, "trp_npc3", slot_troop_morality_type, tmt_humanitarian), #Ymira
        (troop_set_slot, "trp_npc3", slot_troop_morality_value, 4),
        (troop_set_slot, "trp_npc3", slot_troop_2ary_morality_type, tmt_aristocratic),
        (troop_set_slot, "trp_npc3", slot_troop_2ary_morality_value, -1),
        (troop_set_slot, "trp_npc3", slot_troop_personalityclash_object, "trp_npc14"), #Ymira - artimenner
        (troop_set_slot, "trp_npc3", slot_troop_personalityclash2_object, "trp_npc8"), #Ymira - matheld
        (troop_set_slot, "trp_npc3", slot_troop_personalitymatch_object, "trp_npc9"), #Ymira - alayen
        (troop_set_slot, "trp_npc3", slot_troop_home, "p_town_3"), #Veluca
        (troop_set_slot, "trp_npc3", slot_troop_payment_request, 0),
		(troop_set_slot, "trp_npc3", slot_troop_kingsupport_argument, argument_lords),
		(troop_set_slot, "trp_npc3", slot_troop_kingsupport_opponent, "trp_npc5"), #klethi
		(troop_set_slot, "trp_npc3", slot_troop_town_with_contacts, "p_town_15"), #yalen
		(troop_set_slot, "trp_npc3", slot_troop_original_faction, 0),
		(troop_set_slot, "trp_npc3", slot_lord_reputation_type, lrep_benefactor), #



        (troop_set_slot, "trp_npc4", slot_troop_morality_type, tmt_aristocratic), #Rolf
        (troop_set_slot, "trp_npc4", slot_troop_morality_value, 4),
        (troop_set_slot, "trp_npc4", slot_troop_2ary_morality_type, tmt_honest),
        (troop_set_slot, "trp_npc4", slot_troop_2ary_morality_value, -1),
        (troop_set_slot, "trp_npc4", slot_troop_personalityclash_object, "trp_npc10"), #Rolf - bunduk
        (troop_set_slot, "trp_npc4", slot_troop_personalityclash2_object, "trp_npc7"), #Rolf - deshavi
        (troop_set_slot, "trp_npc4", slot_troop_personalitymatch_object, "trp_npc5"), #Rolf - beheshtur
        (troop_set_slot, "trp_npc4", slot_troop_home, "p_village_34"), #Ehlerdah
        (troop_set_slot, "trp_npc4", slot_troop_payment_request, 300),
        (troop_set_slot, "trp_npc4", slot_troop_renown, 100), #SB : renown
		(troop_set_slot, "trp_npc4", slot_troop_kingsupport_argument, argument_claim),
		(troop_set_slot, "trp_npc4", slot_troop_kingsupport_opponent, "trp_npc6"), #firentis
		(troop_set_slot, "trp_npc4", slot_troop_town_with_contacts, "p_town_3"), #veluca
		(troop_set_slot, "trp_npc4", slot_troop_original_faction, 0),
		(troop_set_slot, "trp_npc4", slot_lord_reputation_type, lrep_cunning), #


        (troop_set_slot, "trp_npc5", slot_troop_morality_type, tmt_egalitarian),  #beheshtur
        (troop_set_slot, "trp_npc5", slot_troop_morality_value, 3),  #beheshtur
        (troop_set_slot, "trp_npc5", slot_troop_2ary_morality_type, -1),
        (troop_set_slot, "trp_npc5", slot_troop_2ary_morality_value, 0),
        (troop_set_slot, "trp_npc5", slot_troop_personalityclash_object, "trp_npc2"),  #beheshtur - marnid
        (troop_set_slot, "trp_npc5", slot_troop_personalityclash2_object, "trp_npc11"),  #beheshtur- katrin
        (troop_set_slot, "trp_npc5", slot_troop_personalitymatch_object, "trp_npc4"),  #beheshtur - rolf
        (troop_set_slot, "trp_npc5", slot_troop_home, "p_town_14"), #Halmar
        (troop_set_slot, "trp_npc5", slot_troop_payment_request, 400),
        (troop_set_slot, "trp_npc5", slot_troop_renown, 100), #SB : renown
		(troop_set_slot, "trp_npc5", slot_troop_kingsupport_argument, argument_ruler),
		(troop_set_slot, "trp_npc5", slot_troop_kingsupport_opponent, "trp_npc9"), #firentis
		(troop_set_slot, "trp_npc5", slot_troop_town_with_contacts, "p_town_10"), #tulga
		(troop_set_slot, "trp_npc5", slot_troop_original_faction, "fac_kingdom_3"), #khergit
		(troop_set_slot, "trp_npc5", slot_lord_reputation_type, lrep_cunning), #



        (troop_set_slot, "trp_npc6", slot_troop_morality_type, tmt_humanitarian), #firenz
        (troop_set_slot, "trp_npc6", slot_troop_morality_value, 2),  #beheshtur
        (troop_set_slot, "trp_npc6", slot_troop_2ary_morality_type, tmt_honest),
        (troop_set_slot, "trp_npc6", slot_troop_2ary_morality_value, 1),
        (troop_set_slot, "trp_npc6", slot_troop_personalityclash_object, "trp_npc11"), #firenz
        (troop_set_slot, "trp_npc6", slot_troop_personalityclash2_object, "trp_npc13"), #firenz - nizar
        (troop_set_slot, "trp_npc6", slot_troop_personalitymatch_object, "trp_npc12"),  #firenz - jeremus
        (troop_set_slot, "trp_npc6", slot_troop_home, "p_town_4"), #Suno
        (troop_set_slot, "trp_npc6", slot_troop_payment_request, 0),
        (troop_set_slot, "trp_npc6", slot_troop_renown, 50), #SB : renown
		(troop_set_slot, "trp_npc6", slot_troop_kingsupport_argument, argument_victory),
		(troop_set_slot, "trp_npc6", slot_troop_kingsupport_opponent, "trp_npc8"), #firentis
		(troop_set_slot, "trp_npc6", slot_troop_town_with_contacts, "p_town_7"), #uxkhal
		(troop_set_slot, "trp_npc6", slot_troop_original_faction, "fac_kingdom_1"), #swadia
		(troop_set_slot, "trp_npc6", slot_lord_reputation_type, lrep_upstanding), #



        (troop_set_slot, "trp_npc7", slot_troop_morality_type, tmt_egalitarian),  #deshavi
        (troop_set_slot, "trp_npc7", slot_troop_morality_value, 3),  #beheshtur
        (troop_set_slot, "trp_npc7", slot_troop_2ary_morality_type, -1),
        (troop_set_slot, "trp_npc7", slot_troop_2ary_morality_value, 0),
        (troop_set_slot, "trp_npc7", slot_troop_personalityclash_object, "trp_npc1"),  #deshavi
        (troop_set_slot, "trp_npc7", slot_troop_personalityclash2_object, "trp_npc4"),  #deshavi - rolf
        (troop_set_slot, "trp_npc7", slot_troop_personalitymatch_object, "trp_npc16"),  #deshavi - klethi
        (troop_set_slot, "trp_npc7", slot_troop_home, "p_village_5"), #Kulum
#        (troop_set_slot, "trp_npc7", slot_troop_payment_request, 300),
		(troop_set_slot, "trp_npc7", slot_troop_kingsupport_argument, argument_victory),
		(troop_set_slot, "trp_npc7", slot_troop_kingsupport_opponent, "trp_npc3"), #ymira
		(troop_set_slot, "trp_npc7", slot_troop_town_with_contacts, "p_town_2"), #tihr
		(troop_set_slot, "trp_npc7", slot_troop_original_faction, 0), #swadia
		(troop_set_slot, "trp_npc7", slot_lord_reputation_type, lrep_custodian), #



        (troop_set_slot, "trp_npc8", slot_troop_morality_type, tmt_aristocratic), #matheld
        (troop_set_slot, "trp_npc8", slot_troop_morality_value, 3),  #beheshtur
        (troop_set_slot, "trp_npc8", slot_troop_2ary_morality_type, -1),
        (troop_set_slot, "trp_npc8", slot_troop_2ary_morality_value, 0),
        (troop_set_slot, "trp_npc8", slot_troop_personalityclash_object, "trp_npc12"), #matheld
        (troop_set_slot, "trp_npc8", slot_troop_personalityclash2_object, "trp_npc3"), #matheld - ymira
        (troop_set_slot, "trp_npc8", slot_troop_personalitymatch_object, "trp_npc13"),  #matheld - nizar
        (troop_set_slot, "trp_npc8", slot_troop_home, "p_village_35"), #Fearichen
        (troop_set_slot, "trp_npc8", slot_troop_payment_request, 500),
        (troop_set_slot, "trp_npc8", slot_troop_renown, 75), #SB : renown
		(troop_set_slot, "trp_npc8", slot_troop_kingsupport_argument, argument_lords),
		(troop_set_slot, "trp_npc8", slot_troop_kingsupport_opponent, "trp_npc2"), #marnid
		(troop_set_slot, "trp_npc8", slot_troop_town_with_contacts, "p_town_12"), #wercheg
		(troop_set_slot, "trp_npc8", slot_troop_original_faction, "fac_kingdom_4"), #nords
		(troop_set_slot, "trp_npc8", slot_lord_reputation_type, lrep_martial), #


        (troop_set_slot, "trp_npc9", slot_troop_morality_type, tmt_aristocratic), #alayen
        (troop_set_slot, "trp_npc9", slot_troop_morality_value, 2),  #beheshtur
        (troop_set_slot, "trp_npc9", slot_troop_2ary_morality_type, tmt_honest),
        (troop_set_slot, "trp_npc9", slot_troop_2ary_morality_value, 1),
        (troop_set_slot, "trp_npc9", slot_troop_personalityclash_object, "trp_npc13"), #alayen vs nizar
        (troop_set_slot, "trp_npc9", slot_troop_personalityclash2_object, "trp_npc2"), #alayen vs marnid
        (troop_set_slot, "trp_npc9", slot_troop_personalitymatch_object, "trp_npc3"),  #alayen - ymira
        (troop_set_slot, "trp_npc9", slot_troop_home, "p_town_13"), #Rivacheg
        (troop_set_slot, "trp_npc9", slot_troop_payment_request, 300),
        (troop_set_slot, "trp_npc9", slot_troop_renown, 100), #SB : renown
		(troop_set_slot, "trp_npc9", slot_troop_kingsupport_argument, argument_lords),
		(troop_set_slot, "trp_npc9", slot_troop_kingsupport_opponent, "trp_npc1"), #borcha
		(troop_set_slot, "trp_npc9", slot_troop_town_with_contacts, "p_town_8"), #reyvadin
		(troop_set_slot, "trp_npc9", slot_troop_original_faction, "fac_kingdom_2"), #vaegirs
		(troop_set_slot, "trp_npc9", slot_lord_reputation_type, lrep_martial), #


        (troop_set_slot, "trp_npc10", slot_troop_morality_type, tmt_humanitarian), #bunduk
        (troop_set_slot, "trp_npc10", slot_troop_morality_value, 2),
        (troop_set_slot, "trp_npc10", slot_troop_2ary_morality_type, tmt_egalitarian),
        (troop_set_slot, "trp_npc10", slot_troop_2ary_morality_value, 1),
        (troop_set_slot, "trp_npc10", slot_troop_personalityclash_object, "trp_npc4"), #bunduk vs rolf
        (troop_set_slot, "trp_npc10", slot_troop_personalityclash2_object, "trp_npc14"), #bunduk vs lazalet
        (troop_set_slot, "trp_npc10", slot_troop_personalitymatch_object, "trp_npc11"),  #bunduk likes katrin
        (troop_set_slot, "trp_npc10", slot_troop_home, "p_castle_28"), #Grunwalder Castle
        (troop_set_slot, "trp_npc10", slot_troop_payment_request, 200),
        (troop_set_slot, "trp_npc10", slot_troop_renown, 75), #SB : renown
		(troop_set_slot, "trp_npc10", slot_troop_kingsupport_argument, argument_ruler),
		(troop_set_slot, "trp_npc10", slot_troop_kingsupport_opponent, "trp_npc7"), #nizar
		(troop_set_slot, "trp_npc10", slot_troop_town_with_contacts, "p_town_5"), #jelkala
		(troop_set_slot, "trp_npc10", slot_troop_original_faction, "fac_kingdom_5"), #rhodoks
		(troop_set_slot, "trp_npc10", slot_lord_reputation_type, lrep_benefactor), #



        (troop_set_slot, "trp_npc11", slot_troop_morality_type, tmt_egalitarian),  #katrin
        (troop_set_slot, "trp_npc11", slot_troop_morality_value, 3),
        (troop_set_slot, "trp_npc11", slot_troop_2ary_morality_type, -1),
        (troop_set_slot, "trp_npc11", slot_troop_2ary_morality_value, 0),
        (troop_set_slot, "trp_npc11", slot_troop_personalityclash_object, "trp_npc6"),  #katrin vs firenz
        (troop_set_slot, "trp_npc11", slot_troop_personalityclash2_object, "trp_npc5"),  #katrin - beheshtur
        (troop_set_slot, "trp_npc11", slot_troop_personalitymatch_object, "trp_npc10"),  #katrin likes bunduk
        (troop_set_slot, "trp_npc11", slot_troop_home, "p_town_6"), #Praven
        (troop_set_slot, "trp_npc11", slot_troop_payment_request, 100),
		(troop_set_slot, "trp_npc11", slot_troop_kingsupport_argument, argument_claim),
		(troop_set_slot, "trp_npc11", slot_troop_kingsupport_opponent, "trp_npc15"), #borcha
		(troop_set_slot, "trp_npc11", slot_troop_town_with_contacts, "p_town_6"), #praven
		(troop_set_slot, "trp_npc11", slot_troop_original_faction, 0), #
		(troop_set_slot, "trp_npc11", slot_lord_reputation_type, lrep_custodian), #


        (troop_set_slot, "trp_npc12", slot_troop_morality_type, tmt_humanitarian), #jeremus
        (troop_set_slot, "trp_npc12", slot_troop_morality_value, 3),
        (troop_set_slot, "trp_npc12", slot_troop_2ary_morality_type, -1),
        (troop_set_slot, "trp_npc12", slot_troop_2ary_morality_value, 0),
        (troop_set_slot, "trp_npc12", slot_troop_personalityclash_object, "trp_npc8"), #jerem
        (troop_set_slot, "trp_npc12", slot_troop_personalityclash2_object, "trp_npc15"), #jeremus - artimenner
        (troop_set_slot, "trp_npc12", slot_troop_personalitymatch_object, "trp_npc6"),  #jeremus - firenz
        (troop_set_slot, "trp_npc12", slot_troop_home, "p_castle_16"), #undetermined #University
        (troop_set_slot, "trp_npc12", slot_troop_payment_request, 0),
        (troop_set_slot, "trp_npc12", slot_troop_renown, 100), #SB : renown
		(troop_set_slot, "trp_npc12", slot_troop_kingsupport_argument, argument_claim),
		(troop_set_slot, "trp_npc12", slot_troop_kingsupport_opponent, "trp_npc13"), #nizar
		(troop_set_slot, "trp_npc12", slot_troop_town_with_contacts, "p_town_14"), #halmar
		(troop_set_slot, "trp_npc12", slot_troop_original_faction, 0), #
		(troop_set_slot, "trp_npc12", slot_lord_reputation_type, lrep_benefactor), #



        (troop_set_slot, "trp_npc13", slot_troop_morality_type, tmt_aristocratic), #nizar
        (troop_set_slot, "trp_npc13", slot_troop_morality_value, 3),
        (troop_set_slot, "trp_npc13", slot_troop_2ary_morality_type, -1),
        (troop_set_slot, "trp_npc13", slot_troop_2ary_morality_value, 0),
        (troop_set_slot, "trp_npc13", slot_troop_personalityclash_object, "trp_npc9"), #nizar
        (troop_set_slot, "trp_npc13", slot_troop_personalityclash2_object, "trp_npc6"), #nizar - firenz
        (troop_set_slot, "trp_npc13", slot_troop_personalitymatch_object, "trp_npc8"), #nizar - matheld
        (troop_set_slot, "trp_npc13", slot_troop_home, "p_castle_15"), #Ergellon Castle
        (troop_set_slot, "trp_npc13", slot_troop_payment_request, 300),
        (troop_set_slot, "trp_npc13", slot_troop_renown, 75), #SB : renown
		(troop_set_slot, "trp_npc13", slot_troop_kingsupport_argument, argument_claim),
		(troop_set_slot, "trp_npc13", slot_troop_kingsupport_opponent, "trp_npc10"), #nizar
		(troop_set_slot, "trp_npc13", slot_troop_town_with_contacts, "p_town_4"), #suno
		(troop_set_slot, "trp_npc13", slot_troop_original_faction, 0), #
		(troop_set_slot, "trp_npc13", slot_lord_reputation_type, lrep_roguish), #



        (troop_set_slot, "trp_npc14", slot_troop_morality_type, tmt_aristocratic), #lezalit
        (troop_set_slot, "trp_npc14", slot_troop_morality_value, 4),
        (troop_set_slot, "trp_npc14", slot_troop_2ary_morality_type, tmt_egalitarian),
        (troop_set_slot, "trp_npc14", slot_troop_2ary_morality_value, -1),
        (troop_set_slot, "trp_npc14", slot_troop_personalityclash_object, "trp_npc3"), #lezalit
        (troop_set_slot, "trp_npc14", slot_troop_personalityclash2_object, "trp_npc10"), #lezalit - bunduk
        (troop_set_slot, "trp_npc14", slot_troop_personalitymatch_object, "trp_npc15"), #lezalit - artimenner
        (troop_set_slot, "trp_npc14", slot_troop_home, "p_castle_18"), #Ismirala Castle
        (troop_set_slot, "trp_npc14", slot_troop_payment_request, 400),
        (troop_set_slot, "trp_npc14", slot_troop_renown, 100), #SB : renown
		(troop_set_slot, "trp_npc14", slot_troop_kingsupport_argument, argument_victory),
		(troop_set_slot, "trp_npc14", slot_troop_kingsupport_opponent, "trp_npc11"), #nizar
		(troop_set_slot, "trp_npc14", slot_troop_town_with_contacts, "p_town_16"), #dhirim
		(troop_set_slot, "trp_npc14", slot_troop_original_faction, 0), #
		(troop_set_slot, "trp_npc14", slot_lord_reputation_type, lrep_selfrighteous), #


        (troop_set_slot, "trp_npc15", slot_troop_morality_type, tmt_egalitarian),  #artimenner
        (troop_set_slot, "trp_npc15", slot_troop_morality_value, 2),
        (troop_set_slot, "trp_npc15", slot_troop_2ary_morality_type, tmt_honest),
        (troop_set_slot, "trp_npc15", slot_troop_2ary_morality_value, 1),
        (troop_set_slot, "trp_npc15", slot_troop_personalityclash_object, "trp_npc16"), #artimenner - klethi
        (troop_set_slot, "trp_npc15", slot_troop_personalityclash2_object, "trp_npc12"), #artimenner - jeremus
        (troop_set_slot, "trp_npc15", slot_troop_personalitymatch_object, "trp_npc14"), #lazalit - artimenner
        (troop_set_slot, "trp_npc15", slot_troop_home, "p_castle_1"), #Culmarr Castle
        (troop_set_slot, "trp_npc15", slot_troop_payment_request, 300),
        (troop_set_slot, "trp_npc15", slot_troop_renown, 100), #SB : renown
		(troop_set_slot, "trp_npc15", slot_troop_kingsupport_argument, argument_ruler),
		(troop_set_slot, "trp_npc15", slot_troop_kingsupport_opponent, "trp_npc4"), #nizar
 		(troop_set_slot, "trp_npc15", slot_troop_town_with_contacts, "p_town_20"), #durquba
		(troop_set_slot, "trp_npc15", slot_lord_reputation_type, lrep_custodian), #


        (troop_set_slot, "trp_npc16", slot_troop_morality_type, tmt_aristocratic), #klethi
        (troop_set_slot, "trp_npc16", slot_troop_morality_value, 4),
        (troop_set_slot, "trp_npc16", slot_troop_2ary_morality_type, tmt_humanitarian),
        (troop_set_slot, "trp_npc16", slot_troop_2ary_morality_value, -1),
        (troop_set_slot, "trp_npc16", slot_troop_personalityclash_object, "trp_npc15"), #klethi
        (troop_set_slot, "trp_npc16", slot_troop_personalityclash2_object, "trp_npc1"), #klethi - borcha
        (troop_set_slot, "trp_npc16", slot_troop_personalitymatch_object, "trp_npc7"),  #deshavi - klethi
        (troop_set_slot, "trp_npc16", slot_troop_home, "p_village_20"), #Uslum
        (troop_set_slot, "trp_npc16", slot_troop_payment_request, 200),
        (troop_set_slot, "trp_npc16", slot_troop_kingsupport_argument, argument_lords),
        (troop_set_slot, "trp_npc16", slot_troop_kingsupport_opponent, "trp_npc12"), #nizar
        (troop_set_slot, "trp_npc16", slot_troop_town_with_contacts, "p_town_9"), #khudan
        (troop_set_slot, "trp_npc16", slot_lord_reputation_type, lrep_roguish), #



        (store_sub, "$number_of_npc_slots", slot_troop_strings_end, slot_troop_intro),

        (try_for_range, ":npc", companions_begin, companions_end),


            (try_for_range, ":slot_addition", 0, "$number_of_npc_slots"),
                (store_add, ":slot", ":slot_addition", slot_troop_intro),

                (store_mul, ":string_addition", ":slot_addition", 16),
                (store_add, ":string", "str_npc1_intro", ":string_addition"),
                (val_add, ":string", ":npc"),
                (val_sub, ":string", companions_begin),

                (troop_set_slot, ":npc", ":slot", ":string"),
            (try_end),
        (try_end),


#Post 0907 changes begin
        (call_script, "script_add_log_entry", logent_game_start, "trp_player", -1, -1, -1),
#Post 0907 changes end

    #Rebellion changes begin
        (troop_set_slot, "trp_kingdom_1_pretender",  slot_troop_original_faction, "fac_kingdom_1"),
        (troop_set_slot, "trp_kingdom_2_pretender",  slot_troop_original_faction, "fac_kingdom_2"),
        (troop_set_slot, "trp_kingdom_3_pretender",  slot_troop_original_faction, "fac_kingdom_3"),
        (troop_set_slot, "trp_kingdom_4_pretender",  slot_troop_original_faction, "fac_kingdom_4"),
        (troop_set_slot, "trp_kingdom_5_pretender",  slot_troop_original_faction, "fac_kingdom_5"),
        (troop_set_slot, "trp_kingdom_6_pretender",  slot_troop_original_faction, "fac_kingdom_6"),

    #        (troop_set_slot, "trp_kingdom_1_pretender", slot_troop_support_base,     "p_town_4"), #suno
    #        (troop_set_slot, "trp_kingdom_2_pretender", slot_troop_support_base,     "p_town_11"), #curaw
    #        (troop_set_slot, "trp_kingdom_3_pretender", slot_troop_support_base,     "p_town_18"), #town_18
    #        (troop_set_slot, "trp_kingdom_4_pretender", slot_troop_support_base,     "p_town_12"), #wercheg
    #        (troop_set_slot, "trp_kingdom_5_pretender", slot_troop_support_base,     "p_town_3"), #veluca
        ##diplomacy start+
        (troop_set_slot, "trp_kingdom_1_pretender", slot_troop_home, "p_town_4"),#Lady Isolle - Suno
        (troop_set_slot, "trp_kingdom_2_pretender", slot_troop_home, "p_town_11"),#Prince Valdym - Curaw
        (troop_set_slot, "trp_kingdom_3_pretender", slot_troop_home, "p_town_18"),#Dustum Khan - Narra
        (troop_set_slot, "trp_kingdom_4_pretender", slot_troop_home, "p_town_12"),#Lethwin Far-Seeker - Wercheg
        (troop_set_slot, "trp_kingdom_5_pretender", slot_troop_home, "p_town_3"),#Lord Kastor - Veluca
        (troop_set_slot, "trp_kingdom_6_pretender", slot_troop_home, "p_town_20"),#Arwa the Pearled One - Durquba
        ##diplomacy end+
        (try_for_range, ":pretender", pretenders_begin, pretenders_end),
            (troop_set_slot, ":pretender", slot_lord_reputation_type, lrep_none),
            ##diplomacy start+
            (troop_get_slot, ":home", ":pretender", slot_troop_home),
            (ge, ":home", 1),
            (neg|party_slot_ge, ":home", dplmc_slot_center_original_lord, 1),
            (party_set_slot, ":home", dplmc_slot_center_original_lord, ":pretender"),
            ##diplomacy end+
        (try_end),
#Rebellion changes end
     ]),



  ("objectionable_action",
    [
        (store_script_param_1, ":action_type"),
        (store_script_param_2, ":action_string"),

        (assign, ":grievance_minimum", -2),
        (try_for_range, ":npc", companions_begin, companions_end),
            (main_party_has_troop, ":npc"),

###Primary morality check
            (try_begin),
                (troop_slot_eq, ":npc", slot_troop_morality_type, ":action_type"),
                (troop_get_slot, ":value", ":npc", slot_troop_morality_value),
                (try_begin),
                    (troop_slot_eq, ":npc", slot_troop_morality_state, tms_acknowledged),
# npc is betrayed, major penalty to player honor and morale
                    (troop_get_slot, ":grievance", ":npc", slot_troop_morality_penalties),
                    (val_mul, ":value", 2),
                    (val_add, ":grievance", ":value"),
                    (troop_set_slot, ":npc", slot_troop_morality_penalties, ":grievance"),
                (else_try),
                    (this_or_next|troop_slot_eq, ":npc", slot_troop_morality_state, tms_dismissed),
                        (eq, "$disable_npc_complaints", 1),
# npc is quietly disappointed
                    (troop_get_slot, ":grievance", ":npc", slot_troop_morality_penalties),
                    (val_add, ":grievance", ":value"),
                    (troop_set_slot, ":npc", slot_troop_morality_penalties, ":grievance"),
                (else_try),
# npc raises the issue for the first time
                    (troop_slot_eq, ":npc", slot_troop_morality_state, tms_no_problem),
                    (gt, ":value", ":grievance_minimum"),
                    (assign, "$npc_with_grievance", ":npc"),
                    (assign, "$npc_grievance_string", ":action_string"),
                    (assign, "$npc_grievance_slot", slot_troop_morality_state),
                    (assign, ":grievance_minimum", ":value"),
                    (assign, "$npc_praise_not_complaint", 0),
                    (try_begin),
                        (lt, ":value", 0),
                        (assign, "$npc_praise_not_complaint", 1),
                    (try_end),
                (try_end),

###Secondary morality check
            (else_try),
                (troop_slot_eq, ":npc", slot_troop_2ary_morality_type, ":action_type"),
                (troop_get_slot, ":value", ":npc", slot_troop_2ary_morality_value),
                (try_begin),
                    (troop_slot_eq, ":npc", slot_troop_2ary_morality_state, tms_acknowledged),
# npc is betrayed, major penalty to player honor and morale
                    (troop_get_slot, ":grievance", ":npc", slot_troop_morality_penalties),
                    (val_mul, ":value", 2),
                    (val_add, ":grievance", ":value"),
                    (troop_set_slot, ":npc", slot_troop_morality_penalties, ":grievance"),
                (else_try),
                    (this_or_next|troop_slot_eq, ":npc", slot_troop_2ary_morality_state, tms_dismissed),
                        (eq, "$disable_npc_complaints", 1),
# npc is quietly disappointed
                    (troop_get_slot, ":grievance", ":npc", slot_troop_morality_penalties),
                    (val_add, ":grievance", ":value"),
                    (troop_set_slot, ":npc", slot_troop_morality_penalties, ":grievance"),
                (else_try),
# npc raises the issue for the first time
                    (troop_slot_eq, ":npc", slot_troop_2ary_morality_state, tms_no_problem),
                    (gt, ":value", ":grievance_minimum"),
                    (assign, "$npc_with_grievance", ":npc"),
                    (assign, "$npc_grievance_string", ":action_string"),
                    (assign, "$npc_grievance_slot", slot_troop_2ary_morality_state),
                    (assign, ":grievance_minimum", ":value"),
                    (assign, "$npc_praise_not_complaint", 0),
                    (try_begin),
                        (lt, ":value", 0),
                        (assign, "$npc_praise_not_complaint", 1),
                    (try_end),
                (try_end),
            (try_end),

            (try_begin),
                (gt, "$npc_with_grievance", 0),
                (eq, "$npc_praise_not_complaint", 0),
                (str_store_troop_name, 4, "$npc_with_grievance"),
                (display_message, "@{s4} looks upset.", message_alert),
            (try_end),
        (try_end),
     ]),


  ("post_battle_personality_clash_check",
[
            (try_for_range, ":npc", companions_begin, companions_end),
                (eq, "$disable_npc_complaints", 0),

                (main_party_has_troop, ":npc"),
                (neg|troop_is_wounded, ":npc"),

                (troop_get_slot, ":other_npc", ":npc", slot_troop_personalityclash2_object),
                (main_party_has_troop, ":other_npc"),
                (neg|troop_is_wounded, ":other_npc"),

#                (store_random_in_range, ":random", 0, 3),
                (try_begin),
                    (troop_slot_eq, ":npc", slot_troop_personalityclash2_state, 0),
                    (try_begin),
#                        (eq, ":random", 0),
                        (assign, "$npc_with_personality_clash_2", ":npc"),
                    (try_end),
                (try_end),

            (try_end),

            (try_for_range, ":npc", companions_begin, companions_end),
                (troop_slot_eq, ":npc", slot_troop_personalitymatch_state, 0),
                (eq, "$disable_npc_complaints", 0),

                (main_party_has_troop, ":npc"),
                (neg|troop_is_wounded, ":npc"),

                (troop_get_slot, ":other_npc", ":npc", slot_troop_personalitymatch_object),
                (main_party_has_troop, ":other_npc"),
                (neg|troop_is_wounded, ":other_npc"),
                (assign, "$npc_with_personality_match", ":npc"),
            (try_end),


            (try_begin),
                (gt, "$npc_with_personality_clash_2", 0),
				(try_begin),
					(eq, "$cheat_mode", 1),
					(display_message, "str_personality_clash_conversation_begins"),
				(try_end),

				(try_begin),
					(main_party_has_troop, "$npc_with_personality_clash_2"),
					(assign, "$npc_map_talk_context", slot_troop_personalityclash2_state),
					(start_map_conversation, "$npc_with_personality_clash_2"),
				(else_try),
					(assign, "$npc_with_personality_clash_2", 0),
				(try_end),
            (else_try),
                (gt, "$npc_with_personality_match", 0),
				(try_begin),
					(eq, "$cheat_mode", 1),
					(display_message, "str_personality_match_conversation_begins"),
				(try_end),

				(try_begin),
					(main_party_has_troop, "$npc_with_personality_match"),
					(assign, "$npc_map_talk_context", slot_troop_personalitymatch_state),
					(start_map_conversation, "$npc_with_personality_match"),
				(else_try),
					(assign, "$npc_with_personality_match", 0),
				(try_end),
			(try_end),
     ]),

  #script_event_player_defeated_enemy_party
  # INPUT: none
  # OUTPUT: none
  ("event_player_defeated_enemy_party",
    [(try_begin),
       (check_quest_active, "qst_raid_caravan_to_start_war"),
       (neg|check_quest_concluded, "qst_raid_caravan_to_start_war"),
       (party_slot_eq, "$g_enemy_party", slot_party_type, spt_kingdom_caravan),
       (store_faction_of_party, ":enemy_faction", "$g_enemy_party"),
       (quest_slot_eq, "qst_raid_caravan_to_start_war", slot_quest_target_faction, ":enemy_faction"),
       (quest_get_slot, ":cur_state", "qst_raid_caravan_to_start_war", slot_quest_current_state),
       (quest_get_slot, ":quest_target_amount", "qst_raid_caravan_to_start_war", slot_quest_target_amount),
       (val_add, ":cur_state", 1),
       (quest_set_slot, "qst_raid_caravan_to_start_war", slot_quest_current_state, ":cur_state"),
       (try_begin),
         (ge, ":cur_state", ":quest_target_amount"),
         (quest_get_slot, ":quest_target_faction", "qst_raid_caravan_to_start_war", slot_quest_target_faction),
         (quest_get_slot, ":quest_giver_troop", "qst_raid_caravan_to_start_war", slot_quest_giver_troop),
         (store_troop_faction, ":quest_giver_faction", ":quest_giver_troop"),
         (call_script, "script_diplomacy_start_war_between_kingdoms", ":quest_target_faction", ":quest_giver_faction", 1),
         (call_script, "script_succeed_quest", "qst_raid_caravan_to_start_war"),
       (try_end),
     (try_end),

     ]),

  #script_event_player_captured_as_prisoner
  # INPUT: none
  # OUTPUT: none
  ("event_player_captured_as_prisoner",
    [
        (try_begin),
          (check_quest_active, "qst_raid_caravan_to_start_war"),
          (neg|check_quest_concluded, "qst_raid_caravan_to_start_war"),
          (quest_get_slot, ":quest_target_faction", "qst_raid_caravan_to_start_war", slot_quest_target_faction),
          (store_faction_of_party, ":capturer_faction", "$capturer_party"),
          (eq, ":quest_target_faction", ":capturer_faction"),
          (call_script, "script_fail_quest", "qst_raid_caravan_to_start_war"),
        (try_end),
        #Removing followers of the player
        (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
		  (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
          (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
          (gt, ":party_no", 0),
          (party_is_active, ":party_no"),
          (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
          (party_slot_eq, ":party_no", slot_party_ai_object, "p_main_party"),
          (call_script, "script_party_set_ai_state", ":party_no", spai_undefined, -1),
          (assign, "$g_recalculate_ais", 1),
        (try_end),
     ]),

#NPC morale both returns a string and reg0 as the morale value
  ("npc_morale",
[
        (store_script_param_1, ":npc"),

        (troop_get_slot, ":morality_grievances", ":npc", slot_troop_morality_penalties),
        (troop_get_slot, ":personality_grievances", ":npc", slot_troop_personalityclash_penalties),
        (party_get_morale, ":party_morale", "p_main_party"),

        (store_sub, ":troop_morale", ":party_morale", ":morality_grievances"),
        (val_sub, ":troop_morale", ":personality_grievances"),
        (val_add, ":troop_morale", 50), #SB : this should scale from actual relation

        (assign, reg8, ":troop_morale"),

        (val_mul, ":troop_morale", 3),
        (val_div, ":troop_morale", 4),
        (val_clamp, ":troop_morale", 0, 100),

        (assign, reg5, ":party_morale"),
        (assign, reg6, ":morality_grievances"),
        (assign, reg7, ":personality_grievances"),
        (assign, reg9, ":troop_morale"),

#        (str_store_troop_name, s11, ":npc"),
#        (display_message, "@{!}{s11}'s morale = PM{reg5} + 50 - MG{reg6} - PG{reg7} = {reg8} x 0.75 = {reg9}"),

        (try_begin),
            (lt, ":morality_grievances", 3),
            (str_store_string, 7, "str_happy"),
        (else_try),
            (lt, ":morality_grievances", 15),
            (str_store_string, 7, "str_content"),
        (else_try),
            (lt, ":morality_grievances", 30),
            (str_store_string, 7, "str_concerned"),
        (else_try),
            (lt, ":morality_grievances", 45),
            (str_store_string, 7, "str_not_happy"),
        (else_try),
            (str_store_string, 7, "str_miserable"),
        (try_end),


        (try_begin),
            (lt, ":personality_grievances", 3),
            (str_store_string, 6, "str_happy"),
        (else_try),
            (lt, ":personality_grievances", 15),
            (str_store_string, 6, "str_content"),
        (else_try),
            (lt, ":personality_grievances", 30),
            (str_store_string, 6, "str_concerned"),
        (else_try),
            (lt, ":personality_grievances", 45),
            (str_store_string, 6, "str_not_happy"),
        (else_try),
            (str_store_string, 6, "str_miserable"),
        (try_end),


        (try_begin),
            (gt, ":troop_morale", 80),
            (str_store_string, 8, "str_happy"),
            (str_store_string, 63, "str_bar_enthusiastic"),
        (else_try),
            (gt, ":troop_morale", 60),
            (str_store_string, 8, "str_content"),
            (str_store_string, 63, "str_bar_content"),
        (else_try),
            (gt, ":troop_morale", 40),
            (str_store_string, 8, "str_concerned"),
            (str_store_string, 63, "str_bar_weary"),
        (else_try),
            (gt, ":troop_morale", 20),
            (str_store_string, 8, "str_not_happy"),
            (str_store_string, 63, "str_bar_disgruntled"),
        (else_try),
            (str_store_string, 8, "str_miserable"),
            (str_store_string, 63, "str_bar_miserable"),
        (try_end),


        (str_store_string, 21, "str_npc_morale_report"),
        (assign, reg0, ":troop_morale"),

     ]),
#NPC morale both returns a string and reg0 as the morale value


#
  ("retire_companion",
[
    (store_script_param_1, ":npc"),
    (store_script_param_2, ":length"),

    (remove_member_from_party, ":npc", "p_main_party"),
    (troop_set_slot, ":npc", slot_troop_personalityclash_penalties, 0),
    (troop_set_slot, ":npc", slot_troop_morality_penalties, 0),
    (troop_get_slot, ":renown", "trp_player", slot_troop_renown),
    (store_add, ":return_renown", ":renown", ":length"),
    (troop_set_slot, ":npc", slot_troop_occupation, slto_retirement),
    (troop_set_slot, ":npc", slot_troop_return_renown, ":return_renown"),
    ]),

#NPC companion changes end

  #script_reduce_companion_morale_for_clash
  # INPUT: arg1 = troop_no for companion1 arg2 = troop_no for companion2 arg3 = slot_for_clash_state
  # slot_for_clash_state means: 1=give full penalty to companion1; 2=give full penalty to companion2; 3=give penalty equally
  ("reduce_companion_morale_for_clash",
   [
    (store_script_param, ":companion_1", 1),
    (store_script_param, ":companion_2", 2),
    (store_script_param, ":slot_for_clash_state", 3),

    (troop_get_slot, ":clash_state", ":companion_1", ":slot_for_clash_state"),
    (troop_get_slot, ":grievance_1", ":companion_1", slot_troop_personalityclash_penalties),
    (troop_get_slot, ":grievance_2", ":companion_2", slot_troop_personalityclash_penalties),
    (try_begin),
      (eq, ":clash_state", pclash_penalty_to_self),
      (val_add, ":grievance_1", 5),
    (else_try),
      (eq, ":clash_state", pclash_penalty_to_other),
      (val_add, ":grievance_2", 5),
    (else_try),
      (eq, ":clash_state", pclash_penalty_to_both),
      (val_add, ":grievance_1", 3),
      (val_add, ":grievance_2", 3),
    (try_end),
    (troop_set_slot, ":companion_1", slot_troop_personalityclash_penalties, ":grievance_1"),
    (troop_set_slot, ":companion_2", slot_troop_personalityclash_penalties, ":grievance_2"),
    ]),

#Hunting scripts end

  #script_calculate_ransom_amount_for_troop
  # INPUT: arg1 = troop_no
  # OUTPUT: reg0 = ransom_amount
  ("calculate_ransom_amount_for_troop",
    [(store_script_param, ":troop_no", 1),
     (store_troop_faction, ":faction_no", ":troop_no"),
     (assign, ":ransom_amount", 400),

	 (assign, ":male_relative", -9), #for kingdom ladies, otherwise a number otherwise unused in slot_town_lord
     (try_begin),
       (faction_slot_eq, ":faction_no", slot_faction_leader, ":troop_no"),
       (val_add, ":ransom_amount", 4000),
	 (else_try),
       (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_lady),
       (val_add, ":ransom_amount", 2500), #as though a renown of 1250 -- therefore significantly higher than for roughly equivalent lords
	   (call_script, "script_get_kingdom_lady_social_determinants", ":troop_no"),
	   (assign, ":male_relative", reg0),
     (try_end),

     (assign, ":num_center_points", 0),
     (try_for_range, ":cur_center", centers_begin, centers_end),
       (this_or_next|party_slot_eq, ":cur_center", slot_town_lord, ":troop_no"),
		 (party_slot_eq, ":cur_center", slot_town_lord, ":male_relative"),
       (try_begin),
         (party_slot_eq, ":cur_center", slot_party_type, spt_town),
         (val_add, ":num_center_points", 4),
       (else_try),
         (party_slot_eq, ":cur_center", slot_party_type, spt_castle),
         (val_add, ":num_center_points", 2),
       (else_try),
         (val_add, ":num_center_points", 1),
       (try_end),
     (try_end),
     (val_mul, ":num_center_points", 500),
     (val_add, ":ransom_amount", ":num_center_points"),
     (troop_get_slot, ":renown", ":troop_no", slot_troop_renown),
     (val_mul, ":renown", 2),
     (val_add, ":ransom_amount", ":renown"),
     (store_mul, ":ransom_max_amount", ":ransom_amount", 3),
     (val_div, ":ransom_max_amount", 2),
     (store_random_in_range, ":random_ransom_amount", ":ransom_amount", ":ransom_max_amount"),
     (val_div, ":random_ransom_amount", 100),
     (val_mul, ":random_ransom_amount", 100),
     (assign, reg0, ":random_ransom_amount"),
     ]),

  #script_offer_ransom_amount_to_player_for_prisoners_in_party
  # INPUT: arg1 = party_no
  # OUTPUT: reg0 = result (1 = offered, 0 = not offered)
  ("offer_ransom_amount_to_player_for_prisoners_in_party",
    [(store_script_param, ":party_no", 1),
     (assign, ":result", 0),
     (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (eq, ":result", 0),
       (party_prisoner_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
       (troop_is_hero, ":stack_troop"),
       (this_or_next|troop_slot_eq, ":stack_troop", slot_troop_occupation, slto_kingdom_hero),
       (troop_slot_eq, ":stack_troop", slot_troop_occupation, slto_kingdom_lady),
       (store_troop_faction, ":stack_troop_faction", ":stack_troop"),
       (store_random_in_range, ":random_no", 0, 100),
       (try_begin),
         (faction_slot_eq, ":stack_troop_faction", slot_faction_state, sfs_active),
         (le, ":random_no", 5),
         (neq, "$g_ransom_offer_rejected", 1),
         (assign, ":num_stacks", 0), #break
         (assign, ":result", 1),
         (assign, "$g_ransom_offer_troop", ":stack_troop"),
         (assign, "$g_ransom_offer_party", ":party_no"),
         (jump_to_menu, "mnu_enemy_offer_ransom_for_prisoner"),
       (try_end),
     (try_end),

     #SB : offer ransom for kingdom ladies as per conditions in dialogues
     (try_begin),
       (is_between, ":party_no", walled_centers_begin, walled_centers_end),
       (assign, ":end", kingdom_ladies_end),
       (store_faction_of_party, ":faction_no", ":party_no"),
       (try_for_range, ":heroes", kingdom_ladies_begin, ":end"),
         (troop_slot_eq, ":heroes", slot_troop_cur_center, ":party_no"),
         (troop_slot_eq, ":heroes", slot_troop_prisoner_of_party, ":party_no"),
         (troop_slot_eq, ":heroes", slot_troop_occupation, slto_kingdom_lady),
         (store_faction_of_troop, ":lady_faction", ":heroes"),
         (neq, ":lady_faction", ":faction_no"),
         (faction_slot_eq, ":lady_faction", slot_faction_state, sfs_active),
         (store_random_in_range, ":random_no", 0, 100),
         (le, ":random_no", 5),
         (neq, "$g_ransom_offer_rejected", 1),
         (assign, ":end", 0), #break
         (assign, ":result", 1),
         (assign, "$g_ransom_offer_troop", ":heroes"),
         (assign, "$g_ransom_offer_party", ":party_no"),
         (jump_to_menu, "mnu_enemy_offer_ransom_for_prisoner"),
       (try_end),
     (try_end),
     (assign, reg0, ":result"),
     ]),

  # script_event_hero_taken_prisoner_by_player
  # Input: arg1 = troop_no
  # Output: none
  ("event_hero_taken_prisoner_by_player",
    [
      (store_script_param_1, ":troop_no"),
      (try_begin),
        (check_quest_active, "qst_persuade_lords_to_make_peace"),
        (try_begin),
          (quest_slot_eq, "qst_persuade_lords_to_make_peace", slot_quest_target_troop, ":troop_no"),
          (val_mul, ":troop_no", -1),
          (quest_set_slot, "qst_persuade_lords_to_make_peace", slot_quest_target_troop, ":troop_no"),
          (val_mul, ":troop_no", -1),
        (else_try),
          (quest_slot_eq, "qst_persuade_lords_to_make_peace", slot_quest_object_troop, ":troop_no"),
          (val_mul, ":troop_no", -1),
          (quest_set_slot, "qst_persuade_lords_to_make_peace", slot_quest_object_troop, ":troop_no"),
          (val_mul, ":troop_no", -1),
        (try_end),
        (neg|check_quest_concluded, "qst_persuade_lords_to_make_peace"),
        (neg|quest_slot_ge, "qst_persuade_lords_to_make_peace", slot_quest_target_troop, 0),
        (neg|quest_slot_ge, "qst_persuade_lords_to_make_peace", slot_quest_object_troop, 0),
        (call_script, "script_succeed_quest", "qst_persuade_lords_to_make_peace"),
      (try_end),
      (call_script, "script_update_troop_location_notes", ":troop_no", 0),
  ]),

  # script_cf_check_hero_can_escape_from_player
  # Input: arg1 = troop_no
  # Output: none (can fail)
  ("cf_check_hero_can_escape_from_player",
    [
      (store_script_param_1, ":troop_no"),
      (assign, ":quest_target", 0),
      (try_begin),
        (check_quest_active, "qst_persuade_lords_to_make_peace"),
        (this_or_next|quest_slot_eq, "qst_persuade_lords_to_make_peace", slot_quest_target_troop, ":troop_no"),
        (quest_slot_eq, "qst_persuade_lords_to_make_peace", slot_quest_object_troop, ":troop_no"),
        (assign, ":quest_target", 1),
      (else_try),
        (ge, ":troop_no", "trp_sea_raider_leader"),
        (lt, ":troop_no", "trp_bandit_leaders_end"),
        (try_begin),
          (check_quest_active, "qst_learn_where_merchant_brother_is"),
          (assign, ":quest_target", 1), #always catched
        (else_try),
          (assign, ":quest_target", -1), #always run.
        (try_end),
      (try_end),

      (assign, ":continue", 0),
      (try_begin),
        (eq, ":quest_target", 0), #if not quest target
        (store_random_in_range, ":rand", 0, 100),
        (lt, ":rand", hero_escape_after_defeat_chance),
        (assign, ":continue", 1),
      (else_try),
        (eq, ":quest_target", -1), #if (always run) quest target
        (assign, ":continue", 1),
      (try_end),

      (eq, ":continue", 1),
  ]),

  # script_cf_party_remove_random_regular_troop
  # Input: arg1 = party_no
  # Output: troop_id that has been removed (can fail)
  ("cf_party_remove_random_regular_troop",
    [(store_script_param_1, ":party_no"),
     (party_get_num_companion_stacks, ":num_stacks", ":party_no"),
     (assign, ":num_troops", 0),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
       (neg|troop_is_hero, ":stack_troop"),
       (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
       (val_add, ":num_troops", ":stack_size"),
     (try_end),
     (assign, reg0, -1),
     (gt, ":num_troops", 0),
     (store_random_in_range, ":random_troop", 0, ":num_troops"),
     (try_for_range, ":i_stack", 0, ":num_stacks"),
       (party_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
       (neg|troop_is_hero, ":stack_troop"),
       (party_stack_get_size, ":stack_size", ":party_no", ":i_stack"),
       (val_sub, ":random_troop", ":stack_size"),
       (lt, ":random_troop", 0),
       (assign, ":num_stacks", 0), #break
       (party_remove_members, ":party_no", ":stack_troop", 1),
       (assign, reg0, ":stack_troop"),
     (try_end),
     ]),

  # script_place_player_banner_near_inventory
  # Input: none
  # Output: none
  ("place_player_banner_near_inventory",
    [
    	#normal_banner_begin
    	(troop_get_slot, ":troop_banner_object", "trp_player", slot_troop_banner_scene_prop),
    	#custom_banner_begin
    	(troop_get_slot, ":flag_spr", "trp_player", slot_troop_custom_banner_flag_type),

     (try_begin),
       (assign, ":flag_object", -1),
       (try_begin),
    	#normal_banner_begin
           (gt, ":troop_banner_object", 0),
           (scene_prop_get_instance, ":flag_object", ":troop_banner_object", 0),
    	#custom_banner_begin
       (else_try),
           (eq, ":troop_banner_object", -1),
           (ge, ":flag_spr", 0),
           (val_add, ":flag_spr", custom_banner_flag_scene_props_begin),
           (scene_prop_get_instance, ":flag_object", ":flag_spr", 0),
       (try_end),
       (try_begin),
         (ge, ":flag_object", 0),
         (get_player_agent_no, ":player_agent"),
         (agent_get_look_position, pos1, ":player_agent"),
         (position_move_y, pos1, -500),
         (position_rotate_z, pos1, 180),
         (position_set_z_to_ground_level, pos1),
         (position_move_z, pos1, 300),
         (prop_instance_set_position, ":flag_object", pos1),
       (try_end),
       (scene_prop_get_instance, ":pole_object", "spr_banner_pole", 0),
       (try_begin),
         (ge, ":pole_object", 0),
         (position_move_z, pos1, -320),
         (prop_instance_set_position, ":pole_object", pos1),
       (try_end),
     (else_try),
       (init_position, pos1),
       (position_move_z, pos1, -1000000),
       (scene_prop_get_instance, ":flag_object", banner_scene_props_begin, 0),
       (try_begin),
         (ge, ":flag_object", 0),
         (prop_instance_set_position, ":flag_object", pos1),
       (try_end),
       (scene_prop_get_instance, ":pole_object", "spr_banner_pole", 0),
       (try_begin),
         (ge, ":pole_object", 0),
         (prop_instance_set_position, ":pole_object", pos1),
       (try_end),
     (try_end),
     ]),

  # script_place_player_banner_near_inventory_bms
  # Input: none
  # Output: none
  ("place_player_banner_near_inventory_bms",
    [
    	    	#normal_banner_begin
    	(troop_get_slot, ":troop_banner_object", "trp_player", slot_troop_banner_scene_prop),
    	    	#custom_banner_begin
      (troop_get_slot, ":flag_spr", "trp_player", slot_troop_custom_banner_flag_type),
     (try_begin),
       (try_begin),
    	    	#normal_banner_begin
           (gt, ":troop_banner_object", 0),
           (replace_scene_props, banner_scene_props_begin, ":troop_banner_object"),
       (else_try),
    	    	#custom_banner_begin
           (eq, ":troop_banner_object", -1),
           (ge, ":flag_spr", 0),
           (val_add, ":flag_spr", custom_banner_flag_scene_props_begin),
           (replace_scene_props, banner_scene_props_begin, ":flag_spr"),
       (try_end),
     (try_end),
     ]),

  # script_stay_captive_for_hours
  # Input: arg1 = num_hours
  # Output: none
  ("stay_captive_for_hours",
    [
      (store_script_param, ":num_hours", 1),
      (store_current_hours, ":cur_hours"),
      (val_add, ":cur_hours", ":num_hours"),
      (val_max, "$g_check_autos_at_hour", ":cur_hours"),
      (val_add, ":num_hours", 1),
      (rest_for_hours, ":num_hours", 0, 0),
    ]),

  # script_set_parties_around_player_ignore_player
  # Input: arg1 = ignore_range, arg2 = num_hours_to_ignore
  # Output: none
  ("set_parties_around_player_ignore_player",
    [(store_script_param, ":ignore_range", 1),
     (store_script_param, ":num_hours", 2),
     (try_for_parties, ":party_no"),
       (party_is_active, ":party_no"),
       (store_distance_to_party_from_party, ":dist", "p_main_party", ":party_no"),
       (lt, ":dist", ":ignore_range"),
       (party_ignore_player, ":party_no", ":num_hours"),
     (try_end),
     ]),

  # script_randomly_make_prisoner_heroes_escape_from_party
  # Input: arg1 = party_no, arg2 = escape_chance_mul_1000
  # Output: none
  ("randomly_make_prisoner_heroes_escape_from_party",
    [(store_script_param, ":party_no", 1),
     (store_script_param, ":escape_chance", 2),
     (assign, ":quest_troop_1", -1),
     (assign, ":quest_troop_2", -1),
     (try_begin),
       (check_quest_active, "qst_rescue_lord_by_replace"),
       (quest_get_slot, ":quest_troop_1", "qst_rescue_lord_by_replace", slot_quest_target_troop),
     (try_end),
     (try_begin),
       (check_quest_active, "qst_deliver_message_to_prisoner_lord"),
       (quest_get_slot, ":quest_troop_2", "qst_deliver_message_to_prisoner_lord", slot_quest_target_troop),
     (try_end),
     (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
     (try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
       (party_prisoner_stack_get_troop_id, ":stack_troop", ":party_no", ":i_stack"),
       (troop_is_hero, ":stack_troop"),
       (neq, ":stack_troop", ":quest_troop_1"),
       (neq, ":stack_troop", ":quest_troop_2"),
       (troop_slot_eq, ":stack_troop", slot_troop_occupation, slto_kingdom_hero),
       (store_random_in_range, ":random_no", 0, 1000),
       (lt, ":random_no", ":escape_chance"),
       (party_remove_prisoners, ":party_no", ":stack_troop", 1),
       (call_script, "script_remove_troop_from_prison", ":stack_troop"),
       (str_store_troop_name_link, s1, ":stack_troop"),
       (try_begin),
         (eq, ":party_no", "p_main_party"),
         (str_store_string, s2, "@your party"),
       (else_try),
         (str_store_party_name, s2, ":party_no"),
       (try_end),
       (assign, reg0, 0),
       (try_begin),
         (this_or_next|eq, ":party_no", "p_main_party"),
         (party_slot_eq, ":party_no", slot_town_lord, "trp_player"),
         (assign, reg0, 1),
       (try_end),
       (store_troop_faction, ":troop_faction", ":stack_troop"),
       (str_store_faction_name_link, s3, ":troop_faction"),
       (faction_get_color, ":color", ":troop_faction"),
       #SB : factionalize color, set to log
       (display_log_message, "@{reg0?One of your prisoners, :}{s1} of {s3} has escaped from captivity!", ":color"),
     (try_end),
     ]),


  # script_fill_tournament_participants_troop
  # Input: arg1 = center_no, arg2 = player_at_center
  # Output: none (fills trp_tournament_participants)
  ("fill_tournament_participants_troop",
   [
    (store_script_param, ":center_no", 1),
    (store_script_param, ":player_at_center", 2),
    (assign, ":cur_slot", 0),

      (try_begin),
        (eq, ":player_at_center", 1),
        (troop_set_slot, "trp_tournament_participants", 0, "trp_player"), #we add the player
        (val_add, ":cur_slot", 1),
        (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
        (try_begin), #add adventuring spouse
          (troop_get_slot, ":spouse", "trp_player", slot_troop_spouse),
          (ge, ":spouse", active_npcs_begin),
          (main_party_has_troop, ":spouse"),
          (neg|troop_is_wounded, ":spouse"),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":spouse"),
          (val_add, ":cur_slot", 1),
        (try_end),
        #SB : add in companions
        (try_for_range, ":companion_candidate", companions_begin, companions_end),

          (assign, ":continue", 0),
          (try_begin), #player pays entrance fee
            (main_party_has_troop, ":companion_candidate"),
            (assign, ":continue", 1),
          (else_try), #same conditions as below
            (troop_slot_eq, ":companion_candidate", slot_troop_cur_center, ":center_no"),
            (troop_slot_ge, ":companion_candidate", slot_troop_renown, 100),
            (assign, ":continue", 1),
          (try_end),

          (try_begin), #disqualify from health/imprisonment
            (this_or_next|troop_is_wounded, ":companion_candidate"),
            (troop_slot_ge, ":companion_candidate", slot_troop_prisoner_of_party, centers_begin),
            (assign, ":continue", 0),
          (try_end),
          (eq, ":continue", 1),

          (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":companion_candidate"),
          # (call_script, "script_join_tournament", ":companion_candidate"),
          (val_add, ":cur_slot", 1),
        (try_end),

       # (try_for_range, ":stack_no", 0, ":num_stacks"),
         # (party_stack_get_troop_id, ":cur_troop", "p_main_party", ":stack_no"),
         # (troop_is_hero, ":cur_troop"),
         # (neq, ":cur_troop", "trp_kidnapped_girl"),
         # (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":cur_troop"),
         # (val_add, ":cur_slot", 1),
       # (try_end),
      (else_try), #noble companions with starting renown > 100 can participate
        (eq, ":player_at_center", 0),
        (try_for_range, ":companion_candidate", companions_begin, companions_end),
          #this is handled by having their parties be in town
          (neg|troop_slot_eq, ":companion_candidate", slot_troop_occupation, slto_kingdom_hero),
          (troop_slot_eq, ":companion_candidate", slot_troop_cur_center, ":center_no"),
          (troop_slot_ge, ":companion_candidate", slot_troop_renown, 100), #rofl, alayen, etc
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":companion_candidate"),
          (val_add, ":cur_slot", 1),
        (try_end),

      (try_end),

     #SB : add in pretender who would want renown bonus
    (try_begin),
      (is_between, "$supported_pretender", pretenders_begin, pretenders_end),
      (eq, ":player_at_center", 1),
      (main_party_has_troop, "$supported_pretender"),
      (troop_set_slot, "trp_tournament_participants", ":cur_slot", "$supported_pretender"),
      (val_add, ":cur_slot", 1),
    (try_end),
    (try_for_range, ":pretender", pretenders_begin, pretenders_end),
      # (neq, ":pretender", "$supported_pretender"),
      # (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
      (troop_slot_eq, ":pretender", slot_troop_cur_center, ":center_no"),
      (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":pretender"),
      (val_add, ":cur_slot", 1),
    (try_end),
    (party_collect_attachments_to_party, ":center_no", "p_temp_party"),
    (party_get_num_companion_stacks, ":num_stacks", "p_temp_party"),
    (try_for_range, ":stack_no", 0, ":num_stacks"),
      (party_stack_get_troop_id, ":cur_troop", "p_temp_party", ":stack_no"),
      (troop_is_hero, ":cur_troop"),
      (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":cur_troop"),
      (val_add, ":cur_slot", 1),
    (try_end),

     # (try_begin),
       # (store_random_in_range, ":random_no", 0, 100),
       # (lt, ":random_no", 50),
       # (troop_set_slot, "trp_tournament_participants", ":cur_slot", "trp_xerina"),
       # (val_add, ":cur_slot", 1),
     # (try_end),
     # (try_begin),
       # (store_random_in_range, ":random_no", 0, 100),
       # (lt, ":random_no", 50),
       # (troop_set_slot, "trp_tournament_participants", ":cur_slot", "trp_dranton"),
       # (val_add, ":cur_slot", 1),
     # (try_end),
     # (try_begin),
       # (store_random_in_range, ":random_no", 0, 100),
       # (lt, ":random_no", 50),
       # (troop_set_slot, "trp_tournament_participants", ":cur_slot", "trp_kradus"),
       # (val_add, ":cur_slot", 1),
     # (try_end),
    #SB : recalculate chances
    (store_add, ":heroes_limit", ":cur_slot", 5),
    (val_min, ":heroes_limit", 64),
    (try_for_range, ":hero", tournament_champions_begin, tournament_champions_end),
        # (neg|troop_is_wounded, ":hero"),
        (store_troop_health, ":health", ":hero", 0),
        (gt, ":health", 10),
        (store_random_in_range, ":random_no", 0, 6),
        (troop_set_slot, ":hero", slot_troop_cur_center, -1),
        (troop_set_slot, ":hero", slot_lady_used_tournament, -1),

        (try_begin),
            (lt, ":random_no", 2),
            (lt, ":cur_slot", ":heroes_limit"),
            (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":hero"),
            # (try_begin),
                # (is_between, ":hero", quick_battle_troops_original_begin, quick_battle_troops_tournament_end),
                # (troop_set_slot, ":hero", slot_troop_cur_center, ":center_no"),
            # (try_end),
            (val_add, ":cur_slot", 1),
            #add some health too
            (val_mul, ":random_no", 10),
            (val_add, ":health", ":random_no"),
            (troop_set_health, ":hero", ":health"),
        (try_end),
    (try_end),
    ##SB : random quick-battle heroes (20% each x 11) at full health, capped to 5 per tourney to not saturate
    (try_for_range, ":hero", quick_battle_troops_begin, quick_battle_troops_end),
        (lt, ":cur_slot", ":heroes_limit"),
        (store_random_in_range, ":random_no", 0, 5),
        (try_begin),
            (eq, ":random_no", 0),
            (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":hero"),
            (troop_set_health, ":hero", ":health"),
            (val_add, ":cur_slot", 1),
        (try_end),
    (try_end),
    (assign, ":begin_slot", ":cur_slot"),

    #SB : set up flavour troops (town mercenary, sword sister alternatives)
    (party_get_slot, ":town_merc", ":center_no", slot_center_mercenary_troop_type),
    (party_get_slot, ":merc_amount", ":center_no", slot_center_mercenary_troop_amount),
    (val_mul, ":merc_amount", 2),
    (val_div, ":merc_amount", 3),

    (store_faction_of_party, ":town_faction", ":center_no"),
    #alternatively check if other female heroes are present and allow sword sisters?

    #might need to test for male prejudice against hired blades?
    (try_begin),
      (call_script, "script_cf_dplmc_faction_has_bias_against_gender", ":town_faction", tf_female),
      (assign, ":sword_sister", -1),
    (else_try),
      (assign, ":sword_sister", "trp_sword_sister"),
    (try_end),
    (try_for_range, ":cur_slot", ":begin_slot", 64), #dckplmc - use faction troops unless none applicable
      (store_random_in_range, ":random_no", 0, 6),
      (store_random_in_range, ":random_no2", 0, 3), #1/3 chance of tournament fighters
      (try_begin),
        (eq, ":random_no", 0),
        (try_begin),
          (lt, ":random_no2", 2),
          (faction_get_slot, ":troop_no", ":town_faction", slot_faction_tier_3_troop),
          (gt, ":troop_no", 0),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":troop_no"),
        (else_try),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", "trp_regular_fighter"),
        (try_end),
      (else_try),
        (eq, ":random_no", 1),
        (try_begin),
          (lt, ":random_no2", 2),
          (faction_get_slot, ":troop_no", ":town_faction", slot_faction_tier_4_troop),
          (gt, ":troop_no", 0),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":troop_no"),
        (else_try),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", "trp_veteran_fighter"),
        (try_end),
      (else_try),
        (eq, ":random_no", 2),
        (try_begin),
          (lt, ":random_no2", 2),
          (faction_get_slot, ":troop_no", ":town_faction", slot_faction_tier_5_troop),
          (gt, ":troop_no", 0),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":troop_no"),
        (else_try),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", "trp_champion_fighter"),
        (try_end),
      (else_try),
        (eq, ":random_no", 3),
        (try_begin),
          (eq, ":sword_sister", "trp_sword_sister"),
          (eq, ":random_no2", 2),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":sword_sister"),
        (else_try),
          (lt, ":random_no2", 2),
          (faction_get_slot, ":troop_no", ":town_faction", slot_faction_tier_5_troop),
          (gt, ":troop_no", 0),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":troop_no"),
        (else_try),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", "trp_mercenary_swordsman"),
        (try_end),
      (else_try),
        (eq, ":random_no", 4),
        (try_begin),
          (lt, ":random_no2", 2),
          (faction_get_slot, ":troop_no", ":town_faction", slot_faction_tier_5_troop),
          (gt, ":troop_no", 0),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":troop_no"),
        (else_try),
          (troop_set_slot, "trp_tournament_participants", ":cur_slot", "trp_hired_blade"),
        (try_end),
        #(troop_set_slot, "trp_tournament_participants", ":cur_slot", "trp_hired_blade"),
      (else_try), #SB : use current town mercenary (if any remaining)
        (eq, ":random_no2", 5),
        (gt, ":merc_amount", 0),
        (val_sub, ":merc_amount", 1),
        (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":town_merc"),
      (else_try), #otherwise fallback to random mercenary participant
        (store_random_in_range, ":merc", mercenary_troops_begin, mercenary_troops_end),
        (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":merc"),
      (try_end),
    (try_end),
  ]),

  # script_get_num_tournament_participants
  # Input: none
  # Output: reg0 = num_participants
  ("get_num_tournament_participants",
    [(assign, ":num_participants", 0),
     (try_for_range, ":cur_slot", 0, 64),
       (troop_slot_ge, "trp_tournament_participants", ":cur_slot", 0),
       (val_add, ":num_participants", 1),
     (try_end),
     (assign, reg0, ":num_participants"),
     ]),

  # script_get_random_tournament_participant
  # Input: none
  # Output: reg0 = troop_no
  ("get_random_tournament_participant",
    [(call_script, "script_get_num_tournament_participants"),
     (assign, ":num_participants", reg0),
     (store_random_in_range, ":random_troop", 0, ":num_participants"),
     (assign, ":continue", 1),
     (try_for_range, ":cur_slot", 0, 64),
       (eq, ":continue", 1),
       (troop_slot_ge, "trp_tournament_participants", ":cur_slot", 0),
       (val_sub, ":random_troop", 1),
       (lt, ":random_troop", 0),
       (assign, ":continue", 0),
       (troop_get_slot, ":troop_no", "trp_tournament_participants", ":cur_slot"),
       (troop_set_slot, "trp_tournament_participants", ":cur_slot", -1),
     (try_end),
     (assign, reg0, ":troop_no"),
     ]),

  # script_add_tournament_participant
  # Input: arg1 = troop_no
  # Output: none
  ("add_tournament_participant",
    [(store_script_param, ":troop_no", 1),
     (assign, ":continue", 1),
     (try_for_range, ":cur_slot", 0, 64),
       (eq, ":continue", 1),
       (troop_slot_eq, "trp_tournament_participants", ":cur_slot", -1),
       (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":troop_no"),
       (assign, ":continue", 0),
     (try_end),
     ]),

  # script_get_random_tournament_team_amount_and_size
  # Input: none
  # Output: reg0 = number_of_teams, reg1 = team_size
  ("get_random_tournament_team_amount_and_size",
    [
        (call_script, "script_get_num_tournament_participants"),
        (assign, ":num_participants", reg0),
        (party_get_slot, ":town_max_teams", "$current_town", slot_town_tournament_max_teams),
        (val_add, ":town_max_teams", 1),
        (party_get_slot, ":town_max_team_size", "$current_town", slot_town_tournament_max_team_size),
        (val_add, ":town_max_team_size", 1),
        (assign, ":max_teams", ":num_participants"),
        (val_min, ":max_teams", ":town_max_teams"),
        (assign, ":max_size", ":num_participants"),
        (val_min, ":max_size", ":town_max_team_size"),
        (assign, ":min_size", 1),
        (try_begin),
          (ge, ":num_participants", 32),
          (assign, ":min_size", 2),
          (val_min, ":min_size", ":town_max_team_size"),
        (try_end),
        (assign, ":end_cond", 500),
        (try_for_range, ":unused", 0, ":end_cond"),
          (store_random_in_range, ":random_teams", 2, ":max_teams"),
          (store_random_in_range, ":random_size", ":min_size", ":max_size"),
          (store_mul, ":total_men", ":random_teams", ":random_size"),
          (le, ":total_men", ":num_participants"),
          (store_sub, ":left_men", ":num_participants", ":total_men"),
          (neq, ":left_men", 1),
          (assign, ":end_cond", 0),
        (try_end),
        (try_begin),
          (gt, ":end_cond", 0),
          (assign, ":random_teams", 2),
          (assign, ":random_size", 1),
        (try_end),
        (assign, reg0, ":random_teams"),
        (assign, reg1, ":random_size"),
     ]),

  # script_get_troop_priority_point_for_tournament
  # Input: arg1 = troop_no
  # Output: reg0 = troop_point
  ("get_troop_priority_point_for_tournament",
    [(store_script_param, ":troop_no", 1),
     (assign, ":troop_point", 0),
     (try_begin),
       (ge, ":troop_no", 0),
       (val_add, ":troop_point", 40000),
       (try_begin),
         (eq, ":troop_no", "trp_player"),
         (val_add, ":troop_point", 80000),
       (try_end),
       (try_begin),
         (troop_is_hero, ":troop_no"),
         (val_add, ":troop_point", 20000),
       (try_end),
       (try_begin),
         (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_player_companion),
         (val_add, ":troop_point", 10000),
       (else_try),
         (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
         (troop_get_slot, ":renown", ":troop_no", slot_troop_renown),
         (val_add, ":troop_point", ":renown"),
         (val_add, ":troop_point", 1000), #in order to make it more prior than tournament heroes with higher levels
       (else_try),
         (store_character_level, ":level", ":troop_no"),
         (val_add, ":troop_point", ":level"),
       (try_end),
     (try_end),
     (assign, reg0, ":troop_point"),
     ]),

  # script_sort_tournament_participant_troops
  # Input: none
  # Output: none (sorts trp_tournament_participants)
  ("sort_tournament_participant_troops",
    [(try_for_range, ":cur_slot", 0, 63),
       (store_add, ":cur_slot_2_begin", ":cur_slot", 1),
       (try_for_range, ":cur_slot_2", ":cur_slot_2_begin", 64),
         (troop_get_slot, ":troop_1", "trp_tournament_participants", ":cur_slot"),
         (troop_get_slot, ":troop_2", "trp_tournament_participants", ":cur_slot_2"),
         (call_script, "script_get_troop_priority_point_for_tournament", ":troop_1"),
         (assign, ":troop_1_point", reg0),
         (call_script, "script_get_troop_priority_point_for_tournament", ":troop_2"),
         (assign, ":troop_2_point", reg0),
         (gt, ":troop_2_point", ":troop_1_point"),
         (troop_set_slot, "trp_tournament_participants", ":cur_slot", ":troop_2"),
         (troop_set_slot, "trp_tournament_participants", ":cur_slot_2", ":troop_1"),
       (try_end),
     (try_end),
     ]),

  # script_remove_tournament_participants_randomly
  # Input: arg1 = number_to_be_removed
  # Output: none
  ("remove_tournament_participants_randomly",
    [(store_script_param, ":number_to_be_removed", 1),
     #SB : TODO simulate tournament fighting relationship changes
     (try_for_range, ":unused", 0, ":number_to_be_removed"),
       (assign, ":total_weight", 0),
       (try_for_range, ":cur_slot", 0, 64),
         (troop_get_slot, ":troop_no", "trp_tournament_participants", ":cur_slot"),
         (ge, ":troop_no", 0),
         (store_character_level, ":level", ":troop_no"),
         (val_min, ":level", 38),
         (store_sub, ":weight", 40, ":level"),
         (val_add, ":total_weight", ":weight"),
       (try_end),
       (store_random_in_range, ":random_weight", 0, ":total_weight"),
       (assign, ":continue", 1),
       (try_for_range, ":cur_slot", 0, 64),
         (eq, ":continue", 1),
         (troop_get_slot, ":troop_no", "trp_tournament_participants", ":cur_slot"),
         (ge, ":troop_no", 0),
         (store_character_level, ":level", ":troop_no"),
         (val_min, ":level", 38),
         (store_sub, ":weight", 40, ":level"),
         (val_sub, ":random_weight", ":weight"),
         (lt, ":random_weight", 0),
         (troop_set_slot, "trp_tournament_participants", ":cur_slot", -1),
         (assign, ":continue", 0),
       (try_end),
     (try_end),
     ]),

  # script_end_tournament_fight
  # Input: arg1 = player_team_won (1 or 0)
  # Output: none
  ("end_tournament_fight",
    [
      (store_script_param, ":player_team_won", 1),
      (call_script, "script_get_num_tournament_participants"),
      (assign, ":num_participants", reg0),
      (store_div, ":needed_to_remove_randomly", ":num_participants", 2),
      #Must remove other participants randomly earlier than adding the winners back to participants
      (call_script, "script_remove_tournament_participants_randomly", ":needed_to_remove_randomly"),

      #SB : because we've added relationship losses, we'll also add this here
      (store_div, ":relation", "$g_tournament_cur_tier", 2),
      (assign, ":num_needed", "$g_tournament_num_participants_for_fight"),
      (val_div, ":num_needed", 2),
      (get_player_agent_no, ":player_agent"),
      (agent_get_team, ":player_team", ":player_agent"),
      (try_for_agents, ":agent_no"),
        (agent_is_human, ":agent_no"),
        (agent_get_troop_id, ":troop_id", ":agent_no"),
        (neg|is_between, ":troop_id", arena_masters_begin, arena_masters_end),#omit tournament master
        (agent_get_team, ":agent_team", ":agent_no"),
        (assign, ":cur_point", 0),
        (try_begin),
          (eq, ":player_team_won", 1),
          (eq, ":agent_team", ":player_team"),
          (val_add, ":cur_point", 5000000),#Make sure that team members are chosen
          #SB : apply relationship bonus here
          (agent_is_alive, ":agent_no"),
          (troop_is_hero, ":troop_id"),
          (try_begin), #player's companions, change their morale penalty
            (troop_slot_eq, ":troop_id", slot_troop_occupation, slto_player_companion),
            (troop_get_slot, ":grievance", ":troop_id", slot_troop_personalityclash_penalties),
            (val_sub, ":grievance", "$g_tournament_cur_tier"),
            (troop_set_slot, ":troop_id", slot_troop_personalityclash_penalties, ":grievance"),
          (else_try), #friendly lords, less will have this bonus as the tiers increase
            (call_script, "script_change_player_relation_with_troop", ":troop_id", ":relation"),
          (try_end),
        (try_end),
        (agent_get_kill_count, ":kill_count", ":agent_no", 1), #everyone is knocked unconscious
        (store_mul, ":kill_point", ":kill_count", 160000),#Make sure that kill count is the second most important variable
        (val_add, ":cur_point", ":kill_point"),
        (call_script, "script_get_troop_priority_point_for_tournament", ":troop_id"),
        (val_add, ":cur_point", reg0),
        (try_begin),#reset player's point if kill count is one after the first 2 rounds, or if it is zero
         (eq, ":agent_no", ":player_agent"),
         (eq, ":player_team_won", 0),
         (assign, ":not_passed", 1),
         (try_begin),
           (ge, ":kill_count", 2),
           (assign, ":not_passed", 0),
         (else_try),
           (eq, ":kill_count", 1),
           (le, "$g_tournament_cur_tier", 1),
           (assign, ":not_passed", 0),
         (try_end),
         (eq, ":not_passed", 1),
         (assign, ":cur_point", 0),
       (try_end),
       (agent_set_slot, ":agent_no", slot_agent_tournament_point, ":cur_point"),
     (try_end),
     (try_for_range, ":unused", 0, ":num_needed"),
       (assign, ":best_point", 0),
       (assign, ":best_agent_no", -1),
       (try_for_agents, ":agent_no"),
         (agent_is_human, ":agent_no"),
         (agent_get_slot, ":point", ":agent_no", slot_agent_tournament_point),
         (gt, ":point", ":best_point"),
         (assign, ":best_agent_no", ":agent_no"),
         (assign, ":best_point", ":point"),
       (try_end),
       (agent_set_slot, ":best_agent_no", slot_agent_tournament_point, 0),#Do not select the same agent again
       (agent_get_troop_id, ":troop_id", ":best_agent_no"),
       (call_script, "script_add_tournament_participant", ":troop_id"),
     (try_end),
     (assign, "$g_tournament_player_team_won", ":player_team_won"),
     (jump_to_menu, "mnu_town_tournament"),
     ]),


  # script_get_win_amount_for_tournament_bet
  # Input: none
  # Output: reg0 = win_amount_with_100_denars
  ("get_win_amount_for_tournament_bet",
    [
        (party_get_slot, ":player_odds", "$current_town", slot_town_player_odds),
        (try_begin),
          (eq, "$g_tournament_cur_tier", 0),
          (assign, ":win_amount", 120),
        (else_try),
          (eq, "$g_tournament_cur_tier", 1),
          (assign, ":win_amount", 90),
        (else_try),
          (eq, "$g_tournament_cur_tier", 2),
          (assign, ":win_amount", 60),
        (else_try),
          (eq, "$g_tournament_cur_tier", 3),
          (assign, ":win_amount", 40),
        (else_try),
          (eq, "$g_tournament_cur_tier", 4),
          (assign, ":win_amount", 20),
        (else_try),
          (assign, ":win_amount", 8),
        (try_end),
        (val_mul, ":win_amount", ":player_odds"),
        (val_div, ":win_amount", 100),
        (val_add, ":win_amount", 100), #win amount when 100 denars is placed
        (assign, reg0, ":win_amount"),
     ]),

  # script_tournament_place_bet
  # Input: arg1 = bet_amount
  # Output: none
  ("tournament_place_bet",
    [
        (store_script_param, ":bet_amount", 1),
        (call_script, "script_get_win_amount_for_tournament_bet"),
        (assign, ":win_amount", reg0),
        (val_mul, ":win_amount", ":bet_amount"),
        (val_div, ":win_amount", 100),
        (val_sub, ":win_amount", ":bet_amount"),
        (val_add, "$g_tournament_bet_placed", ":bet_amount"),
        (val_add, "$g_tournament_bet_win_amount", ":win_amount"),
        (troop_remove_gold, "trp_player", ":bet_amount"),
        (assign, "$g_tournament_last_bet_tier", "$g_tournament_cur_tier"),
     ]),

  # script_calculate_amount_of_cattle_can_be_stolen
  # Input: arg1 = village_no
  # Output: reg0 = max_amount
  ("calculate_amount_of_cattle_can_be_stolen",
    [
      (store_script_param, ":village_no", 1),
      (call_script, "script_get_max_skill_of_player_party", "skl_looting"),
      (assign, ":max_skill", reg0),
      (store_mul, ":can_steal", ":max_skill", 2),
      (call_script, "script_party_count_fit_for_battle", "p_main_party"),
      (store_add, ":num_men_effect", reg0, 10),
      (val_div, ":num_men_effect", 10),
      (val_add, ":can_steal", ":num_men_effect"),
      (party_get_slot, ":num_cattle", ":village_no", slot_village_number_of_cattle),
      (val_min, ":can_steal", ":num_cattle"),
      (assign, reg0, ":can_steal"),
     ]),


  # script_draw_banner_to_region
  # Input: arg1 = troop_no, arg2 = center_pos_x, arg3 = center_pos_y, arg4 = width, arg5 = height, arg6 = stretch_width, arg7 = stretch_height, arg8 = default_scale, arg9 = max_charge_scale, arg10 = drawn_item_type
  # drawn_item_type is 0 for banners, 1 for shields, 2 for heater shield, 3 for armor
  # arguments will be used as fixed point values
  # Output: none
  ("draw_banner_to_region",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":center_pos_x", 2),
      (store_script_param, ":center_pos_y", 3),
      (store_script_param, ":width", 4),
      (store_script_param, ":height", 5),
      (store_script_param, ":stretch_width", 6),
      (store_script_param, ":stretch_height", 7),
      (store_script_param, ":default_scale", 8),
      (store_script_param, ":max_charge_scale", 9),
      (store_script_param, ":drawn_item_type", 10),

      (troop_get_slot, ":bg_type", ":troop_no", slot_troop_custom_banner_bg_type),
      (val_add, ":bg_type", custom_banner_backgrounds_begin),
      (troop_get_slot, ":bg_color_1", ":troop_no", slot_troop_custom_banner_bg_color_1),
      (troop_get_slot, ":bg_color_2", ":troop_no", slot_troop_custom_banner_bg_color_2),
      (troop_get_slot, ":num_charges", ":troop_no", slot_troop_custom_banner_num_charges),
      (troop_get_slot, ":positioning", ":troop_no", slot_troop_custom_banner_positioning),
      (call_script, "script_get_troop_custom_banner_num_positionings", ":troop_no"),
      (assign, ":num_positionings", reg0),
      (val_mod, ":positioning", ":num_positionings"),

      (init_position, pos2),
      (position_set_x, pos2, ":width"),
      (position_set_y, pos2, ":height"),
      (assign, ":default_value", 1),
      (convert_to_fixed_point, ":default_value"),
      (position_set_z, pos2, ":default_value"),

      (init_position, pos1),
      (position_set_x, pos1, ":center_pos_x"),
      (position_set_y, pos1, ":center_pos_y"),
      (position_move_z, pos1, -20),

      (init_position, pos3),
      (position_set_x, pos3, ":default_scale"),
      (position_set_y, pos3, ":default_scale"),
      (position_set_z, pos3, ":default_value"),

      (try_begin),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_bg"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg01"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg02"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg03"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg08"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg09"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg10"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg11"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg12"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg13"),
        (this_or_next|eq, ":bg_type", "mesh_custom_banner_fg16"),
        (eq, ":bg_type", "mesh_custom_banner_fg17"),
        (cur_tableau_add_mesh_with_scale_and_vertex_color, ":bg_type", pos1, pos2, 0, ":bg_color_1"),
      (else_try),
        (cur_tableau_add_mesh_with_scale_and_vertex_color, ":bg_type", pos1, pos3, 0, ":bg_color_1"),
      (try_end),
      (position_move_z, pos1, -20),
      (position_move_x, pos2, ":width"),
      (position_move_y, pos2, ":height"),
      (cur_tableau_add_mesh_with_scale_and_vertex_color, "mesh_custom_banner_bg", pos1, pos2, 0, ":bg_color_2"),

      (assign, ":charge_stretch", ":stretch_width"),
      (val_min, ":charge_stretch", ":stretch_height"),
      (val_min, ":charge_stretch", ":max_charge_scale"),
      (call_script, "script_get_custom_banner_charge_type_position_scale_color", "trp_player", ":positioning"),

      (try_begin),
        (this_or_next|eq, ":drawn_item_type", 2), #heater shield
        (eq, ":drawn_item_type", 3), #armor
        (assign, ":change_center_pos", 0),
        (try_begin),
          (eq, ":num_charges", 1),
          (assign, ":change_center_pos", 1),
        (else_try),
          (eq, ":num_charges", 2),
          (eq, ":positioning", 1),
          (assign, ":change_center_pos", 1),
        (else_try),
          (eq, ":num_charges", 3),
          (eq, ":positioning", 1),
          (assign, ":change_center_pos", 1),
        (try_end),
        (try_begin),
          (eq, ":change_center_pos", 1),
          (val_add, ":center_pos_y", 30),
        (try_end),
      (try_end),

      (try_begin),
        (ge, ":num_charges", 1),
        (val_mul, reg1, ":charge_stretch"),
        (val_div, reg1, 10000),
        (position_get_x, ":x", pos0),
        (position_get_y, ":y", pos0),
        (val_mul, ":x", ":stretch_width"),
        (val_mul, ":y", ":stretch_height"),
        (val_div, ":x", 10000),
        (val_div, ":y", 10000),
        (val_add, ":x", ":center_pos_x"),
        (val_add, ":y", ":center_pos_y"),
        (position_set_x, pos0, ":x"),
        (position_set_y, pos0, ":y"),
        (assign, ":scale_value", reg1),
        (convert_to_fixed_point, ":scale_value"),
        (store_mul, ":scale_value_inverse", ":scale_value", -1),
        (init_position, pos4),
        (position_set_x, pos4, ":scale_value"),
        (position_set_y, pos4, ":scale_value"),
        (position_set_z, pos4, ":scale_value"),
        (store_div, ":orientation", reg0, 256), #orientation flags
        (try_begin),
          (this_or_next|eq, ":orientation", 1),
          (eq, ":orientation", 3),
          (position_set_x, pos4, ":scale_value_inverse"),
        (try_end),
        (try_begin),
          (this_or_next|eq, ":orientation", 2),
          (eq, ":orientation", 3),
          (position_set_y, pos4, ":scale_value_inverse"),
        (try_end),
        (val_mod, reg0, 256), #remove orientation flags
        (cur_tableau_add_mesh_with_scale_and_vertex_color, reg0, pos0, pos4, 0, reg2),
      (try_end),
      (try_begin),
        (ge, ":num_charges", 2),
        (val_mul, reg4, ":charge_stretch"),
        (val_div, reg4, 10000),
        (position_get_x, ":x", pos1),
        (position_get_y, ":y", pos1),
        (val_mul, ":x", ":stretch_width"),
        (val_mul, ":y", ":stretch_height"),
        (val_div, ":x", 10000),
        (val_div, ":y", 10000),
        (val_add, ":x", ":center_pos_x"),
        (val_add, ":y", ":center_pos_y"),
        (position_set_x, pos1, ":x"),
        (position_set_y, pos1, ":y"),

        (assign, ":scale_value", reg4),
        (convert_to_fixed_point, ":scale_value"),
        (store_mul, ":scale_value_inverse", ":scale_value", -1),
        (init_position, pos4),
        (position_set_x, pos4, ":scale_value"),
        (position_set_y, pos4, ":scale_value"),
        (position_set_z, pos4, ":scale_value"),
        (store_div, ":orientation", reg3, 256), #orientation flags
        (try_begin),
          (this_or_next|eq, ":orientation", 1),
          (eq, ":orientation", 3),
          (position_set_x, pos4, ":scale_value_inverse"),
        (try_end),
        (try_begin),
          (this_or_next|eq, ":orientation", 2),
          (eq, ":orientation", 3),
          (position_set_y, pos4, ":scale_value_inverse"),
        (try_end),
        (val_mod, reg3, 256), #remove orientation flags

        (cur_tableau_add_mesh_with_scale_and_vertex_color, reg3, pos1, pos4, 0, reg5),
      (try_end),
      (try_begin),
        (ge, ":num_charges", 3),
        (val_mul, reg7, ":charge_stretch"),
        (val_div, reg7, 10000),
        (position_get_x, ":x", pos2),
        (position_get_y, ":y", pos2),
        (val_mul, ":x", ":stretch_width"),
        (val_mul, ":y", ":stretch_height"),
        (val_div, ":x", 10000),
        (val_div, ":y", 10000),
        (val_add, ":x", ":center_pos_x"),
        (val_add, ":y", ":center_pos_y"),
        (position_set_x, pos2, ":x"),
        (position_set_y, pos2, ":y"),

        (assign, ":scale_value", reg7),
        (convert_to_fixed_point, ":scale_value"),
        (store_mul, ":scale_value_inverse", ":scale_value", -1),
        (init_position, pos4),
        (position_set_x, pos4, ":scale_value"),
        (position_set_y, pos4, ":scale_value"),
        (position_set_z, pos4, ":scale_value"),
        (store_div, ":orientation", reg6, 256), #orientation flags
        (try_begin),
          (this_or_next|eq, ":orientation", 1),
          (eq, ":orientation", 3),
          (position_set_x, pos4, ":scale_value_inverse"),
        (try_end),
        (try_begin),
          (this_or_next|eq, ":orientation", 2),
          (eq, ":orientation", 3),
          (position_set_y, pos4, ":scale_value_inverse"),
        (try_end),
        (val_mod, reg6, 256), #remove orientation flags

        (cur_tableau_add_mesh_with_scale_and_vertex_color, reg6, pos2, pos4, 0, reg8),
      (try_end),
      (try_begin),
        (ge, ":num_charges", 4),
        (val_mul, reg10, ":charge_stretch"),
        (val_div, reg10, 10000),
        (position_get_x, ":x", pos3),
        (position_get_y, ":y", pos3),
        (val_mul, ":x", ":stretch_width"),
        (val_mul, ":y", ":stretch_height"),
        (val_div, ":x", 10000),
        (val_div, ":y", 10000),
        (val_add, ":x", ":center_pos_x"),
        (val_add, ":y", ":center_pos_y"),
        (position_set_x, pos3, ":x"),
        (position_set_y, pos3, ":y"),

        (assign, ":scale_value", reg10),
        (convert_to_fixed_point, ":scale_value"),
        (store_mul, ":scale_value_inverse", ":scale_value", -1),
        (init_position, pos4),
        (position_set_x, pos4, ":scale_value"),
        (position_set_y, pos4, ":scale_value"),
        (position_set_z, pos4, ":scale_value"),
        (store_div, ":orientation", reg9, 256), #orientation flags
        (try_begin),
          (this_or_next|eq, ":orientation", 1),
          (eq, ":orientation", 3),
          (position_set_x, pos4, ":scale_value_inverse"),
        (try_end),
        (try_begin),
          (this_or_next|eq, ":orientation", 2),
          (eq, ":orientation", 3),
          (position_set_y, pos4, ":scale_value_inverse"),
        (try_end),
        (val_mod, reg9, 256), #remove orientation flags

        (cur_tableau_add_mesh_with_scale_and_vertex_color, reg9, pos3, pos4, 0, reg11),
      (try_end),
     ]),

  # script_get_troop_custom_banner_num_positionings
  # Input: arg1 = troop_no
  # Output: reg0 = num_positionings
  ("get_troop_custom_banner_num_positionings",
    [
      (store_script_param, ":troop_no", 1),
      (troop_get_slot, ":num_charges", ":troop_no", slot_troop_custom_banner_num_charges),
      (try_begin),
        (eq, ":num_charges", 1),
        (assign, ":num_positionings", 2),
      (else_try),
        (eq, ":num_charges", 2),
        (assign, ":num_positionings", 4),
      (else_try),
        (eq, ":num_charges", 3),
        (assign, ":num_positionings", 6),
      (else_try),
        (assign, ":num_positionings", 2),
      (try_end),
      (assign, reg0, ":num_positionings"),
     ]),

  # script_get_custom_banner_charge_type_position_scale_color
  # Input: arg1 = troop_no, arg2 = positioning_index
  # Output: reg0 = type_1
  #         reg1 = scale_1
  #         reg2 = color_1
  #         reg3 = type_2
  #         reg4 = scale_2
  #         reg5 = color_2
  #         reg6 = type_3
  #         reg7 = scale_3
  #         reg8 = color_3
  #         reg9 = type_4
  #         reg10 = scale_4
  #         reg11 = color_4
  ("get_custom_banner_charge_type_position_scale_color",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":positioning", 2),
      (troop_get_slot, ":num_charges", ":troop_no", slot_troop_custom_banner_num_charges),
      (init_position, pos0),
      (init_position, pos1),
      (init_position, pos2),
      (init_position, pos3),

      (troop_get_slot, reg0, ":troop_no", slot_troop_custom_banner_charge_type_1),
      (val_add, reg0, custom_banner_charges_begin),
      (troop_get_slot, reg2, ":troop_no", slot_troop_custom_banner_charge_color_1),
      (troop_get_slot, reg3, ":troop_no", slot_troop_custom_banner_charge_type_2),
      (val_add, reg3, custom_banner_charges_begin),
      (troop_get_slot, reg5, ":troop_no", slot_troop_custom_banner_charge_color_2),
      (troop_get_slot, reg6, ":troop_no", slot_troop_custom_banner_charge_type_3),
      (val_add, reg6, custom_banner_charges_begin),
      (troop_get_slot, reg8, ":troop_no", slot_troop_custom_banner_charge_color_3),
      (troop_get_slot, reg9, ":troop_no", slot_troop_custom_banner_charge_type_4),
      (val_add, reg9, custom_banner_charges_begin),
      (troop_get_slot, reg11, ":troop_no", slot_troop_custom_banner_charge_color_4),

      (try_begin),
        (eq, ":num_charges", 1),
        (try_begin),
          (eq, ":positioning", 0),
          (assign, reg1, 100),
        (else_try),
          (assign, reg1, 50),
        (try_end),
      (else_try),
        (eq, ":num_charges", 2),
        (try_begin),
          (eq, ":positioning", 0),
          (position_set_y, pos0, 25),
          (position_set_y, pos1, -25),
          (assign, reg1, 40),
          (assign, reg4, 40),
        (else_try),
          (eq, ":positioning", 1),
          (position_set_x, pos0, -25),
          (position_set_x, pos1, 25),
          (assign, reg1, 40),
          (assign, reg4, 40),
        (else_try),
          (eq, ":positioning", 2),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, 25),
          (position_set_x, pos1, 25),
          (position_set_y, pos1, -25),
          (assign, reg1, 50),
          (assign, reg4, 50),
        (else_try),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, -25),
          (position_set_x, pos1, 25),
          (position_set_y, pos1, 25),
          (assign, reg1, 50),
          (assign, reg4, 50),
        (try_end),
      (else_try),
        (eq, ":num_charges", 3),
        (try_begin),
          (eq, ":positioning", 0),
          (position_set_y, pos0, 33),
          (position_set_y, pos2, -33),
          (assign, reg1, 30),
          (assign, reg4, 30),
          (assign, reg7, 30),
        (else_try),
          (eq, ":positioning", 1),
          (position_set_x, pos0, -33),
          (position_set_x, pos2, 33),
          (assign, reg1, 30),
          (assign, reg4, 30),
          (assign, reg7, 30),
        (else_try),
          (eq, ":positioning", 2),
          (position_set_x, pos0, -30),
          (position_set_y, pos0, 30),
          (position_set_x, pos2, 30),
          (position_set_y, pos2, -30),
          (assign, reg1, 35),
          (assign, reg4, 35),
          (assign, reg7, 35),
        (else_try),
          (eq, ":positioning", 3),
          (position_set_x, pos0, -30),
          (position_set_y, pos0, -30),
          (position_set_x, pos2, 30),
          (position_set_y, pos2, 30),
          (assign, reg1, 35),
          (assign, reg4, 35),
          (assign, reg7, 35),
        (else_try),
          (eq, ":positioning", 4),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, -25),
          (position_set_y, pos1, 25),
          (position_set_x, pos2, 25),
          (position_set_y, pos2, -25),
          (assign, reg1, 50),
          (assign, reg4, 50),
          (assign, reg7, 50),
        (else_try),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, 25),
          (position_set_y, pos1, -25),
          (position_set_x, pos2, 25),
          (position_set_y, pos2, 25),
          (assign, reg1, 50),
          (assign, reg4, 50),
          (assign, reg7, 50),
        (try_end),
      (else_try),
        (try_begin),
          (eq, ":positioning", 0),
          (position_set_x, pos0, -25),
          (position_set_y, pos0, 25),
          (position_set_x, pos1, 25),
          (position_set_y, pos1, 25),
          (position_set_x, pos2, -25),
          (position_set_y, pos2, -25),
          (position_set_x, pos3, 25),
          (position_set_y, pos3, -25),
          (assign, reg1, 50),
          (assign, reg4, 50),
          (assign, reg7, 50),
          (assign, reg10, 50),
        (else_try),
          (position_set_y, pos0, 30),
          (position_set_x, pos1, -30),
          (position_set_x, pos2, 30),
          (position_set_y, pos3, -30),
          (assign, reg1, 35),
          (assign, reg4, 35),
          (assign, reg7, 35),
          (assign, reg10, 35),
        (try_end),
      (try_end),
     ]),

  # script_get_random_custom_banner
  # Input: arg1 = troop_no
  # Output: none
  ("get_random_custom_banner",
    [
      (store_script_param, ":troop_no", 1),
      (store_random_in_range, ":num_charges", 1, 5),
      (troop_set_slot, ":troop_no", slot_troop_custom_banner_num_charges, ":num_charges"),
      (store_random_in_range, ":random_color_index", 0, 42),
      (call_script, "script_get_custom_banner_color_from_index", ":random_color_index"),
      (assign, ":color_1", reg0),
      (troop_set_slot, ":troop_no", slot_troop_custom_banner_bg_color_1, ":color_1"),
      (assign, ":end_cond", 1),
      (try_for_range, ":unused", 0, ":end_cond"),
        (store_random_in_range, ":random_color_index", 0, 42),
        (call_script, "script_get_custom_banner_color_from_index", ":random_color_index"),
        (assign, ":color_2", reg0),
        (try_begin),
          (call_script, "script_cf_check_color_visibility", ":color_1", ":color_2"),
          (troop_set_slot, ":troop_no", slot_troop_custom_banner_bg_color_2, ":color_2"),
        (else_try),
          (val_add, ":end_cond", 1),
        (try_end),
      (try_end),
      (assign, ":end_cond", 4),
      (assign, ":cur_charge", 0),
      (try_for_range, ":unused", 0, ":end_cond"),
        (store_random_in_range, ":random_color_index", 0, 42),
        (call_script, "script_get_custom_banner_color_from_index", ":random_color_index"),
        (assign, ":charge_color", reg0),
        (try_begin),
          (call_script, "script_cf_check_color_visibility", ":charge_color", ":color_1"),
          (call_script, "script_cf_check_color_visibility", ":charge_color", ":color_2"),
          (store_add, ":cur_slot", ":cur_charge", slot_troop_custom_banner_charge_color_1),
          (troop_set_slot, ":troop_no", ":cur_slot", ":charge_color"),
          (store_random_in_range, ":random_charge", custom_banner_charges_begin, custom_banner_charges_end),
          (val_sub, ":random_charge", custom_banner_charges_begin),
          (store_add, ":cur_slot", ":cur_charge", slot_troop_custom_banner_charge_type_1),
          (troop_set_slot, ":troop_no", ":cur_slot", ":random_charge"),
          (val_add, ":cur_charge", 1),
        (else_try),
          (val_add, ":end_cond", 1),
        (try_end),
      (try_end),
      (store_random_in_range, ":random_bg", custom_banner_backgrounds_begin, custom_banner_backgrounds_end),
      (val_sub, ":random_bg", custom_banner_backgrounds_begin),
      (troop_set_slot, ":troop_no", slot_troop_custom_banner_bg_type, ":random_bg"),
      (store_random_in_range, ":random_flag", custom_banner_flag_types_begin, custom_banner_flag_types_end),
      (val_sub, ":random_flag", custom_banner_flag_types_begin),
      (troop_set_slot, ":troop_no", slot_troop_custom_banner_flag_type, ":random_flag"),
      (store_random_in_range, ":random_positioning", 0, 4),
      (troop_set_slot, ":troop_no", slot_troop_custom_banner_positioning, ":random_positioning"),
     ]),

  # script_get_custom_banner_color_from_index
  # Input: arg1 = color_index
  # Output: reg0 = color
  ("get_custom_banner_color_from_index",
    [
      (store_script_param, ":color_index", 1),

      (assign, ":cur_color", 0xFF000000),
      (assign, ":red", 0x00),
      (assign, ":green", 0x00),
      (assign, ":blue", 0x00),
      (store_mod, ":mod_i_color", ":color_index", 7),
      (try_begin),
        (eq, ":mod_i_color", 0),
        (assign, ":blue", 0xFF),
      (else_try),
        (eq, ":mod_i_color", 1),
        (assign, ":red", 0xEE),
      (else_try),
        (eq, ":mod_i_color", 2),
        (assign, ":red", 0xFB),
        (assign, ":green", 0xAC),
      (else_try),
        (eq, ":mod_i_color", 3),
        (assign, ":red", 0x5F),
        (assign, ":blue", 0xFF),
      (else_try),
        (eq, ":mod_i_color", 4),
        (assign, ":red", 0x05),
        (assign, ":green", 0x44),
      (else_try),
        (eq, ":mod_i_color", 5),
        (assign, ":red", 0xEE),
        (assign, ":green", 0xEE),
        (assign, ":blue", 0xEE),
      (else_try),
        (assign, ":red", 0x22),
        (assign, ":green", 0x22),
        (assign, ":blue", 0x22),
      (try_end),
      (store_div, ":cur_tone", ":color_index", 7),
      (store_sub, ":cur_tone", 8, ":cur_tone"),
      (val_mul, ":red", ":cur_tone"),
      (val_div, ":red", 8),
      (val_mul, ":green", ":cur_tone"),
      (val_div, ":green", 8),
      (val_mul, ":blue", ":cur_tone"),
      (val_div, ":blue", 8),
      (val_mul, ":green", 0x100),
      (val_mul, ":red", 0x10000),
      (val_add, ":cur_color", ":blue"),
      (val_add, ":cur_color", ":green"),
      (val_add, ":cur_color", ":red"),
      (assign, reg0, ":cur_color"),
     ]),

  # script_cf_check_color_visibility
  # Input: arg1 = color_1, arg2 = color_2
  # Output: none
  ("cf_check_color_visibility",
    [
      (store_script_param, ":color_1", 1),
      (store_script_param, ":color_2", 2),
      (store_mod, ":blue_1", ":color_1", 256),
      (store_div, ":green_1", ":color_1", 256),
      (val_mod, ":green_1", 256),
      (store_div, ":red_1", ":color_1", 256 * 256),
      (val_mod, ":red_1", 256),
      (store_mod, ":blue_2", ":color_2", 256),
      (store_div, ":green_2", ":color_2", 256),
      (val_mod, ":green_2", 256),
      (store_div, ":red_2", ":color_2", 256 * 256),
      (val_mod, ":red_2", 256),
      (store_sub, ":red_dif", ":red_1", ":red_2"),
      (val_abs, ":red_dif"),
      (store_sub, ":green_dif", ":green_1", ":green_2"),
      (val_abs, ":green_dif"),
      (store_sub, ":blue_dif", ":blue_1", ":blue_2"),
      (val_abs, ":blue_dif"),
      (assign, ":max_dif", 0),
      (val_max, ":max_dif", ":red_dif"),
      (val_max, ":max_dif", ":green_dif"),
      (val_max, ":max_dif", ":blue_dif"),
      (ge, ":max_dif", 64),
     ]),

  # script_get_next_active_kingdom
  # Input: arg1 = faction_no
  # Output: reg0 = faction_no (does not choose player faction)
  ("get_next_active_kingdom",
    [
      (store_script_param, ":faction_no", 1),
      (assign, ":end_cond", kingdoms_end),
      (try_for_range, ":unused", kingdoms_begin, ":end_cond"),
        (val_add, ":faction_no", 1),
        (try_begin),
          (ge, ":faction_no", kingdoms_end),
          (assign, ":faction_no", kingdoms_begin),
        (try_end),
        (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
        (neq, ":faction_no", "fac_player_supporters_faction"),
        (assign, ":end_cond", 0),
      (try_end),
      (assign, reg0, ":faction_no"),
     ]),

#  # script_store_average_center_value_per_faction
#  # Input: none
#  # Output: none (sets $g_average_center_value_per_faction)
#  ("store_average_center_value_per_faction",
#    [
#      (store_sub, ":num_towns", towns_end, towns_begin),
#      (store_sub, ":num_castles", castles_end, castles_begin),
#      (assign, ":num_factions", 0),
#      (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
#        (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
#        (val_add, ":num_factions", 1),
#      (try_end),
#      (val_max, ":num_factions", 1),
#      (store_mul, "$g_average_center_value_per_faction", ":num_towns", 2),
#      (val_add, "$g_average_center_value_per_faction", ":num_castles"),
#      (val_mul, "$g_average_center_value_per_faction", 10),
#      (val_div, "$g_average_center_value_per_faction", ":num_factions"),
#     ]),

  # script_remove_cattles_if_herd_is_close_to_party
  # Input: arg1 = party_no, arg2 = maximum_number_of_cattles_required
  # Output: reg0 = number_of_cattles_removed
  ("remove_cattles_if_herd_is_close_to_party",
    [
      (store_script_param, ":party_no", 1),
      (store_script_param, ":max_req", 2),
      (assign, ":cur_req", ":max_req"),
      (try_for_parties, ":cur_party"),
        (gt, ":cur_req", 0),
        (party_slot_eq, ":cur_party", slot_party_type, spt_cattle_herd),
        (store_distance_to_party_from_party, ":dist", ":cur_party", ":party_no"),
        (lt, ":dist", 3),

        #Do not use the quest herd for "move cattle herd"
        (assign, ":subcontinue", 1),
        (try_begin),
          (check_quest_active, "qst_move_cattle_herd"),
          (quest_slot_eq, "qst_move_cattle_herd", slot_quest_target_party, ":cur_party"),
          (assign, ":subcontinue", 0),
        (try_end),
        (eq, ":subcontinue", 1),
        #Do not use the quest herd for "move cattle herd" ends

        (party_count_companions_of_type, ":num_cattle", ":cur_party", "trp_cattle"),
        (try_begin),
          (le, ":num_cattle", ":cur_req"),
          (assign, ":num_added", ":num_cattle"),
          (remove_party, ":cur_party"),
        (else_try),
          (assign, ":num_added", ":cur_req"),
          (party_remove_members, ":cur_party", "trp_cattle", ":cur_req"),
        (try_end),
        (val_sub, ":cur_req", ":num_added"),


        (try_begin),
          (party_slot_eq, ":party_no", slot_party_type, spt_village),
          (party_get_slot, ":village_cattle_amount", ":party_no", slot_village_number_of_cattle),
          (val_add, ":village_cattle_amount", ":num_added"),
          (party_set_slot, ":party_no", slot_village_number_of_cattle, ":village_cattle_amount"),
        (try_end),

        (assign, reg3, ":num_added"),
        (str_store_party_name_link, s1, ":party_no"),
        (display_message, "@You brought {reg3} heads of cattle to {s1}."),
		(try_begin),
			(gt, "$cheat_mode", 0),
			(assign, reg4, ":village_cattle_amount"),
			(display_message, "@{!}Village now has {reg4}"),
		(try_end),
      (try_end),
      (store_sub, reg0, ":max_req", ":cur_req"),
     ]),

  # script_get_rumor_to_s61
  # Input: rumor_id
  # Output: reg0 = 1 if rumor found, 0 otherwise; s61 will contain rumor string if found
  ("get_rumor_to_s61",
    [
     (store_script_param, ":base_rumor_id", 1), # the script returns the same rumor for the same rumor id, so that one cannot hear all rumors by
                                                # speaking to a single person.
     ##diplomacy start+ save reg4 in order to revert it at the end of the script
	 (assign, ":save_reg4", reg4),
	 ##diplomacy end+
     (store_current_hours, ":cur_hours"),
     (store_div, ":cur_day", ":cur_hours", 24),
     (assign, ":rumor_found", 0),
     (assign, ":num_tries", 3),
     (try_for_range, ":try_no", 0, ":num_tries"),
       (store_mul, ":rumor_id", ":try_no", 6781),
       (val_add, ":rumor_id", ":base_rumor_id"),
       (store_mod, ":rumor_type", ":rumor_id", 7),
       (val_add, ":rumor_id", ":cur_hours"),
       (try_begin),
         (eq,  ":rumor_type", 0),
         (try_begin),
           (store_sub, ":range", towns_end, towns_begin),
           (store_mod, ":random_center", ":rumor_id", ":range"),
           (val_add, ":random_center", towns_begin),
           (party_slot_ge, ":random_center", slot_town_has_tournament, 1),
           (neq, ":random_center", "$current_town"),
           (str_store_party_name, s62, ":random_center"),
           (str_store_string, s61, "@I heard that there will be a tournament in {s62} soon."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 1),
         (try_begin),
           (store_sub, ":range", active_npcs_end, original_kingdom_heroes_begin), #was reversed
           (store_mod, ":random_hero", ":rumor_id", ":range"),
           (val_add, ":random_hero", original_kingdom_heroes_begin),
		   (is_between, ":random_hero", active_npcs_begin, active_npcs_end),
           (troop_get_slot, ":personality", ":random_hero", slot_lord_reputation_type),
		   ##diplomacy start+ give rumors for non-noble personalities, and make pronouns gender-correct
		   (try_begin),
		      (ge, ":personality", lrep_roguish),
			  (try_begin),
			    (eq, ":personality", lrep_benefactor),#Ymira, Bunduk, Jeremus
				(assign, ":personality", lrep_goodnatured),#treats people living in his lands decently
			  (else_try),
			    (eq, ":personality", lrep_custodian),#Marnid, Artimenner, Deshavi, Katrin
				(assign, ":personality", lrep_goodnatured),#good to his followers, and rewards them if they work well
			  (else_try),
			    (call_script, "script_dplmc_get_troop_morality_value", ":random_hero", tmt_humanitarian),
				(lt, reg0, 0),#Klethi
				(assign, ":personality", lrep_debauched),#likes to torture his enemies
			  (try_end),
			  (ge, ":personality", lrep_roguish),
			  (assign, ":personality", 0),#zero out to avoid jumping to a nonsensical string
		   (try_end),
		   (call_script, "script_dplmc_store_troop_is_female_reg", ":random_hero", 4),#store gender to reg4 to make pronouns gender-correct
		   ##diplomacy end+
           (gt, ":personality", 0),
           (store_add, ":rumor_string", ":personality", "str_gossip_about_character_default"),
           (str_store_troop_name, s6, ":random_hero"),
           (str_store_string, s61, ":rumor_string"),
           (assign, ":rumor_found", 1),
         (try_end),
         ##diplomacy start+ Change the rumor string in some circumstances to avoid implying the hero is currently ruling a fief
         (try_begin),
           (neg|is_between, ":random_hero", heroes_begin, heroes_end),
         (else_try),
           #Dead
           (troop_slot_eq, ":random_hero", slot_troop_occupation, dplmc_slto_dead),
           (str_store_troop_name, s6, ":random_hero"),
           (str_store_string, s61, "@I heard some people say they don't believe {s6} is really dead."),#The doubters are wrong, like with Tupac or Elvis.
           (assign, ":rumor_found", 1),
         (else_try),
           #In exile
           (this_or_next|troop_slot_eq, ":random_hero", slot_troop_occupation, slto_retirement),
           (troop_slot_eq, ":random_hero", slot_troop_occupation, dplmc_slto_exile),
           (str_store_troop_name, s6, ":random_hero"),
           (str_store_string, s61, "@I heard a traveller say that he came across {s6} while journeying outside these lands."),
           (assign, ":rumor_found", 1),
         (else_try),
           #Inactive pretender
           (troop_slot_eq, ":random_hero", slot_troop_occupation, slto_inactive_pretender),
           (neq, ":random_hero", "$supported_pretender"),
           (troop_get_slot, reg4, ":random_hero", slot_troop_original_faction),
           (is_between, reg4, npc_kingdoms_begin, npc_kingdoms_end),
           (faction_slot_eq, reg4, slot_faction_state, sfs_active),
           (faction_get_slot, reg4, reg4, slot_faction_leader),
           (gt, reg4, -1),
           (str_store_troop_name, s61, reg4),
           (str_store_string, s6, ":random_hero"),
           (str_store_string, s61, "@I heard that {s6} intends to raise an army and seize the throne from {s61}."),
           (assign, ":rumor_found", 1),
         (try_end),
         ##diplomacy end+
       (else_try),
         (eq,  ":rumor_type", 2),
         (try_begin),
           (store_sub, ":range", trade_goods_end, trade_goods_begin),
           (store_add, ":random_trade_good", ":rumor_id", ":cur_day"),
           (store_mod, ":random_trade_good", ":random_trade_good", ":range"),
           (store_add, ":random_trade_good_slot", ":random_trade_good", slot_town_trade_good_prices_begin),
           (val_add, ":random_trade_good", trade_goods_begin),
           (store_mul, ":min_price", average_price_factor, 3),
           (val_div, ":min_price", 4),
           (assign, ":min_price_center", -1),
           (try_for_range, ":sub_try_no", 0, 10),
             (store_sub, ":range", towns_end, towns_begin),
             (store_add, ":center_rumor_id", ":rumor_id", ":sub_try_no"),
             (store_mod, ":random_center", ":center_rumor_id", ":range"),
             (val_add, ":random_center", towns_begin),
             (neq, ":random_center", "$g_encountered_party"),
             (party_get_slot, ":cur_price", ":random_center", ":random_trade_good_slot"),
             (lt, ":cur_price", ":min_price"),
             (assign, ":min_price", ":cur_price"),
             (assign, ":min_price_center", ":random_center"),
           (try_end),
           (ge, ":min_price_center", 0),
           (str_store_item_name, s62, ":random_trade_good"),
           (str_store_party_name, s63, ":min_price_center"),
           (str_store_string, s61, "@I heard that one can buy {s62} very cheap at {s63}."),
           (assign, ":rumor_found", 1),
         (try_end),
       (else_try),
         (eq,  ":rumor_type", 3),
         (try_begin),
           (store_sub, ":range", trade_goods_end, trade_goods_begin),
           (store_add, ":random_trade_good", ":rumor_id", ":cur_day"),
           (store_mod, ":random_trade_good", ":random_trade_good", ":range"),
           (store_add, ":random_trade_good_slot", ":random_trade_good", slot_town_trade_good_prices_begin),
           (val_add, ":random_trade_good", trade_goods_begin),
           (store_mul, ":max_price", average_price_factor, 5),
           (val_div, ":max_price", 4),
           (assign, ":max_price_center", -1),
           (try_for_range, ":sub_try_no", 0, 10),
             (store_sub, ":range", towns_end, towns_begin),
             (store_add, ":center_rumor_id", ":rumor_id", ":sub_try_no"),
             (store_mod, ":random_center", ":center_rumor_id", ":range"),
             (val_add, ":random_center", towns_begin),
             (neq, ":random_center", "$g_encountered_party"),
             (party_get_slot, ":cur_price", ":random_center", ":random_trade_good_slot"),
             (gt, ":cur_price", ":max_price"),
             (assign, ":max_price", ":cur_price"),
             (assign, ":max_price_center", ":random_center"),
           (try_end),
           (ge, ":max_price_center", 0),
           (str_store_item_name, s62, ":random_trade_good"),
           (str_store_party_name, s63, ":max_price_center"),
           (str_store_string, s61, "@I heard that they pay a very high price for {s62} at {s63}."),
           (assign, ":rumor_found", 1),
         (try_end),
       (try_end),
       (try_begin),
         (gt, ":rumor_found", 0),
         (assign, ":num_tries", 0),
       (try_end),
     (try_end),
     (assign, reg0, ":rumor_found"),
	 ##diplomacy start+ revert reg4
	 (assign, reg4, ":save_reg4"),
	 ##diplomacy end+
     ]),

  ("lord_comment_to_s43",
    [(store_script_param, ":lord", 1),
     (store_script_param, ":default_string", 2),

    (troop_get_slot,":reputation", ":lord", slot_lord_reputation_type),

		#some default strings will have added comments for the added commons reputation types
		##diplomacy start+
		(try_begin),
		#Don't reassign personalities of lords
			(is_between, ":reputation", lrep_none, lrep_upstanding + 1),
       		(else_try),
		#Special case for anti-humanitarians (Klethi in Native)
		    (neg|is_between, ":reputation", lrep_none, lrep_upstanding + 1),
	            (neq, ":reputation", lrep_benefactor),
	            (neq, ":reputation", lrep_moralist),
	            (neq, ":reputation", lrep_conventional),
		    (call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_humanitarian),
	      	    (lt, reg0, 0),#<- In Native, this only applies to Klethi
		    #Use lrep_debauched by default, and refine further below.
		    (assign, ":reputation", lrep_debauched),
		    (try_begin),
			#If pious, anti-humanitarians use lrep_selfrighteous
		    	(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_pious),
			(ge, reg0, 1),#<- Describes no one in Native
			(assign, ":reputation", lrep_selfrighteous),
		    (else_try),
			#If aggressive, anti-humanitarians use lrep_quarrelsome
		    	(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_aristocratic),
			(this_or_next|eq, ":reputation", lrep_adventurous),
				(ge, reg0, 1),#<- In Native describes Alayen, Matheld, Rolf, Nizar, Lezalit, Klethi (but only Klethi can even reach here)
			(assign, ":reputation", lrep_quarrelsome),
		    (try_end),
		(else_try),
		#Special case for "pious" characters (no one in Native)
			(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_pious),
			(ge, reg0, 1),
			(try_begin),
				#Handle these separately to prevent inappropriate reassignment
				(this_or_next|eq, ":reputation", lrep_benefactor),
					(eq, ":reputation", lrep_moralist),
				(assign, ":reputation", lrep_upstanding),
			(else_try),
				#Ordinarily upstanding
				(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_humanitarian),
				(ge, reg0, 0),#<- In Native describes all but Klethi
				(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_egalitarian),
				(ge, reg0, 0),#<- In Native describes all but Lezalit
				(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_honest),
				(ge, reg0, 0),#<- In Native describes all but Rolf
				(assign, ":reputation", lrep_upstanding),
		    	(else_try),
				#If vicious, self-righteous is also a possibility
			        (assign, ":reputation", lrep_selfrighteous),
		     	(try_end),
		(else_try),
		#Special case for dishonest commoners.
		#Pragmatic-style amoral: lrep_cunning
		#Jerk-style amoral: lrep_debauched
	 	 	(neg|is_between, ":reputation", lrep_none, lrep_upstanding + 1),
	            	(neq, ":reputation", lrep_moralist),
	            	(neq, ":reputation", lrep_benefactor),
			(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_honest),
			(lt, reg0, 0),#<- In Native only describes Rolf (who wouldn't reach here, since he is lrep_cunning)
			(try_begin),
				(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_egalitarian),
				(lt, reg0, 1),
				(assign, ":egalitarian", reg0),
				(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_humanitarian),
				(lt, reg0, 1),
				(this_or_next|lt, reg0, 0),
					(lt, ":egalitarian", 0),
				(assign, ":reputation", lrep_debauched),
			(else_try),
				(assign, ":reputation", lrep_cunning),
			(try_end),
		(else_try),
			(eq, ":reputation", lrep_roguish),
			(assign, ":reputation", lrep_goodnatured),
		(else_try),
			(eq, ":reputation", lrep_custodian),
			(assign, ":reputation", lrep_cunning),
		(else_try),
			(eq, ":reputation", lrep_benefactor),
			(assign, ":reputation", lrep_goodnatured),
        #add support for lady personalities
        (else_try),
            (eq, ":reputation", lrep_ambitious),
            (assign, ":reputation", lrep_cunning),
	(else_try),
	    (this_or_next|eq, ":reputation", lrep_conventional),
	    	(eq, ":reputation", lrep_otherworldly),
	    (assign, ":reputation", lrep_goodnatured),
	(else_try),
	    (eq, ":reputation", lrep_adventurous),
   	    (assign, ":reputation", lrep_martial),
  	    (call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_egalitarian),
	    (try_begin),
		    (lt, reg0, 0),#<- In Native describes no one
		    (assign, ":reputation", lrep_quarrelsome),
	    (try_end),
	(else_try),
	    (eq, ":reputation", lrep_moralist),
	    (assign, ":reputation", lrep_upstanding),
	(try_end),
	##diplomacy end+

	##diplomacy start+ Add some variability
	#For non-companion, non-monarchs who don't have any tmt_* morality values, this
	# just amounts to a 5% chance to use lrep_none instead of their real reputation
	# (except where that would cause problems).
	#Otherwise,
	# 16,17:
	#   tmt_pious > 0, with lrep_debauched or lrep_quarrelsome or lrep_selfrighteous: lrep_selfrighteous
	#   tmt_pious > 0, with one of (tmt_egalitarian, tmt_honest, tmt_humanitarian) < 0 and none > 0: lrep_selfrighteous
	#   (tmt_pious >= 0 and tmt_honest >= 0) and (tmt_pious > 0 or tmt_honest > 0): lrep_upstanding
	#   tmt_honest < 0: lrep_cunning
	#   lrep_none and is a king or pretender: lrep_cunning
	#
	# 18,19:
	#   tmt_aristocratic > 0, with lrep_debauched or lrep_quarrelsome: lrep_quarrelsome
	#   lrep_martial, with (tmt_honest, tmt_egalitarian, tmt_humanitarian) all non-positive and
	#      at least one negative, and tmt_pious < 1 (so not to overlap with 16,17): lrep_quarrelsome
	#   tmt_aristocratic > 0: lrep_martial
	#   lrep_none and is a king or pretender: lrep_martial
	(store_random_in_range, ":random_chance", 0, 20),
	(assign, ":new_reputation", ":reputation"),
	(try_begin),
		(eq, 1, 1),#Disable this feature for now.
	(else_try),
		#Disable the first time you're talking to someone, or if you haven't
		#spoken to this NPC recently.
		(store_current_hours, ":recently"),
		(val_sub, ":recently", 24),
		(this_or_next|neq, "$g_talk_troop_met", 1),
		(this_or_next|neg|troop_slot_ge, ":lord", slot_troop_met, 1),
		(this_or_next|neg|troop_slot_ge, ":lord", slot_troop_last_talk_time, ":recently"),
		#Disable for things that come in sequences
		(this_or_next|eq, ":default_string", "str_rebellion_dilemma_default"),
			(eq, ":default_string", "str_rebellion_dilemma_2_default"),
		#Set this value to signal to the debug message at the end
		(assign, ":random_chance", -1),
	(else_try),
		#10% chance of lrep_martial or lrep_quarrelsome if appropriate...
		#if already lrep_martial, check separately here for possible conversion
		#to lrep_quarrelsome
		(is_between, ":random_chance", 18, 20),
		(eq, ":reputation", lrep_martial),
		(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_egalitarian),
		(lt, reg0, 1),
		(assign, ":bad_sum", reg0),
		(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_humanitarian),
		(lt, reg0, 1),
		(val_add, ":bad_sum", reg0),
		(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_honest),
		(lt, reg0, 1),
		(val_add, ":bad_sum", reg0),
		#at least one of tmt_egalitarian, tmt_humanitarian, and tmt_honest were negative (and none were positive)
		(lt, ":bad_sum", 0),
		#disable for positive tmt_pious, since that's handled separately as an alternative to lrep_upstanding for [16,17]
		(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_honest),
		(lt, reg0, 1),
		(assign, ":new_reputation", lrep_quarrelsome),
     	(else_try),
		#10% chance of lrep_martial or lrep_quarrelsome if appropriate
		#Applies to: Rolf, Nizar, Lezalit, Klethi
		#(Also Alayen and Matheld, but they are already lrep_martial)
		(is_between, ":random_chance", 18, 20),
		(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_aristocratic),
		(ge, reg0, 1),
		(try_begin),
			#some personalities use lrep_quarrelsome (only Klethi in Native)
			(this_or_next|eq, ":reputation", lrep_debauched),
				(eq, ":reputation", lrep_quarrelsome),#<-- i.e. no change
			(assign, ":new_reputation", lrep_quarrelsome),
		(else_try),
			#other personalities use lrep_martial
	      		(assign, ":new_reputation", lrep_martial),
		(try_end),
	(else_try),
		#10% chance of lrep_upstanding or lrep_selfrighteous if appropriate
		#Applies to: Marnid, Alayen, Artimenner
		#(Also Firentis, but he is already lrep_upstanding)
		(is_between, ":random_chance", 16, 18),
		(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_honest),
		(assign, ":honest", reg0),
		(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_pious),
		(assign, ":pious", reg0),
		(this_or_next|ge, ":honest", 1),#one or the other must be greater than zero
			(ge, ":pious", 1),
		(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_egalitarian),
		(assign, ":egalitarian", reg0),
		(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_humanitarian),
		(assign, ":humanitarian", reg0),
		(try_begin),
			#Unpleasant personalities use "selfrighteous" instead
			#(Applies to no one in Native)
			(this_or_next|eq, ":reputation", lrep_debauched),
			(this_or_next|eq, ":reputation", lrep_quarrelsome),
			(this_or_next|eq, ":reputation", lrep_selfrighteous),#<- i.e. no change
			(this_or_next|lt, ":honest", 0),
			(this_or_next|lt, ":egalitarian", 0),
				(lt, ":humanitarian", 0),
			(assign, ":new_reputation", lrep_selfrighteous),
		(else_try),
		   	#Other personalities use upstanding
			(assign, ":new_reputation", lrep_upstanding),
		(try_end),
	(else_try),
		#10% chance of lrep_cunning if appropriate
		(is_between, ":random_chance", 16, 18),
		(lt, ":honest", 0),#<- In Native only Rolf satisfies this, but he is already lrep_cunning
		(assign, ":reputation", lrep_cunning),
	(else_try),
		#Ruler, if personality triggers not met: 10% cunning, 10% martial
		(is_between, ":random_chance", 16, 20),
		(eq, ":reputation", lrep_none),
		(this_or_next|is_between, ":lord", kings_begin, kings_end),
			(is_between, ":lord", pretenders_begin, pretenders_end),
		(try_begin),
			(is_between, ":random_chance", 16, 18),
			(assign, ":new_reputation", lrep_cunning),
		(else_try),
			(is_between, ":random_chance", 18, 20),
			(call_script, "script_dplmc_get_troop_morality_value", ":lord", tmt_aristocratic),
			(ge, reg0, 0),#Won't reach here if positive, so you could just check if it equals zero
			(assign, ":new_reputation", lrep_martial),
		(try_end),
	(else_try),
		#Others, if personality triggers not met: 5% chance of null
		(is_between, ":random_chance", 16, 20),#base 20%
		(store_mod, ":rand_mod", ":random_chance",4),
		(troop_get_slot, reg0, ":lord", slot_troop_temp_decision_seed),
		(val_mod, reg0, 4),
		(eq, ":rand_mod", reg0),#1/4 of the time, 5%
		#disable for things that don't have a "lrep_none" version defined
		(neq, ":default_string", "str_rebellion_dilemma_default"),
		(neq, ":default_string", "str_rebellion_dilemma_2_default"),
		(neq, ":default_string", "str_changed_my_mind_default"),
		(neq, ":default_string", "str_political_philosophy_default"),
		(neq, ":default_string", "str_rebellion_rival_default"),
		(neq, ":default_string", "str_rebellion_agree_default"),
		(neq, ":default_string", "str_rebellion_refuse_default"),
		(neq, ":default_string", "str_talk_later_default"),
		(neq, ":default_string", "str_npc_claim_throne_liege"),
		#use lrep_none
		(assign, ":new_reputation", lrep_none),
	(try_end),
	(try_begin),
		(eq, 1, 0),#Disable this feature for now.
		(ge, "$cheat_mode", 1),
		(assign, ":save_reg1", reg1),
		(assign, ":save_reg2", reg2),
		(assign, reg0, ":random_chance"),
		(assign, reg1, ":reputation"),
		(assign, reg2, ":new_reputation"),
		(try_begin),
			(neq, ":reputation", ":new_reputation"),
			(display_message, "@{!} DEBUG - random {reg0} (0 to 20), used reputation {reg2} instead of {reg1}"),
		(else_try),
			(lt, ":random_chance", 0),
			(display_message, "@{!} DEBUG - variable responses disabled, kept reputation {reg2}"),
		(else_try),
			(display_message, "@{!} DEBUG - random {reg0} (0 to 20), kept reputation {reg2}"),
		(try_end),
		(assign, reg1, ":save_reg1"),
		(assign, reg2, ":save_reg2"),
	(try_end),
	(assign, ":reputation", ":new_reputation"),
	##diplomacy end+

    (store_add, ":result", ":reputation", ":default_string"),

    (str_store_string, 43, ":result"),
	(assign, reg0, ":result"),


	]),

#Troop Commentaries begin

  # script_add_log_entry
  # Input: arg1 = entry_type, arg2 = event_actor, arg3 = center_object, arg4 = troop_object, arg5 = faction_object
  # Output: none
  ("add_log_entry",
    [(store_script_param, ":entry_type", 1),
     (store_script_param, ":actor", 2),
     (store_script_param, ":center_object", 3),
     (store_script_param, ":troop_object", 4),
     (store_script_param, ":faction_object", 5),
     (assign, ":center_object_lord", -1),
     (assign, ":center_object_faction", -1),
     (assign, ":troop_object_faction", -1),

     (try_begin),
       (party_is_active, ":center_object", 0),
       (party_get_slot, ":center_object_lord", ":center_object", slot_town_lord),
       (store_faction_of_party, ":center_object_faction", ":center_object"),
	 (else_try),
	   (assign, ":center_object_lord", 0),
       (assign, ":center_object_faction", 0),
     (try_end),

     (try_begin),
       (is_between, ":troop_object", 0, "trp_local_merchant"),
       (store_troop_faction, ":troop_object_faction", ":troop_object"),
	 (else_try),
	   (assign, ":troop_object_faction", 0),
     (try_end),

     (val_add, "$num_log_entries", 1),

     (store_current_hours, ":entry_time"),
     (troop_set_slot, "trp_log_array_entry_type",            "$num_log_entries", ":entry_type"),
     (troop_set_slot, "trp_log_array_entry_time",            "$num_log_entries", ":entry_time"),
     (troop_set_slot, "trp_log_array_actor",                 "$num_log_entries", ":actor"),
     (troop_set_slot, "trp_log_array_center_object",         "$num_log_entries", ":center_object"),
     (troop_set_slot, "trp_log_array_center_object_lord",    "$num_log_entries", ":center_object_lord"),
     (troop_set_slot, "trp_log_array_center_object_faction", "$num_log_entries", ":center_object_faction"),
     (troop_set_slot, "trp_log_array_troop_object",          "$num_log_entries", ":troop_object"),
     (troop_set_slot, "trp_log_array_troop_object_faction",  "$num_log_entries", ":troop_object_faction"),
     (troop_set_slot, "trp_log_array_faction_object",        "$num_log_entries", ":faction_object"),

     (try_begin),
       (eq, "$cheat_mode", 1),
       (assign, reg3, "$num_log_entries"),
       (assign, reg4, ":entry_type"),
       (display_message, "@{!}Log entry {reg3}: type {reg4}"),
       (try_begin),
          (gt, ":center_object", 0),
		  (neq, ":entry_type", logent_traveller_attacked),
		  (neq, ":entry_type", logent_party_traded),
		  (party_is_active, ":center_object"), #sometimes is a troop

          (str_store_party_name, s4, ":center_object"),
          (display_message, "@{!}Center: {s4}"),
       (try_end),
       (try_begin),
          (gt, ":troop_object", 0),
		  (neq, ":entry_type", logent_traveller_attacked),
		  (neq, ":entry_type", logent_party_traded),

		  (str_store_troop_name, s4, ":troop_object"),
		  (display_message, "@{!}Troop: {s4}"),
       (try_end),
       (try_begin),
          (gt, ":center_object_lord", 0),
		  (neq, ":entry_type", logent_traveller_attacked),
		  (neq, ":entry_type", logent_party_traded),

		  (str_store_troop_name, s4, ":center_object_lord"),
          (display_message, "@{!}Lord: {s4}"),
       (try_end),
     (try_end),


     (try_begin),
	   (this_or_next|eq, ":entry_type", logent_lord_defeated_by_player),
       (this_or_next|eq, ":entry_type", logent_player_participated_in_major_battle),
		(eq, ":entry_type", logent_player_participated_in_siege),

       (try_begin),
         (eq, "$cheat_mode", 1),
         (display_message, "@{!}Ally party is present"),
       (try_end),
	   ##diplomacy start+ support kingdom ladies as well
       #(try_for_range, ":hero", active_npcs_begin, active_npcs_end),
	   (try_for_range, ":hero", heroes_begin, heroes_end),
	     (this_or_next|is_between, ":hero", active_npcs_begin, active_npcs_end),
	     (this_or_next|troop_slot_eq, ":hero", slot_troop_occupation, slto_kingdom_hero),
		 (this_or_next|troop_slot_eq, ":hero", slot_troop_occupation, slto_player_companion),
		    (troop_slot_eq, ":hero", slot_troop_occupation, slto_kingdom_seneschal),
	   ##diplomacy end+
         (party_count_companions_of_type, ":hero_present", "p_collective_friends", ":hero"),
         (gt, ":hero_present", 0),
         (troop_set_slot, ":hero", slot_troop_present_at_event, "$num_log_entries"),
#         (store_sub, ":skip_up_to_here", "$num_log_entries", 1),
#         (troop_set_slot, ":hero", slot_troop_last_comment_slot, ":skip_up_to_here"),
         (try_begin),
           (eq, "$cheat_mode", 1),
           (str_store_troop_name, s4, ":hero"),
           (display_message, "@{!}{s4} is present at event"),
         (try_end),
       (try_end),
     (else_try), #SB : log kingdom policy changes as well
        (eq, ":entry_type", logent_player_renamed_capital),
        (party_clear, "p_temp_party"),
        (call_script, "script_get_heroes_attached_to_center", ":center_object", "p_temp_party"),
        (party_get_num_companion_stacks, ":num_stacks","p_temp_party"),
        (try_for_range, ":stack", 0, ":num_stacks"),
          (party_stack_get_troop_id, ":hero", "p_temp_party", ":stack"),
          (troop_set_slot, ":hero", slot_troop_present_at_event, "$num_log_entries"), #need to check if this gets called before or after, add +1
        (try_end),
        #they can give their opinion in the feast, although comment strings aren't set up.
     (try_end),
     ]),


  # script_get_relevant_comment_for_log_entry
  # Input: arg1 = log_entry_no,
  # Output: reg0 = comment_id; reg1 = relevance
  # Notes: 50 is the default relevance.
  # A comment with relevance less than 30 will always be skipped.
  # A comment with relevance 75 or more will never be skipped.
  # A comment with relevance 50 has about 50% chance to be skipped.
  # If there is more than one comment that is not skipped, the system will randomize their relevance values, and then choose the highest one.
  # Also note that the relevance of events decreases as time passes. After three months, relevance reduces to 50%, after 6 months, 25%, etc...
  ##diplomacy start+
  ##May also set reg4 or reg3 to correspond to gender
  ##diplomac end+
  ("get_relevant_comment_for_log_entry",
    [(store_script_param, ":log_entry_no", 1),

     (troop_get_slot, ":entry_type",            "trp_log_array_entry_type",            ":log_entry_no"),
     (troop_get_slot, ":entry_time",            "trp_log_array_entry_time",            ":log_entry_no"),
     (troop_get_slot, ":actor",                 "trp_log_array_actor",                 ":log_entry_no"),
     (troop_get_slot, ":center_object",         "trp_log_array_center_object",         ":log_entry_no"),
     (troop_get_slot, ":center_object_lord",    "trp_log_array_center_object_lord",    ":log_entry_no"),
     (troop_get_slot, ":center_object_faction", "trp_log_array_center_object_faction", ":log_entry_no"),
     (troop_get_slot, ":troop_object",          "trp_log_array_troop_object",          ":log_entry_no"),
     (troop_get_slot, ":troop_object_faction",  "trp_log_array_troop_object_faction",  ":log_entry_no"),
     (troop_get_slot, ":faction_object",        "trp_log_array_faction_object",        ":log_entry_no"),

     (assign, ":relevance", 0),
     (assign, ":comment", -1),
     (assign, ":rejoinder", -1),
     (assign, ":suggested_relation_change", 0),

     (troop_get_slot, ":reputation", "$g_talk_troop", slot_lord_reputation_type),
	 ##diplomacy start+
	 (assign, ":return_reg4", reg4),
	 #Set an initial value for ":return_reg4", although further down
	 #some specific log types override this.
	 (try_begin),
		(is_between, ":troop_object", heroes_begin, heroes_end),
		(neq, ":troop_object", "$g_talk_troop"),
		(assign, ":return_reg4", 0),
		(try_begin),
			(call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
			(assign, ":return_reg4", 1),
		(try_end),
	 (else_try),
		(is_between, ":actor", heroes_begin, heroes_end),
		(neq, ":actor", "$g_talk_troop"),
		(assign, ":return_reg4", 0),
		(try_begin),
			(call_script, "script_cf_dplmc_troop_is_female", ":actor"),
			(assign, ":return_reg4", 1),
		(try_end),
	 (try_end),


	 #add support for commoner/lady reputations
     (troop_get_slot, ":true_reputation", "$g_talk_troop", slot_lord_reputation_type),#unmodified value
	 #(troop_get_type, ":talk_troop_gender",  "$g_talk_troop"),
	 (call_script, "script_dplmc_store_troop_is_female", "$g_talk_troop"),
	 (assign, ":talk_troop_gender", reg0),
	 (try_begin),
	    (neg|is_between, ":reputation", lrep_none, lrep_upstanding + 1),#<-- no changes are required for standard lord personalities
		(try_begin),
			(eq, ":true_reputation", lrep_ambitious),
			(assign, ":reputation", lrep_cunning),
		(else_try),
			(eq, ":true_reputation", lrep_moralist),
			(assign, ":reputation", lrep_upstanding),
		(else_try),
			(this_or_next|eq, ":true_reputation", lrep_conventional),
			   (this_or_next|eq, ":true_reputation", lrep_otherworldly),
			   (eq, ":true_reputation", lrep_benefactor),
			(assign, ":reputation", lrep_goodnatured),
		(try_end),
	 (try_end),
	 ##diplomacy end+
     (store_current_hours, ":current_time"),
     (store_sub, ":entry_hours_elapsed", ":current_time", ":entry_time"),

#Post 0907 changes begin
     (assign, ":players_kingdom_relation", 0), ##the below is so that lords will not congratulate player on attacking neutrals
	 (try_begin),
        (gt, "$players_kingdom", 0),
		(store_relation, ":players_kingdom_relation", "$players_kingdom", ":troop_object_faction"),
	 (try_end),

     (try_begin),
       (eq, "$cheat_mode", -1), #temporarily disabled
       (try_begin),
         (assign, reg5, ":log_entry_no"),
         (assign, reg6, ":entry_type"),
         (assign, reg8, ":entry_time"),

         (gt, "$players_kingdom", 0),
         (try_begin),
            (gt, ":troop_object_faction", 0),
            (assign, reg7, ":players_kingdom_relation"),
            (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}: player's kingdom relation to troop object = {reg7}"),
         (else_try),
            (gt, ":center_object_faction", 0),
            (assign, reg7, ":players_kingdom_relation"),
            (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}: player's kingdom relation to center object faction = {reg7}"),
         (else_try),
            (gt, ":faction_object", 0),
            (assign, reg7, ":players_kingdom_relation"),
            (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}: player's kingdom relation to faction object = {reg7}"),
         (else_try),
            (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}. No relevant kingdom relation"),
         (try_end),
       (else_try),
         (display_message, "@{!}Event #{reg5}, type {reg6}, time {reg8}. Player unaffiliated"),
       (try_end),
     (try_end),

     ##diplomacy start+
	 #In Native, it's assumed that anyone with lrep_none is a liege, but that isn't alwasys true.
	 #(For example, it's possible in a Native game for a defeated pretender to end up as the vassal
	 #of an NPC lord (!), but still talk as if they're ruling a kingdom.)
	 #  Instead of just relying on personality for this, explicily check if they're a liege.
	 (call_script, "script_dplmc_get_troop_standing_in_faction", "$g_talk_troop", "$g_talk_troop_faction"),
	 (try_begin),
		 (ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
		 (assign, ":speaker_is_a_liege", 1),
	 (else_try),
	     (assign, ":speaker_is_a_liege", 0),
	 (try_end),
	 ##diplomacy end+
     (try_begin),
       (eq, ":entry_type", logent_game_start),
       (eq, "$g_talk_troop_met", 0),
       (is_between, "$g_talk_troop_faction_relation", -5, 5),
       (is_between, "$g_talk_troop_relation", -5, 5),

       (assign, ":relevance", 25),
       (troop_get_slot, ":plyr_renown", "trp_player", slot_troop_renown),
		##diplomacy start+
		(try_begin),
			(lt, "$g_disable_condescending_comments", 0),#prejudice mode: high
			(call_script, "script_cf_dplmc_faction_has_bias_against_gender", "$g_talk_troop_faction", "$character_gender"),#bias against gender
			#80% renown
			(val_mul, ":plyr_renown", 4),
			(val_add, ":plyr_renown", 3),
			(val_div, ":plyr_renown", 5),
		(try_end),
		##diplomacy end+
#normal_banner_begin
       (troop_get_slot, ":banner", "trp_player", slot_troop_banner_scene_prop),
#custom_banner_begin
       (try_begin),
           (eq, ":banner", -1),
           (troop_get_slot, ":banner", "trp_player", slot_troop_custom_banner_flag_type),
       (try_end),
       (store_random_in_range, ":renown_check", 100, 200),
       (try_begin),
	      ##diplomacy start+
		  (gt, ":speaker_is_a_liege", 0),#Explicitly check if the speaker is a liege rather than relying solely on reputation
		  ##diplomacy end+
          (eq, ":reputation", lrep_none),
          (gt, "$players_kingdom", 0),
          (assign, ":comment", "str_comment_intro_liege_affiliated"),
		  (try_begin),
			(faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
			(assign, ":comment", "str_comment_intro_liege_affiliated_to_player"),
		  (try_end),
	   (else_try),
	      ##diplomacy start+
		  ##OLD:
		  #(eq, "$character_gender",tf_female),
		  ##NEW:
		  #Instead of assuming there's anti-female bias in all settings, check on a kingdom-by-kingdom basis.
		  (call_script, "script_cf_dplmc_faction_has_bias_against_gender", "$g_talk_troop_faction", "$character_gender"),
		  ##diplomacy end+

		  (call_script, "script_troop_get_romantic_chemistry_with_troop", "$g_talk_troop", "trp_player"),
		  (assign, ":attraction", reg0),
		  (store_random_in_range, ":random", 0, 2),
		  (this_or_next|eq, ":random", 0),
			  (gt, ":attraction", 10),
          ##diplomacy start+ disable remarks about women if the speaker is a woman (or visa versa, for settings with biases against men)
		  (this_or_next|gt, ":attraction", 10),
			(neq, ":talk_troop_gender", "$character_gender"),
		  ##diplomacy end+
		  (try_begin),
            (this_or_next|gt, ":plyr_renown", ":renown_check"),
			##diplomacy start+
			#	(eq, "$g_disable_condescending_comments", 1),
			    (ge, "$g_disable_condescending_comments", 1),
			##diplomacy end+
            (assign, ":comment", "str_comment_intro_female_famous_liege"),
            (val_add, ":comment", ":reputation"),
		  (else_try),
		    (ge, ":attraction", 9),
			(assign, ":comment", "str_comment_intro_female_admiring_liege"),
			(val_add, ":comment", ":reputation"),
		  (else_try),
            (gt, ":banner", 0),
			(assign, ":comment", "str_comment_intro_female_noble_liege"),
			(val_add, ":comment", ":reputation"),
		  (else_try),
			(assign, ":comment", "str_comment_intro_female_common_liege"),
			(val_add, ":comment", ":reputation"),
		  (try_end),

		  #Rejoinders for comments
		  (try_begin),
			(eq, ":comment", "str_comment_intro_female_common_badtempered"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_badtempered"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_noble_pitiless"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_noble_pitiless"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_common_pitiless"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_pitiless"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_noble_sadistic"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_noble_sadistic"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_common_sadistic"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_sadistic"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_common_upstanding"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_upstanding"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_noble_upstanding"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_noble_upstanding"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_common_martial"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_common_martial"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_sadistic_admiring"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_sadistic_admiring"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_badtempered_admiring"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_badtempered_admiring"),
		  (else_try),
			(eq, ":comment", "str_comment_intro_female_pitiless_admiring"),
			(assign, ":rejoinder", "str_rejoinder_intro_female_pitiless_admiring"),
		  (try_end),

	   (else_try),
		  #Male character or non-gendered comment
		  (try_begin),
			(gt, ":plyr_renown", ":renown_check"),
            (assign, ":comment", "str_comment_intro_famous_liege"),
            (val_add, ":comment", ":reputation"),
		  (else_try),
            (gt, ":banner", 0),
			(assign, ":comment", "str_comment_intro_noble_liege"),
			(val_add, ":comment", ":reputation"),

			(try_begin),
				(eq, ":comment", "str_comment_intro_noble_sadistic"),
				(assign, ":rejoinder", "str_rejoinder_intro_noble_sadistic"),
			(try_end),

          (else_try),
            (assign, ":comment", "str_comment_intro_common_liege"),
            (val_add, ":comment", ":reputation"),
		  (try_end),
       (try_end),
#Post 0907 changes end

     (else_try),
       (eq, ":entry_type", logent_village_raided),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
         (assign, ":relevance", 200),
         (assign, ":suggested_relation_change", -1),
         (assign, ":comment", "str_comment_you_raided_my_village_default"),
         (try_begin),
            (lt, "$g_talk_troop_faction_relation", -5),
            (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_you_raided_my_village_enemy_benevolent"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -5),
            (this_or_next|eq, ":reputation", lrep_cunning),
                (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_you_raided_my_village_enemy_coldblooded"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_raided_my_village_enemy_spiteful"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -5),
            (assign, ":comment", "str_comment_you_raided_my_village_enemy"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_raided_my_village_unfriendly_spiteful"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (assign, ":comment", "str_comment_you_raided_my_village_friendly"),
         (try_end),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_village_extorted),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
         (assign, ":relevance", 30),
         (assign, ":suggested_relation_change", -1),
         (assign, ":comment", "str_comment_you_robbed_my_village_default"),
         (try_begin),
            (lt, "$g_talk_troop_faction_relation", -5),
            (this_or_next|eq, ":reputation", lrep_cunning),
                (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_you_robbed_my_village_enemy_coldblooded"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -5),
            (assign, ":comment", "str_comment_you_robbed_my_village_enemy"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_robbed_my_village_friendly_spiteful"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (assign, ":comment", "str_comment_you_robbed_my_village_friendly"),
         (try_end),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_caravan_accosted),
       (eq, ":actor", "trp_player"),
       (eq, ":faction_object", "$g_talk_troop_faction"),
           (eq, ":center_object", -1),
           (eq, ":troop_object", -1),



       (faction_slot_eq, "$g_talk_troop_faction", slot_faction_leader, "$g_talk_troop"),
       (assign, ":relevance", 30),
       (assign, ":suggested_relation_change", -1),
       (assign, ":comment", "str_comment_you_accosted_my_caravan_default"),
       (try_begin),
            (lt, "$g_talk_troop_faction_relation", -5),
            (assign, ":comment", "str_comment_you_accosted_my_caravan_enemy"),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_helped_peasants),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
         (assign, ":relevance", 40),
         (assign, ":suggested_relation_change", 0),
         (try_begin),
            (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_you_helped_villagers_benevolent"),
            (assign, ":suggested_relation_change", 1),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_helped_villagers_friendly_cruel"),
            (assign, ":suggested_relation_change", -1),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_helped_villagers_unfriendly_spiteful"),
            (assign, ":suggested_relation_change", -1),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (assign, ":comment", "str_comment_you_helped_villagers_friendly"),
         (else_try),
            (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_helped_villagers_cruel"),
            (assign, ":suggested_relation_change", -1),
         (else_try),
             (assign, ":comment", "str_comment_you_helped_villagers_default"),
         (try_end),
       (try_end),

###Combat events
     (else_try),
       (eq, ":entry_type", logent_castle_captured_by_player),

       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
		 (store_faction_of_party, ":current_center_faction", ":center_object"),
		 (eq, ":current_center_faction", "$players_kingdom"),
		 (neq, "$g_talk_troop_faction", "$players_kingdom"),

         (this_or_next|eq, ":reputation", lrep_quarrelsome),
			(eq, ":reputation", lrep_debauched),

         (assign, ":comment", "str_comment_you_captured_my_castle_enemy_spiteful"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":center_object_lord", "$g_talk_troop"),
		 (store_faction_of_party, ":current_center_faction", ":center_object"),
		 (eq, ":current_center_faction", "$players_kingdom"),
		 (neq, "$g_talk_troop_faction", "$players_kingdom"),

         (this_or_next|eq, ":reputation", lrep_martial),
			(eq, ":reputation", lrep_goodnatured),

         (assign, ":comment", "str_comment_you_captured_my_castle_enemy_chivalrous"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":center_object_lord", "$g_talk_troop"),
		 (store_faction_of_party, ":current_center_faction", ":center_object"),
		 (eq, ":current_center_faction", "$players_kingdom"),
		 (neq, "$g_talk_troop_faction", "$players_kingdom"),

         (assign, ":comment", "str_comment_you_captured_my_castle_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
         (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied_spiteful"),
         (assign, ":relevance", 75),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (gt, "$g_talk_troop_relation", 5),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied_friendly"),
         (assign, ":relevance", 75),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
         (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied_unfriendly_spiteful"),
         (assign, ":relevance", 75),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied_unfriendly"),
         (assign, ":relevance", 75),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (assign, ":comment", "str_comment_you_captured_a_castle_allied"),
         (assign, ":relevance", 75),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_player_claims_throne_1),
       (eq, "$players_kingdom", "$g_talk_troop_faction"),
	   (faction_slot_eq, "$g_talk_troop_faction", slot_faction_leader, "$g_talk_troop"),
       (assign, ":comment", "str_comment_you_claimed_the_throne_1_player_liege"),
       (assign, ":relevance", 500),
       (lt, "$g_talk_troop_relation", -10),

     (else_try),
       (eq, ":entry_type", logent_player_claims_throne_2),
       (eq, "$players_kingdom", "$g_talk_troop_faction"),
	   (faction_slot_eq, "$g_talk_troop_faction", slot_faction_leader, "$g_talk_troop"),
       (assign, ":comment", "str_comment_you_claimed_the_throne_2_player_liege"),
       (assign, ":relevance", 500),
       (lt, "$g_talk_troop_relation", -10),

     (else_try), #player appointed a commoner
       (eq, ":entry_type", logent_liege_grants_fief_to_vassal),
	   (eq, ":actor", "trp_player"),
           (troop_slot_ge, ":troop_object", slot_lord_reputation_type, lrep_roguish),
           ##diplomacy start+
           (neq, ":troop_object", "trp_npc13"),#Nizar isn't a commoner
		   (neg|troop_slot_ge, ":troop_object", slot_lord_reputation_type, lrep_conventional),#ladies aren't commoners
		   (assign, ":return_reg4", 0),
		   (try_begin),
			  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
			  (assign, ":return_reg4", 1),
		   (try_end),
           ##diplomacy end+
       (try_begin),
	   ##diplomacy start+
	      #Companions: make a supportive remark if the person is compatible with you
	      (is_between, "$g_talk_troop", companions_begin, companions_end),
	      (troop_slot_eq, "$g_talk_troop", slot_troop_personalitymatch_object, ":troop_object"),
	      (assign, ":comment", "str_dplmc_comment_you_enfiefed_a_commoner_supportive"),
	      (assign, ":relevance", 100),
	      (assign, ":suggested_relation_change", 0),
	   (else_try),
		   #Make a supportive remark if you like the person a lot (overrides objections)
		   (call_script, "script_troop_get_relation_with_troop", ":troop_object", "$g_talk_troop"),
 	       (ge, reg0, 50),
		   (assign, ":comment", "str_dplmc_comment_you_enfiefed_a_commoner_supportive"),
		   (assign, ":relevance", 100),
		   (assign, ":suggested_relation_change", 0),
	   (else_try),
	       #Make a supportive remark if you like the person and wouldn't ordinarily object
		   (ge, reg0, 20),
		   (this_or_next|is_between, ":true_reputation", lrep_roguish, lrep_conventional),
		   (this_or_next|eq, ":reputation", lrep_cunning),
		   (eq, ":reputation", lrep_goodnatured),
		   (assign, ":comment", "str_dplmc_comment_you_enfiefed_a_commoner_supportive"),
		   (assign, ":relevance", 100),
		   (assign, ":suggested_relation_change", 0),
	   (else_try),
	       #Don't complain about your own spouse.
		   (troop_slot_eq, "$g_talk_troop", ":troop_object", slot_troop_spouse),
	   (else_try),
		   #Don't complain if you aren't actually a lord.
		   (is_between, ":true_reputation", lrep_roguish, lrep_conventional),
	   (else_try),
	   ##diplomacy end+
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_you_enfiefed_a_commoner_nasty"),##diplomacy start+ note: this line uses reg4 from above for gender-correct pronoun ##diplomacy end+
           (assign, ":relevance", 100),
		   (assign, ":suggested_relation_change", -3),

       (else_try),
		   (eq, ":reputation", lrep_upstanding),
           (assign, ":comment", "str_comment_you_enfiefed_a_commoner_hesitant"),##diplomacy start+ note: next line uses reg4 from above for gender-correct pronoun ##diplomacy end+
           (assign, ":relevance", 100),
		   (assign, ":suggested_relation_change", -2),

       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
			   (eq, ":reputation", lrep_martial),
           (assign, ":comment", "str_comment_you_enfiefed_a_commoner_derisive"),##diplomacy start+ note: next line uses reg4 from above for gender-correct pronoun ##diplomacy end+
           (assign, ":relevance", 100),
		   (assign, ":suggested_relation_change", -4),

       (try_end),

#Post 0907 changes begin
     (else_try),
       (this_or_next|eq, ":entry_type", logent_lord_defeated_by_player),
            (eq, ":entry_type", logent_lord_helped_by_player),
       (troop_slot_eq, "$g_talk_troop", slot_troop_present_at_event, ":log_entry_no"),
       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_we_defeated_a_lord_unfriendly_spiteful"),
           (assign, ":relevance", 150),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (assign, ":comment", "str_comment_we_defeated_a_lord_unfriendly"),
           (assign, ":relevance", 150),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
               (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_we_defeated_a_lord_cruel"),
           (assign, ":relevance", 150),
       (else_try),
           (eq, ":reputation", lrep_quarrelsome),
           (assign, ":comment", "str_comment_we_defeated_a_lord_cruel"),
           (assign, ":relevance", 150),
       (else_try),
           (eq, ":reputation", lrep_upstanding),
           (assign, ":comment", "str_comment_we_defeated_a_lord_upstanding"),
           (assign, ":relevance", 150),
       (else_try),
           (assign, ":comment", "str_comment_we_defeated_a_lord_default"),
           (assign, ":relevance", 150),
       (try_end),

     (else_try),
       (this_or_next|eq, ":entry_type", logent_castle_captured_by_player),
       (eq, ":entry_type", logent_player_participated_in_siege),

       (troop_slot_eq, "$g_talk_troop", slot_troop_present_at_event, ":log_entry_no"),

       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
           (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_we_fought_in_siege_unfriendly_spiteful"),
           (assign, ":relevance", 150),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (assign, ":comment", "str_comment_we_fought_in_siege_unfriendly"),
           (assign, ":relevance", 150),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
           (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_we_fought_in_siege_cruel"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (else_try),
           (eq, ":reputation", lrep_quarrelsome),
           (assign, ":comment", "str_comment_we_fought_in_siege_quarrelsome"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (else_try),
           (eq, ":reputation", lrep_upstanding),
           (assign, ":comment", "str_comment_we_fought_in_siege_upstanding"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (else_try),
           (eq, ":reputation", lrep_martial),
           (assign, ":comment", "str_comment_we_fought_in_siege_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 2),
       (else_try),
           (faction_slot_eq, "$players_kingdom", slot_faction_leader, "$g_talk_troop"),
           (assign, ":comment", "str_comment_we_fought_in_siege_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
		(else_try),
           (assign, ":comment", "str_comment_we_fought_in_siege_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_castle_given_to_lord_by_player),

       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
         (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_give_castle_in_my_control"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_martial),
         (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_give_castle_in_my_control"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_give_castle_in_my_control"),
         (assign, ":relevance", 200),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_player_participated_in_major_battle),
       (troop_slot_eq, "$g_talk_troop", slot_troop_present_at_event, ":log_entry_no"),
       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_unfriendly_spiteful"),
           (assign, ":relevance", 150),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_unfriendly"),
           (assign, ":relevance", 150),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
               (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_cruel"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (else_try),
           (eq, ":reputation", lrep_quarrelsome),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_cruel"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (else_try),
           (eq, ":reputation", lrep_upstanding),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_upstanding"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (else_try),
           (faction_slot_eq, "$players_kingdom", slot_faction_leader, "$g_talk_troop"),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (else_try),
           (eq, ":reputation", lrep_martial),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 2),
	   (else_try),
           (assign, ":comment", "str_comment_we_fought_in_major_battle_default"),
           (assign, ":relevance", 150),
		   (assign, ":suggested_relation_change", 1),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_player_suggestion_succeeded),
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_player_suggestion_succeeded"),
         (assign, ":relevance", 200),
		 (assign, ":suggested_relation_change", 3),

	   (try_end),
     (else_try),
       (eq, ":entry_type", logent_player_suggestion_failed),
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_player_suggestion_failed"),
         (assign, ":relevance", 200),
		 (assign, ":suggested_relation_change", -5),

	   (try_end),

#Post 0907 changes end

     (else_try),
       (eq, ":entry_type", logent_lord_defeated_by_player),
	   ##diplomacy start+  Set reg4 for calling scripts
	   (try_begin),
		  (neq, ":troop_object", "$g_talk_troop"),
		  (assign, ":return_reg4", 0),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_defeated_me_enemy_chivalrous"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_debauched),
             (eq, ":reputation", lrep_quarrelsome),
         (assign, ":comment", "str_comment_you_defeated_me_enemy_spiteful"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_defeated_me_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_cunning),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_pragmatic"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_chivalrous"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_spiteful"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (faction_slot_eq, "$players_kingdom", slot_faction_leader, "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_liege"),
         (assign, ":relevance", 150),
		 (assign, ":suggested_relation_change", 1),

       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_unfriendly_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_unfriendly_chivalrous"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied"),
         (assign, ":relevance", 65),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_lord_defeated_by_player),
	   ##diplomacy start+  Set reg4 for calling scripts
	   (try_begin),
		  (neq, ":troop_object", "$g_talk_troop"),
		  (assign, ":return_reg4", 0),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_defeated_me_enemy_chivalrous"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_debauched),
             (eq, ":reputation", lrep_quarrelsome),
         (assign, ":comment", "str_comment_you_defeated_me_enemy_spiteful"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_defeated_me_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_cunning),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_pragmatic"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_chivalrous"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy_spiteful"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, ":troop_object_faction", "$g_talk_troop_faction"),
         (assign, ":comment", "str_comment_you_defeated_my_friend_enemy"),
         (assign, ":relevance", 85),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (faction_slot_eq, "$players_kingdom", slot_faction_leader, "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_liege"),
         (assign, ":relevance", 70),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_unfriendly_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied_unfriendly_chivalrous"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (assign, ":comment", "str_comment_you_defeated_a_lord_allied"),
         (assign, ":relevance", 65),
       (try_end),

#Post 0907 changes begin
     (else_try),
       (eq, ":entry_type", logent_lord_helped_by_player),
       (neq, ":troop_object", "$g_talk_troop"),
       (eq, ":troop_object_faction", "$g_talk_troop_faction"),
	   ##diplomacy start+  Set reg4 for calling scripts
	   (assign, ":return_reg4", 0),
	   (try_begin),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+
       (try_begin),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_upstanding),
             (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_helped_my_ally_unfriendly_chivalrous"),
         (assign, ":relevance", 65),
         (assign, ":suggested_relation_change", 2),
       (else_try),
         (lt, "$g_talk_troop_relation", -5),
         (assign, ":comment", "str_comment_you_helped_my_ally_unfriendly"),
         (assign, ":relevance", 0),
       (else_try),
	      ##diplomacy start+
		  (gt, ":speaker_is_a_liege", 0),#Explicitly check if the speaker is a liege rather than relying solely on reputation
		  ##diplomacy end+
         (eq, ":reputation", lrep_none),
         (assign, ":comment", "str_comment_you_helped_my_ally_liege"),
         (assign, ":relevance", 65),
         (assign, ":suggested_relation_change", 3),
       (else_try),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_helped_my_ally_unfriendly_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_helped_my_ally_spiteful"),
         (assign, ":relevance", 65),
       (else_try),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_you_helped_my_ally_chivalrous"),
         (assign, ":relevance", 65),
         (assign, ":suggested_relation_change", 2),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_helped_my_ally_default"),
       (try_end),

#Post 0907 changes begin
     (else_try),
       (eq, ":entry_type", logent_player_defeated_by_lord),
	   ##diplomacy start+  Set reg4 for calling scripts
	   (try_begin),
		  (neq, ":troop_object", "$g_talk_troop"),
		  (assign, ":return_reg4", 0),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+
       (troop_slot_eq, "$g_talk_troop", slot_troop_present_at_event, ":log_entry_no"),
       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_we_were_defeated_unfriendly_spiteful"),
           (assign, ":relevance", 150),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (assign, ":comment", "str_comment_we_were_defeated_unfriendly"),
           (assign, ":relevance", 150),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_selfrighteous),
               (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_we_were_defeated_cruel"),
           (assign, ":relevance", 150),
       (else_try),
           (assign, ":comment", "str_comment_we_were_defeated_default"),
           (assign, ":relevance", 150),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_player_defeated_by_lord),
  	   ##diplomacy start+  Set reg4 for calling scripts
	   (try_begin),
		  (neq, ":troop_object", "$g_talk_troop"),
		  (assign, ":return_reg4", 0),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_I_defeated_you_enemy_spiteful"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_I_defeated_you_enemy_chivalrous"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_I_defeated_you_enemy_benevolent"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_selfrighteous),
             (eq, ":reputation", lrep_cunning),
         (assign, ":comment", "str_comment_I_defeated_you_enemy_coldblooded"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_I_defeated_you_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_I_defeated_you_enemy"),
         (assign, ":relevance", 200),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
         (gt, "$g_talk_troop_relation", 5),
         (assign, ":comment", "str_comment_you_were_defeated_allied_friendly_spiteful"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
         (lt, "$g_talk_troop_relation", -5),
         (assign, ":comment", "str_comment_you_were_defeated_allied_unfriendly_cruel"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
         (le, "$g_talk_troop_relation", 5),
         (assign, ":comment", "str_comment_you_were_defeated_allied_spiteful"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (eq, ":reputation", lrep_selfrighteous),
         (assign, ":comment", "str_comment_you_were_defeated_allied_pitiless"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (eq, ":reputation", lrep_upstanding),
         (lt, "$g_talk_troop_relation", -15),
         (assign, ":comment", "str_comment_you_were_defeated_allied_unfriendly_upstanding"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, "$g_talk_troop_relation", -10),
         (assign, ":comment", "str_comment_you_were_defeated_allied_unfriendly"),
         (assign, ":relevance", 65),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (assign, ":comment", "str_comment_you_were_defeated_allied"),
         (assign, ":relevance", 65),
       (try_end),
#Post 0907 changes end

#Post 0907 changes begin
     (else_try),
       (eq, ":entry_type", logent_player_retreated_from_lord),
       (troop_slot_eq, "$g_talk_troop", slot_troop_present_at_event, ":log_entry_no"),
   	   ##diplomacy start+  Set reg4 for calling scripts
	   (try_begin),
		  (neq, ":troop_object", "$g_talk_troop"),
		  (assign, ":return_reg4", 0),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+
       (try_begin),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_you_abandoned_us_unfriendly_spiteful"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -5),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (eq, ":reputation", lrep_selfrighteous),
           (assign, ":comment", "str_comment_you_abandoned_us_unfriendly_pitiless"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -5),
       (else_try),
           (lt, "$g_talk_troop_relation", -5),
           (this_or_next|eq, ":reputation", lrep_quarrelsome),
               (eq, ":reputation", lrep_debauched),
           (assign, ":comment", "str_comment_you_abandoned_us_spiteful"),
           (assign, ":suggested_relation_change", -5),
       (else_try),
           (eq, ":reputation", lrep_martial),
           (assign, ":comment", "str_comment_you_abandoned_us_chivalrous"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -2),
       (else_try),
           (this_or_next|eq, ":reputation", lrep_upstanding),
               (eq, ":reputation", lrep_goodnatured),
           (assign, ":comment", "str_comment_you_abandoned_us_benefitofdoubt"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -1),
       (else_try),
           (assign, ":comment", "str_comment_you_abandoned_us_default"),
           (assign, ":relevance", 150),
           (assign, ":suggested_relation_change", -2),
       (try_end),


#Post 0907 changes end

     (else_try),
       (this_or_next|eq, ":entry_type", logent_player_retreated_from_lord),
            (eq, ":entry_type", logent_player_retreated_from_lord_cowardly),

       (eq, ":troop_object", "$g_talk_troop"),
       (try_begin),
         (eq, "$cheat_mode", 1),
         (assign, reg7, ":entry_hours_elapsed"),
         (display_message, "@{!}Elapsed hours: {reg7}"),
       (try_end),
       (gt, ":entry_hours_elapsed", 2),
       (try_begin),
         (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy_spiteful"),
         (assign, ":relevance", 25),
       (else_try),
         (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy_chivalrous"),
         (assign, ":relevance", 25),
       (else_try),
         (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy_benevolent"),
         (assign, ":relevance", 25),
       (else_try),
         (eq, ":reputation", lrep_cunning),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy_coldblooded"),
         (assign, ":relevance", 25),
       (else_try),
         (assign, ":comment", "str_comment_you_ran_from_me_enemy"),
         (assign, ":relevance", 25),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_player_retreated_from_lord_cowardly),
       ##diplomacy start+  Set reg4 for calling scripts
       (try_begin),
          (neq, ":troop_object", "$g_talk_troop"),
          (assign, ":return_reg4", 0),
          (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
          (assign, ":return_reg4", 1),
       (try_end),
       ##diplomacy end+
       (try_begin),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_relation", 5),
         (eq, ":reputation", lrep_martial),
         (assign, ":comment", "str_comment_you_ran_from_foe_allied_chivalrous"),
         (assign, ":relevance", 80),
         (assign, ":suggested_relation_change", -3),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
         (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_you_ran_from_foe_allied_upstanding"),
         (assign, ":relevance", 80),
         (assign, ":suggested_relation_change", -1),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_relation", 5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_ran_from_foe_allied_spiteful"),
         (assign, ":relevance", 80),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_lord_defeated_but_let_go_by_player),
       ##diplomacy start+  Set reg4 for calling scripts
       (try_begin),
          (neq, ":troop_object", "$g_talk_troop"),
          (assign, ":return_reg4", 0),
          (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
          (assign, ":return_reg4", 1),
       (try_end),
       ##diplomacy end+
       (try_begin),
         (eq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_let_me_go_spiteful"),
         (assign, ":relevance", 300),
         (assign, ":suggested_relation_change", -15),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (ge, "$g_talk_troop_faction_relation", 0),
         (assign, ":comment", "str_comment_you_let_me_go_default"),
         (assign, ":relevance", 300),
         (assign, ":suggested_relation_change", 2),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_faction_relation", 0),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_upstanding),
         (assign, ":suggested_relation_change", 5),
         (assign, ":relevance", 300),
         (assign, ":comment", "str_comment_you_let_me_go_enemy_chivalrous"),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_faction_relation", 0),
         (this_or_next|eq, ":reputation", lrep_selfrighteous),
             (eq, ":reputation", lrep_cunning),
         (assign, ":relevance", 300),
         (assign, ":comment", "str_comment_you_let_me_go_enemy_coldblooded"),
       (else_try),
         (eq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_faction_relation", 0),
         (assign, ":relevance", 300),
         (assign, ":comment", "str_comment_you_let_me_go_enemy"),
         (assign, ":suggested_relation_change", 1),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_martial),
             (eq, ":reputation", lrep_goodnatured),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied_chivalrous"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (eq, ":reputation", lrep_upstanding),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied_upstanding"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (this_or_next|eq, ":reputation", lrep_cunning),
             (eq, ":reputation", lrep_selfrighteous),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied_coldblooded"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (lt, "$g_talk_troop_relation", -5),
         (this_or_next|eq, ":reputation", lrep_quarrelsome),
             (eq, ":reputation", lrep_debauched),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied_unfriendly_spiteful"),
         (assign, ":relevance", 80),
       (else_try),
         (eq, "$players_kingdom", "$g_talk_troop_faction"),
         (lt, ":players_kingdom_relation", 0),
         (neq, ":troop_object", "$g_talk_troop"),
         (assign, ":comment", "str_comment_you_let_go_a_lord_allied"),
         (assign, ":relevance", 80),
       (try_end),

#Internal faction relations

     (else_try),
       (eq, ":entry_type", logent_pledged_allegiance),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":faction_object", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
		 (eq, ":faction_object", "$players_kingdom"), #Ie, no switch of kingdoms
         (assign, ":relevance", 200),
         (try_begin),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_martial),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_martial_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_martial),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_martial"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_quarrelsome),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_quarrelsome_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_quarrelsome),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_quarrelsome"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_selfrighteous_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_selfrighteous"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_cunning),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_cunning_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_cunning),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_cunning"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_debauched_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_debauched"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_goodnatured),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_goodnatured_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_goodnatured),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_goodnatured"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_upstanding_unfriendly"),
         (else_try),
            (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_pledged_allegiance_allied_upstanding"),
         (try_end),
       (try_end),


     (else_try),
       (eq, ":entry_type", logent_liege_grants_fief_to_vassal),
       (eq, ":troop_object", "trp_player"),
       (try_begin),
         (eq, ":faction_object", "$g_talk_troop_faction"),
         (neq, ":actor", "$g_talk_troop"),
         (eq, ":faction_object", "$players_kingdom"),
         (assign, ":relevance", 110),
         (try_begin),
            (gt, "$g_talk_troop_relation", 5),
            (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_friendly_cruel"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_cunning),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_friendly_cynical"),
         (else_try),
            (gt, "$g_talk_troop_relation", 5),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_friendly"),
         (else_try),
            (is_between, "$g_talk_troop_relation", -5, 5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_spiteful"),
            (assign, ":suggested_relation_change", -2),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_unfriendly_upstanding"),
         (else_try),
            (lt, "$g_talk_troop_relation", -5),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied_unfriendly_spiteful"),
         (else_try),
            (assign, ":comment", "str_comment_our_king_granted_you_a_fief_allied"),
         (try_end),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_renounced_allegiance),
       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":faction_object", "$g_talk_troop_faction"),
         (neq, ":troop_object", "$g_talk_troop"),
         (try_begin),
           (ge, "$g_talk_troop_faction_relation", 0),
           (neq, "$g_talk_troop_faction", "$players_kingdom"),
           (assign, ":relevance", 180),
           (try_begin),
             (gt, "$g_talk_troop_relation", 5),
             (assign, ":comment", "str_comment_you_renounced_your_alliegance_friendly"),
           (else_try),
             (ge, "$g_talk_troop_relation", 0),
             (eq, ":reputation", lrep_goodnatured),
             (assign, ":comment", "str_comment_you_renounced_your_alliegance_friendly"),
		   (else_try),
		     (assign, ":comment", "str_comment_you_renounced_your_alliegance_default"),
           (try_end),
         (else_try),
           (lt, "$g_talk_troop_faction_relation", 0),
           (assign, ":relevance", 300),
           (try_begin),
              (ge, "$g_talk_troop_relation", 0),
              (this_or_next|eq, ":reputation", lrep_selfrighteous),
                  (eq, ":reputation", lrep_debauched),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_unfriendly_moralizing"),
           (else_try),
              (gt, "$g_talk_troop_relation", 5),
              (this_or_next|eq, ":reputation", lrep_goodnatured),
                (eq, ":reputation", lrep_upstanding),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_enemy_friendly"),
           (else_try),
              (gt, "$g_talk_troop_relation", 5),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_enemy"),
           (else_try),
              (is_between, "$g_talk_troop_relation", -5, 5),
              (this_or_next|eq, ":reputation", lrep_quarrelsome),
                  (eq, ":reputation", lrep_debauched),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_unfriendly_spiteful"),
              (assign, ":suggested_relation_change", -2),
           (else_try),
              (lt, "$g_talk_troop_relation", -5),
              (this_or_next|eq, ":reputation", lrep_quarrelsome),
              (this_or_next|eq, ":reputation", lrep_selfrighteous),
                (eq, ":reputation", lrep_debauched),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_unfriendly_spiteful"),
           (else_try),
              (assign, ":comment", "str_comment_you_renounced_your_alliegance_default"),
           (try_end),
         (try_end),
       (try_end),

     (else_try),
       (eq, ":entry_type", logent_lady_marries_lord),
	   (eq, ":troop_object", "trp_player"),
   	   ##diplomacy start+  Set reg4 for calling scripts
	   (try_begin),
		  (neq, ":actor", "$g_talk_troop"),
		  (assign, ":return_reg4", 0),
		  (call_script, "script_cf_dplmc_troop_is_female", ":actor"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+
	   (try_begin),
		  (this_or_next|eq, ":reputation", lrep_quarrelsome),
			(eq, ":reputation", lrep_debauched),
		  (lt, "$g_talk_troop_relation", -5),
          (assign, ":relevance", 200),
		  (assign, ":comment", "str_comment_marriage_normal_nasty"),
	   (else_try),
		  (call_script, "script_troop_get_family_relation_to_troop", ":actor", "$g_talk_troop"),
		  (ge, reg0, 5),
		  (assign, ":comment", "str_comment_marriage_normal_family"),
          (assign, ":relevance", 300),
		  (assign, ":suggested_relation_change", reg0),
		  (val_div, ":suggested_relation_change", 3),
	   (else_try),
		  (store_faction_of_troop, ":bride_faction", ":actor"),
		  (eq, ":bride_faction", "$g_talk_troop_faction"),
		  (assign, ":comment", "str_comment_marriage_normal"),
          (assign, ":relevance", 100),
	   (try_end),
     (else_try),
       (eq, ":entry_type", logent_lady_elopes_with_lord),
	   (eq, ":troop_object", "trp_player"),
  	   ##diplomacy start+  Set reg4 for calling scripts
	   (try_begin),
		  (neq, ":actor", "$g_talk_troop"),
		  (assign, ":return_reg4", 0),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+
	   (try_begin),
		  (call_script, "script_troop_get_family_relation_to_troop", ":actor", "$g_talk_troop"),
		  (ge, reg0, 5),
		  (assign, ":comment", "str_comment_marriage_elopement_family"),
          (assign, ":relevance", 300),
		  (store_sub, ":suggested_relation_change", 0, reg0),
		  (val_div, ":suggested_relation_change", 3),
	   (else_try),
		  (store_faction_of_troop, ":bride_faction", ":actor"),
		  (eq, ":bride_faction", "$g_talk_troop_faction"),
		  (faction_slot_eq, ":bride_faction", slot_faction_leader, "$g_talk_troop"),
		  (assign, ":comment", "str_comment_marriage_elopement_liege"),
          (assign, ":relevance", 300),
		  (assign, ":suggested_relation_change", -10),
	   (try_end),
     (else_try), #this is specific to quarrels with the player
       (eq, ":entry_type", logent_lords_quarrel_over_woman),
 	   (eq, ":actor", "$g_talk_troop"),
 	   (eq, ":center_object", "trp_player"),

	   (neg|troop_slot_ge, ":troop_object", slot_troop_spouse, "trp_player"),

	   (str_store_troop_name, s54, ":troop_object"),
   	   ##diplomacy start+  Set reg4 for calling scripts
	   (assign, ":return_reg4", 0),
	   (try_begin),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+
	   (try_begin),
	       (this_or_next|eq, ":reputation", lrep_selfrighteous),
	       (this_or_next|eq, ":reputation", lrep_quarrelsome),
				(eq, ":reputation", lrep_debauched),

	       (assign, ":comment", "str_comment_i_quarreled_with_you_over_woman_derisive"),
		   (assign, ":relevance", 200),
	       (assign, ":suggested_relation_change", -20),
	   (else_try),
	       (assign, ":comment", "str_comment_i_quarreled_with_you_over_woman_default"),
		   (assign, ":relevance", 200),
	       (assign, ":suggested_relation_change", -20),
	   (try_end),

     (else_try),
       (eq, ":entry_type", logent_border_incident_troop_breaks_truce),
 	   (eq, ":actor", "trp_player"),
 	   (faction_slot_eq, ":faction_object", slot_faction_leader, "$g_talk_troop"),
	   (eq, "$players_kingdom", ":faction_object"),

	   (assign, ":suggested_relation_change", -10),
	   (assign, ":comment", "str_comment_you_broke_truce_as_my_vassal"),
	   (assign, ":relevance", 300),

     (else_try),
       (eq, ":entry_type", logent_border_incident_troop_attacks_neutral),
 	   (eq, ":actor", "trp_player"),
 	   (faction_slot_eq, ":faction_object", slot_faction_leader, "$g_talk_troop"),
	   (eq, "$players_kingdom", ":faction_object"),

	   (assign, ":suggested_relation_change", -3),
	   (assign, ":comment", "str_comment_you_attacked_neutral_as_my_vassal"),
	   (assign, ":relevance", 200),

	 #THE FOLLOWING ARE ALL COMPLAINTS SPOKEN BY LORDS WITHIN CONVERATIONS, RATHER THAN COMMENTS WHEN THE PLAYER FIRST SPEAKS TO A LORD
	 (else_try), #these need to have the actor and object strings added because they are used outside of "script_get_relevant_comment_to_s42"
       (eq, ":entry_type", logent_ruler_intervenes_in_quarrel),
 	   (eq, ":center_object", "$g_talk_troop"), #actor is liege lord, center object is loser lord, troop object is winner lord
	   (str_store_troop_name, s50, ":actor"),
	   (str_store_troop_name, s51, ":center_object"), #s50 is actor, s51 is center object, s54 is troop object
	   (str_store_troop_name, s54, ":troop_object"), #s50 is actor, s51 is center object, s54 is troop object
       (assign, ":comment", "str_comment_lord_intervened_against_me"),
	   (assign, ":relevance", -1),

	 (else_try),
       (eq, ":entry_type", logent_lord_protests_marshall_appointment),
 	   (eq, ":actor", "$g_talk_troop"),

	   (str_store_troop_name, s51, ":center_object"), #s51 is center object (marshall), s54 is troop object (liege lord),
	   (str_store_troop_name, s54, ":troop_object"),

       (assign, ":comment", "str_comment_i_protested_marshall_appointment"),
	   (assign, ":relevance", -1),

	 (else_try),
       (eq, ":entry_type", logent_lord_blames_defeat),
 	   (eq, ":actor", "$g_talk_troop"),

	   (str_store_troop_name, s51, ":center_object"), #s51 is center object (marshall), s54 is troop object (liege lord),
	   (str_store_troop_name, s54, ":troop_object"),
	   (str_store_troop_name, s56, ":faction_object"), #faction object is unusual in this circumstance

       (assign, ":comment", "str_comment_i_blamed_defeat"),
	   (assign, ":relevance", -1),

	 (else_try),
       (eq, ":entry_type", logent_troop_feels_cheated_by_troop_over_land),
 	   (eq, ":actor", "$g_talk_troop"),

	   (str_store_party_name, s51, ":center_object"),
	   (str_store_troop_name, s54, ":troop_object"),
	   (str_store_troop_name, s56, ":faction_object"), #faction object is unusual in this circumstance

       (assign, ":comment", "str_comment_i_was_entitled_to_fief"),
	   (assign, ":relevance", -1),

	 (else_try),
       (eq, ":entry_type", logent_lords_quarrel_over_woman),
 	   (eq, ":actor", "$g_talk_troop"),

	   (str_store_troop_name, s51, ":center_object"),
	   (str_store_troop_name, s54, ":troop_object"),
	   ##diplomacy start+  Set reg4 and reg3 for calling scripts
	   #(assign, reg3, 0),# #Exclude reg3, since it is used for output anyway
	   #(try_begin),
	   #  (call_script, "script_cf_dplmc_troop_is_female", ":center_object"),
	   #  (assign, reg3, 1),
	   #(try_end),
	   (assign, ":return_reg4", 0),
	   (try_begin),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+

       (assign, ":comment", "str_comment_i_quarreled_with_troop_over_woman"),
	   (assign, ":relevance", -1),

	 (else_try),
       (eq, ":entry_type", logent_lords_quarrel_over_woman),
 	   (eq, ":center_object", "$g_talk_troop"),

	   (str_store_troop_name, s51, ":actor"),
	   (str_store_troop_name, s54, ":troop_object"),
	   ##diplomacy start+  Set reg4 and reg3 for calling scripts
	   #(assign, reg3, 0),#Exclude reg3, since it is used for output anyway
	   #(try_begin),
	   #  (call_script, "script_cf_dplmc_troop_is_female", ":actor"),
	   #  (assign, reg3, 1),
	   #(try_end),
	   (assign, ":return_reg4", 0),
	   (try_begin),
		  (call_script, "script_cf_dplmc_troop_is_female", ":troop_object"),
		  (assign, ":return_reg4", 1),
	   (try_end),
	   ##diplomacy end+

       (assign, ":comment", "str_comment_i_quarreled_with_troop_over_woman"),
	   (assign, ":relevance", -1),

	 (else_try),
       (eq, ":entry_type", logent_player_stole_cattles_from_village),

       (eq, ":actor", "trp_player"),
       (try_begin),
         (eq, ":center_object_lord", "$g_talk_troop"),
         (assign, ":relevance", 200),
         (assign, ":suggested_relation_change", -1),
         (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_default"),
         (try_begin),
            (lt, "$g_talk_troop_faction_relation", -3),
            (this_or_next|eq, ":reputation", lrep_goodnatured),
            (eq, ":reputation", lrep_upstanding),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_enemy_benevolent"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -3),
            (this_or_next|eq, ":reputation", lrep_cunning),
                (eq, ":reputation", lrep_selfrighteous),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_enemy_coldblooded"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -3),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_enemy_spiteful"),
         (else_try),
            (lt, "$g_talk_troop_faction_relation", -3),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_enemy"),
         (else_try),
            (lt, "$g_talk_troop_relation", -3),
            (this_or_next|eq, ":reputation", lrep_quarrelsome),
                (eq, ":reputation", lrep_debauched),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_unfriendly_spiteful"),
         (else_try),
            (gt, "$g_talk_troop_relation", 6),
            (assign, ":comment", "str_comment_you_stole_cattles_from_my_village_friendly"),
         (try_end),
       (try_end),

     (try_end),

     (assign, reg0, ":comment"),
     (assign, reg1, ":relevance"),
     (assign, reg2, ":suggested_relation_change"),
     (assign, reg3, ":rejoinder"),
     ##diplomacy start+
     (assign, reg4, ":return_reg4"),
     ##diplomacy end+
    ]),

  # script_get_relevant_comment_to_s42
  # Input: none
  # Output: reg0 = 1 if comment found, 0 otherwise; s61 will contain comment string if found
  ("get_relevant_comment_to_s42",
    [

     (troop_get_slot, ":reputation", "$g_talk_troop", slot_lord_reputation_type),
     (try_begin),
       (eq, "$cheat_mode", 1),
       (store_add, ":rep_string", ":reputation", "str_personality_archetypes"),
       (str_store_string, s15, ":rep_string"),
       (display_message, "@{!}Reputation type: {s15}"),
     (try_end),


     (assign, ":highest_score_so_far", 50),
     (assign, ":best_comment_so_far", -1),
     (assign, ":rejoinder_to_best_comment_so_far", -1),
     (assign, ":comment_found", 0),
     (assign, ":best_log_entry", -1),
     (assign, ":comment_relation_change", 0),
     (store_current_hours, ":current_time"),
	 ##diplomacy start+
	 (assign, ":best_comment_reg4", 0),
	 ##diplomacy end+

#prevents multiple comments in conversations in same hour

#     (troop_get_slot, ":talk_troop_last_comment_time", "$g_talk_troop", slot_troop_last_comment_time),
#"$num_log_entries should also be set to one, not zero. This is included in the initialize npcs script, although could be moved to game_start
     (troop_get_slot, ":talk_troop_last_comment_slot", "$g_talk_troop", slot_troop_last_comment_slot),
     (troop_set_slot, "$g_talk_troop", slot_troop_last_comment_slot, "$num_log_entries"),

     (store_add, ":log_entries_plus_one", "$num_log_entries", 1),
     (try_for_range, ":log_entry_no", 1, ":log_entries_plus_one"),
#      It should be log entries plus one, so that the try_ sequence does not stop short of the last log entry
#      $Num_log_entries is now the number of the last log entry, which begins at "1" rather than "0"
#      This is so that (le, ":log_entry_no", ":talk_troop_last_comment_slot") works properly

       (troop_get_slot, ":entry_time",           "trp_log_array_entry_time",           ":log_entry_no"),
#      (val_max, ":entry_time", 1), #This is needed for pre-game events to be commented upon, if hours are used rather than the order of events
       (store_sub, ":entry_hours_elapsed", ":current_time", ":entry_time"),
       (try_begin),
         (le, ":log_entry_no", ":talk_troop_last_comment_slot"),
#         (le, ":entry_time", ":talk_troop_last_comment_time"),
         (try_begin),
           (eq, ":log_entry_no", ":talk_troop_last_comment_slot"),
           (eq, "$cheat_mode", 1),
           (assign, reg5, ":log_entry_no"),
           (display_message, "@{!}Entries up to #{reg5} skipped"),
         (try_end),
#       I suggest using the log entry number as opposed to time so that events in the same hour can be commented upon
#       This feels more natural, for example, if there are other lords in the court when the player pledges allegiance
       (else_try),
#         (le, ":entry_hours_elapsed", 3), #don't comment on really fresh events
#       (else_try),
         (call_script, "script_get_relevant_comment_for_log_entry", ":log_entry_no"),
         (gt, reg1, 10),
         (assign, ":score", reg1),
         (assign, ":comment", reg0),
		 #reg2 is what
		 (assign, ":rejoinder", reg3),

         (store_random_in_range, ":rand", 70, 140),
         (val_mul, ":score", ":rand"),
         (store_add, ":entry_time_score", ":entry_hours_elapsed", 500), #approx. one month
         (val_mul, ":score", 1000),
         (val_div, ":score", ":entry_time_score"), ###Relevance decreases over time - halved after one month, one-third after two, etc
         (try_begin),
           (gt, ":score", ":highest_score_so_far"),
           (assign, ":highest_score_so_far", ":score"),
           (assign, ":best_comment_so_far",  ":comment"),
           (assign, ":rejoinder_to_best_comment_so_far",  ":rejoinder"),
           (assign, ":best_log_entry", ":log_entry_no"),
           (assign, ":comment_relation_change", reg2),
		   ##diplomacy start+
		   (assign, ":best_comment_reg4", reg4),
		   ##diplomacy end+
         (try_end),
       (try_end),
     (try_end),

     (try_begin),
       (gt, ":best_comment_so_far", 0),
       (assign, ":comment_found", 1), #comment found print it to s61 now.
       (troop_get_slot, ":actor",                 "trp_log_array_actor",                 ":best_log_entry"),
       (troop_get_slot, ":center_object",         "trp_log_array_center_object",         ":best_log_entry"),
       (troop_get_slot, ":center_object_lord",    "trp_log_array_center_object_lord",    ":best_log_entry"),
       (troop_get_slot, ":center_object_faction", "trp_log_array_center_object_faction", ":best_log_entry"),
       (troop_get_slot, ":troop_object",          "trp_log_array_troop_object",          ":best_log_entry"),
       (troop_get_slot, ":troop_object_faction",  "trp_log_array_troop_object_faction",  ":best_log_entry"),
       (troop_get_slot, ":faction_object",        "trp_log_array_faction_object",        ":best_log_entry"),
	   ##diplomacy start+
	   (assign, reg4, ":best_comment_reg4"),
	   ##diplomacy end+
       (try_begin),
         (ge, ":actor", 0),
         (str_store_troop_name,   s50, ":actor"),
		 ##diplomacy start+
		 (eq, ":best_comment_so_far", "str_comment_i_quarreled_with_troop_over_woman"),
		 (neq, ":actor", "$g_talk_troop"),
		 (neq, ":actor", "trp_player"),
         #SB : other script
         (call_script, "script_dplmc_store_troop_is_female_reg", ":actor", 3),
		 ##diplomacy end+
       (try_end),
       (try_begin),
         (ge, ":center_object", 0),
		 ##diplomacy start+
		 ##OLD:
		 #(str_store_party_name,   s51, ":center_object"),
		 ##NEW:
		 #Alternate meaning (not usually called from this script, but just in case)
		 #In this case, s51 is actually a troop.  Use reg3 for the gender.
		 (try_begin),
			(eq, ":best_comment_so_far", "str_comment_i_quarreled_with_troop_over_woman"),
			(str_store_troop_name, s51, ":center_object"),
			(neq, ":center_object", "$g_talk_troop"),
			(neq, ":center_object", "trp_player"),
			(call_script, "script_dplmc_store_troop_is_female_reg", ":center_object", 3),
		 (else_try),
		   (neq, ":best_comment_so_far", "str_comment_i_quarreled_with_troop_over_woman"),
 		   (str_store_party_name,   s51, ":center_object"),#<- old behavior
  	    (try_end),
		##diplomacy end+
       (try_end),
       (try_begin),
         (ge, ":center_object_lord", 0),
         (str_store_troop_name,   s52, ":center_object_lord"),
       (try_end),
       (try_begin),
         (ge, ":center_object_faction", 0),
         (str_store_faction_name, s53, ":center_object_faction"),
       (try_end),
       (try_begin),
         (ge, ":troop_object", 0),
         (str_store_troop_name,   s54, ":troop_object"),
       (try_end),
       (try_begin),
         (is_between, ":troop_object_faction", kingdoms_begin, kingdoms_end),
         (str_store_faction_name, s55, ":troop_object_faction"),
         (str_store_string, s55, "str_the_s55"),
	   (else_try),
		 (is_between, ":troop_object", bandits_begin, bandits_end),
         (str_store_string, s55, "str_bandits"),
	   (else_try),
	     (eq, ":troop_object_faction", "fac_deserters"),
         (str_store_string, s55, "str_deserters"),
       (else_try),
         (str_store_string, s55, "str_travellers_on_the_road"),
	   (else_try),

       (try_end),

       (try_begin),
         (ge, ":faction_object", 0),
         (str_store_faction_name, s56, ":faction_object"),
       (try_end),
	   (assign, "$g_last_comment_copied_to_s42", ":best_comment_so_far"), #maybe deprecate
	   (assign, "$g_rejoinder_to_last_comment", ":rejoinder_to_best_comment_so_far"),

       (str_store_string, s42, ":best_comment_so_far"),
     (try_end),

     (assign, reg0, ":comment_found"),

     (assign, "$log_comment_relation_change", ":comment_relation_change"),
     ]),

#
  ("merchant_road_info_to_s42", #also does itemss to s32
    [
	(store_script_param, ":center", 1),

	(assign, ":last_bandit_party_found", -1),
	(assign, ":last_bandit_party_origin", -1),
	(assign, ":last_bandit_party_destination", -1),
	(assign, ":last_bandit_party_hours_ago", -1),

	(str_clear, s32),

	(str_clear, s42),
	(str_clear, s47), #safe roads

	(try_for_range, ":center_to_reset", centers_begin, centers_end),
		(party_set_slot, ":center_to_reset", slot_party_temp_slot_1, 0),
	(try_end),

	(assign, ":road_attacks", 0),
	(assign, ":trades", 0),

#first mention all attacks
    (try_for_range, ":log_entry_iterator", 0, "$num_log_entries"),
		(store_sub, ":log_entry_no", "$num_log_entries", ":log_entry_iterator"),
#how long ago?
        (this_or_next|troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_traveller_attacked),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_party_traded),

#       reference - (call_script, "script_add_log_entry", logent_traveller_attacked, ":winner_party" (actor),  ":origin" (center object), ":destination" (troop_object), ":winner_faction"),

        (troop_get_slot, ":origin",         "trp_log_array_center_object",         ":log_entry_no"),
        (troop_get_slot, ":destination",    "trp_log_array_troop_object",          ":log_entry_no"),

		(this_or_next|eq, ":origin", ":center"),
			(eq, ":destination", ":center"),


        (troop_get_slot, ":event_time",            "trp_log_array_entry_time",              ":log_entry_no"),
		(store_current_hours, ":cur_hour"),
		(store_sub, ":hours_ago", ":cur_hour", ":event_time"),
		(assign, reg3, ":hours_ago"),

		(lt, ":hours_ago", 672), #four weeks

		(try_begin),
			(eq, "$cheat_mode", 1),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_traveller_attacked),
			(display_message, "str_attack_on_travellers_found_reg3_hours_ago"),
		(else_try),
			(eq, "$cheat_mode", 1),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_party_traded),
			(display_message, "str_trade_event_found_reg3_hours_ago"),
		(try_end),

		(try_begin), #possibly make script -- get_colloquial_for_time
			(lt, ":hours_ago", 24),
			(str_store_string, s46, "str_a_short_while_ago"),
		(else_try),
			(lt, ":hours_ago", 48),
			(str_store_string, s46, "str_one_day_ago"),
		(else_try),
			(lt, ":hours_ago", 72),
			(str_store_string, s46, "@two days ago"),
		(else_try),
			(lt, ":hours_ago", 154),
			(str_store_string, s46, "str_earlier_this_week"),
		(else_try),
			(lt, ":hours_ago", 240),
			(str_store_string, s46, "str_about_a_week_ago"),
		(else_try),
			(lt, ":hours_ago", 480),
			(str_store_string, s46, "str_about_two_weeks_ago"),
		(else_try),
			(str_store_string, s46, "str_several_weeks_ago"),
		(try_end),



        (troop_get_slot, ":actor", "trp_log_array_actor", ":log_entry_no"),
        (troop_get_slot, ":faction_object", "trp_log_array_faction_object", ":log_entry_no"),

		(str_store_string, s39, "str_unknown_assailants"),
		(assign, ":assailants_known", -1),
		(try_begin),
			(party_is_active, ":actor"),
			(store_faction_of_party, ":actor_faction", ":actor"),
			(eq, ":faction_object", ":actor_faction"),
			(assign, ":assailants_known", ":actor"),
			(str_store_party_name, s39, ":assailants_known"),
			(assign, "$g_bandit_party_for_bounty", -1),
			(try_begin), #possibly make script -- get_colloquial_for_faction
				(eq, ":faction_object", "fac_kingdom_1"),
				(str_store_string, s39, "str_swadians"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_2"),
				(str_store_string, s39, "str_vaegirs"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_3"),
				(str_store_string, s39, "str_khergits"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_4"),
				(str_store_string, s39, "str_nords"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_5"),
				(str_store_string, s39, "str_rhodoks"),
			(else_try),
				(eq, ":faction_object", "fac_kingdom_6"),
				(str_store_string, s39, "str_sarranids"),
			(else_try),
				(eq, ":faction_object", "fac_player_supporters_faction"),
				(str_store_string, s39, "str_your_followers"),
			(else_try), #bandits
				(assign, ":last_bandit_party_found", ":assailants_known"),
				(assign, ":last_bandit_party_origin", ":origin"),
				(assign, ":last_bandit_party_destination", ":destination"),
				(assign, ":last_bandit_party_hours_ago", ":hours_ago"),
			(try_end),
		(try_end),

		(try_begin),
			(eq, ":origin", ":center"),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_traveller_attacked),
			(party_slot_eq, ":destination", slot_party_temp_slot_1, 0),

			(party_set_slot, ":destination", slot_party_temp_slot_1, 1),
			(str_store_party_name, s40, ":destination"),
			(str_store_string, s44, "str_we_have_heard_that_travellers_heading_to_s40_were_attacked_on_the_road_s46_by_s39"),
			(str_store_string, s43, "str_s42"),
			(str_store_string, s42, "str_s43_s44"),

			(val_add, ":road_attacks", 1),
			#travellers were attacked on the road to...
		(else_try),
			(eq, ":destination", ":center"),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_traveller_attacked),
			(party_slot_eq, ":origin", slot_party_temp_slot_1, 0),

			(party_set_slot, ":origin", slot_party_temp_slot_1, 1),
			(str_store_party_name, s40, ":origin"),
			(str_store_string, s44, "str_we_have_heard_that_travellers_coming_from_s40_were_attacked_on_the_road_s46_by_s39"),

			(str_store_string, s43, "str_s42"),
			(str_store_string, s42, "str_s43_s44"),

			(val_add, ":road_attacks", 1),

		#travellers from here traded at...
#		(else_try),
#			(eq, ":origin", ":center"),
#			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_party_traded),
#			(party_slot_eq, ":destination", slot_party_temp_slot_1, 0),

#			(party_set_slot, ":destination", slot_party_temp_slot_1, 1),
#			(str_store_party_name, s40, ":destination"),
#			(str_store_string, s44, "@Travellers headed to {s40} traded there {s46}"),
#			(str_store_string, s43, "@{s42"),
#			(str_store_string, s42, "str_s43_s44"),

			#caravan from traded at...
		(else_try),
			(eq, ":destination", ":center"),
			(troop_slot_eq, "trp_log_array_entry_type", ":log_entry_no", logent_party_traded),
			(party_slot_eq, ":origin", slot_party_temp_slot_1, 0),

			(party_set_slot, ":origin", slot_party_temp_slot_1, 1),
			(str_store_party_name, s40, ":origin"),
			(str_store_string, s44, "str_travellers_coming_from_s40_traded_here_s46"),
			(str_store_string, s43, "str_s42"),
			(str_store_string, s42, "str_s43_s44"),

			(val_add, ":trades", 1),

			#caravan from traded at...
		(try_end),

	(try_end),


	(try_begin),
		(le, ":trades", 2),
		(eq, ":road_attacks", 0),
		(store_current_hours, ":hours"),
		(lt, ":hours", 168),
		(str_store_string, s42, "str_it_is_still_early_in_the_caravan_season_so_we_have_seen_little_tradings42"),
	(else_try),
		(eq, ":trades", 0),
		(eq, ":road_attacks", 0),
		(str_store_string, s42, "str_there_has_been_very_little_trading_activity_here_recentlys42"),
	(else_try),
		(le, ":trades", 2),
		(eq, ":road_attacks", 0),
		(str_store_string, s42, "str_there_has_some_trading_activity_here_recently_but_not_enoughs42"),
	(else_try),
		(le, ":trades", 2),
		(le, ":road_attacks", 2),
		(str_store_string, s42, "str_there_has_some_trading_activity_here_recently_but_the_roads_are_dangerouss42"),
	(else_try),
		(ge, ":road_attacks", 3),
		(str_store_string, s42, "str_the_roads_around_here_are_very_dangerouss42"),
	(else_try),
		(ge, ":road_attacks", 1),
		(str_store_string, s42, "str_we_have_received_many_traders_in_town_here_although_there_is_some_danger_on_the_roadss42"),
	(else_try),
		(str_store_string, s42, "str_we_have_received_many_traders_in_town_heres42"),
	(try_end),

#do safe roads
	(assign, ":unused_trade_route_found", 0),
	(try_for_range, ":trade_route_slot", slot_town_trade_routes_begin, slot_town_trade_routes_end),
		(party_get_slot, ":trade_center", ":center", ":trade_route_slot"),
		(is_between, ":trade_center", centers_begin, centers_end),

		(party_slot_eq, ":trade_center", slot_party_temp_slot_1, 0),

#		(party_get_slot, ":town_lord", ":trade_center", slot_town_lord),

		(str_store_party_name, s41, ":trade_center"),
		(try_begin),
			(eq, ":unused_trade_route_found", 1),
			(str_store_string, s44, "str_s44_s41"),
		(else_try),
			(str_store_string, s44, "str_s41"),
		(try_end),
		(assign, ":unused_trade_route_found", 1),
	(try_end),
	(try_begin),
		(eq, ":unused_trade_route_found", 1),
		(str_store_string, s47, "str_there_is_little_news_about_the_caravan_routes_to_the_towns_of_s44_and_nearby_parts_but_no_news_is_good_news_and_those_are_therefore_considered_safe"),
	(try_end),

	(assign, ":safe_village_road_found", 0),
	(try_for_range, ":village", villages_begin, villages_end),
		(party_slot_eq, ":village", slot_village_market_town, ":center"),
		(party_slot_eq, ":village", slot_party_temp_slot_1, 0),

#		(party_get_slot, ":town_lord", ":village", slot_town_lord),
		(str_store_party_name, s41, ":village"),
		(try_begin),
			(eq, ":safe_village_road_found", 1),
			(str_store_string, s44, "str_s44_s41"),
		(else_try),
			(str_store_string, s44, "str_s41"),
		(try_end),
		(assign, ":safe_village_road_found", 1),
	(try_end),

	(try_begin),
		(eq, ":safe_village_road_found", 1),
		(eq, ":unused_trade_route_found", 1),
		(str_store_string, s47, "str_s47_also_the_roads_to_the_villages_of_s44_and_other_outlying_hamlets_are_considered_safe"),
	(else_try),
		(eq, ":safe_village_road_found", 1),
		(str_store_string, s47, "str_however_the_roads_to_the_villages_of_s44_and_other_outlying_hamlets_are_considered_safe"),
	(try_end),

	(str_store_string, s33, "str_we_have_shortages_of"),
	(assign, ":some_shortages_found", 0),
	(try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),
        (store_sub, ":cur_good_price_slot", ":cur_good", trade_goods_begin),
        (val_add, ":cur_good_price_slot", slot_town_trade_good_prices_begin),
        (party_get_slot, ":price", ":center", ":cur_good_price_slot"),
		(gt, ":price", 1100),

        (str_store_item_name, s34, ":cur_good"),
        (assign, reg1, ":price"),
        (str_store_string, s33, "str_s33_s34_reg1"),

		(assign, ":some_shortages_found", 1),
	(try_end),

	(try_begin),
		(eq, ":some_shortages_found", 0),
		(str_store_string, s32, "str_we_have_adequate_stores_of_all_commodities"),
	(else_try),
		(str_store_string, s32, "str_s33_and_some_other_commodities"),
	(try_end),

	(assign, reg0, ":last_bandit_party_found"),
	(assign, reg1, ":last_bandit_party_origin"),
	(assign, reg2, ":last_bandit_party_destination"),
	(assign, reg3, ":last_bandit_party_hours_ago"),


	]
	),

  ("get_manhunt_information_to_s15",
    [
     (store_script_param, ":quest", 1),

	(str_store_string, s15, "str_the_roads_are_full_of_brigands_friend_but_that_name_in_particular_does_not_sound_familiar_good_hunting_to_you_nonetheless"),
    (quest_get_slot, ":quarry", ":quest", slot_quest_target_party),
	(try_begin),
		(is_between, "$g_talk_troop", active_npcs_begin, active_npcs_end),
		(troop_get_slot, ":talk_party", "$g_talk_troop", slot_troop_leaded_party),
	(else_try),
		(gt, "$g_encountered_party", "p_spawn_points_end"),
		(assign, ":talk_party", "$g_encountered_party"),
	(else_try),
		(assign, ":talk_party", -1),
	(try_end),

    (try_for_range, ":log_entry", 0, "$num_log_entries"),
		(gt, ":talk_party", -1),
		(troop_get_slot, ":party", "trp_log_array_actor", ":log_entry"),
		(eq, ":party", ":talk_party"),
		(troop_get_slot, ":bandit_party", "trp_log_array_troop_object", ":log_entry"),
		(eq, ":bandit_party", ":quarry"),
		(store_current_hours, ":hours_ago"),
		(troop_get_slot, ":sighting_time", "trp_log_array_entry_time",  ":log_entry"),
		(val_sub, ":hours_ago", ":sighting_time"),
		(try_begin),
			(le, ":hours_ago", 1),
			(str_store_string, s16, "str_less_than_an_hour_ago"),
		(else_try),
			(le, ":hours_ago", 48),
			(assign, reg3, ":hours_ago"),
			(str_store_string, s16, "str_maybe_reg3_hours_ago"),
		(else_try),
			(val_div, ":hours_ago", 24),
			(assign, reg3, ":hours_ago"),
			(str_store_string, s16, "str_reg3_days_ago"),
		(try_end),

		(troop_get_slot, ":center", "trp_log_array_center_object", ":log_entry"),
		(str_store_party_name, s17, ":center"),
		(troop_get_slot, ":entry_type", "trp_log_array_entry_type", ":log_entry"),
		(eq, ":entry_type", logent_party_spots_wanted_bandits),
		(str_store_string, s15, "str_youre_in_luck_we_sighted_those_bastards_s16_near_s17_hurry_and_you_might_be_able_to_pick_up_their_trail_while_its_still_hot"),

#		(try_begin),
#			(eq, ":entry_type", logent_party_chases_wanted_bandits),
#			(str_store_string, s15, "@You're in luck. We gave chase to those bastards {s16} near {s17}. They have eluded us so far -- but perhaps you will do better..."),
#		(else_try),
#			(eq, ":entry_type", logent_party_runs_from_wanted_bandits),
#			(str_store_string, s15, "@As it happens, they tried to run us down near {s17} {s16}. By the heavens, I hope you teach them a lesson."),
#		(try_end),
	(try_end),
	]),


#Troop Commentaries end



  ("rebellion_arguments", #Right now, called only in one place. This is only used when for player overtures, and will need some changes if this script is called when NPCs try to suborn lords
    [
     (store_script_param, ":lord", 1),
     (store_script_param, ":argument", 2),
     (store_script_param, ":candidate", 3),

     (assign, ":argument_appeal", 0),
     (assign, ":argument_strength", 0),

     (troop_get_slot, ":reputation", ":lord", slot_lord_reputation_type),

	 (store_faction_of_troop, ":lord_faction", ":candidate"),
	 (store_faction_of_troop, ":candidate_faction", ":candidate"),

	 (try_begin),
		(eq, ":candidate", "trp_player"),
		(assign, ":right_to_rule", "$player_right_to_rule"),
	 (else_try), #default right to rule of 75 for pretenders claiming throne
		(is_between, ":candidate", pretenders_begin, pretenders_end),
		(troop_slot_eq, ":candidate", slot_troop_original_faction, ":lord_faction"),
		(assign, ":right_to_rule", 75),
	 (else_try), #default right to rule of 60 for all other lords
		(assign, ":right_to_rule", 60),
	 (try_end),

	 (try_begin),
		(eq, ":argument", argument_claim),
		(store_sub, ":argument_strength", ":right_to_rule", 30),
	 (else_try),
		(eq, ":argument", argument_ruler),
		(store_sub, ":argument_strength", "$player_honor", 20),
	 (else_try),
		(eq, ":argument", argument_lords),
		(store_sub, ":argument_strength", "$player_honor", 20),
	 (else_try),
	    #argument_strength is ((5 * number of centers player have) - 40) if argument type is argument_victory
		(eq, ":argument", argument_victory),
		(assign, ":argument_strength", 0),
		(try_for_range, ":center", centers_begin, centers_end),
			(store_faction_of_party, ":center_faction", ":center"),
			(assign, ":argument_strength", -40),
			(try_begin),
				(eq, "$players_kingdom", ":candidate_faction"),
				##diplomacy start+
				(this_or_next|eq, ":center_faction", "$players_kingdom"),
				##diplomacy end+
				(this_or_next|eq, ":center_faction", "fac_player_faction"),
				(eq, ":center_faction", "fac_player_supporters_faction"),
				(val_add, ":argument_strength", 5),
			(else_try),
				(eq, ":center_faction", ":candidate_faction"),
				(val_add, ":argument_strength", 5),
			(try_end),
		(try_end),
	 (else_try),
	    #argument_strength is (20 - 20 * (number of lords in player's faction which not awareded fief by player although there is a fief awarding in future promise))
		(eq, ":argument", argument_benefit),
		(assign, ":argument_strength", 20),
		(try_for_range, ":lord_promised_fief", active_npcs_begin, active_npcs_end),
			(store_faction_of_troop, ":other_faction", ":lord_promised_fief"),
			(neq, ":lord", "$g_talk_troop"),
			(this_or_next|eq, ":other_faction", "fac_player_supporters_faction"),
			(eq, ":other_faction", "$players_kingdom"),
			(troop_slot_eq, ":lord_promised_fief", slot_troop_promised_fief, 1),
			(val_sub, ":argument_strength", 20),
		(try_end),
	 (try_end),
	 (val_clamp, ":argument_strength", -40, 41),

     (try_begin),
         (eq, ":reputation", lrep_martial),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", 30),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_claims_to_the_throne_good_there_is_nothing_id_rather_do_than_fight_for_a_good_cause"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_claims_to_the_throne_well_there_is_nothing_id_rather_do_than_fight_for_a_good_cause_but_the_claim_you_make_seems_somewhat_weak"),
		     (try_end),
         (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", 10),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_i_am_pleased_that_you_speak_of_upholding_my_ancient_rights_which_are_sometimes_trod_upon_in_these_sorry_days"),
			 (else_try),
			    ##diplomacy start+ use culturally-approrpriate term
				(call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_KING, 14),
				##diplomacy end+
				(str_store_string, s15, "str_i_am_pleased_that_you_speak_of_upholding_my_ancient_rights_but_sometimes_men_make_pledges_before_they_are_king_which_they_cannot_keep_once_they_take_the_throne"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", 0),
			 (try_begin),
				##diplomacy start+: use culturally-approrpriate term
				(call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_USE_MY_WEAPON, s14),
				##diplomacy end+
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_well_i_supposed_thats_good_but_sometimes_the_commons_overstep_their_boundaries_im_more_concerned_that_your_claim_be_legal_so_i_can_swing_my_sword_with_a_good_conscience"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", -10),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_good_i_ask_for_no_more_than_my_due"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_unfortunately_you_are_not_wellknown_for_rewarding_those_to_whom_you_have_made_such_offers"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", -30),
			 (str_store_string, s15, "str_you_speak_of_unifying_calradia_well_i_believe_that_well_always_be_fighting__its_important_that_we_fight_for_a_rightful_cause"),
         (try_end),
     (else_try),
        (eq, ":reputation", lrep_quarrelsome),
        (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", -20),
 			 (str_store_string, s15, "str_you_talk_of_claims_to_the_throne_but_i_leave_bickering_about_legalities_to_the_lawyers_and_clerks"),
		(else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", -30),
			  ##diplomacy start+ use culturally-approrpriate term
			  (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_KING, 14),
			  ##diplomacy end+
			 (str_store_string, s15, "str_you_speak_of_ruling_justly_hah_ill_believe_theres_such_a_thing_as_a_just_king_when_i_see_one"),
		(else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", 0),
			 ##diplomacy start+ use culturally-approrpriate term
			  (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_KING, 14),
			  ##diplomacy end+
			 (str_store_string, s15, "str_you_spoke_of_protecting_the_rights_of_the_nobles_if_you_did_youd_be_the_first_king_to_do_so_in_a_very_long_time"),
		(else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", 30),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_ay_well_lets_see_if_you_deliver"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_bah_youre_not_known_for_delivering_on_your_pledges"),
			 (try_end),
	    (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 10),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_well_youve_done_a_good_job_at_making_calradia_bend_its_knee_to_you_so_maybe_thats_not_just_talk"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_id_be_impressed_if_i_thought_you_could_do_it_but_unfortunately_you_dont"),
			 (try_end),
		(try_end),
     (else_try),
         (eq, ":reputation", lrep_selfrighteous),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", -20),
			 (str_store_string, s15, "str_you_speak_of_claims_to_the_throne_well_any_peasant_can_claim_to_be_a_kings_bastard"),
		 (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", -30),
			 (str_store_string, s15, "str_well_its_a_fine_thing_to_court_the_commons_with_promises_but_what_do_you_have_to_offer_me"),
		 (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", 0),
			 ##diplomacy start+ use culturally-approrpriate term
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_LORD_PLURAL, 15),
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_LORD, 14),
			 ##diplomacy end+
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_that_would_make_a_fine_change_if_my_rights_as_lord_would_be_respected"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_that_would_make_a_fine_change_if_my_rights_as_lord_would_be_respected_however_it_is_easy_for_you_to_make_promises_while_you_are_weak_that_you_have_no_intention_of_keeping_when_you_are_strong"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", 20),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_well_my_family_is_of_ancient_and_noble_lineage_so_you_promise_me_no_more_than_my_due_still_your_gesture_is_appreciated"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_well_you_make_that_pledge_but_i_am_not_impressed"),
			 (try_end),
		 (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 20),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_well_much_of_this_land_now_bends_its_knee_to_you_so_perhaps_that_is_not_just_talk"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_but_right_now_yours_is_just_one_squabbling_faction_among_many"),
			 (try_end),
         (try_end),
     (else_try),
         (eq, ":reputation", lrep_cunning),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", -30),
			 (str_store_string, s15, "str_you_speak_of_claims_well_no_offense_but_a_claim_unsupported_by_might_rarely_prospers"),
         (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", 10),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_well_i_suppose_that_will_make_for_a_more_prosperous_realm_ive_always_tried_to_treat_my_peasants_decently_saves_going_to_bed_worrying_about_whether_youll_wake_up_with_the_roof_on_fire"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_very_well_but_remember_that_peasants_are_more_likely_to_cause_trouble_if_you_make_promises_then_dont_deliver_than_if_you_never_made_the_promise_in_the_first_place"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", 15),
 			 ##diplomacy start+ use culturally-approrpriate term
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_KING, 15),
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_LORD_PLURAL, 14),
			 ##diplomacy end+
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_good_youd_be_well_advised_to_do_that__men_fight_better_for_a_king_wholl_respect_their_rights"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_very_well_but_remember__failing_to_keep_promises_which_you_made_while_scrambling_up_the_throne_is_the_quickest_way_to_topple_off_of_it_once_you_get_there"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", -20),
			 (str_store_string, s15, "str_you_speak_of_giving_me_land_very_good_but_often_i_find_that_when_a_man_makes_too_many_promises_trying_to_get_to_the_top_he_has_trouble_keeping_them_once_he_reaches_it"),
         (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 20),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_well_many_have_said_that_you_might_very_well_be_the_one_to_do_it"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_well_all_the_kings_say_that_im_not_sure_that_you_will_succeed_while_they_fail"),
			 (try_end),
         (try_end),
     (else_try),
         (eq, ":reputation", lrep_debauched),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", -20),
			 (str_store_string, s15, "str_you_speak_of_claims_do_you_think_i_care_for_the_nattering_of_lawyers"),
         (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", -20),
             ##diplomacy start+ replace "swineherd" with culturally-appropriate term
             (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_SWINEHERD, 14),
             ##diplomacy end+
			 (str_store_string, s15, "str_you_speak_of_protecting_the_commons_how_kind_of_you_i_shall_tell_my_swineherd_all_about_your_sweet_promises_no_doubt_he_will_become_your_most_faithful_vassal"),
         (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", -10),
             ##diplomacy start+ replace "lords" with culturally-appropriate term
             (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_LORD_PLURAL, 14),
             ##diplomacy end+
			 (str_store_string, s15, "str_you_speak_of_protecing_the_rights_of_lords_such_sweet_words_but_ill_tell_you_this__the_only_rights_that_are_respected_in_this_world_are_the_rights_to_dominate_whoever_is_weaker_and_to_submit_to_whoever_is_stronger"),
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", 20),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_yes_very_good__but_you_had_best_deliver"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_giving_me_land_hah_perhaps_all_those_others_to_whom_you_promised_lands_will_simply_step_aside"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 10),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_you_may_indeed_humble_the_other_kings_of_this_land_and_in_that_case_i_would_hope_that_you_would_remember_me_as_your_faithful_servant"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_but_you_are_weak_and_i_think_that_you_will_remain_weak"),
			 (try_end),
         (try_end),
	 (else_try),
         (eq, ":reputation", lrep_goodnatured),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", 10),
			 ##diplomacy start+ replace "king" with culturally-appropriate term
             (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_KING, 14),
			 ##diplomacy end+
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_claims_its_good_for_a_king_to_have_a_strong_claim_although_admittedly_im_more_concerned_that_he_rules_just_ly_than_with_legalities_anyway_your_claim_seems_wellfounded_to_me"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_claims_but_your_claim_seems_a_bit_weak_to_me"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", 20),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_i_like_that_my_tenants_are_a_happy_lot_i_think_but_i_hear_of_others_in_other_estates_that_arent_so_fortunate"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_im_glad_to_hear_you_say_that_but_do_me_a_favor__dont_promise_the_commons_anything_you_cant_deliver_thats_a_sure_way_to_get_them_to_rebel_and_it_breaks_my_heart_to_have_to_put_them_down"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_lords),
			 (assign, ":argument_appeal", 0),
			 ##diplomacy start+ use culturally-approrpriate term
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_KING, 15),
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_LORD_PLURAL, 14),
			 ##diplomacy end+
			 (str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_well_very_good_i_suppose_but_you_know__we_lords_can_take_of_ourselves_its_the_common_folk_who_need_a_strong_king_to_look_out_for_them_to_my_mind"),
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", -15),
			 (str_store_string, s15, "str_you_speak_of_giving_me_land_its_kind_of_you_really_though_that_is_not_necessary"),
         (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", -25),
             ##diplomacy start+
             #Save culturally-appropriate variant of "sword" (as in "by the sword") to s14
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_WEAPON, 14),
			 ##diplomacy end+
			 (str_store_string, s15, "str_you_speak_of_unifying_calradia_well_maybe_you_can_unite_this_land_by_the_sword_but_im_not_sure_that_this_will_make_you_a_good_ruler"),
         (try_end),
     (else_try),
         (eq, ":reputation", lrep_upstanding),
         (try_begin),
             (eq, ":argument", argument_claim),
             (assign, ":argument_appeal", 10),
			 ##diplomacy start+ use culturally-approrpriate term
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_KING, 14),
			 ##diplomacy end+
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_claims_a_king_must_have_a_strong_legal_claim_for_there_not_to_be_chaos_in_the_realm_and_yours_is_wellestablished"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_claims_a_king_must_have_a_strong_legal_claim_for_there_not_to_be_chaos_in_the_realm_but_your_claim_is_not_so_strong"),
			 (try_end),
		 (else_try),
             (eq, ":argument", argument_lords),
             (assign, ":argument_appeal", -5),
			 ##diplomacy start+ use culturally-approrpriate term
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_KING, 14),
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_LORD_PLURAL, 15),
			 ##diplomacy end+
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_it_is_of_course_important_that_a_king_respect_the_rights_of_his_vassals_although_i_worry_that_a_king_who_took_a_throne_without_proper_cause_would_not_rule_with_justice"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_rights_of_lords_it_is_of_course_important_that_a_king_respect_the_rights_of_his_vassals_however_i_would_like_to_know_that_you_would_indeed_deliver_on_your_promises"),
			 (try_end),
		 (else_try),
             (eq, ":argument", argument_ruler),
             (assign, ":argument_appeal", 5),
			 ##diplomacy start+ use culturally-approrpriate term
			 (call_script, "script_dplmc_print_cultural_word_to_sreg", ":lord", DPLMC_CULTURAL_TERM_KING, 14),
			 ##diplomacy end+
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_i_would_be_pleased_to_serve_a_king_who_respected_the_rights_of_his_subjects_although_i_worry_that_a_king_who_took_a_throne_without_proper_cause_would_not_rule_with_justice"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_protecting_the_commons_i_would_be_pleased_to_serve_a_king_who_respected_the_rights_of_his_subjects_however_i_would_like_to_know_that_you_would_indeed_deliver_on_your_promises"),
			 (try_end),
         (else_try),
             (eq, ":argument", argument_benefit),
             (assign, ":argument_appeal", -40),
			 (str_store_string, s15, "str_i_am_not_swayed_by_promises_of_reward"),
		 (else_try),
             (eq, ":argument", argument_victory),
             (assign, ":argument_appeal", 10),
			 (try_begin),
				(gt, ":argument_strength", 0),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_it_would_be_good_to_bring_peace_to_the_realm_and_i_believe_that_you_are_strong_enough_to_do_so"),
			 (else_try),
				(str_store_string, s15, "str_you_speak_of_unifying_calradia_it_would_be_good_to_bring_peace_the_realm_but_with_your_kingdom_in_its_current_state_i_worry_that_you_are_just_bringing_more_discord"),
			 (try_end),
         (try_end),
     (try_end),

	 (str_store_string, s14, "str_s15"),

     (assign, reg0, ":argument_appeal"),
     (assign, reg1, ":argument_strength"),
]),



#Rebellion changes end

  # script_get_culture_with_party_faction_for_music
  # Input: arg1 = party_no
  # Output: reg0 = culture
  ("get_culture_with_party_faction_for_music",
    [
      (store_script_param, ":party_no", 1),
      (store_faction_of_party, ":faction_no", ":party_no"),
      (try_begin),
        (this_or_next|eq, ":faction_no", "fac_player_faction"),
        (eq, ":faction_no", "fac_player_supporters_faction"),
        (assign, ":faction_no", "$players_kingdom"),
      (try_end),
      (try_begin),
        (is_between, ":party_no", centers_begin, centers_end),
        (this_or_next|eq, ":faction_no", "fac_player_supporters_faction"),
        (neg|is_between, ":faction_no", kingdoms_begin, kingdoms_end),
        (party_get_slot, ":faction_no", ":party_no", slot_center_original_faction),
      (try_end),
      (call_script, "script_get_culture_with_faction_for_music", ":faction_no"),
     ]),

  # script_get_culture_with_faction_for_music
  # Input: arg1 = party_no
  # Output: reg0 = culture
  ("get_culture_with_faction_for_music",
    [
      (store_script_param, ":faction_no", 1),
      (try_begin),
        (eq, ":faction_no", "fac_kingdom_1"),
        (assign, ":result", mtf_culture_1),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_2"),
        (assign, ":result", mtf_culture_2),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_3"),
        (assign, ":result", mtf_culture_3),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_4"),
        (assign, ":result", mtf_culture_4),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_5"),
        (assign, ":result", mtf_culture_5),
      (else_try),
        (eq, ":faction_no", "fac_kingdom_6"),
        (assign, ":result", mtf_culture_6),
      (else_try),
        (this_or_next|eq, ":faction_no", "fac_outlaws"),
        (this_or_next|eq, ":faction_no", "fac_peasant_rebels"),
        (this_or_next|eq, ":faction_no", "fac_deserters"),
        (this_or_next|eq, ":faction_no", "fac_mountain_bandits"),
        (eq, ":faction_no", "fac_forest_bandits"),
        (assign, ":result", mtf_culture_6),
      (else_try),
        (assign, ":result", 0), #no culture, including player with no bindings to another kingdom
      (try_end),
      (assign, reg0, ":result"),
     ]),

  # script_music_set_situation_with_culture
  # Input: arg1 = music_situation
  # Output: none
  ("music_set_situation_with_culture",
    [
      (store_script_param, ":situation", 1),
      (assign, ":culture", 0), #no culture
      (try_begin),
        (this_or_next|eq, ":situation", mtf_sit_town),
        (this_or_next|eq, ":situation", mtf_sit_day),
        (this_or_next|eq, ":situation", mtf_sit_night),
        (this_or_next|eq, ":situation", mtf_sit_town_infiltrate),
        (eq, ":situation", mtf_sit_encounter_hostile),
        (call_script, "script_get_culture_with_party_faction_for_music", "$g_encountered_party"),
        (val_or, ":culture", reg0),
      (else_try),
        (this_or_next|eq, ":situation", mtf_sit_ambushed),
        (eq, ":situation", mtf_sit_fight),
        (call_script, "script_get_culture_with_party_faction_for_music", "$g_encountered_party"),
        (val_or, ":culture", reg0),
        (call_script, "script_get_culture_with_party_faction_for_music", "p_main_party"),
        (val_or, ":culture", reg0),
        (call_script, "script_get_closest_center", "p_main_party"),
        (call_script, "script_get_culture_with_party_faction_for_music", reg0),
        (val_or, ":culture", reg0),
      (else_try),
        (eq, ":situation", mtf_sit_multiplayer_fight),
        (call_script, "script_get_culture_with_faction_for_music", "$g_multiplayer_team_1_faction"),
        (val_or, ":culture", reg0),
        (call_script, "script_get_culture_with_faction_for_music", "$g_multiplayer_team_2_faction"),
        (val_or, ":culture", reg0),
      (else_try),
        (eq, ":situation", mtf_sit_travel),
        (call_script, "script_get_culture_with_party_faction_for_music", "p_main_party"),
        (val_or, ":culture", reg0),
        (call_script, "script_get_closest_center", "p_main_party"),
        (call_script, "script_get_culture_with_party_faction_for_music", reg0),
        (val_or, ":culture", reg0),
      (else_try),
        (eq, ":situation", mtf_sit_victorious),
        (call_script, "script_get_culture_with_party_faction_for_music", "p_main_party"),
        (val_or, ":culture", reg0),
      (else_try),
        (eq, ":situation", mtf_sit_killed),
        (call_script, "script_get_culture_with_party_faction_for_music", "$g_encountered_party"),
        (val_or, ":culture", reg0),
      (try_end),
      (try_begin),
        (this_or_next|eq, ":situation", mtf_sit_town),
        (eq, ":situation", mtf_sit_day),
        (try_begin),
          (is_currently_night),
          (assign, ":situation", mtf_sit_night),
        (try_end),
      (try_end),
      (music_set_situation, ":situation"),
      (music_set_culture, ":culture"),
     ]),


  # script_combat_music_set_situation_with_culture
  # Input: none
  # Output: none
  ("combat_music_set_situation_with_culture",
    [
      (assign, ":situation", mtf_sit_fight),
      (assign, ":num_allies", 0),
      (assign, ":num_enemies", 0),
      (try_for_agents, ":agent_no"),
        (agent_is_alive, ":agent_no"),
        (agent_is_human, ":agent_no"),
        (agent_get_troop_id, ":agent_troop_id", ":agent_no"),
        (store_character_level, ":troop_level", ":agent_troop_id"),
        (val_add,  ":troop_level", 10),
        (val_mul, ":troop_level", ":troop_level"),
        (try_begin),
          (agent_is_ally, ":agent_no"),
          (val_add, ":num_allies", ":troop_level"),
        (else_try),
          (val_add, ":num_enemies", ":troop_level"),
        (try_end),
      (try_end),
      (val_mul, ":num_allies", 4), #play ambushed music if we are 2 times outnumbered.
      (val_div, ":num_allies", 3),
      (try_begin),
        (lt, ":num_allies", ":num_enemies"),
        (assign, ":situation", mtf_sit_ambushed),
      (try_end),
      (call_script, "script_music_set_situation_with_culture", ":situation"),
     ]),

  # script_play_victorious_sound
  # Input: none
  # Output: none
  ("play_victorious_sound",
   [
     (call_script, "script_music_set_situation_with_culture", mtf_sit_victorious),
#      (play_cue_track, "track_victorious_neutral_1"),
#      (play_track, "track_victorious_neutral_1", 1),
     ]),

  # script_set_items_for_tournament
  # Input: arg1 = horse_chance, arg2 = lance_chance (with horse only), arg3 = sword_chance, arg4 = axe_chance, arg5 = bow_chance (without horse only), arg6 = javelin_chance (with horse only), arg7 = mounted_bow_chance (with horse only), arg8 = crossbow_sword_chance, arg9 = armor_item_begin, arg10 = helm_item_begin
  # Output: none (sets mt_arena_melee_fight items)
  ("set_items_for_tournament",
    [
      (store_script_param, ":horse_chance", 1),
      (store_script_param, ":lance_chance", 2),
      (store_script_param, ":sword_chance", 3),
      (store_script_param, ":axe_chance", 4),
      (store_script_param, ":bow_chance", 5),
      (store_script_param, ":javelin_chance", 6),
      (store_script_param, ":mounted_bow_chance", 7),
      (store_script_param, ":crossbow_sword_chance", 8),
      (store_script_param, ":armor_item_begin", 9),
      (store_script_param, ":helm_item_begin", 10),
      (store_add, ":total_chance", ":sword_chance", ":axe_chance"),
      (val_add, ":total_chance", ":crossbow_sword_chance"),


      #SB : move shield/team calculations up top, start off by one since we'll increment immediately
      (assign, ":cur_team", -1),
      (store_sub, ":cur_shield_item", "itm_arena_shield_red", 1),
      (try_begin),
        (ge, ":armor_item_begin", 0),
        (store_sub, ":cur_armor_item", ":armor_item_begin", 1),
      (else_try), #doesn't matter, we're checking parameter not this value
        (assign, ":cur_armor_item", -999),
      (try_end),
      (try_begin),
        (ge, ":helm_item_begin", 0),
        (store_sub, ":cur_helm_item", ":helm_item_begin", 1),
      (else_try),
        (assign, ":cur_helm_item", -999),
      (try_end),

      (try_for_range, ":i_ep", 0, 32),
        (mission_tpl_entry_clear_override_items, "mt_arena_melee_fight", ":i_ep"),
        (assign, ":has_horse", 0),
        # (store_div, ":cur_team", ":i_ep", 8),
        (try_begin), #SB : incrementing at same rate
          (store_mod, ":entry", ":i_ep", 8),
          (eq, ":entry", 0),
          (val_add, ":cur_team", 1),
          (val_add, ":cur_shield_item", 1),
          (val_add, ":cur_armor_item", 1),
          (val_add, ":cur_helm_item", 1),
        (try_end),
        (try_begin),
          (store_random_in_range, ":random_no", 0, 100),
          (lt, ":random_no", ":horse_chance"),
          (assign, ":has_horse", 1),
          (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_horse"),
        (try_end),
        (try_begin),
          (eq, ":has_horse", 1),
          (store_add, ":cur_total_chance", ":total_chance", ":lance_chance"),
          (val_add, ":cur_total_chance", ":javelin_chance"),
          (val_add, ":cur_total_chance", ":mounted_bow_chance"),
        (else_try),
          (store_add, ":cur_total_chance", ":total_chance", ":bow_chance"),
        (try_end),
        (store_random_in_range, ":random_no", 0, ":cur_total_chance"),
        # (store_add, ":cur_shield_item", "itm_arena_shield_red", ":cur_team"),

        #SB : deal with player entry here
        (try_begin),
          (eq, "$g_player_entry_point", ":i_ep"),
          (assign, ":continue", -1),
          (assign, ":proficiency", -1), #this checks if ranged proficiency are lower than
          #first check ranged weapon preference
          (store_proficiency_level, ":bow_prof", "trp_player", wpt_archery),
          (store_proficiency_level, ":xbow_prof", "trp_player", wpt_crossbow),
          (store_proficiency_level, ":throw_prof", "trp_player", wpt_throwing),

          #check parameters to disallow weapon types
          (try_begin),
            (le, ":bow_chance", 0),
            (le, ":mounted_bow_chance", 0),
            (assign, ":bow_prof", -1),
          (try_end),
          (try_begin),
            (this_or_next|le, ":crossbow_sword_chance", 0),
            (eq, ":has_horse", 1), #Native disallows mounted crossbow
            (assign, ":xbow_prof", -1),
          (try_end),
          (try_begin),
            (le, ":javelin_chance", 0),
            (assign, ":throw_prof", -1),
          (try_end),

          (try_begin), #do a gt check here to ensure it's not set to -1
            (gt, ":bow_prof", ":proficiency"),
            (ge, ":bow_prof", ":xbow_prof"),
            (ge, ":bow_prof", ":throw_prof"),
            (assign, ":continue", wpt_archery),
            (assign, ":proficiency", ":bow_prof"),
          (else_try),
            (gt, ":xbow_prof", ":proficiency"),
            (ge, ":xbow_prof", ":bow_prof"),
            (ge, ":xbow_prof", ":throw_prof"),
            (assign, ":continue", wpt_crossbow),
            (assign, ":proficiency", ":xbow_prof"),
          (else_try),
            (gt, ":throw_prof", ":proficiency"),
            (ge, ":throw_prof", ":bow_prof"),
            (ge, ":throw_prof", ":xbow_prof"),
            (assign, ":continue", wpt_throwing),
            (assign, ":proficiency", ":throw_prof"),
          (try_end),
          #then check melee preference
          (store_proficiency_level, ":onehands", "trp_player", wpt_one_handed_weapon),
          (store_proficiency_level, ":twohands", "trp_player", wpt_two_handed_weapon),
          (store_proficiency_level, ":polearms", "trp_player", wpt_polearm),
          (try_begin),
            (le, ":sword_chance", 0),
            (le, ":axe_chance", 0),
            (assign, ":onehands", -1),
          (try_end),
          (try_begin),
            (le, ":sword_chance", 0),
            (assign, ":twohands", -1),
          (try_end),
          (try_begin),
            (this_or_next|le, ":lance_chance", 0),
            (eq, ":has_horse", 0),
            (assign, ":polearms", -1),
          (try_end),

          (try_begin),
            (gt, ":onehands", ":proficiency"),
            (ge, ":onehands", ":twohands"),
            (ge, ":onehands", ":polearms"),
            (assign, ":continue", wpt_one_handed_weapon),
            (assign, ":proficiency", ":onehands"),
          (else_try),
            (gt, ":twohands", ":proficiency"),
            (ge, ":twohands", ":onehands"),
            (ge, ":twohands", ":polearms"),
            (assign, ":continue", wpt_two_handed_weapon),
            (assign, ":proficiency", ":twohands"),
          (else_try), #do not allow staves when dismounted
            (gt, ":polearms", ":proficiency"),
            (ge, ":polearms", ":onehands"),
            (ge, ":polearms", ":twohands"),
            (assign, ":continue", wpt_polearm),
            (assign, ":proficiency", ":polearms"),
          (try_end),

          #finally add items
          (try_begin),
            (eq, ":continue", wpt_polearm),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_lance"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", ":cur_shield_item"),
          (else_try),
            (eq, ":continue", wpt_two_handed_weapon),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_sword_two_handed"),
          (else_try),
            (eq, ":continue", wpt_one_handed_weapon),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", ":cur_shield_item"),
            (try_begin),
              (ge, ":sword_chance", ":axe_chance"),
              (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_sword"),
            (else_try),
              (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_axe"),
            (try_end),
          (else_try),
            (eq, ":continue", wpt_throwing),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_javelin"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", ":cur_shield_item"),
          (else_try),
            (eq, ":continue", wpt_crossbow),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_sword"), #do not replace with axe
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_crossbow"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_bolts"),
          (else_try),
            (eq, ":continue", wpt_archery),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_bow"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_arrows"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_tutorial_dagger"), #keep this
          (try_end),
          #otherwise fall through to default randomization
          (neq, ":continue", -1), #no wpt chosen
          # (assign, reg1, ":continue"),
          # (assign, reg2, ":proficiency"),
          # (display_message, "@final type {reg1} at prof {reg2}"),
        (else_try),
          (try_begin),
            (val_sub, ":random_no", ":sword_chance"),
            (lt, ":random_no", 0),
            (try_begin),
              (store_random_in_range, ":sub_random_no", 0, 100),
              (lt, ":sub_random_no", 50),
              (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_sword"),
              (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", ":cur_shield_item"),
#              (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_shield"),
            (else_try),
              (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_sword_two_handed"),
            (try_end),
          (else_try),
            (val_sub, ":random_no", ":axe_chance"),
            (lt, ":random_no", 0),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_axe"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", ":cur_shield_item"),
#           (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_shield"),
          (else_try),
            (val_sub, ":random_no", ":crossbow_sword_chance"),
            (lt, ":random_no", 0),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_sword"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_crossbow"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_bolts"),
          (else_try),
            (eq, ":has_horse", 0),
            (val_sub, ":random_no", ":bow_chance"),
            (lt, ":random_no", 0),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_bow"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_arrows"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_tutorial_dagger"),
          (else_try),
            (eq, ":has_horse", 1),
            (val_sub, ":random_no", ":lance_chance"),
            (lt, ":random_no", 0),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_lance"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", ":cur_shield_item"),
#            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_shield"),
          (else_try),
            (eq, ":has_horse", 1),
            (val_sub, ":random_no", ":javelin_chance"),
            (lt, ":random_no", 0),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_javelin"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", ":cur_shield_item"),
#            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_shield"),
          (else_try),
            (eq, ":has_horse", 1),
            (val_sub, ":random_no", ":mounted_bow_chance"),
            (lt, ":random_no", 0),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_bow"),
            (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_arrows"),
            #SB : change this to a weapon that's actually usable
            (try_begin),
              (ge, ":sword_chance", ":axe_chance"),
              (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_sword"),
            (else_try),
              (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_arena_axe"),
            (try_end),
            # (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_practice_dagger"),
          (try_end),
        (try_end),
        (try_begin),
          (ge, ":armor_item_begin", 0),
          # (store_add, ":cur_armor_item", ":armor_item_begin", ":cur_team"), #SB : moved to top
          (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", ":cur_armor_item"),
          (lt, ":cur_armor_item", "itm_arena_tunic_white"),
          (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", "itm_mail_mittens"),
        (try_end),
        (try_begin),
          (ge, ":helm_item_begin", 0),
          # (store_add, ":cur_helm_item", ":helm_item_begin", ":cur_team"), #SB : moved to top
          (mission_tpl_entry_add_override_item, "mt_arena_melee_fight", ":i_ep", ":cur_helm_item"),
        (try_end),
      (try_end),
     ]),


  # script_custom_battle_end
  # Input: none
  # Output: none
  ("custom_battle_end",
    [
      (assign, "$g_custom_battle_team1_death_count", 0),
      (assign, "$g_custom_battle_team2_death_count", 0),
      (get_player_agent_no, ":player_agent"),
      (agent_get_team, ":player_team", ":player_agent"),
      (try_for_agents, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (neg|agent_is_alive, ":cur_agent"),
        (agent_get_team, ":cur_team", ":cur_agent"),
        (try_begin),
          (eq, ":cur_team", ":player_team"),
          (val_add, "$g_custom_battle_team1_death_count", 1),
        (else_try),
          (val_add, "$g_custom_battle_team2_death_count", 1),
        (try_end),
      (try_end),
      ]),

  # script_remove_troop_from_prison
  # Input: troop_no
  # Output: none
  #Other search terms: release, peace

  ("remove_troop_from_prison",
    [
      (store_script_param, ":troop_no", 1),
      (troop_set_slot, ":troop_no", slot_troop_prisoner_of_party, -1),
      (troop_set_slot, ":troop_no", slot_troop_courtesan, -1),
      (try_begin),
        (eq, "$do_not_cancel_quest", 0),
        (check_quest_active, "qst_rescue_lord_by_replace"),
        (quest_slot_eq, "qst_rescue_lord_by_replace", slot_quest_target_troop, ":troop_no"),
        (call_script, "script_cancel_quest", "qst_rescue_lord_by_replace"),
      (try_end),
      (try_begin),
        (eq, "$do_not_cancel_quest", 0),
        (check_quest_active, "qst_rescue_prisoner"),
        (quest_slot_eq, "qst_rescue_prisoner", slot_quest_target_troop, ":troop_no"),
        (call_script, "script_cancel_quest", "qst_rescue_prisoner"),
        #SB : cancel companion missions
        (try_for_range, ":companions", companions_begin, companions_end),
          (troop_slot_eq, ":companions", slot_troop_current_mission, dplmc_npc_mission_rescue_prisoner),
          (troop_slot_eq, ":companions", slot_troop_mission_object, ":troop_no"),
          (troop_set_slot, ":companions", slot_troop_current_mission, npc_mission_rejoin_when_possible),
          (troop_set_slot, ":companions", slot_troop_days_on_mission, 1),
        (try_end),
        # also accrues debts
        (try_for_range, ":troop_no", heroes_begin, heroes_end),
          # (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
          (troop_get_slot, ":cur_debt", ":troop_no", slot_troop_player_debt),
          (gt, ":cur_debt", dplmc_ransom_debt_mask),
          (val_mod, ":cur_debt", dplmc_ransom_debt_mask),
          (troop_set_slot, ":troop_no", slot_troop_player_debt, ":cur_debt"),
        (try_end),
      (try_end),
      (try_begin),
        (check_quest_active, "qst_deliver_message_to_prisoner_lord"),
        (quest_slot_eq, "qst_deliver_message_to_prisoner_lord", slot_quest_target_troop, ":troop_no"),
        (call_script, "script_cancel_quest", "qst_deliver_message_to_prisoner_lord"),
      (try_end),
      ]),

  # script_debug_variables
  # Input: two variables which will be examined by coder, this script is only for debugging.
  # Output: none
  ("debug_variables",
    [
      (store_script_param, ":unused", 1),
      (store_script_param, ":unused_2", 2),
    ]),

#lord recruitment scripts begin
  ("troop_describes_troop_to_s15",
  [
	(store_script_param, ":troop_1", 1),
	(store_script_param, ":troop_2", 2),


	(str_store_troop_name, s15, ":troop_2"),

	(try_begin),
		(eq, ":troop_2", "trp_player"),
		(str_store_string, s15, "str_you"),
	(else_try),
		(eq, ":troop_2", ":troop_1"),
		(str_store_string, s15, "str_myself"),
	(else_try),
		(call_script, "script_troop_get_family_relation_to_troop", ":troop_2", ":troop_1"),
		(gt, reg0, 0),
		(str_store_string, s15, "str_my_s11_s15"),
	(else_try),
		(call_script, "script_troop_get_relation_with_troop", ":troop_2", ":troop_1"),
		(ge, reg0, 20),
		(str_store_string, s15, "str_my_friend_s15"),
	(try_end),

	]),

  ("troop_describes_quarrel_with_troop_to_s14",
  #perhaps replace this with get_relevant_comment at a later date
    [
	(store_script_param, ":troop", 1),
	(store_script_param, ":troop_2", 2),

	(str_store_troop_name, s15, ":troop"),
	(str_store_troop_name, s16, ":troop_2"),

	(str_store_string, s14, "str_stop_gap__s15_is_the_rival_of_s16"),

	(try_begin),
		(eq, ":troop", "$g_talk_troop"),
		(call_script, "script_cf_test_lord_incompatibility_to_s17", ":troop", ":troop_2"),
		(str_store_string, s14, s17),
	(else_try),
		(eq, ":troop_2", "$g_talk_troop"),
		(call_script, "script_cf_test_lord_incompatibility_to_s17", ":troop_2", ":troop"),
		(str_store_string, s14, s17),
	(else_try),
		(str_store_string, s14, "str_general_quarrel"),
	(try_end),

]),

  ("cf_test_lord_incompatibility_to_s17", #writes rivalry chance to reg0
    [

	(store_script_param, ":source_lord", 1),
	(store_script_param, ":target_lord", 2),


	(assign, ":chance_of_rivalry", 0),

	(troop_get_slot, ":source_reputation", ":source_lord", slot_lord_reputation_type),
	(troop_get_slot, ":target_reputation", ":target_lord", slot_lord_reputation_type),

	##diplomacy start+ Note: the next line is in native, but as far as I can discern the register value wasn't actually used.
	(troop_get_type, reg15, ":target_lord"),
	##diplomacy end+

	(str_store_troop_name, s18, ":target_lord"),

	(assign, ":divisor", 1),

	(call_script, "script_troop_get_family_relation_to_troop", ":target_lord", ":source_lord"),
	(assign, ":family_relationship", reg0),

	(try_begin),
		(gt, ":family_relationship", 0),
		(store_div, ":family_divisor", reg0, 5),
		(val_add, ":divisor", ":family_divisor"),
		(str_store_string, s18, "str_my_s11_s18"),
	(else_try),
		(gt, ":target_reputation", lrep_upstanding),
		(this_or_next|eq, ":source_reputation", lrep_debauched),
			(eq, ":source_reputation", lrep_selfrighteous),
		(str_store_string, s18, "str_the_socalled_s11_s18"),
	(try_end),

   ##diplomacy start+ get gender types
	(assign, ":save_reg65", reg65),#save register values to revert at end of script
	(assign, ":save_reg3", reg3),
	(call_script, "script_dplmc_store_troop_is_female_reg", ":target_lord", 3),#reg3 used below for gender-correct pronouns
	(call_script, "script_dplmc_store_troop_is_female", ":source_lord"),
   (assign, reg65, reg0),#used below in some situations for speaker
   (assign, reg0, ":family_relationship"),#revert register to value before this section
	##diplomacy end+
	(try_begin), #test if reps are compatible
        (eq, ":source_reputation", lrep_martial),
		(is_between, ":family_relationship", 1, 5), #uncles and cousins

		(assign, ":chance_of_rivalry", 100),
        (str_store_string, s17, "str_s18_would_cheat_me_of_my_inheritance_by_heaven_i_know_my_rights_and_im_not_going_to_back_down"),
	(else_try),
        (eq, ":source_reputation", lrep_martial),
        (eq, ":target_reputation", lrep_quarrelsome),
        (str_store_string, s17, "str_s18_once_questioned_my_honour_and_my_bravery_i_long_for_the_day_when_i_can_meet_him_in_battle_and_make_him_retract_his_statement"),
		(assign, ":chance_of_rivalry", 50),

	(else_try),
        (eq, ":source_reputation", lrep_martial),
        (eq, ":target_reputation", lrep_upstanding),
        (str_store_string, s17, "str_s18_once_questioned_my_judgment_in_battle_by_heaven_would_he_have_us_shirk_our_duty_to_smite_our_sovereigns_foes"),
		(assign, ":chance_of_rivalry", 50),

	(else_try),
        (eq, ":target_reputation", lrep_martial),
		(is_between, ":family_relationship", 1, 5),

		(assign, ":chance_of_rivalry", 100),
        (str_store_string, s17, "str_s18_seems_to_think_he_has_the_right_to_some_of_my_property_well_he_does_not"),

	(else_try),
        (eq, ":source_reputation", lrep_quarrelsome),
        (eq, ":target_reputation", lrep_martial),
        (str_store_string, s17, "str_s18_once_took_something_i_said_amiss_stubborn_bastard_wont_give_it_up_and_keeps_trying_to_get_me_to_recant_my_words"),
		(assign, ":chance_of_rivalry", 50),

	(else_try),
        (eq, ":source_reputation", lrep_quarrelsome),
        (eq, ":target_reputation", lrep_cunning),
        (str_store_string, s17, "str_s18_is_a_crafty_weasel_and_i_dont_trust_him_one_bit"),
		(assign, ":chance_of_rivalry", 100),


    (else_try),
        (eq, ":source_reputation", lrep_debauched),
        (eq, ":target_reputation", lrep_upstanding),
		(str_store_string, s17, "str_s18_i_despite_him_he_puts_on_such_a_nauseating_display_of_virtue_and_thinks_nothing_of_insulting_his_betters"),
		(assign, ":chance_of_rivalry", 100),

        #debauched insults upstanding

    (else_try),
        (eq, ":source_reputation", lrep_debauched),
        (eq, ":target_reputation", lrep_selfrighteous),
		(str_store_string, s17, "str_s18_entered_into_a_little_deal_with_me_and_is_now_trying_to_wriggle_out_of_it"),
		(assign, ":chance_of_rivalry", 100),

        #debauched insults selfrighteous



    (else_try),
        (eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_debauched),
		(str_store_string, s17, "str_s18_once_ran_an_errand_for_me_and_now_thinks_i_owe_him_something_i_owe_his_ilk_nothing"),
		(assign, ":chance_of_rivalry", 100),
        #selfrighteous dismisses debauched

    (else_try),
        (eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_goodnatured),
		(str_store_string, s17, "str_s18_is_soft_and_weak_and_not_fit_to_govern_a_fief_and_i_have_always_detested_him"),
		(assign, ":chance_of_rivalry", 100),



	(else_try),
        (eq, ":source_reputation", lrep_cunning),
        (eq, ":target_reputation", lrep_quarrelsome),
        (str_store_string, s17, "str_s18_is_a_quarrelsome_oaf_and_a_liability_in_my_opinion_and_ive_let_him_know_as_much"),
		(assign, ":chance_of_rivalry", 100),
        #cunning insults quarrelsome

	(else_try),
        (eq, ":source_reputation", lrep_cunning),
        (eq, ":target_reputation", lrep_goodnatured),
        (str_store_string, s17, "str_s18_i_am_sorry_to_say_is_far_too_softhearted_a_man_to_be_given_any_kind_of_responsibility_his_chivalry_will_allow_the_enemy_to_flee_to_fight_another_day_and_will_cost_the_lives_of_my_own_faithful_men"),
		(assign, ":chance_of_rivalry", 100),


	(else_try),
        (eq, ":source_reputation", lrep_goodnatured),
        (eq, ":target_reputation", lrep_cunning),
        (str_store_string, s17, "str_s18_seems_to_have_something_against_me_for_some_reason_i_dont_like_to_talk_ill_of_people_but_i_think_hes_can_be_a_bit_of_a_cad_sometimes"),
		(assign, ":chance_of_rivalry", 100),

	(else_try),
        (eq, ":source_reputation", lrep_goodnatured),
        (eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_s18_has_always_treated_me_contemptuously_although_i_have_done_him_no_wrong"),
		(assign, ":chance_of_rivalry", 100),



	(else_try),
        (eq, ":source_reputation", lrep_upstanding),
        (eq, ":target_reputation", lrep_debauched),
        (str_store_string, s17, "str_s18_is_thoroughly_dishonorable_and_a_compulsive_spinner_of_intrigues_which_i_fear_will_drag_us_into_wars_or_incite_rebellions"),
		(assign, ":chance_of_rivalry", 50),

	(else_try),
        (eq, ":source_reputation", lrep_upstanding),
        (eq, ":target_reputation", lrep_martial),
        (str_store_string, s17, "str_s18_disappoints_me_i_once_scolded_for_his_rashness_in_battle_and_he_took_offense_i_do_not_care_to_apologize_for_my_efforts_to_save_his_life_and_the_lives_of_his_men"),
		(assign, ":chance_of_rivalry", 50),

	#for commons
	(else_try),
        (this_or_next|eq, ":source_reputation", lrep_upstanding),
		(this_or_next|eq, ":source_reputation", lrep_martial),
			(eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_roguish),
        (str_store_string, s17, "str_s18_squanders_money_and_carouses_in_a_way_most_unbefitting_a_noble_by_doing_so_he_disgraces_us_all"),
		(assign, ":chance_of_rivalry", 100),


	(else_try),
        (eq, ":source_reputation", lrep_roguish),
        (this_or_next|eq, ":target_reputation", lrep_upstanding),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_s18_has_been_speaking_ill_of_me_behind_my_back_or_so_they_say"),
		(assign, ":chance_of_rivalry", 100),


	(else_try),
        (this_or_next|eq, ":source_reputation", lrep_quarrelsome),
		(this_or_next|eq, ":source_reputation", lrep_martial),
			(eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_custodian),
        (str_store_string, s17, "str_s18_is_a_disgrace_reg3shehe_consorts_with_merchants_lends_money_at_interest_uses_coarse_language_and_shows_no_attempt_to_uphold_the_dignity_of_the_honor_bestowed_upon_reg3herhim"),
		(assign, ":chance_of_rivalry", 100),

	(else_try),
        (eq, ":source_reputation", lrep_custodian),
		(this_or_next|eq, ":target_reputation", lrep_quarrelsome),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_s18_has_condemned_me_for_engaging_in_commerce_what_could_possibly_be_wrong_with_that"),
		(assign, ":chance_of_rivalry", 100),


	(else_try),
        (this_or_next|eq, ":source_reputation", lrep_debauched),
		(this_or_next|eq, ":source_reputation", lrep_martial),
			(eq, ":source_reputation", lrep_selfrighteous),
        (eq, ":target_reputation", lrep_benefactor),
        (str_store_string, s17, "str_s18_i_have_heard_has_been_encouraging_seditious_ideas_among_the_peasantry__a_foolish_move_which_endangers_us_all"),
		(assign, ":chance_of_rivalry", 100),


	(else_try),
        (eq, ":source_reputation", lrep_benefactor),
		(this_or_next|eq, ":target_reputation", lrep_debauched),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_s18_has_called_me_out_for_the_way_i_deal_with_my_tenants_well_so_be_it_if_i_teach_them_that_they_are_the_equal_of_anyone_with_socalled_gentle_blood_what_is_it_to_reg3herhim"),
		(assign, ":chance_of_rivalry", 100),


	#lady incompatibilities
	(else_try),
		(eq, ":source_reputation", lrep_conventional),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_selfrighteous),
        (str_store_string, s17, "str_a_most_gallant_gentleman_who_knows_how_to_treat_a_lady"),
		(assign, ":chance_of_rivalry", -50),

	(else_try),
		(eq, ":source_reputation", lrep_conventional),
		(eq, ":target_reputation", lrep_quarrelsome),
        (str_store_string, s17, "str_a_base_cad"),
		(assign, ":chance_of_rivalry", 50),


	(else_try),
		(eq, ":source_reputation", lrep_adventurous),
		(eq, ":target_reputation", lrep_cunning),
        (str_store_string, s17, "str_a_man_who_treats_me_as_his_equal_which_is_rare"),
		(assign, ":chance_of_rivalry", -50),

	(else_try),
		(eq, ":source_reputation", lrep_adventurous),
		(this_or_next|eq, ":target_reputation", lrep_martial),
			(eq, ":target_reputation", lrep_debauched),
		(str_store_string, s17, "str_appears_to_value_me_with_his_estate_and_his_horse_as_prizes_worth_having"),
		(assign, ":chance_of_rivalry", 50),

	(else_try),
		(eq, ":source_reputation", lrep_adventurous),
		(neq, ":target_reputation", lrep_goodnatured),

        (str_store_string, s17, "str_a_bit_dull_but_what_can_you_expect"),
		(assign, ":chance_of_rivalry", 10),

	(else_try),
		(eq, ":source_reputation", lrep_otherworldly),
		(call_script, "script_troop_get_romantic_chemistry_with_troop", ":source_lord", ":target_lord"),
		(ge, reg0, 10),
        (str_store_string, s17, "str_the_man_whom_destiny_intends_for_me"),
		(assign, ":chance_of_rivalry", -50),

	(else_try),
		(eq, ":source_reputation", lrep_otherworldly),
		(lt, reg0, 0),

        (str_store_string, s17, "str_is_not_right_for_me__i_cannot_say_why_but_he_makes_my_skin_crawl"),
		(assign, ":chance_of_rivalry", 50),


	(else_try),
		(eq, ":source_reputation", lrep_ambitious),
		(this_or_next|eq, ":target_reputation", lrep_selfrighteous),
			(eq, ":target_reputation", lrep_cunning),
        (str_store_string, s17, "str_is_a_man_who_clearly_intends_to_make_his_mark_in_the_world"),
		(assign, ":chance_of_rivalry", -20),

	(else_try),
		(eq, ":source_reputation", lrep_ambitious),
		(eq, ":target_reputation", lrep_goodnatured),

        (str_store_string, s17, "str_is_a_layabout_a_naif_prey_for_others_who_are_cleverer_than_he"),
		(assign, ":chance_of_rivalry", 30),


	(else_try),
		(eq, ":source_reputation", lrep_moralist),
		(eq, ":target_reputation", lrep_upstanding),

        (str_store_string, s17, "str_is_a_man_of_stalwart_character"),
		(assign, ":chance_of_rivalry", -50),

	(else_try),
		(eq, ":source_reputation", lrep_moralist),
		(this_or_next|eq, ":target_reputation", lrep_debauched),
			(eq, ":target_reputation", lrep_cunning),

        (str_store_string, s17, "str_appears_to_be_a_man_of_low_morals"),
		(assign, ":chance_of_rivalry", 50),

	(else_try),
		(eq, ":source_reputation", lrep_moralist),
		(eq, ":target_reputation", lrep_quarrelsome),

        (str_store_string, s17, "str_appears_to_be_a_man_who_lacks_selfdiscipline"),
		(assign, ":chance_of_rivalry", 50),
##diplomacy start+ Support for promoted ladies:
   (else_try),
       #Ambitious vs otherworldly
       (eq, ":source_reputation", lrep_ambitious),
       (troop_slot_eq, ":source_lord", slot_troop_occupation, slto_kingdom_hero),
       (eq, ":target_reputation", lrep_otherworldly),
       (troop_slot_eq, ":target_lord", slot_troop_occupation, slto_kingdom_hero),
       (str_store_string, s17, "str_s18_is_soft_and_weak_and_not_fit_to_govern_a_fief_and_i_have_always_detested_him"),
       (str_store_string, s17, "str_s18_has_always_treated_me_contemptuously_although_i_have_done_him_no_wrong"),
		(assign, ":chance_of_rivalry", 100),
   (else_try),
       #Otherworldly vs ambitious
       (eq, ":source_reputation", lrep_otherworldly),
       (troop_slot_eq, ":source_lord", slot_troop_occupation, slto_kingdom_hero),
       (eq, ":target_reputation", lrep_ambitious),
       (troop_slot_eq, ":target_lord", slot_troop_occupation, slto_kingdom_hero),
       (str_store_string, s17, "str_s18_has_always_treated_me_contemptuously_although_i_have_done_him_no_wrong"),
		(assign, ":chance_of_rivalry", 100),
   (else_try),
       #Quarrelsome quarrels with conventional and moralist
       (eq, ":source_reputation", lrep_quarrelsome),
       (troop_slot_eq, ":target_lord", slot_troop_occupation, slto_kingdom_hero),
       (this_or_next|eq, ":target_reputation", lrep_moralist),
          (eq, ":target_reputation", lrep_conventional),
       (str_store_string, s17, "str_s18_once_took_something_i_said_amiss_stubborn_bastard_wont_give_it_up_and_keeps_trying_to_get_me_to_recant_my_words"),
		(assign, ":chance_of_rivalry", 50),
   (else_try),
        #Cunning conflicts with moralist
        (eq, ":source_reputation", lrep_cunning),
        (eq, ":target_reputation", lrep_moralist),
        (troop_slot_eq, ":target_lord", slot_troop_occupation, slto_kingdom_hero),
        (str_store_string, s17, "str_s18_i_am_sorry_to_say_is_far_too_softhearted_a_man_to_be_given_any_kind_of_responsibility_his_chivalry_will_allow_the_enemy_to_flee_to_fight_another_day_and_will_cost_the_lives_of_my_own_faithful_men"),
		(assign, ":chance_of_rivalry", 50),
    (else_try),
        #Debauched conflicts with moralist
        (eq, ":source_reputation", lrep_debauched),
        (troop_slot_eq, ":target_lord", slot_troop_occupation, slto_kingdom_hero),
        (eq, ":target_reputation", lrep_moralist),
		(str_store_string, s17, "str_s18_i_despite_him_he_puts_on_such_a_nauseating_display_of_virtue_and_thinks_nothing_of_insulting_his_betters"),
		(assign, ":chance_of_rivalry", 50),
    (else_try),
        #Martial or debauched conflicts with adventurous
	   (this_or_next|eq, ":source_reputation", lrep_martial),
	   (eq, ":source_reputation", lrep_debauched),
      (troop_slot_eq, ":target_lord", slot_troop_occupation, slto_kingdom_hero),
      (eq, ":target_reputation", lrep_adventurous),
      (str_store_string, s17, "str_s18_once_took_something_i_said_amiss_stubborn_bastard_wont_give_it_up_and_keeps_trying_to_get_me_to_recant_my_words"),
		(assign, ":chance_of_rivalry", 50),
	(else_try),
        (eq, ":source_reputation", lrep_goodnatured),
        (troop_slot_eq, ":target_lord", slot_troop_occupation, slto_kingdom_hero),
        (eq, ":target_reputation", lrep_ambitious),
        (str_store_string, s17, "str_s18_seems_to_have_something_against_me_for_some_reason_i_dont_like_to_talk_ill_of_people_but_i_think_hes_can_be_a_bit_of_a_cad_sometimes"),
		  (assign, ":chance_of_rivalry", 30),
##Add support for secondary morality types
	(else_try),
		(call_script, "script_dplmc_get_troop_morality_value", ":target_lord", tmt_honest),
		(ge, reg0, 1),#This would apply (if no previous condition was reached) to Marnid, Rolf, Firentis, Alayan, and Jeremus.
		(eq, ":source_reputation", lrep_moralist),
		(str_store_string, s17, "str_is_a_man_of_stalwart_character"),#<- (does not apply to Rolf, since he is Cunning)
		(assign, ":chance_of_rivalry", -50),
	(else_try),
		(call_script, "script_dplmc_get_troop_morality_value", ":target_lord", tmt_pious),
		(ge, reg0, 1),#This doesn't apply to anyone at the moment.
		(eq, ":source_reputation", lrep_moralist),
		(str_store_string, s17, "str_is_a_man_of_stalwart_character"),
		(assign, ":chance_of_rivalry", -50),
	(try_end),

##diplomacy end+

	(val_div, ":chance_of_rivalry", ":divisor"),
##diplomacy start+ for companions, use compatability information
    (try_begin),
	   (is_between, ":source_lord", companions_begin, companions_end),
	   (troop_slot_eq, ":source_lord", slot_troop_personalitymatch_object, ":target_lord"),
	   (val_min, ":chance_of_rivalry", -100),
	(else_try),
	   (is_between, ":source_lord", companions_begin, companions_end),
	   (this_or_next|troop_slot_eq, ":source_lord", slot_troop_personalityclash_object, ":target_lord"),
	   (troop_slot_eq, ":source_lord", slot_troop_personalityclash2_object, ":target_lord"),
	   (try_begin),
	      (le, ":chance_of_rivalry", 0),
		  (str_store_string, s17, "str_general_quarrel"),
	   (try_end),
	   (val_max, ":chance_of_rivalry", 100),
	(try_end),
	(assign, reg3, ":save_reg3"),#revert reg3
	(assign, reg65, ":save_reg65"),#revert reg65
##diplomacy end+
	(assign, reg0, ":chance_of_rivalry"),

	(neq, ":chance_of_rivalry", 0),
#	(eq, ":incompatibility_found", 1), #cf can be removed with this

	]),

  ("troop_get_romantic_chemistry_with_troop", #source is lady, target is man
    [
      ##diplomacy start+ (players of either gender may marry opposite-gender lords)
      #Note: the above is misleading even in Native, since when target_lord is the player,
      #target_lord can be female and source_lady can be male.
	  (assign, ":save_reg1", reg1),
      ##diplomacy end+
      (store_script_param, ":source_lady", 1),
      (store_script_param, ":target_lord", 2),

      (store_add, ":chemistry_sum", ":source_lady", ":target_lord"),
      (val_add, ":chemistry_sum", "$romantic_attraction_seed"),

      #This calculates (modula ^ 2) * 3
      (store_mod, ":chemistry_remainder", ":chemistry_sum", 5),
      (val_mul, ":chemistry_remainder", ":chemistry_remainder"), #0, 1, 4, 9, 16
      (val_mul, ":chemistry_remainder", 3), #0, 3, 12, 27, 48

      (store_attribute_level, ":romantic_chemistry", ":target_lord", ca_charisma),
      (val_sub, ":romantic_chemistry", ":chemistry_remainder"),

      (val_mul, ":romantic_chemistry", 2),
      ##diplomacy start+ ensure companion compatability
      (try_begin),
         (is_between, ":source_lady", companions_begin, companions_end),
         (troop_slot_eq, ":source_lady", slot_troop_personalitymatch_object, ":target_lord"),
         (val_max, ":romantic_chemistry", 15),
      (else_try),
         (is_between, ":target_lord", companions_begin, companions_end),
         (troop_slot_eq, ":target_lord", slot_troop_personalitymatch_object, ":source_lady"),
         (val_max, ":romantic_chemistry", 15),
	  #...and companion incompatibility.
	  (else_try),
  	     (is_between, ":source_lady", companions_begin, companions_end),
		 (this_or_next|troop_slot_eq, ":source_lady", slot_troop_personalityclash_object, ":target_lord"),
			(troop_slot_eq, ":source_lady", slot_troop_personalityclash2_object, ":target_lord"),
		 (val_min, ":romantic_chemistry", -15),
  	  (else_try),
  	     (is_between, ":target_lord", companions_begin, companions_end),
		 (this_or_next|troop_slot_eq, ":target_lord", slot_troop_personalityclash_object, ":source_lady"),
			(troop_slot_eq, ":target_lord", slot_troop_personalityclash2_object, ":source_lady"),
		(val_min, ":romantic_chemistry", -15),
	  #Prevent glitches.  This can be enabled explicitly if intentional.
      (else_try),
	     (call_script, "script_dplmc_store_is_female_troop_1_troop_2", ":source_lady", ":target_lord"),
         (eq, reg0, reg1),#different genders
         #(val_min, ":romantic_chemistry", -15), #dckplmc
      (try_end),
	  (assign, reg1, ":save_reg1"),
      ##diplomacy end+
      (assign, reg0, ":romantic_chemistry"),

      #examples :
      #For a charisma of 18, yields (18 - 0) * 2 = 36, (18 - 3) * 2 = 30, (18 - 12) * 2 = 12, (18 - 27) * 2 = -18, (18 - 48) * 2 = -60
      #For a charisma of 10, yields (10 - 0) * 2 = 20, (10 - 3) * 2 = 14, (10 - 12) * 2 = -4, (10 - 27) * 2 = -34, (10 - 48) * 2 = -76
      #For a charisma of 7, yields  (7 - 0) * 2 = 14,  (7 - 3) * 2 = 8,   (7 - 12) * 2 = -10, (7 - 27) * 2 = -40,  (7 - 48) * 2 = -82

      #15 is high attraction, 0 is moderate attraction, -76 is lowest attraction
	]),


  ("cf_troop_get_romantic_attraction_to_troop", #source is lady, target is man
    [

	(store_script_param, ":source_lady", 1),
	(store_script_param, ":target_lord", 2),

	(assign, ":weighted_romantic_assessment", 0),
    ##diplomacy start+
	(assign, ":save_reg1", reg1),
	#Use gender script
	#(troop_get_type, ":source_is_female", ":source_lady"),
	#(eq, ":source_is_female", 1),
	#(troop_get_type, ":target_is_female", ":target_lord"),
	#(eq, ":target_is_female", 0),
	(call_script, "script_dplmc_store_is_female_troop_1_troop_2", ":source_lady", ":target_lord"),
	(assign, ":source_is_female", reg0),
	(assign, ":target_is_female", reg1),
	(assign, reg1, ":save_reg1"),
    #(assign, reg0, -15), #dckplmc
	(neq, ":source_is_female", ":target_is_female"),
	##diplomacy end+

	(call_script, "script_troop_get_romantic_chemistry_with_troop", ":source_lady", ":target_lord"),
	(assign, ":romantic_chemistry", reg0),


	#objective attraction - average renown
	(troop_get_slot, ":modified_renown", ":target_lord", slot_troop_renown),
	(assign, ":lady_status", 60),
   ##diplomacy start+ adjust status based on who they are
	(try_begin),
      #The renown bonus is decreased the more important the lady's relatives are.
      (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_HIGH),
      (troop_get_slot, ":best_renown", ":source_lady", slot_troop_renown),
      (try_begin),
        (troop_get_slot, ":relative", ":source_lady", slot_troop_father),
        (ge, ":relative", 0),
        (troop_get_slot, ":other_renown", ":relative", slot_troop_renown),
        (val_max, ":best_renown", ":other_renown"),
   	(try_end),
   	(try_begin),
		  (troop_get_slot, ":relative", ":source_lady", slot_troop_guardian),
        (ge, ":relative", 0),
        (troop_get_slot, ":other_renown", ":relative", slot_troop_renown),
        (val_max, ":best_renown", ":other_renown"),
   	(try_end),
   	(try_begin),
		  (troop_get_slot, ":relative", ":source_lady", slot_troop_mother),
        (ge, ":relative", 0),
        (troop_get_slot, ":other_renown", ":relative", slot_troop_renown),
        (val_max, ":best_renown", ":other_renown"),
   	(try_end),
   	(try_begin),
		  (ge, ":best_renown", 600),
        (store_div, ":lady_status", ":best_renown", 10),
   	(else_try),
		  (lt, ":best_renown", 400),
        (store_div, ":lady_status", ":best_renown", 10),
		  (val_add, ":lady_status", 20),
   	(try_end),
   	(val_clamp, ":lady_status", 30, 90),
   (try_end),
   ##diplomacy end+
	(val_div, ":modified_renown", 5),
	(val_sub, ":modified_renown", ":lady_status"),
	(val_min, ":modified_renown", 60),



	#weight values
	(try_begin),
		(assign, ":personality_match", 0),
		(call_script, "script_cf_test_lord_incompatibility_to_s17", ":source_lady", ":target_lord"),
		(store_sub, ":personality_match", 0, reg0),
	(try_end),

	(troop_get_slot, ":lady_reputation", ":source_lady", slot_lord_reputation_type),
	(try_begin),
		(eq, ":lady_reputation", lrep_ambitious),
		(val_mul, ":modified_renown", 2),
		(val_div, ":romantic_chemistry", 2),
	(else_try),
		(eq, ":lady_reputation", lrep_otherworldly),
		(val_div, ":modified_renown", 2),
		(val_mul, ":romantic_chemistry", 2),
	(else_try),
		(eq, ":lady_reputation", lrep_adventurous),
		(val_div, ":modified_renown", 2),
	(else_try),
		(eq, ":lady_reputation", lrep_moralist),
		(val_div, ":modified_renown", 2),
		(val_div, ":romantic_chemistry", 2),
	(try_end),

	(val_add, ":weighted_romantic_assessment", ":romantic_chemistry"),
	(val_add, ":weighted_romantic_assessment", ":personality_match"),
	(val_add, ":weighted_romantic_assessment", ":modified_renown"),

	(assign, reg0, ":weighted_romantic_assessment"),

	]),


  ("cf_random_political_event", #right now, just enmities
    [

	##diplomacy start+ Lay more groundwork for heroes other than active-npcs being lords
	##OLD:
	#(store_random_in_range, ":lord_1", active_npcs_begin, active_npcs_end),
	#(store_random_in_range, ":lord_2", active_npcs_begin, active_npcs_end),
	##NEW:
	(store_random_in_range, ":lord_1", heroes_begin, heroes_end),
	(try_begin),
	   (neg|is_between, ":lord_1", active_npcs_begin, active_npcs_end),
	   (neg|troop_slot_eq, ":lord_1", slot_troop_occupation, slto_kingdom_hero),
	   (store_random_in_range, ":lord_1", active_npcs_begin, active_npcs_end),
	(try_end),
	(store_random_in_range, ":lord_2", heroes_begin, heroes_end),
	(try_begin),
	   (neg|is_between, ":lord_2", active_npcs_begin, active_npcs_end),
	   (neg|troop_slot_eq, ":lord_2", slot_troop_occupation, slto_kingdom_hero),
	   (store_random_in_range, ":lord_2", active_npcs_begin, active_npcs_end),
	(try_end),
	##diplomacy end+

	(troop_slot_eq, ":lord_1", slot_troop_occupation, slto_kingdom_hero),
	(troop_slot_eq, ":lord_2", slot_troop_occupation, slto_kingdom_hero),

	(neq, ":lord_1", ":lord_2"),

	(val_add, "$total_political_events", 1),

	(store_troop_faction, ":lord_1_faction", ":lord_1"),
	(store_troop_faction, ":lord_2_faction", ":lord_2"),

	(assign, reg8, "$total_political_events"),


	(faction_get_slot, ":faction_1_leader", ":lord_1_faction", slot_faction_leader),
	(faction_get_slot, ":faction_2_leader", ":lord_2_faction", slot_faction_leader),

	(this_or_next|eq, ":lord_1_faction", ":lord_2_faction"),
	(this_or_next|eq, ":lord_1", ":faction_1_leader"),
		(eq, ":lord_2", ":faction_2_leader"),


	(call_script, "script_troop_get_relation_with_troop", ":lord_1", ":lord_2"),
	(assign, ":relation", reg0),


	(store_random_in_range, ":random", 0, 100),

	(try_begin),
		#reconciliation
		#The chance of a liege reconciling two quarreling vassals is equal to (relationship with lord 1 x relationship with lord 2) / 4

		(eq, ":lord_1_faction", ":lord_2_faction"),
		(neq, ":faction_1_leader", "trp_player"),

		(le, ":relation", -10),

#		(ge, "$total_political_events", 5000),

		(call_script, "script_troop_get_relation_with_troop", ":lord_1", ":faction_1_leader"),
		(gt, reg0, 0),
		(assign, ":lord_1_leader_rel", reg0),

		(call_script, "script_troop_get_relation_with_troop", ":lord_2", ":faction_1_leader"),
		(gt, reg0, 0),
		(store_mul, ":reconciliation_chance", ":lord_1_leader_rel", reg0),
		(val_div, ":reconciliation_chance", 4),	#was 2 before

		(le, ":random", ":reconciliation_chance"),

		(str_store_troop_name, s4, ":faction_1_leader"),
		(str_store_troop_name, s5, ":lord_1"),
		(str_store_troop_name, s6, ":lord_2"),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(display_message, "str_check_reg8_s4_reconciles_s5_and_s6_"),
		(try_end),

		(call_script, "script_troop_change_relation_with_troop", ":lord_1", ":lord_2", 20),
		(val_add, "$total_random_quarrel_changes", 20),
	(else_try),	#lord intervenes in quarrel
		(eq, ":lord_1_faction", ":lord_2_faction"),

		(le, ":relation", -10),
#		(ge, ":random", 50),
		(try_begin),
			(eq, ":faction_1_leader", "trp_player"),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_diagnostic__player_should_receive_consultation_quest_here_if_not_already_active"),
			(try_end),
			(neg|check_quest_active, "qst_consult_with_minister"),
			(neg|check_quest_active, "qst_resolve_dispute"),
			(eq, "$g_minister_notification_quest", 0),
			(assign, "$g_minister_notification_quest", "qst_resolve_dispute"),
			(quest_set_slot, "qst_resolve_dispute", slot_quest_target_troop, ":lord_1"),
			(quest_set_slot, "qst_resolve_dispute", slot_quest_object_troop, ":lord_2"),

			(call_script, "script_add_notification_menu", "mnu_notification_player_should_consult", 0, 0),


		(else_try),
			(call_script, "script_troop_get_relation_with_troop", ":lord_1", ":faction_1_leader"),
			(assign, ":lord_1_rel_w_leader", reg0),

			(call_script, "script_troop_get_relation_with_troop", ":lord_2", ":faction_1_leader"),
			(assign, ":lord_2_rel_w_leader", reg0),

			(store_random_in_range, ":another_random", -5, 5),

			(val_add, ":lord_1_rel_w_leader", ":another_random"),

			(try_begin),
				(ge, ":lord_1_rel_w_leader", ":lord_2_rel_w_leader"),
				(assign, ":winner_lord", ":lord_1"),
				(assign, ":loser_lord", ":lord_2"),
			(else_try),
				(assign, ":loser_lord", ":lord_1"),
				(assign, ":winner_lord", ":lord_2"),
			(try_end),

			(str_store_troop_name, s4, ":faction_1_leader"),
			(str_store_troop_name, s5, ":winner_lord"),
			(str_store_troop_name, s6, ":loser_lord"),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_check_reg8_s4_rules_in_s5s_favor_in_quarrel_with_s6_"),
			(try_end),

			(call_script, "script_add_log_entry", logent_ruler_intervenes_in_quarrel, ":faction_1_leader",  ":loser_lord", ":winner_lord", ":lord_1_faction"), #faction leader is actor, loser lord is center object, winner lord is troop_object

			(call_script, "script_troop_change_relation_with_troop", ":winner_lord", ":faction_1_leader", 10),
			(call_script, "script_troop_change_relation_with_troop", ":loser_lord", ":faction_1_leader", -20),
			(val_add, "$total_random_quarrel_changes", -10),

		(try_end),


	(else_try), #new quarrel - companions
		(is_between, ":lord_1", companions_begin, companions_end),
		(is_between, ":lord_2", companions_begin, companions_end),

		(ge, ":relation", -10),
		(this_or_next|troop_slot_eq, ":lord_1", slot_troop_personalityclash_object, ":lord_2"),
			(troop_slot_eq, ":lord_1", slot_troop_personalityclash2_object, ":lord_2"),

		(str_store_troop_name, s5, ":lord_1"),
		(str_store_troop_name, s6, ":lord_2"),

		(try_begin),
			(eq, "$cheat_mode", 1),
			(display_message, "str_check_reg8_new_rivalry_generated_between_s5_and_s6"),
		(try_end),

		(call_script, "script_troop_change_relation_with_troop", ":lord_1", ":lord_2", -30),
		(val_add, "$total_random_quarrel_changes", -30),


	(else_try), #new quarrel - others
		(eq, ":lord_1_faction", ":lord_2_faction"),

		(ge, ":relation", -10), #can have two quarrels

		(call_script, "script_cf_test_lord_incompatibility_to_s17", ":lord_1", ":lord_2"),
		(assign, ":chance_of_enmity", reg0),
		(gt, ":chance_of_enmity", 0),


		(lt, ":random", ":chance_of_enmity"), #50 or 100 percent, usually


		(str_store_troop_name, s5, ":lord_1"),
		(str_store_troop_name, s6, ":lord_2"),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(display_message, "str_check_reg8_new_rivalry_generated_between_s5_and_s6"),
		(try_end),

		(call_script, "script_troop_change_relation_with_troop", ":lord_1", ":lord_2", -30),
		(val_add, "$total_random_quarrel_changes", -30),

#		(call_script, "script_update_troop_notes", ":lord_1"),
#		(call_script, "script_update_troop_notes", ":lord_2"),
	(else_try), #a lord attempts to suborn a character
		(store_current_hours, ":hours"),
		(ge, ":hours", 24),

		(neq, ":lord_1_faction", ":lord_2_faction"),
#		(eq, ":lord_1", ":faction_1_leader"),
		(is_between, ":lord_1_faction", kingdoms_begin, kingdoms_end),

		(call_script, "script_cf_troop_can_intrigue", ":lord_2", 0),
		(neq, ":lord_2", ":faction_2_leader"),
		(neq, ":lord_2", ":faction_1_leader"),

		(str_store_troop_name, s5, ":faction_1_leader"),
		(str_store_troop_name, s6, ":lord_2"),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "str_check_reg8_s5_attempts_to_win_over_s6"),
		(try_end),

		(call_script, "script_calculate_troop_political_factors_for_liege", ":lord_2", ":faction_1_leader"),
		(assign, ":lord_1_score", reg0),

		(call_script, "script_calculate_troop_political_factors_for_liege", ":lord_2", ":faction_2_leader"),
		(assign, ":faction_2_leader_score", reg0),

		(try_begin),
			(gt, ":lord_1_score", ":faction_2_leader_score"),


			(try_begin),
				(ge, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":lord_2"),
				(display_message, "@{!}DEBUG - {s4} faction changed in subornment"),
			(try_end),

			(call_script, "script_change_troop_faction", ":lord_2", ":lord_1_faction"),
		(try_end),
	(try_end),



]),


#this calculates the average number of rivalries per lord, giving a rough indication of how easily a faction may be divided
#fairly expensive in terms of CPU
  ("evaluate_realm_stability",

    [
	(store_script_param, ":realm", 1),

	(assign, ":total_lords", 0),
	(assign, ":total_restless_lords", 0),
	(assign, ":total_disgruntled_lords", 0),

	(faction_get_slot, ":liege", ":realm", slot_faction_leader),

	(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
		(troop_slot_eq, ":lord", slot_troop_occupation, slto_kingdom_hero),
		(store_troop_faction, ":lord_faction", ":lord"),
		(eq, ":lord_faction", ":realm"),
		(val_add, ":total_lords", 1),

		(call_script, "script_calculate_troop_political_factors_for_liege", ":lord", ":liege"),
		(try_begin),
			(le, reg3, -10),
			(val_add, ":total_disgruntled_lords", 1),
		(else_try),
			(le, reg3, 10),
			(val_add, ":total_restless_lords", 1),
		(try_end),
	(try_end),

	(try_begin),
		(gt, ":total_lords", 0),
		(store_mul, ":instability_quotient", ":total_disgruntled_lords", 100),
		(val_div, ":instability_quotient", ":total_lords"),

		(store_mul, ":restless_quotient", ":total_restless_lords", 100),
		(val_div, ":restless_quotient", ":total_lords"),

		(store_mul, ":combined_quotient", ":instability_quotient", 2),
		(val_add, ":combined_quotient", ":restless_quotient"),
		(faction_set_slot, ":realm", slot_faction_instability, ":combined_quotient"),

		(assign, reg0, ":instability_quotient"),
		# (assign, reg1, ":restless_quotient"),
		(assign, reg1, ":restless_quotient"),
	(else_try),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_faction_name, s1, ":realm"),
			(display_message, "str_s1_has_no_lords"),
		(try_end),
		(assign, reg0, 0),
		(assign, reg1, 0),
	(try_end),

	]),



#lord recruitment scripts end

#called from game_event_simulate_battle
#Includes a number of consequences that follow on battles, mostly affecting relations between different NPCs
#This only fires from complete victories
  ("battle_political_consequences",
    [
	(store_script_param, ":defeated_party", 1),
	(store_script_param, ":winner_party", 2),

	(try_begin),
		(eq, "$cheat_mode", 1),
		(str_store_party_name, s4, ":winner_party"),
		(str_store_party_name, s5, ":defeated_party"),
		(display_message, "str_do_political_consequences_for_s4_victory_over_s5"),
	(try_end),

	(store_faction_of_party, ":winner_faction", ":winner_party"),
	(try_begin),
		(eq, ":winner_party", "p_main_party"),
		(assign, ":winner_faction", "$players_kingdom"),
	(try_end),

	(party_get_template_id, ":defeated_party_template", ":defeated_party"),

	#did the battle involve travellers?
	(try_begin),
		(this_or_next|eq, ":defeated_party_template", "pt_village_farmers"),
			(eq, ":defeated_party_template", "pt_kingdom_caravan_party"),


		(party_get_slot, ":destination", ":defeated_party", slot_party_ai_object),
		(party_get_slot, ":origin", ":defeated_party", slot_party_last_traded_center),

        (call_script, "script_add_log_entry", logent_traveller_attacked, ":winner_party",  ":origin", ":destination", ":winner_faction"),

		(try_begin),
			(eq, "$cheat_mode", 2),
			(neg|is_between, ":winner_faction", kingdoms_begin, kingdoms_end),
			(str_store_string, s65, "str_bandits_attacked_a_party_on_the_roads_so_a_bounty_is_probably_available"),
			(call_script, "script_add_notification_menu", "mnu_debug_alert_from_s65", 0, 0),

			(str_store_party_name, s15, ":origin"),
			(str_store_party_name, s16, ":destination"),
			(display_message, "str_travellers_attacked_on_road_from_s15_to_s16"),
		(try_end),


		#by logging the faction and the party, we can verify that the party number is unlikely to have been reassigned - or at any rate, that the factions have not changed
	(try_end),

	#winner consequences:
	#1)   leader improves relations with other leaders
	#2)  Player given credit for victory if the victorious party is following the player's advice
	(try_begin),
		(party_get_template_id, ":winner_party_template", ":winner_party"),
		(eq, ":winner_party_template", "pt_kingdom_hero_party"),
		(neq, ":winner_party", "p_main_party"),
		#Do not do for player party, as is included in post-battle dialogs

		(party_stack_get_troop_id, ":winner_leader", ":winner_party", 0),
		##diplomacy start+ Support additional types
		(troop_is_hero, ":winner_leader"),
		(this_or_next|troop_slot_eq, ":winner_leader", slot_troop_occupation, slto_kingdom_hero),
		##diplomacy end+
		(is_between, ":winner_leader", active_npcs_begin, active_npcs_end),

		(store_faction_of_party, ":winner_faction", ":winner_party"),

		(party_collect_attachments_to_party, ":winner_party", "p_temp_party_2"),
        (party_get_num_companion_stacks, ":num_stacks", "p_temp_party_2"),
		(try_for_range, ":troop_iterator", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":cur_troop_id", "p_temp_party_2", ":troop_iterator"),
	    ##diplomacy start+ support promoted kingdom ladies
	    (is_between, ":cur_troop_id", heroes_begin, heroes_end),
	    (this_or_next|troop_slot_eq, ":cur_troop_id", slot_troop_occupation, slto_kingdom_hero),
	    ##diplomacy end+
            (is_between, ":cur_troop_id", active_npcs_begin, active_npcs_end),

			(try_begin),
				(troop_get_slot, ":winner_lord_party", ":cur_troop_id", slot_troop_leaded_party),
				(party_is_active, ":winner_lord_party"),
				(call_script, "script_cf_party_under_player_suggestion", ":winner_lord_party"),
				(call_script, "script_add_log_entry", logent_player_suggestion_succeeded, "trp_player", -1, ":cur_troop_id", -1),
			(try_end),


			(store_faction_of_troop, ":troop_faction", ":cur_troop_id"),
			(eq, ":troop_faction", ":winner_faction"),
			(neq, ":cur_troop_id", ":winner_leader"),

			(try_begin),
				(eq, "$cheat_mode", 4),
				(str_store_troop_name, s15, ":cur_troop_id"),
				(str_store_troop_name, s16, ":winner_leader"),
				(display_message, "str_s15_shares_joy_of_victory_with_s16"),
			(try_end),

			(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", ":winner_leader", 3),
			(val_add, "$total_battle_ally_changes", 3),

		(try_end),
		(party_clear, "p_temp_party_2"),
	(try_end),

	#consequences of defeat,
	#1) -1 relation with lord per lord, plus -15 if there is an incompatible marshal
	#2)  losers under player suggestion blame the player
	#3) Some losers resent the victor lord
	#4) Possible quarrels over defeat
	(try_begin),
		(party_collect_attachments_to_party, ":defeated_party", "p_temp_party_2"),
        (party_get_num_companion_stacks, ":num_stacks", "p_temp_party_2"),

		(try_begin),
			(gt, "$marshall_defeated_in_battle", 0),
			(str_store_troop_name, s15, "$marshall_defeated_in_battle"),
			(store_faction_of_troop, ":defeated_marshall_faction", "$marshall_defeated_in_battle"),
            (try_begin),
                (eq, "$cheat_mode", 1),
			    (display_message, "str_faction_marshall_s15_involved_in_defeat"),
            (try_end),
		(else_try),
			(eq, "$marshall_defeated_in_battle", "trp_player"),
			(eq, ":defeated_party", "p_main_party"),
			(faction_slot_eq, "fac_player_supporters_faction", slot_faction_state, sfs_active),
            (try_begin),
                (eq, "$cheat_mode", 1),
			    (display_message, "str_player_faction_marshall_involved_in_defeat"),
            (try_end),
		(else_try),
			(assign, "$marshall_defeated_in_battle", -1),
		(try_end),

		(try_for_range, ":troop_iterator", 0, ":num_stacks"),
            (party_stack_get_troop_id, ":cur_troop_id", "p_temp_party_2", ":troop_iterator"),
            (troop_slot_eq, ":cur_troop_id", slot_troop_occupation, slto_kingdom_hero),

			(try_begin), #is party under suggestion?
				(troop_get_slot, ":defeated_lord_party", ":cur_troop_id", slot_troop_leaded_party),
				(party_is_active, ":defeated_lord_party"),

				#is party under suggestion?
				(call_script, "script_cf_party_under_player_suggestion", ":defeated_lord_party"),
				(call_script, "script_add_log_entry", logent_player_suggestion_failed, "trp_player", -1, ":cur_troop_id", -1),
			(try_end),


			(store_faction_of_troop, ":troop_faction", ":cur_troop_id"),

			(faction_get_slot, ":faction_leader", ":troop_faction", slot_faction_leader),
			(neq, ":cur_troop_id", ":faction_leader"),

			#Lose one point relation with liege
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s14, ":cur_troop_id"),
				(str_store_faction_name, s15, ":troop_faction"),

				(display_message, "str_s14_of_s15_defeated_in_battle_loses_one_point_relation_with_liege"),
			(try_end),

			(try_begin),
				(this_or_next|neq, ":faction_leader", "trp_player"), #if leader is zero at beginning of game. I'm not entirely sure how this could happen...
					(eq, "$players_kingdom", ":troop_faction"),

				(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", ":faction_leader", -1),
				(val_add, "$total_battle_ally_changes", -1),
			(try_end),


			(call_script, "script_faction_inflict_war_damage_on_faction", ":winner_faction", ":troop_faction", 10),


			(try_begin),
				(this_or_next|is_between, ":winner_leader", active_npcs_begin, active_npcs_end),
					(eq, ":winner_leader", "trp_player"),

				(this_or_next|neq, ":winner_leader", "trp_player"), #prevents winner leader being zero, for whatever reason
					(eq, ":winner_party", "p_main_party"),

				(this_or_next|troop_slot_eq, ":cur_troop_id", slot_lord_reputation_type, lrep_quarrelsome),
				(this_or_next|troop_slot_eq, ":cur_troop_id", slot_lord_reputation_type, lrep_selfrighteous),
					(troop_slot_eq, ":cur_troop_id", slot_lord_reputation_type, lrep_debauched),

				(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", ":winner_leader", -1),
				(val_add, "$total_battle_enemy_changes", -1),

				(try_begin),
					(eq, "$cheat_mode", 1),
					(str_store_troop_name, s14, ":cur_troop_id"),
					(str_store_troop_name, s15, ":winner_leader"),

					(display_message, "str_s14_defeated_in_battle_by_s15_loses_one_point_relation"),
				(try_end),


			(try_end),

			(gt, "$marshall_defeated_in_battle", -1),
			(eq, ":troop_faction", ":defeated_marshall_faction"),
			(str_store_troop_name, s14, ":cur_troop_id"),

			(call_script, "script_cf_test_lord_incompatibility_to_s17", ":cur_troop_id", "$marshall_defeated_in_battle"),
            (try_begin),
                (eq, "$cheat_mode", 1),
			    (display_message, "str_s14_blames_s15_for_defeat"),
            (try_end),

			(call_script, "script_add_log_entry", logent_lord_blames_defeat, ":cur_troop_id", "$marshall_defeated_in_battle", ":faction_leader", ":winner_faction"),

			(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", ":faction_leader", -15),
			(val_add, "$total_battle_ally_changes", -15),

			(neq, "$marshall_defeated_in_battle", ":faction_leader"),
			(call_script, "script_troop_change_relation_with_troop", ":cur_troop_id", "$marshall_defeated_in_battle", -15),
			(val_add, "$total_battle_ally_changes", -15),

		(try_end),

		(party_clear, "p_temp_party_2"),
	(try_end),
	]),

    #SB : possibly lower controversy of attacker npc?
    ("faction_inflict_war_damage_on_faction",
    [
	(store_script_param, ":actor_faction", 1),
	(store_script_param, ":target_faction", 2),
	(store_script_param, ":amount", 3),


	(store_add, ":slot_war_damage", ":target_faction", slot_faction_war_damage_inflicted_on_factions_begin),
	(val_sub, ":slot_war_damage", kingdoms_begin),
	##diplomacy start+ Due to aberrant behavior, non-standard kingdoms
	##like fac_commoners can end up with parties on the map, and possibly
	##could end up inflicting or receiving war damage.  Guard against this.
	(try_begin),
	(is_between, ":slot_war_damage", slot_faction_war_damage_inflicted_on_factions_begin, slot_faction_war_damage_inflicted_on_factions_end),
	(gt, ":actor_faction", 0),
	##diplomacy end+
	(faction_get_slot, ":cur_war_damage", ":actor_faction", ":slot_war_damage"),

	(val_add, ":cur_war_damage", ":amount"),
	(faction_set_slot, ":actor_faction", ":slot_war_damage", ":cur_war_damage"),
	##diplomacy start+ Close added if-statement
	(else_try),
	   #For use in cheat-mode below
	   (assign, ":cur_war_damage", 0),
	(try_end),
	##diplomacy end+


	(try_begin),
	  (ge, "$cheat_mode", 1),
	  (str_store_faction_name, s4, ":actor_faction"),
	  (str_store_faction_name, s5, ":target_faction"),
	  (assign, reg3, ":cur_war_damage"),
	  (assign, reg4, ":amount"),
	  (display_message, "@{!}{s4} inflicts {reg4} damage on {s5}, raising total inflicted to {reg3}"),
	(try_end),


	(faction_get_slot, ":faction_marshal", ":target_faction", slot_faction_marshall),
	(try_begin),
		(ge, ":faction_marshal", 0),
		(gt, ":amount", 0),

		(troop_get_slot, ":controversy", ":faction_marshal", slot_troop_controversy),
		(val_add, ":controversy", ":amount"),
		(val_min, ":controversy", 100),
		(troop_set_slot, ":faction_marshal", slot_troop_controversy, ":controversy"),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":faction_marshal"),
			(assign, reg4, ":amount"),
			(assign, reg5, ":controversy"),
			(display_message, "@{!}War damage raises {s4}'s controversy by {reg4} to {reg5}"),
		(try_end),
	(try_end),

	(faction_get_slot, ":faction_marshal", ":actor_faction", slot_faction_marshall),
	(try_begin),
		(ge, ":faction_marshal", 0),
		(val_div, ":amount", 3),
		(gt, ":amount", 0),


		(troop_get_slot, ":controversy", ":faction_marshal", slot_troop_controversy),
		(val_sub, ":controversy", ":amount"),
		(val_max, ":controversy", 0),
		(troop_set_slot, ":faction_marshal", slot_troop_controversy, ":controversy"),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":faction_marshal"),
			(assign, reg4, ":amount"),
			(assign, reg5, ":controversy"),
			(display_message, "@{!}War damage lowers {s4}'s controversy by {reg4} to {reg5}"),
		(try_end),
	(try_end),



	]),

    ("calculate_troop_political_factors_for_liege",
    [
	(store_script_param, ":troop", 1),
	(store_script_param, ":liege", 2),

	(troop_get_slot, ":lord_reputation", ":troop", slot_lord_reputation_type),

	##diplomacy start+ Work correctly in certain situations where this can be called w/o a liege.
	##OLD:
	#(store_faction_of_troop, ":faction", ":liege"),
	##NEW:
	(try_begin),
	   (eq, ":liege", "trp_player"),
	   (assign, ":faction", "fac_player_supporters_faction"),
	   (try_begin),
	     #Handle "player is co-ruler of NPC faction"
	     (is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
	     (call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
	     (ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
	     (assign, ":faction", "$players_kingdom"),
	     (faction_get_slot, reg0, ":faction", slot_faction_leader),
	     (gt, reg0, 0),
	     (assign, ":liege", reg0),
	   (try_end),
	(else_try),
	   #Ordinary case
	   (ge, ":liege", 0),
	   (store_faction_of_troop, ":faction", ":liege"),
	(else_try),
	   (store_faction_of_troop, reg0, ":troop"),
	   (faction_slot_eq, reg0, slot_faction_leader, ":liege"),
	   (assign, ":faction", reg0),
	(else_try),
	   (assign, ":faction", kingdoms_end),
	   (try_for_range, reg0, kingdoms_begin, ":faction"),
	      (faction_slot_eq, reg0, slot_faction_leader, ":liege"),
	      (assign, ":faction", reg0),
	   (try_end),
	   (neg|is_between, ":faction", kingdoms_begin, kingdoms_end),
	   (assign, ":faction", "fac_no_faction"),
	(try_end),
	##diplomacy end+


	(try_begin),
		(eq, ":faction", "fac_player_faction"),
		(assign, ":faction", "fac_player_supporters_faction"),
	(try_end),

	(assign, ":liege_is_undeclared_rebel", 0),
	(try_begin),
		(neg|faction_slot_eq, ":faction", slot_faction_leader, ":liege"),
		#the liege is a rebel
		(assign, ":liege_is_undeclared_rebel", 1),
		(try_begin),
			(eq, "$cheat_mode", 1),
                        ##diplomacy start+ Guard against bad liege
                        (ge, ":liege", 0),
                        ##diplomacy end+
			(str_store_troop_name, s32, ":liege"),
			(display_message, "str_s32_is_undeclared_rebel"),
		(try_end),
	(try_end),

	(assign, ":result_for_material", 0),
	(assign, ":penalty_for_changing_sides", 0),



	#FACTOR 1 - MILITARY SECURITY
	(assign, ":result_for_security", 0),

	#find the lord's home
	(assign, ":base_center", -1),
	(try_begin),
		##diplomacy start+ add support for promoted kingdom ladies
		(is_between, ":troop", heroes_begin, heroes_end),
		(this_or_next|troop_slot_eq, ":troop", slot_troop_occupation, slto_kingdom_hero),
		##diplomacy end+
		(is_between, ":troop", active_npcs_begin, active_npcs_end),
		(try_for_range, ":center", centers_begin, centers_end),
			(eq, ":base_center", -1),
			(party_slot_eq, ":center", slot_town_lord, ":troop"),
			(assign, ":base_center", ":center"),
		(try_end),
	(try_end),

	(assign, ":faction_has_base", 0),

	#add up all other centers for the security value
	(try_for_range, ":center", centers_begin, centers_end),
		(neq, ":center", ":base_center"),
		(gt, ":base_center", 0),

		(try_begin),
			(is_between, ":center", towns_begin, towns_end),
			(assign, ":weight", 9000),
		(else_try),
			(is_between, ":center", castles_begin, castles_end),
			(assign, ":weight", 6000),
		(else_try),
			(assign, ":weight", 1000),
		(try_end),

		(store_distance_to_party_from_party, ":distance", ":base_center", ":center"),
		(val_add, ":distance", 10),
		(val_div, ":weight", ":distance"),
		(val_div, ":weight", ":distance"),

		(store_faction_of_party, ":center_faction", ":center"),

		(try_begin),
			(eq, ":center_faction", ":faction"),

			(assign, ":faction_has_base", 1),
			(val_add, ":result_for_security", ":weight"),
		(else_try),
			(neq, ":center_faction", ":faction"),
			(store_relation, ":center_relation", ":center_faction", ":faction"),

			(try_begin), #potentially hostile center
				(this_or_next|eq, ":liege_is_undeclared_rebel", 1),
					(lt, ":center_relation", 0),
				(val_div, ":weight", 2),
			(else_try), #neutral center
				(val_div, ":weight", 4),
			(try_end),

			(val_sub, ":result_for_security", ":weight"),
		(try_end),
	(try_end),


	#if a faction controls no other centers, then there is a small bonus
	(try_begin),
		(eq, ":faction_has_base", 0),
		(val_add, ":result_for_security", 20),
		(try_begin),
			(eq, "$cheat_mode", 2),
			(display_message, "str_small_bonus_for_no_base"),
		(try_end),
	(try_end),
	(val_clamp, ":result_for_security", -100, 100),


	(assign, ":result_for_security_weighted", ":result_for_security"),
	##diplomacy start+
   #ADDED TO THIS, SEE BELOW
	#(try_begin),
	#	(eq, ":lord_reputation", lrep_cunning),
	#	(val_mul, ":result_for_security_weighted", 2),
	#(else_try),
	#	(eq, ":lord_reputation", lrep_martial),
	#	(val_div, ":result_for_security_weighted", 2),
	#(try_end),
	#
    ##Use companion morality type "tmt_aristocratic" as a synonym/antonym for bold
	(call_script, "script_dplmc_get_troop_morality_value", ":troop", tmt_aristocratic),
	(assign, ":lord_tmt_aristocratic", reg0),
	(try_begin),
		(lt, ":lord_tmt_aristocratic", 1),
		(this_or_next|lt, ":lord_tmt_aristocratic", 0),
		(eq, ":lord_reputation", lrep_cunning),
		(val_mul, ":result_for_security_weighted", 2),
	(else_try),
		(ge, ":lord_tmt_aristocratic", 0),
		(this_or_next|ge, ":lord_tmt_aristocratic", 1),
		(eq, ":lord_reputation", lrep_martial),
		(val_div, ":result_for_security_weighted", 2),
	(try_end),
	##diplomacy end+

	#FACTOR 2 - INTERNAL FACTION POLITICS
	#this is a calculation of how much influence the lord believes he will have in each faction
	(assign, ":result_for_political", 0),

    (try_for_range, ":loop_var", "trp_kingdom_heroes_including_player_begin", active_npcs_end),
        (assign, ":kingdom_hero", ":loop_var"),
	##diplomacy start+ Skip what follows when there is no liege
	(ge, ":liege", 0),
	##diplomacy end+

		(this_or_next|troop_slot_eq, ":kingdom_hero", slot_troop_occupation, slto_kingdom_hero),
		(this_or_next|eq, ":kingdom_hero", "trp_kingdom_heroes_including_player_begin"),
			(is_between, ":kingdom_hero", pretenders_begin, pretenders_end),

		(store_faction_of_troop, ":kingdom_hero_faction", ":kingdom_hero"),

        (try_begin),
            (eq, ":loop_var", "trp_kingdom_heroes_including_player_begin"),
            (assign, ":kingdom_hero", "trp_player"),
			(assign, ":kingdom_hero_faction", "$players_kingdom"),
			(try_begin), #do not count player relation if the player is trying to suborn the character. this has the slight potential for a miscalculation, if the script is called from outside dialogs and $g_talk_troop has not been reset
				(eq, "$g_talk_troop", ":troop"),
				(store_faction_of_troop, ":cur_faction", ":troop"),
				(eq, ":cur_faction", ":faction"),
				(assign, ":kingdom_hero_faction", 0),
			(try_end),
		(try_end),

		(eq, ":kingdom_hero_faction", ":faction"),
		(neg|faction_slot_eq, ":kingdom_hero_faction", slot_faction_leader, ":kingdom_hero"),
		(neq, ":liege_is_undeclared_rebel", 1),
		(neg|is_between, ":kingdom_hero", pretenders_begin, pretenders_end),


		(call_script, "script_troop_get_relation_with_troop", ":troop", ":kingdom_hero"),
		(assign, ":troop_rel_w_hero", reg0),

		(call_script, "script_troop_get_relation_with_troop", ":kingdom_hero", ":liege"),
		(assign, ":hero_rel_w_liege", reg0),

		(store_mul, ":lord_political_weight", ":troop_rel_w_hero", ":hero_rel_w_liege"),
		(val_div, ":lord_political_weight", 100),

		(try_begin),
			(eq, "$cheat_mode", 2), #disabled
			(eq, "$g_talk_troop", ":troop"),
			(str_store_faction_name, s20, ":kingdom_hero_faction"),
			(str_store_troop_name, s15, ":kingdom_hero"),
			(assign, reg15, ":lord_political_weight"),
			(display_message, "str_s15_considered_member_of_faction_s20_weight_of_reg15"),
		(try_end),

		(val_add, ":result_for_political", ":lord_political_weight"),
	(try_end),

	(val_clamp, ":result_for_political", -100, 101), #lords portion represents half

	(try_begin),
		##diplomacy start+ When there isn't a liege, use 0
		(assign, ":liege_relation", 0),
		(ge, ":liege", 0),
		##diplomacy end+
		(call_script, "script_troop_get_relation_with_troop", ":troop", ":liege"),
		(assign, ":liege_relation", reg0),
		(val_add, ":result_for_political", ":liege_relation"),
	(try_end),

	(val_div, ":result_for_political", 2),

	(val_clamp, ":result_for_political", -100, 101), #liege portion represents half

	(assign, ":result_for_political_weighted", ":result_for_political"),

	(try_begin),
		(this_or_next|eq, ":lord_reputation", lrep_goodnatured),
			(eq, ":lord_reputation", lrep_quarrelsome),
		(val_mul, ":result_for_political_weighted", 2),
	(try_end),

	#FACTOR 3 - PROMISES AND OTHER ANTICIPATED GAINS
	#lord's calculation of anticipated gains
	(assign, ":result_for_material", 0),
	(assign, ":result_for_material_weighted", ":result_for_material"),


	#FACTOR 4 - IDEOLOGY
	#lord's calculation of ideological comfort
	(try_begin),
		#Originally, the argument section was not used for a non-player liege. Actually, it can be used
		(eq, 1, 0),
		(neq, ":liege", "trp_player"),
		(neq, ":liege", "$supported_pretender"), #player is advocate for pretender
		(assign, ":argument_strength", 0),
		(assign, ":argument_appeal", 0),
		(assign, ":result_for_argument", 0),
	(else_try),	#only if the recruitment candidate is either the player, or a supported pretender
		(troop_get_slot, ":recruitment_argument", ":troop", slot_lord_recruitment_argument),

		(call_script, "script_rebellion_arguments", ":troop", ":recruitment_argument", ":liege"),
		(assign, ":argument_appeal", reg0),
		(assign, ":argument_strength", reg1),

		(store_add, ":result_for_argument", ":argument_appeal", ":argument_strength"),

		(store_skill_level, ":player_persuasion_skill", "skl_persuasion", "trp_player"),
		(try_begin),
			(gt, ":result_for_argument", 0),
			#make sure player is the one making the overture

			#if player has 0 persuasion, ":result_for_argument" will be multiplied by 3/10.
			(store_add, ":player_persuasion_skill_plus_5_mul_066", ":player_persuasion_skill", 5),
			(val_mul, ":player_persuasion_skill_plus_5_mul_066", 2),
			(val_div, ":player_persuasion_skill_plus_5_mul_066", 3),

			(val_mul, ":result_for_argument", ":player_persuasion_skill_plus_5_mul_066"),
			(val_div, ":result_for_argument", 10),
		(else_try),
			(lt, ":result_for_argument", 0),
			(store_sub, ":ten_minus_player_persuasion_skill", 10, ":player_persuasion_skill"),
			(val_mul, ":result_for_argument", ":ten_minus_player_persuasion_skill"),
			(val_div, ":result_for_argument", 10),
		(try_end),

		(try_begin),
			(neq, ":liege", "trp_player"),
			(neq, ":liege", "$supported_pretender"), #player is advocate for pretender
			(val_div, ":argument_strength", 2),
			(val_div, ":argument_appeal", 2),
			(val_div, ":result_for_argument", 2),
		(try_end),

	(try_end),

#	(try_begin),
#		(eq, ":lord_reputation", lrep_cunning),
#		(val_div, ":result_for_ideological_weighted", 2),
#	(else_try),
#		(eq, ":lord_reputation", lrep_upstanding),
#		(val_mul, ":result_for_ideological_weighted", 2),
#	(try_end),


	#FACTOR 5 - PENALTY FOR CHANGING SIDES
	(try_begin), #no penalty for the incumbent
		(store_faction_of_troop, ":cur_faction", ":troop"),
		(eq, ":cur_faction", ":faction"),
		(assign, ":penalty_for_changing_sides", 0),
	(else_try), #penalty for the player
		(eq, ":liege", "trp_player"),
		(store_sub, ":penalty_for_changing_sides", 60, "$player_right_to_rule"),
	(else_try), #same culture, such as a pretender
		##diplomacy start+ skip when there is no liege
		(ge, ":liege", 0),
		##diplomacy end+
		(troop_get_slot, ":orig_faction_of_lord", ":troop", slot_troop_original_faction),
		(troop_get_slot, ":orig_faction_of_liege", ":liege", slot_troop_original_faction),
		(eq, ":orig_faction_of_lord", ":orig_faction_of_liege"),
		(assign, ":penalty_for_changing_sides", 10),
	##diplomacy start+
	#"same culture, such as a pretender" pt. 2
	(else_try),
		(troop_slot_eq, ":troop", slot_troop_original_faction, ":faction"),
		(assign, ":penalty_for_changing_sides", 10),
	##diplomacy end+
	(else_try), #a liege from a different culture
		(assign, ":penalty_for_changing_sides", 50),
	(try_end),
	(val_clamp, ":penalty_for_changing_sides", 0, 101),

	(assign, ":penalty_for_changing_sides_weighted", ":penalty_for_changing_sides"),
	##diplomacy start+
	#(try_begin),
	#	(eq, ":lord_reputation", lrep_debauched),
	#	(val_div, ":penalty_for_changing_sides_weighted", 2),
	#(else_try),
	#	(eq, ":lord_reputation", lrep_upstanding),
	#	(val_mul, ":penalty_for_changing_sides_weighted", 2),
	#(try_end),
	#
	##Use companion morality type "tmt_honest" as a synonym/antonym for deal-keeping
	(call_script, "script_dplmc_get_troop_morality_value", ":troop", tmt_honest),
	(assign, ":lord_tmt_honest", reg0),
	(try_begin),
		(this_or_next|lt, ":lord_tmt_honest", 0),
		(eq, ":lord_reputation", lrep_debauched),
		(val_div, ":penalty_for_changing_sides_weighted", 2),
	(else_try),
		(this_or_next|ge, ":lord_tmt_honest", 1),
		(eq, ":lord_reputation", lrep_upstanding),
		(val_mul, ":penalty_for_changing_sides_weighted", 2),
	(try_end),
	##diplomacy end+



	(assign, reg1, ":result_for_security"),
	(assign, reg2, ":result_for_security_weighted"),
	(assign, reg3, ":result_for_political"),
	(assign, reg4, ":result_for_political_weighted"),
	(assign, reg5, ":result_for_material"),
	(assign, reg6, ":result_for_material_weighted"),
	(assign, reg7, ":argument_strength"),
	(assign, reg17, ":argument_appeal"),

	(assign, reg8, ":result_for_argument"),
	(assign, reg9, ":penalty_for_changing_sides"),
	(assign, reg10, ":penalty_for_changing_sides_weighted"),


	(try_begin),
		(eq, "$cheat_mode", 1),
		(eq, "$g_talk_troop", ":troop"),
		(str_store_troop_name, s20, ":troop"),
		(str_store_faction_name, s21, ":faction"),
		##diplomacy start+
		##OLD:
		#(str_store_troop_name, s22, ":liege"),
		##NEW:
		(try_begin),
		  (gt, ":liege", -1),
		  (str_store_troop_name, s22, ":liege"),
		(else_try),
		  (str_store_string, s22, "str_noone"),
		(try_end),
		##diplomacy end+

		(display_message, "@{!}G_talk_troop {s20} evaluates being vassal to {s22} of {s21}"),

		(display_message, "str_base_result_for_security_reg1"),
		(display_message, "str_result_for_security_weighted_by_personality_reg2"),
		(display_message, "str_base_result_for_political_connections_reg3"),
		(display_message, "str_result_for_political_connections_weighted_by_personality_reg4"),
#		(display_message, "@{!}Result for anticipated_gains: {reg5}"),
#		(display_message, "@{!}Result for anticipated_gains weighted by personality: {reg6}"),

		(try_begin),
			(this_or_next|eq, ":liege", "trp_player"),
				(eq, ":liege", "$supported_pretender"), #player is advocate for pretender
			(display_message, "str_result_for_argument_strength_reg7"),
			(display_message, "str_result_for_argument_appeal_reg17"),
			(display_message, "str_combined_result_for_argument_modified_by_persuasion_reg8"),
		(try_end),
		(display_message, "str_base_changing_sides_penalty_reg9"),
		(display_message, "str_changing_sides_penalty_weighted_by_personality_reg10"),
	(try_end),

	(store_add, ":total", ":result_for_security_weighted", ":result_for_political_weighted"),
	(val_add, ":total", ":result_for_material_weighted"),
	(val_add, ":total", ":result_for_argument"),
	(val_sub, ":total", ":penalty_for_changing_sides_weighted"),


	(assign, reg0, ":total"),

	(try_begin),
		(eq, "$cheat_mode", 2),
		(display_message, "@{!}DEBUG -- Analyzing lord allegiances, combined bonuses and penalties = {reg0}"),
		#(display_message, "str_combined_bonuses_and_penalties_=_reg0"),
	(try_end),
	]),



    ("cf_troop_can_intrigue",
	#This script should be called from dialogs, and also prior to any event which might result in a lord changing sides
    [
      (store_script_param, ":troop", 1),
      (store_script_param, ":skip_player_party", 2),

		##diplomacy start+
		#Use this to filter out lords who are supposed to be "off the board"
		(assign, ":bad_occupation", 0),
		(try_begin),
		   (gt, ":troop", 0),
			(troop_is_hero, ":troop"),
		   (troop_slot_eq, ":troop", slot_lord_reputation_type, dplmc_slto_dead),
		   (assign, ":bad_occupation", 1),#altered 2011-06-08
		(try_end),
		(eq, ":bad_occupation", 0),
		##diplomacy end+

      (troop_get_slot, ":led_party_1", ":troop", slot_troop_leaded_party),
      (party_is_active, ":led_party_1"),

      (try_begin),
        (eq, "$cheat_mode", 1),
        (eq, ":troop", "$g_talk_troop"),
        (display_message, "str_intrigue_test_troop_party_is_active"),
      (try_end),

      (party_get_battle_opponent, ":battle_opponent", ":led_party_1"),
      (le, ":battle_opponent", 0), #battle opponent can be 0 for an attached party?

      (try_begin),
        (eq, "$cheat_mode", 1),
        (eq, ":troop", "$g_talk_troop"),
        (display_message, "str_intrigue_test_troop_party_is_not_in_battle"),
      (try_end),

      (troop_slot_eq, ":troop", slot_troop_prisoner_of_party, -1),

      (try_begin),
        (eq, "$cheat_mode", 1),
        (eq, ":troop", "$g_talk_troop"),
        (display_message, "str_intrigue_test_troop_is_not_prisoner"),
      (try_end),

      (party_get_attached_to, ":led_party_1_attached", ":led_party_1"),

      (store_faction_of_party, ":led_party_1_faction", ":led_party_1"),

      (assign, ":other_lords_nearby", 0),
      (try_for_range, ":troop_2", active_npcs_begin, active_npcs_end),
        (neq, ":troop", ":troop_2"),
        (eq, ":other_lords_nearby", 0),

        (troop_slot_eq, ":troop_2", slot_troop_occupation, slto_kingdom_hero),

        (troop_get_slot, ":led_party_2", ":troop_2", slot_troop_leaded_party),
        (party_is_active, ":led_party_2"),
        (neq, ":led_party_1", ":led_party_2"),

        (store_faction_of_party, ":led_party_2_faction", ":led_party_2"),
        (eq, ":led_party_1_faction", ":led_party_2_faction"),

        (try_begin),
          (eq, ":led_party_1_attached", -1),
          (store_distance_to_party_from_party, ":distance", ":led_party_1", ":led_party_2"),
          (lt, ":distance", 3),
          (assign, ":other_lords_nearby", 1),
        (else_try),
          (is_between, ":led_party_1_attached", walled_centers_begin, walled_centers_end),
          (party_get_attached_to, ":led_party_2_attached", ":led_party_2"),
          (eq, ":led_party_1_attached", ":led_party_2_attached"),
          (assign, ":other_lords_nearby", 1),
        (try_end),
      (try_end),

      (try_begin),
        (eq, "$cheat_mode", 1),
        (eq, ":troop", "$g_talk_troop"),
        (display_message, "str_intrigue_test_troop_is_nearby"),
      (try_end),

      (try_begin),
        (eq, ":skip_player_party", 0),
        #temporary spot
      (try_end),

      (eq, ":other_lords_nearby", 0),
	]),


    ("troop_change_relation_with_troop",
    [
	(store_script_param, ":troop1", 1),
	(store_script_param, ":troop2", 2),
	(store_script_param, ":amount", 3),

	(try_begin),
		(eq, ":troop1", "trp_player"),
		(call_script, "script_change_player_relation_with_troop", ":troop2", ":amount"),
	(else_try),
		(eq, ":troop2", "trp_player"),
		(call_script, "script_change_player_relation_with_troop", ":troop1", ":amount"),
	(else_try),
		##diplomacy start+ Cancel the result for bad troop values
		(this_or_next|lt, ":troop1", 0),
		(this_or_next|lt, ":troop2", 0),
		##diplomacy end+
		(eq, ":troop1", ":troop2"),
		##diplomacy start+ Do this to avoid the controversy check further below
		(assign, ":amount", 0),
		##diplomacy end+
	(else_try),
		(call_script, "script_troop_get_relation_with_troop", ":troop1", ":troop2"),
		(store_add, ":new_relation", reg0, ":amount"),

		(val_clamp, ":new_relation", -100, 101),

		(try_begin),
			(eq, ":new_relation", 0),
			(assign, ":new_relation", 1), #this removes the need for a separate "met" slot - any non-zero relation will be a met
		(try_end),

		(store_add, ":troop1_slot_for_troop2", ":troop2", slot_troop_relations_begin),
		(troop_set_slot, ":troop1", ":troop1_slot_for_troop2", ":new_relation"),

		(store_add, ":troop2_slot_for_troop1", ":troop1", slot_troop_relations_begin),
		(troop_set_slot, ":troop2", ":troop2_slot_for_troop1", ":new_relation"),
	(try_end),


	(try_begin), #generate controversy if troops are in the same faciton
		(lt, ":amount", -5),
		(try_begin),
			(eq, ":troop1", "trp_player"),
			(assign, ":faction1", "$players_kingdom"),
		(else_try),
			(store_faction_of_troop, ":faction1", ":troop1"),
		(try_end),
		(try_begin),
			(eq, ":troop2", "trp_player"),
			(assign, ":faction2", "$players_kingdom"),
		(else_try),
			(store_faction_of_troop, ":faction2", ":troop2"),
		(try_end),
		(eq, ":faction1", ":faction2"),
		(is_between, ":faction1", kingdoms_begin, kingdoms_end),

		(store_mul, ":controversy_generated", ":amount", -1),

		(troop_get_slot, ":controversy1", ":troop1", slot_troop_controversy),
		(val_add, ":controversy1", ":controversy_generated"),
		(val_min, ":controversy1", 100),
		(troop_set_slot, ":troop1", slot_troop_controversy, ":controversy1"),

		(troop_get_slot, ":controversy2", ":troop2", slot_troop_controversy),
		(val_add, ":controversy2", ":controversy_generated"),
		(val_min, ":controversy2", 100),
		(troop_set_slot, ":troop2", slot_troop_controversy, ":controversy2"),

	(try_end),

	(try_begin),
		##diplomacy start+ Also enable messages for promoted kingdom ladies
		#OLD:
		#(is_between, ":troop1", active_npcs_begin, active_npcs_end),
		#(is_between, ":troop2", active_npcs_begin, active_npcs_end),
		#
		#NEW:
		(is_between, ":troop1", heroes_begin, heroes_end),
		(this_or_next|troop_slot_eq, ":troop1", slot_troop_occupation, slto_kingdom_hero),
			(is_between, ":troop1", active_npcs_begin, active_npcs_end),

		(is_between, ":troop2", heroes_begin, heroes_end),
		(this_or_next|troop_slot_eq, ":troop2", slot_troop_occupation, slto_kingdom_hero),
			(is_between, ":troop2", active_npcs_begin, active_npcs_end),
		##diplomacy end+
		(neq, ":troop1", ":troop2"),

		(try_begin),
			(gt, ":amount", 0),
			(val_add, "$total_relation_adds", ":amount"),
		(else_try),
			(val_sub, "$total_relation_subs", ":amount"),
		(try_end),
	(try_end),

	(try_begin),
		(eq, "$cheat_mode", 4), #change back to 4
		##diplomacy start+ Also enable messages for promoted kingdom ladies
		#OLD:
		# (is_between, ":troop1", active_npcs_begin, active_npcs_end),
		# (is_between, ":troop2", active_npcs_begin, active_npcs_end),
		#
		#NEW:
		(is_between, ":troop1", heroes_begin, heroes_end),
		(this_or_next|troop_slot_eq, ":troop1", slot_troop_occupation, slto_kingdom_hero),
			(is_between, ":troop1", active_npcs_begin, active_npcs_end),

		(is_between, ":troop2", heroes_begin, heroes_end),
		(this_or_next|troop_slot_eq, ":troop2", slot_troop_occupation, slto_kingdom_hero),
			(is_between, ":troop2", active_npcs_begin, active_npcs_end),
		##diplomacy end+
		(neq, ":troop1", ":troop2"),

		(str_store_troop_name, s20, ":troop1"),
		(str_store_troop_name, s15, ":troop2"),
		(assign, reg4, ":amount"),
		(assign, reg14, ":new_relation"),
		(display_message, "str_s20_relation_with_s15_changed_by_reg4_to_reg14"),

		(assign, reg4, "$total_relation_adds"),
		(display_message, "str_total_additions_reg4"),
		(assign, reg4, "$total_relation_subs"),
		(display_message, "str_total_subtractions_reg4"),

		(assign, reg4, "$total_courtship_quarrel_changes"),
		(display_message, "@{!}DEBUG -- Total courtship quarrel changes: {reg4}"),

		(assign, reg4, "$total_random_quarrel_changes"),
		(display_message, "@{!}DEBUG -- Total random quarrel changes: {reg4}"),

		(assign, reg4, "$total_battle_ally_changes"),
		(display_message, "@{!}DEBUG -- Total battle changes for allies: {reg4}"),

		(assign, reg4, "$total_battle_enemy_changes"),
		(display_message, "@{!}DEBUG -- Total battle changes for enemies: {reg4}"),

		(assign, reg4, "$total_promotion_changes"),
		(display_message, "@{!}DEBUG -- Total promotion changes: {reg4}"),

		(assign, reg4, "$total_feast_changes"),
		(display_message, "@{!}DEBUG -- Total feast changes: {reg4}"),

		(assign, reg4, "$total_policy_dispute_changes"),
		(assign, reg5, "$number_of_controversial_policy_decisions"),
		(display_message, "@{!}DEBUG -- Total policy dispute changes: {reg4} from {reg5} decisions"),

		(assign, reg4, "$total_indictment_changes"),
		(display_message, "@{!}DEBUG -- Total faction switch changes: {reg4}"),

		(assign, reg4, "$total_no_fief_changes"),
		(display_message, "@{!}DEBUG -- Total no fief changes: {reg4}"),

		(assign, reg4, "$total_relation_changes_through_convergence"),
		(display_message, "@{!}DEBUG -- Total changes through convergence: {reg4}"),

		(assign, reg4, "$total_vassal_days_responding_to_campaign"),
		(display_message, "@{!}DEBUG -- Total vassal responses to campaign: {reg4}"),

		(assign, reg4, "$total_vassal_days_on_campaign"),
		(display_message, "@{!}DEBUG -- Total vassal campaign days: {reg4}"),

		(val_max, "$total_vassal_days_on_campaign", 1),
		(store_mul, ":response_rate", "$total_vassal_days_responding_to_campaign", 100),
		(val_div, ":response_rate", "$total_vassal_days_on_campaign"),
		(assign, reg4, ":response_rate"),
		(display_message, "@{!}DEBUG -- Vassal response rate: {reg4}"),



#		(assign, reg4, "$total_joy_battle_changes"),
#		(display_message, "@{!}DEBUG -- Total joy of battle changes"),

	(try_end),

	]),


    ("troop_get_relation_with_troop",
    [
	(store_script_param, ":troop1", 1),
	(store_script_param, ":troop2", 2),

	(assign, ":relation", 0),
	(try_begin),
		##diplomacy start+
		#Change "eq -1", to "lt 0"
		(this_or_next|lt, ":troop1", 0),
			(lt, ":troop2", 0),
		##diplomacy end+

		#Possibly switch to relation with liege
		(assign, ":relation", 0),
	(else_try),
		(eq, ":troop1", "trp_player"),
		(call_script, "script_troop_get_player_relation", ":troop2"),
		(assign, ":relation", reg0),
	(else_try),
		(eq, ":troop2", "trp_player"),
		(call_script, "script_troop_get_player_relation", ":troop1"),
		(assign, ":relation", reg0),
	(else_try),
		(store_add, ":troop1_slot_for_troop2", ":troop2", slot_troop_relations_begin),
		(troop_get_slot, ":relation", ":troop1", ":troop1_slot_for_troop2"),
	(try_end),


	(val_clamp, ":relation", -100, 101),
	(assign, reg0, ":relation"),

	]),



	("appoint_faction_marshall",
    [
	(store_script_param, ":faction_no", 1),
	(store_script_param, ":faction_marshall", 2),


    (faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),
    (faction_get_slot, ":old_marshall", ":faction_no", slot_faction_marshall),

    (faction_set_slot, ":faction_no", slot_faction_marshall, ":faction_marshall"),

    (try_begin),
		(ge, ":old_marshall", 0),
		(troop_get_slot, ":old_marshall_party", ":old_marshall", slot_troop_leaded_party),
        (party_is_active, ":old_marshall_party"),
        (party_set_marshal, ":old_marshall_party", 0),
    (try_end),


    (try_begin),
      (ge, ":faction_marshall", 0),
	  (troop_get_slot, ":new_marshall_party", ":faction_marshall", slot_troop_leaded_party),
      (party_is_active, ":new_marshall_party"),
      (party_set_marshal,":new_marshall_party", 1),
    (try_end),


	(try_begin),
		(neq, ":faction_marshall", ":faction_leader"),
		(neq, ":faction_marshall", ":old_marshall"),
		##diplomacy start+ Support promoted kingdom ladies
		(this_or_next|eq, ":faction_marshall", "trp_player"),
			(is_between, ":faction_marshall", heroes_begin, heroes_end),
		(this_or_next|troop_slot_eq, ":faction_marshall", slot_troop_occupation, slto_kingdom_hero),
		##diplomacy end+
		(this_or_next|eq, ":faction_marshall", "trp_player"),
			(is_between, ":faction_marshall", active_npcs_begin, active_npcs_end),

		(this_or_next|neq, ":faction_no", "fac_player_supporters_faction"),
			(neg|check_quest_active, "qst_rebel_against_kingdom"),

		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_faction_name, s15, ":faction_no"),
			(display_message, "str_checking_lord_reactions_in_s15"),
		(try_end),


		(call_script, "script_troop_change_relation_with_troop", ":faction_marshall", ":faction_leader", 5),
		(val_add, "$total_promotion_changes", 5),

		##diplomacy start+
		(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", ":faction_no"),
		(assign, ":player_standing_in_faction", reg0),
		#(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),

		#Support promoted kingdom ladies
		##OLD:
		#(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
		##NEW:
		(try_for_range, ":lord", heroes_begin, heroes_end),
		##diplomacy end+
			(troop_slot_eq, ":lord", slot_troop_occupation, slto_kingdom_hero),
			(store_faction_of_troop, ":lord_faction", ":lord"),
			(eq, ":lord_faction", ":faction_no"),

			(neq, ":lord", ":faction_marshall"),
			(neq, ":lord", ":faction_leader"),

			(call_script, "script_troop_get_relation_with_troop", ":faction_marshall", ":lord"),
#			(try_begin),
#				(eq, "$cheat_mode", 1),
#				(str_store_troop_name, s14, ":lord"),
#				(str_store_troop_name, s17, ":faction_marshall"),
#				(display_message, "@{!}{s14}'s relation with {s17} is {reg0}"),
#			(try_end),
			(store_sub, ":adjust_relations", reg0, 10),
			(val_div, ":adjust_relations", 15),
			##diplomacy start+
			#In some situtations the player can set the marshall freely even though he isn't the faction leader.
			(try_begin),
				(eq, ":faction_marshall", "trp_player"),
				(ge, ":player_standing_in_faction", DPLMC_FACTION_STANDING_LEADER_SPOUSE),
				#Still allow a relation gain below if the lord had actively supported the player
				#(which doesn't happen now if the player is the ruler, but could).
				(val_min, ":adjust_relations", 0),
			(try_end),
			##diplomacy end+
			(neq, ":adjust_relations", 0),

			#Not negatively affected if they favored the lord
			(try_begin),
				(troop_slot_eq, ":lord", slot_troop_stance_on_faction_issue, ":faction_marshall"),
				(val_add, ":adjust_relations", 1),
				(val_max, ":adjust_relations", 0),
			(try_end),

			(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":lord", ":adjust_relations"),
			(val_add, "$total_promotion_changes", ":adjust_relations"),

			(lt, ":adjust_relations", -2),
			(store_random_in_range, ":random", 1, 10),

			(val_add, ":adjust_relations", ":random"),

			(lt, ":adjust_relations", 0),

			(str_store_troop_name, s14, ":lord"),
			(str_store_troop_name, s15, ":faction_marshall"),

			(try_begin),
			##diplomacy start+ Show protest information for your own kingdom if you have a chancellor or are the ruler
				(ge, ":player_standing_in_faction", DPLMC_FACTION_STANDING_MEMBER),
				(this_or_next|ge, ":player_standing_in_faction", DPLMC_FACTION_STANDING_LEADER_SPOUSE),#<- via the minister, or just hearing about it
					(gt, "$g_player_chancellor", 0),#<- via your chancellor
				(neg|troop_slot_eq, ":lord", slot_troop_met, 0),
				(display_message, "str_s14_protests_the_appointment_of_s15_as_marshall"),
			(else_try),
				(call_script, "script_dplmc_store_troop_is_eligible_for_affiliate_messages", ":lord"),
				(this_or_next|gt, reg0, 0),
			##diplomacy end+
                (eq, "$cheat_mode", 1),
                (display_message, "str_s14_protests_the_appointment_of_s15_as_marshall"),
            (try_end),

			(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":lord", -10),
			(call_script, "script_troop_change_relation_with_troop", ":faction_marshall", ":lord", -5),
			(val_add, "$total_promotion_changes", -15),

			(call_script, "script_add_log_entry", logent_lord_protests_marshall_appointment, ":lord",  ":faction_marshall", ":faction_leader", "$g_encountered_party_faction"),

		(try_end),
	(try_end),

		]),

	#it might be easier to monitor whether prices are following an intuitive pattern if we separate production from consumption
	#the current system still works very well, however
	("center_get_item_consumption",
    [
	]),

	("locate_player_minister", #maybe deprecate this
    [
	##diplomacy start+ Handle player is co-ruler of NPC faction
	(assign, ":alt_faction", "fac_player_supporters_faction"),
	(try_begin),
		(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
		(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
		(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
		(assign, ":alt_faction", "$players_kingdom"),
	(try_end),
	##diplomacy end+
	(assign, ":walled_center_found", 0),
	(try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
		(lt, ":walled_center_found", centers_begin),
		(store_faction_of_party, ":walled_center_faction", ":walled_center"),
		##diplomacy start+
		(this_or_next|eq, ":walled_center_faction", ":alt_faction"),
		##diplomacy end+
		(eq, ":walled_center_faction", "fac_player_supporters_faction"),
		(neg|party_slot_ge, ":walled_center", slot_town_lord, active_npcs_begin), #ie, player or a reserved slot
		(assign, ":walled_center_found", ":walled_center"),
	(try_end),

	(troop_get_slot, ":old_location", "$g_player_minister", slot_troop_cur_center),
	(troop_set_slot, "$g_player_minister", slot_troop_cur_center, ":walled_center_found"),

	(try_begin),
		(neq, ":old_location", ":walled_center"),
		(str_store_party_name, s10, ":walled_center"),
		(str_store_troop_name, s11, "$g_player_minister"),
		(display_message, "str_s11_relocates_to_s10"),
	(try_end),

	]),


	("lord_get_home_center",
	[
      (store_script_param, ":troop_no", 1),
      (assign, ":result", -1),

		##diplomacy start+
		(assign, ":best_score", -1),
		(troop_get_slot, ":troop_original_faction", ":troop_no", slot_troop_original_faction),
		#The default script prefers towns to castles, but aside from that is
		#fairly arbitrary.  Add scores that take into account original faction
		#and so forth.
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
        (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
		  (assign, ":center_score", 10),#10 for castles, 20 for towns
		  (try_begin),
		    (is_between, ":center_no", towns_begin, towns_end),
			(assign, ":center_score", 20),
		  (try_end),
		  (try_begin),
		    (troop_slot_eq, ":troop_no", slot_troop_home, ":center_no"),
			(val_add, ":center_score", 6),
          (else_try),
			(party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":troop_no"),
			(val_add, ":center_score", 5),
		  (else_try),
		    (is_between, ":troop_original_faction", kingdoms_begin, kingdoms_end),
			(party_slot_eq, ":center_no", slot_center_original_faction, ":troop_original_faction"),
			(val_add, ":center_score", 4),
		  (try_end),
		  (gt, ":center_score", ":best_score"),
          (assign, ":result", ":center_no"),
		  (assign, ":best_score", ":center_score"),
      (try_end),
		##diplomacy end+

      #SB : add loop breaks
      (try_begin),
        (eq, ":result", -1),
        (assign, ":limit", walled_centers_end),
        (try_for_range, ":center_no", walled_centers_begin, ":limit"),
          (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
          (assign, ":result", ":center_no"),
          (assign, ":limit", walled_centers_begin),
        (try_end),
      (try_end),

      #NOTE : In old code if a lord has no walled center then home city of this lord is assigning to
      #faction leader's home city. Now I changed this to assign home cities more logical and homogeneous.
      #In new code if a lord has no walled center then his home city becomes his village's border_city.
      #This means his home city becomes owner city of his village. If he has no village then as last change
      #his home city become faction leader's home city.
      (try_begin),
        (eq, ":result", -1),

        #SB : add loop breaks
        (assign, ":limit", villages_end),
        (try_for_range, ":center_no", villages_begin, ":limit"),
          (eq, ":result", -1),
          (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),

          # (try_begin),
            # (neg|is_between, ":center_no", walled_centers_begin, walled_centers_end),
          (party_get_slot, ":bound_center", ":center_no", slot_village_bound_center),
          (assign, ":result", ":bound_center"),
          (assign, ":limit", villages_begin),
          # (try_end),
        (try_end),
      (try_end),

      #If lord has no walled center and is player faction, then assign player court
      (try_begin),
        (eq, ":result", -1),
        (store_faction_of_troop, ":faction_no", ":troop_no"),
        (eq, ":faction_no", "fac_player_supporters_faction"),
		(is_between, "$g_player_court", walled_centers_begin, walled_centers_end),
		(store_faction_of_party, ":player_court_faction", "$g_player_court"),
		(eq, ":player_court_faction", "fac_player_supporters_faction"),

        (assign, ":result", "$g_player_court"),
      (try_end),

      #If lord has no walled center and any not walled village then assign faction capital
      (try_begin),
        (eq, ":result", -1),
        (store_faction_of_troop, ":faction_no", ":troop_no"),
        (faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),
        (neq, ":troop_no", ":faction_leader"),
        (ge, ":faction_leader", 0),#<- Fix for ticket 36.
        ##By the way, if this was Native, the following two lines would fix
        ##the weird bug where relatives of exiled lords start accumulating
        ##in the player's court:
        #(this_or_next|neq, ":faction_leader", ":troop_no"),
        #(eq, "$players_kingdom", ":faction_no"),
        ##This is unnecessary in Diplomacy, though, since I initialize slot_faction_leader to -1
        ##to distinguish factions led by the player from factions without actual leaders.
        (call_script, "script_lord_get_home_center", ":faction_leader"),
        (gt, reg0, -1),
        (assign, ":result", reg0),
      (try_end),

	  #Any center of the faction
      (try_begin),
        (eq, ":result", -1),
		(store_faction_of_troop, ":faction_no", ":troop_no"),

		(try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
		    (eq, ":result", -1),

			(store_faction_of_party, ":center_faction", ":walled_center"),
			(eq, ":faction_no", ":center_faction"),
			(assign, ":result", ":walled_center"),
		(try_end),
      (try_end),



      (assign, reg0, ":result"),
	]),




	("get_kingdom_lady_social_determinants", #Calradian society is rather patriarchal, at least among the upper classes
    [
	(store_script_param, ":kingdom_lady", 1),

	(store_faction_of_troop, ":faction_of_lady", ":kingdom_lady"),
	(assign, ":center", -1),
	(assign, ":closest_male_relative", -1),
	(assign, ":best_center_score", 0),

	##diplomacy start+
	##TODO: Re-implement, disabled for now.  "Don't get stuck attached to a MIA relative"
	(try_begin),
		(troop_slot_ge, ":kingdom_lady", slot_troop_spouse, 0),
		(troop_get_slot, ":closest_male_relative", ":kingdom_lady", slot_troop_spouse),
		#(neg|troop_slot_ge, ":closest_male_relative", slot_troop_occupation, slto_retirement),#added: has not been removed from play
	(else_try),
		(troop_slot_ge, ":kingdom_lady", slot_troop_father, 0),
		(troop_get_slot, ":closest_male_relative", ":kingdom_lady", slot_troop_father),
		#(neg|troop_slot_ge, ":closest_male_relative", slot_troop_occupation, slto_retirement),#added: has not been removed from play
	(else_try),
		#added
		(troop_slot_ge, ":kingdom_lady", slot_troop_mother, 0),
		(troop_get_slot, ":closest_male_relative", ":kingdom_lady", slot_troop_mother),
		(troop_slot_eq, ":closest_male_relative", slot_troop_occupation, slto_kingdom_hero),
	(else_try),
		(troop_slot_ge, ":kingdom_lady", slot_troop_guardian, 0),
		(troop_get_slot, ":closest_male_relative", ":kingdom_lady", slot_troop_guardian),
		#(neg|troop_slot_ge, ":closest_male_relative", slot_troop_occupation, slto_retirement),#added: has not been removed from play
	(try_end),
	##diplomacy end+

	##diplomacy start+
    #Avoid strange problems if the argument is not a kingdom lady.
	(try_begin),
		(this_or_next|is_between, ":kingdom_lady", kingdom_ladies_begin, kingdom_ladies_end),
			(troop_slot_eq, ":kingdom_lady", slot_troop_occupation, slto_kingdom_lady),
		(neg|troop_slot_eq, ":kingdom_lady", slot_troop_occupation, slto_kingdom_hero),
		(assign, ":is_lady", 1),
	(else_try),
		(assign, ":is_lady", 0),
		(assign, ":closest_male_relative", ":kingdom_lady"),# is doing this useful for the way this script is used, or should we just set it to -1?
	(try_end),

	##OLD:
	#(try_begin), #if ongoing social event (maybe add if not besieged)
	##NEW:
	(try_begin),
		(eq, ":is_lady", 0),
		(call_script, "script_lord_get_home_center", ":kingdom_lady"),
		(assign, ":center", reg0),
		(is_between, ":center", walled_centers_begin, walled_centers_end),
	(else_try), #if ongoing social event (maybe add if not besieged)
	##diplomacy end+
		(faction_slot_eq, ":faction_of_lady", slot_faction_ai_state, sfai_feast),
		(faction_get_slot, ":feast_center", ":faction_of_lady", slot_faction_ai_object),

		(gt, ":closest_male_relative", -1),
		(troop_get_slot, ":closest_male_party", ":closest_male_relative", slot_troop_leaded_party),
		(party_is_active, ":closest_male_party"),
		(party_get_attached_to, ":closest_male_cur_location", ":closest_male_party"),

		(eq, ":closest_male_cur_location", ":feast_center"),
		(is_between, ":feast_center", walled_centers_begin, walled_centers_end),

		(assign, ":center", ":feast_center"),

	(else_try),
		(troop_slot_eq, "trp_player", slot_troop_spouse, ":kingdom_lady"),
		###diplomacy begin
    (try_begin),
    ##diplomacy end
		(is_between, "$g_player_court", walled_centers_begin, walled_centers_end),
		(assign, ":center", "$g_player_court"),
		##diplomacy begin
    (else_try),
      (troop_get_slot, ":cur_residence", ":kingdom_lady", slot_troop_cur_center),
      (is_between, ":cur_residence", walled_centers_begin, walled_centers_end),
      (party_slot_eq, ":cur_residence", slot_town_lord, "trp_player"),
      (assign, ":center", ":cur_residence"),
    (try_end),
    (is_between, ":center",  walled_centers_begin, walled_centers_end),
    ##diplomacy end
	(else_try),
		(try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
			(store_faction_of_party, ":walled_center_faction", ":walled_center"),
			(this_or_next|eq, ":faction_of_lady", ":walled_center_faction"),
				(neg|is_between, ":faction_of_lady", kingdoms_begin, kingdoms_end), #lady married to a player without a faction

			(party_get_slot, ":castle_lord", ":walled_center", slot_town_lord),

			(gt, ":castle_lord", -1),

			(call_script, "script_troop_get_family_relation_to_troop", ":kingdom_lady", ":castle_lord"),
			##diplomacy start+
			(try_begin),
				(eq, ":is_lady", 0),
				(eq, ":castle_lord", ":kingdom_lady"),
				(val_max, reg0, 16),
			(try_end),
			##diplomacy end+

			(try_begin),
				(this_or_next|is_between, ":faction_of_lady", kingdoms_begin, kingdoms_end),
					(troop_slot_eq, "trp_player", slot_troop_spouse, ":kingdom_lady"),

				(faction_slot_eq, ":faction_of_lady", slot_faction_leader, ":castle_lord"),
				(val_max, reg0, 1),
			(try_end),

			(try_begin),
				(eq, "$cheat_mode", 2),
				(str_store_troop_name, s3, ":kingdom_lady"),
				(str_store_troop_name, s4, ":castle_lord"),
				(str_store_party_name, s5, ":walled_center"),
				(display_message, "str_checking_s3_at_s5_with_s11_relationship_with_s4_score_reg0"),
				(str_clear, s11),
			(try_end),

			(gt, reg0, ":best_center_score"),

			(assign, ":best_center_score", reg0),
			(assign, ":center", ":walled_center"),


	    (try_end),
	(try_end),

	(assign, reg0, ":closest_male_relative"),
	(assign, reg1, ":center"),


	]),


	#This is probably unnecessarily complicated, but can support a multi-generational mod
	("age_troop_one_year",
    [
	(store_script_param, ":troop_no", 1),
    ##diplomacy start+ use gender script
	#(troop_get_type, ":is_female", ":troop_no"),
	(assign, ":save_reg0", reg0),
	(call_script, "script_dplmc_store_troop_is_female", ":troop_no"),
	(assign, ":is_female", reg0),
	(assign, reg0, ":save_reg0"),
	##diplomacy end+

	(troop_get_slot, ":age", ":troop_no", slot_troop_age),
	(troop_get_slot, ":appearance", ":troop_no", slot_troop_age_appearance),

	(val_add, ":age", 1),
	(store_random_in_range, ":addition", 1, 5),

	(try_begin),
		(eq, ":is_female", 1),
#		(val_add, ":addition", 2), #the women's age slider seems to produce less change than the male one - commented out: makes women look too old.
	(try_end),

	(val_add, ":appearance", ":addition"),
	(try_begin),
		(gt, ":age", 45),
		(store_attribute_level, ":strength", ":troop_no", ca_strength),
		(store_attribute_level, ":agility", ":troop_no", ca_agility),
		(store_random_in_range, ":random", 0, 50), #2% loss brings it down to about 36% by age 90, but of course can be counteracted by new level gain
		(try_begin),
			(lt, ":random", ":strength"),
			(troop_raise_attribute, ":troop_no", ca_strength, -1),
		(try_end),
		(try_begin),
			(lt, ":random", ":agility"),
			(troop_raise_attribute, ":troop_no", ca_agility, -1),
		(try_end),
	(try_end),

	(val_clamp, ":appearance", 1, 100),

	(troop_set_slot, ":troop_no", slot_troop_age, ":age"),
	(troop_set_slot, ":troop_no", slot_troop_age_appearance, ":appearance"),
	(troop_set_age, ":troop_no", ":appearance"),
	]),


	("add_lady_items",
	[
	(store_script_param, ":lady_no", 1),
	(troop_equip_items, ":lady_no"),

	(store_faction_of_troop, ":faction_no", ":lady_no"),

	(store_random_in_range, ":random", 0, 6),

	(try_begin), #assign clothes
		(this_or_next|troop_slot_eq, ":lady_no", slot_lord_reputation_type, lrep_adventurous),
			(troop_slot_eq, ":lady_no", slot_lord_reputation_type, lrep_ambitious),

		(this_or_next|troop_slot_eq, ":lady_no", slot_lord_reputation_type, lrep_adventurous),
			(lt, ":random", 2),

		(neg|troop_slot_ge, ":lady_no", slot_troop_age, 40),
		(try_begin),
			(eq, ":faction_no", "fac_kingdom_2"),
			(lt, ":random", 4),
			(troop_add_item, ":lady_no", "itm_fur_coat", 0),
		(else_try),
			(eq, ":faction_no", "fac_kingdom_3"),
			(lt, ":random", 3),
			(troop_add_item, ":lady_no", "itm_nomad_robe", 0),
		(else_try),
			(troop_add_item, ":lady_no", "itm_nomad_vest", 0),
		(try_end),
	(else_try),
		(eq, ":faction_no", "fac_kingdom_1"),
		(try_begin),
			(lt, ":random", 2),
			(troop_add_item, ":lady_no", "itm_lady_dress_ruby", 0),
		(else_try),
			(lt, ":random", 4),
			(troop_add_item, ":lady_no", "itm_lady_dress_green", 0),
		(else_try),
			(troop_add_item, ":lady_no", "itm_lady_dress_blue", 0),
		(try_end),
	(else_try),
		(eq, ":faction_no", "fac_kingdom_2"),
		(try_begin),
			(eq, ":random", 0),
			(troop_add_item, ":lady_no", "itm_blue_dress", 0),
		(else_try),
			(eq, ":random", 1),
			(troop_add_item, ":lady_no", "itm_lady_dress_green", 0),
		(else_try),
			(eq, ":random", 2),
			(troop_add_item, ":lady_no", "itm_lady_dress_blue", 0),
		(else_try),
			(lt, ":random", 5),
			(neg|troop_slot_eq, ":lady_no", slot_lord_reputation_type, lrep_conventional),
			(neg|troop_slot_eq, ":lady_no", slot_lord_reputation_type, lrep_ambitious),
			(troop_add_item, ":lady_no", "itm_peasant_dress", 0),
		(else_try),
			(lt, ":random", 5),
			(troop_add_item, ":lady_no", "itm_lady_dress_ruby", 0),
		(else_try),
			(troop_add_item, ":lady_no", "itm_court_dress", 0),
		(try_end),

	(else_try),
		(eq, ":faction_no", "fac_kingdom_3"),
		(troop_add_item, ":lady_no", "itm_khergit_lady_dress", 0),

	(else_try),
		(eq, ":faction_no", "fac_kingdom_4"),

	(else_try),
		(eq, ":faction_no", "fac_kingdom_5"),


	(try_end),
	(troop_equip_items, ":lady_no"),

	#also available:
	#itm_blue_dress
	#itm_court_dress

	#to add for khergits -- salwar/shalvar?
	#western tang costume (p105, china's golden age)
	#kipchak woman from russia book

	(try_begin), #assign headguear matched to item
		(this_or_next|troop_has_item_equipped, ":lady_no", "itm_nomad_vest"),
		(this_or_next|troop_has_item_equipped, ":lady_no", "itm_fur_coat"),
			(troop_has_item_equipped, ":lady_no", "itm_nomad_robe"),

		#assign no headgear
	(else_try),
		(this_or_next|troop_slot_eq, ":lady_no", slot_lord_reputation_type, lrep_moralist),
		(this_or_next|troop_slot_eq, ":lady_no", slot_lord_reputation_type, lrep_conventional),
			(lt, ":random", 2),


		(try_begin),
			(troop_has_item_equipped, ":lady_no", "itm_khergit_lady_dress"),
			(troop_add_item, ":lady_no", "itm_khergit_lady_hat", 0),

		(else_try),
			(troop_has_item_equipped, ":lady_no", "itm_lady_dress_ruby"),
			(troop_add_item, ":lady_no", "itm_turret_hat_ruby", 0),

			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving ruby turret hat to {s4}"),
		(else_try),
			(troop_has_item_equipped, ":lady_no", "itm_lady_dress_blue"),
			(troop_add_item, ":lady_no", "itm_turret_hat_blue", 0),

			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving blue turret hat to {s4}"),
		(else_try),
			(troop_has_item_equipped, ":lady_no", "itm_lady_dress_green"),
			(troop_add_item, ":lady_no", "itm_turret_hat_green", 0),

			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving green turret hat to {s4}"),
		(else_try),
			(troop_has_item_equipped, ":lady_no", "itm_green_dress"),
			(troop_add_item, ":lady_no", "itm_wimple_with_veil", 0),

			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving green-lined wimple to {s4}"),
		(else_try),
			(neq, ":faction_no", "fac_kingdom_3"),
			(neq, ":faction_no", "fac_kingdom_6"),
			(troop_add_item, ":lady_no", "itm_wimple_a", 0),

			(str_store_troop_name, s4, ":lady_no"),
#			(display_message, "@Giving red-lined wimple to {s4}"),
		(else_try),
			(eq, ":faction_no", "fac_kingdom_6"),
			(try_begin),
				(troop_has_item_equipped, ":lady_no", "itm_sarranid_lady_dress"),
				(troop_add_item, ":lady_no", "itm_sarranid_head_cloth", 0),
			(else_try),
				(troop_add_item, ":lady_no", "itm_sarranid_head_cloth_b", 0),
			(try_end),
		(try_end),
	(try_end),
	(troop_equip_items, ":lady_no"),
	##diplomacy start+
	##Save personal items of kingdom ladies
	(call_script, "script_dplmc_save_civilian_clothing", ":lady_no"),
	##diplomacy end+
	]
	),

	("init_troop_age",
	[
	(store_script_param, ":troop_no", 1),
	(store_script_param, ":age", 2), #minimum 20

	(try_begin),
		(gt, ":age", 20),
		(troop_set_slot, ":troop_no", slot_troop_age, 20),
	(else_try),
		(troop_set_slot, ":troop_no", slot_troop_age, ":age"),
	(try_end),

	(store_sub, ":years_to_age", ":age", 20),
    (troop_set_age, ":troop_no", 0),

	(try_begin),
		(gt, ":years_to_age", 0),
		(try_for_range, ":unused", 0, ":years_to_age"),
			(call_script, "script_age_troop_one_year", ":troop_no"),
		(try_end),
	(try_end),

	]),


	("assign_troop_love_interests", #Called at the beginning, or whenever a lord is spurned
    [
	(store_script_param, ":cur_troop", 1),
    ##diplomacy start+
	#wrap the entire thing in a try-statement: do nothing when called erroneously
	(assign, ":save_reg0", reg0),
	(assign, ":save_reg1", reg1),
	(try_begin),
	(this_or_next|is_between, ":cur_troop", lords_begin, lords_end),
	(this_or_next|is_between, ":cur_troop", companions_begin, companions_end),
	(troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),#kingdom heroes only
	(troop_slot_eq, ":cur_troop", slot_troop_spouse, -1),#not married, engaged
	(troop_slot_eq, ":cur_troop", slot_troop_betrothed, -1),

	#avoid unintentional erroneous pairings (intentional exceptions can be added)
	#(troop_get_type, ":troop_type", ":cur_troop"),
	(call_script, "script_dplmc_store_troop_is_female", ":cur_troop"),
	(assign, ":troop_type", reg0),

	(try_begin),
	    #Certain personality types don't care about flouting convention.
		(this_or_next|troop_slot_eq, ":cur_troop", slot_lord_reputation_type, lrep_debauched),
        (this_or_next|troop_slot_eq, ":cur_troop", slot_lord_reputation_type, lrep_roguish),
        (troop_slot_eq, ":cur_troop", slot_lord_reputation_type, lrep_adventurous),
		(assign, ":troop_type", abs(tf_male) + abs(tf_female) + 1),#guaranteed not to equal tf_male or tf_female
	(try_end),
	(store_faction_of_troop, ":troop_faction", ":cur_troop"),
	#assign default initial courtships for companions
	(try_begin),
		(is_between, ":cur_troop", companions_begin, companions_end),
        (troop_get_slot, ":cur_lady", ":cur_troop", slot_troop_personalitymatch_object),
        (is_between, ":cur_lady", heroes_begin, heroes_end),

		(store_faction_of_troop, ":lady_faction", ":cur_lady"),
		(eq, ":troop_faction", ":lady_faction"),
		#(call_script, "script_troop_get_family_relation_to_troop", ":cur_troop", ":cur_lady"),
		(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":cur_troop", ":cur_lady"),
		(lt, reg0, 2),#check not a close relative
        #(troop_get_type, reg0, ":cur_lady"),
		(call_script, "script_dplmc_store_troop_is_female", ":cur_lady"),
        (neq, ":troop_type", reg0),#check gender compatability
		(neq, ":cur_lady", ":cur_troop"),#check not yourself
		(neg|troop_slot_ge, ":cur_lady", slot_troop_occupation, slto_retirement),#check in the game and not retired, exiled, dead, etc.
		(troop_slot_ge, ":cur_lady", slot_troop_occupation, slto_kingdom_hero),
		(call_script, "script_troop_get_relation_with_troop", ":cur_troop", ":cur_lady"),
		(ge, reg0, 0), #do not develop love interest if already spurned (but DO allow re-courting)

		(neg|troop_slot_eq, ":cur_troop", slot_troop_love_interest_1, ":cur_lady"),
		(neg|troop_slot_eq, ":cur_troop", slot_troop_love_interest_2, ":cur_lady"),
		(neg|troop_slot_eq, ":cur_troop", slot_troop_love_interest_3, ":cur_lady"),
		(try_begin),
		    (this_or_next|troop_slot_eq, ":cur_troop", slot_troop_love_interest_1, -1),
			(troop_slot_eq, ":cur_troop", slot_troop_love_interest_1, 0),
			(troop_set_slot, ":cur_troop", slot_troop_love_interest_1, ":cur_lady"),
		(else_try),
		    (this_or_next|troop_slot_eq, ":cur_troop", slot_troop_love_interest_2, -1),
			(troop_slot_eq, ":cur_troop", slot_troop_love_interest_2, 0),
			(troop_set_slot, ":cur_troop", slot_troop_love_interest_2, ":cur_lady"),
		(else_try),
		    (this_or_next|troop_slot_eq, ":cur_troop", slot_troop_love_interest_3, -1),
			(troop_slot_eq, ":cur_troop", slot_troop_love_interest_3, 0),
			(troop_set_slot, ":cur_troop", slot_troop_love_interest_3, ":cur_lady"),
		(try_end),
    (try_end),
    ##diplomacy end+
	(try_for_range, ":unused", 0, 50),
		(store_random_in_range, ":cur_lady", kingdom_ladies_begin, kingdom_ladies_end),
		(troop_slot_eq, ":cur_lady", slot_troop_spouse, -1),
		(store_faction_of_troop, ":lady_faction", ":cur_lady"),
		(eq, ":troop_faction", ":lady_faction"),
		##diplomacy start+
		##(call_script, "script_troop_get_family_relation_to_troop", ":cur_troop", ":cur_lady"),
        (call_script, "script_dplmc_troop_get_family_relation_to_troop", ":cur_troop", ":cur_lady"),
		#(eq, reg0, 0),
		#right now nothing gives a value of 1, but change this check in case more distant relations are reported
		(lt, reg0, 2),#check not a close relative
		#(troop_get_type, reg0, ":cur_lady"),
		(call_script, "script_dplmc_store_troop_is_female", ":cur_lady"),
        (neq, ":troop_type", reg0),#check gender compatability
		(neq, ":cur_lady", ":cur_troop"),#check not yourself
		(neg|troop_slot_ge, ":cur_lady", slot_troop_occupation, slto_retirement),#check in the game and not retired, exiled, dead, etc.
		(troop_slot_ge, ":cur_lady", slot_troop_occupation, slto_kingdom_hero),
        ##diplomacy end+
		(call_script, "script_troop_get_relation_with_troop", ":cur_troop", ":cur_lady"),

		(eq, reg0, 0), #do not develop love interest if already spurned or courted

		(neg|troop_slot_eq, ":cur_troop", slot_troop_love_interest_1, ":cur_lady"),
		(neg|troop_slot_eq, ":cur_troop", slot_troop_love_interest_2, ":cur_lady"),
		(neg|troop_slot_eq, ":cur_troop", slot_troop_love_interest_3, ":cur_lady"),
	##diplomacy start+ also allow -1 to signify no-one courted
		(try_begin),
			(this_or_next|troop_slot_eq, ":cur_troop", slot_troop_love_interest_1, -1),#< added
			(troop_slot_eq, ":cur_troop", slot_troop_love_interest_1, 0),
			(troop_set_slot, ":cur_troop", slot_troop_love_interest_1, ":cur_lady"),
		(else_try),
			(this_or_next|troop_slot_eq, ":cur_troop", slot_troop_love_interest_2, -1),#< added
			(troop_slot_eq, ":cur_troop", slot_troop_love_interest_2, 0),
			(troop_set_slot, ":cur_troop", slot_troop_love_interest_2, ":cur_lady"),
		(else_try),
			(this_or_next|troop_slot_eq, ":cur_troop", slot_troop_love_interest_3, -1),#< added
			(troop_slot_eq, ":cur_troop", slot_troop_love_interest_3, 0),
			(troop_set_slot, ":cur_troop", slot_troop_love_interest_3, ":cur_lady"),
		(try_end),
	(try_end),
        (try_end),
	(assign, reg1, ":save_reg1"),
	(assign, reg0, ":save_reg0"),#revert register
	##diplomacy end+
	]),

	("faction_conclude_feast",
	[
	(store_script_param, ":faction_no", 1),
	(store_script_param, ":venue", 2),

	(str_store_faction_name, s3, ":faction_no"),
	(str_store_party_name, s4, ":venue"),

    (try_begin),
        (eq, "$cheat_mode", 1),
	    (display_message, "str_s3_feast_concludes_at_s4"),
    (try_end),

	(try_begin),
		(eq, ":faction_no", "fac_player_faction"),
		(assign, ":faction_no", "$players_kingdom"),
	(try_end),

	(party_set_slot, ":venue", slot_town_has_tournament, 0),

	#markspot

	(assign, ":nobility_in_faction", 0),
	(assign, ":nobility_in_attendance", 0),

	(try_for_range, ":troop_no", active_npcs_begin, kingdom_ladies_end),
		(store_faction_of_troop, ":troop_faction", ":troop_no"),
		(eq, ":faction_no", ":troop_faction"),

		(val_add, ":nobility_in_faction", 1),

		#CHECK -- is the troop there?
		(troop_slot_eq, ":troop_no", slot_troop_cur_center, ":venue"),
		(val_add, ":nobility_in_attendance", 1),

		#check for marriages
		##diplomacy start+ enable marriages for non-kingdom ladies (for example, between two companions)
		(this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_robber_knight),
		(this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
		(this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_seneschal),
		(this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_player_companion),
		##diplomacy end+
		(troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_lady),
		(troop_get_slot, ":groom", ":troop_no", slot_troop_betrothed),
		(gt, ":groom", 0),

		(troop_get_slot, ":groom_party", ":groom", slot_troop_leaded_party),
		(party_is_active, ":groom_party"),
		(party_get_attached_to, ":groom_party_attached", ":groom_party"),
		(eq, ":groom_party_attached", ":venue"),

		(store_faction_of_troop, ":lady_faction", ":troop_no"),
		(store_faction_of_troop, ":groom_faction", ":groom"),

		(eq, ":groom_faction", ":lady_faction"),
		(eq, ":lady_faction", ":faction_no"),
		(store_current_hours, ":hours_since_betrothal"),
		(troop_get_slot, ":betrothal_time", ":troop_no", slot_troop_betrothal_time),
		(val_sub, ":hours_since_betrothal", ":betrothal_time"),
		(ge, ":hours_since_betrothal", 144), #6 days, should perhaps eventually be 29 days, or 696 yours

		(call_script, "script_get_kingdom_lady_social_determinants", ":troop_no"),
		(assign, ":wedding_venue", reg1),
        ##diplomacy start+ be less picky about where to hold the feast as time goes on
		#(eq, ":venue", ":wedding_venue"),
		(neq, ":troop_no", "trp_player"),
		(neq, ":groom", "trp_player"),
		(party_get_slot, ":town_lord", ":venue", slot_town_lord),
		(assign, ":hold_the_wedding", 0),
		(try_begin),
			#after 6 days, will be held if the venue is the ideal one
			(eq, ":venue", ":wedding_venue"),
			(assign, ":hold_the_wedding", 1),
		(else_try),
			#after 6 days, will be held if the bride's father/guardian holds a feast
			(ge, ":town_lord", 0),
			(this_or_next|troop_slot_eq, ":troop_no", slot_troop_father, ":town_lord"),
			(this_or_next|troop_slot_eq, ":troop_no", slot_troop_mother, ":town_lord"),
			   (troop_slot_eq, ":troop_no", slot_troop_guardian, ":town_lord"),
			(assign, ":hold_the_wedding", 1),
		(else_try),
			#after 20 days, will be held if the bride, the groom, or either of their
			#parents hold a feast
			(ge, ":hours_since_betrothal", 24 * 20),
			(ge, ":town_lord", 0),
			(this_or_next|eq, ":troop_no", ":town_lord"),
			(this_or_next|eq, ":groom", ":town_lord"),
			(this_or_next|troop_slot_eq, ":groom", slot_troop_father, ":town_lord"),
			   (troop_slot_eq, ":groom", slot_troop_mother, ":town_lord"),
			(assign, ":hold_the_wedding", 1),
		(else_try),
			#after 60 days, if against all odds the engagement hasn't been called off,
			#the faction leader qualifies, as does any relative
			(ge, ":hours_since_betrothal", 24 * 60),
			(ge, ":town_lord", 0),
			#(call_script, "script_troop_get_family_relation_to_troop", ":town_lord", ":troop_no"),
			(call_script, "script_dplmc_troop_get_family_relation_to_troop",  ":town_lord", ":troop_no"),
			(assign, ":bride_relation", reg0),
			#(call_script, "script_troop_get_family_relation_to_troop", ":town_lord", ":groom"),
			(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":town_lord", ":groom"),
			(this_or_next|faction_slot_eq, ":troop_faction", slot_faction_leader, ":town_lord"),
			(this_or_next|ge, reg0, 1),
				(ge, ":bride_relation", 1),
			(assign, ":hold_the_wedding", 1),
		(try_end),
		(eq, ":hold_the_wedding", 1),
		##diplomacy end+
		(call_script, "script_courtship_event_bride_marry_groom", ":troop_no", ":groom", 0), #parameters from dialog
	(try_end),


#ssss	(assign, ":placeholder_reminder_to_calculate_effect_for_player_feast", 1),



	(party_get_slot, ":feast_host", ":venue", slot_town_lord),
	(assign, ":quality_of_feast", 0),

	(try_begin),
		(check_quest_active, "qst_organize_feast"),
		(quest_slot_eq, "qst_organize_feast", slot_quest_target_center, ":venue"),
		(assign, ":feast_host", "trp_player"),

		(assign, ":total_guests", 400),

		(call_script, "script_succeed_quest", "qst_organize_feast"),
		(call_script, "script_end_quest", "qst_organize_feast"),

		(call_script, "script_internal_politics_rate_feast_to_s9", "trp_household_possessions", ":total_guests", "$players_kingdom", 1),
		(assign, ":quality_of_feast", reg0),
	(else_try),
		(assign, ":quality_of_feast", 60),
	(try_end),


	(try_begin),
		(ge, "$cheat_mode", 1),
		(str_store_troop_name, s4, ":feast_host"),
		(assign, reg4, ":quality_of_feast"),
		(display_message, "@{!}DEBUG - {s4}'s feast has rating of {reg4}"),
	(try_end),


	(try_begin),
	  (ge, ":feast_host", 0),
	  (store_div, ":renown_boost", ":quality_of_feast", 3),
	  (call_script, "script_change_troop_renown", ":feast_host", ":renown_boost"),

	  (try_for_range, ":troop_no", active_npcs_begin, active_npcs_end),
		(troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
		(troop_get_slot, ":leaded_party", ":troop_no", slot_troop_leaded_party),
		(party_is_active, ":leaded_party"),
		(party_get_attached_to, ":leaded_party_attached", ":leaded_party"),
		(eq, ":leaded_party_attached", ":venue"),

		(assign, ":relation_booster", ":quality_of_feast"),
		(val_div, ":relation_booster", 20),

		(try_begin),
			(eq, ":feast_host", "trp_player"),
			(val_sub, ":relation_booster", 1),
			(val_max, ":relation_booster", 0),
		(try_end),
		(call_script, "script_troop_change_relation_with_troop", ":feast_host", ":troop_no", ":relation_booster"),
		(val_add, "$total_feast_changes", ":relation_booster"),
	  (try_end),
	(try_end),


	(assign, reg3, ":nobility_in_attendance"),
	(assign, reg4, ":nobility_in_faction"),

	(try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "str_attendance_reg3_nobles_out_of_reg4"),
	(try_end),
	]),

	("lady_evaluate_troop_as_suitor",
	[
	(store_script_param, ":lady", 1),
	(store_script_param, ":suitor", 2),

	(call_script, "script_troop_get_romantic_chemistry_with_troop", ":lady", ":suitor"),
	(assign, ":romantic_chemistry", reg0),

	(try_begin),
      (call_script, "script_cf_test_lord_incompatibility_to_s17", ":lady", ":suitor"),
    (try_end),

	(store_sub, ":personality_modifier", 0, reg0),
	(assign, reg2, ":personality_modifier"),

	(try_begin),
		(troop_get_slot, ":renown_modifier", ":suitor", slot_troop_renown),
		(val_div, ":renown_modifier", 20),
		(try_begin),
			(this_or_next|troop_slot_eq, ":lady", slot_lord_reputation_type, lrep_conventional),
				(troop_slot_eq, ":lady", slot_lord_reputation_type, lrep_ambitious),
			(val_mul, ":renown_modifier", 2),
			(val_sub, ":renown_modifier", 15),
		(try_end),
	(try_end),

	(store_add, ":final_score", ":renown_modifier", ":personality_modifier"),
	(val_add, ":final_score", ":romantic_chemistry"),
	(assign, reg0, ":final_score"),
	]),

	("courtship_event_troop_court_lady",
	[
	(store_script_param, ":suitor", 1),
	(store_script_param, ":lady", 2),


	#(try_begin),
	  #(eq, "$cheat_mode", 1),
	  #(str_store_troop_name, s4, ":suitor"),
	  #(str_store_troop_name, s5, ":lady"),
	  #(troop_get_slot, ":lady_location", ":lady", slot_troop_cur_center),
	  #(str_store_party_name, s7, ":lady_location"),
	  #(display_message, "str_s4_pursues_suit_with_s5_in_s7"),
	#(try_end),

	(troop_get_slot, ":previous_suitor", ":lady", slot_lady_last_suitor),
	(troop_set_slot, ":lady", slot_lady_last_suitor, ":suitor"), #can determine quarrels

	(try_begin),
		(eq, ":previous_suitor", "trp_player"),

		(troop_slot_ge, ":lady", slot_troop_met, 2),
		(call_script, "script_troop_get_relation_with_troop", ":suitor", "trp_player"), #add this to list of quarrels
		(assign, ":suitor_relation_w_player", reg0),

		(try_begin),
			(this_or_next|troop_slot_eq, ":suitor", slot_lord_reputation_type, lrep_selfrighteous),
			(this_or_next|troop_slot_eq, ":suitor", slot_lord_reputation_type, lrep_quarrelsome),
				(troop_slot_eq, ":suitor", slot_lord_reputation_type, lrep_debauched),
			(gt, ":suitor_relation_w_player", -20),
			(call_script, "script_add_log_entry", logent_lords_quarrel_over_woman, ":suitor", "trp_player", ":lady", 0),
		(else_try),
			(is_between, ":suitor_relation_w_player", -5, -25),
			(call_script, "script_add_log_entry", logent_lords_quarrel_over_woman, ":suitor", "trp_player", ":lady", 0),
		(try_end),
	(else_try),
		(neq, ":previous_suitor", "trp_player"), #not the player

		(neq, ":suitor", ":previous_suitor"),
		(ge, ":previous_suitor", active_npcs_begin),

		(call_script, "script_cf_test_lord_incompatibility_to_s17", ":suitor", ":previous_suitor"),
		(call_script, "script_add_log_entry", logent_lords_quarrel_over_woman, ":suitor", ":previous_suitor", ":lady", 0),

		(call_script, "script_troop_get_relation_with_troop", ":suitor", ":previous_suitor"), #add this to list of quarrels
		(ge, reg0, 0),
		(call_script, "script_troop_change_relation_with_troop", ":suitor", ":previous_suitor", -20),
		(val_add, "$total_courtship_quarrel_changes", -20),
	(else_try),	 #quarrelsome lords quarrel anyway
		(troop_slot_eq, ":suitor", slot_lord_reputation_type, lrep_quarrelsome),
		(neq, ":suitor", ":previous_suitor"),
		(ge, ":previous_suitor", active_npcs_begin),

#		(neq, ":previous_suitor", "trp_player"),

		(call_script, "script_troop_get_relation_with_troop", ":suitor", ":previous_suitor"), #add this to list of quarrels
		(lt, reg0, 10),
		(call_script, "script_add_log_entry", logent_lords_quarrel_over_woman, ":suitor", ":previous_suitor", ":lady", 0),
		(ge, reg0, 0),
		(call_script, "script_troop_change_relation_with_troop", ":suitor", ":previous_suitor", -20),
		(val_add, "$total_courtship_quarrel_changes", -20),

	(try_end),


#	(call_script, "script_troop_get_relation_with_troop", ":lady", ":suitor"),
#	(assign, ":orig_relation", reg0),

    (call_script, "script_lady_evaluate_troop_as_suitor", ":lady", ":suitor"),

	(store_random_in_range, ":random", 5, 16),
	(store_div, ":relationship_change", reg0, ":random"),

	(call_script, "script_troop_get_relation_with_troop", ":lady", ":suitor"),
	(assign, ":orig_relation", reg0),

	(call_script, "script_troop_change_relation_with_troop", ":lady", ":suitor", ":relationship_change"),

	(call_script, "script_troop_get_relation_with_troop", ":lady", ":suitor"),
	(assign, ":lady_suitor_relation", reg0),

	(try_begin),
		(ge, ":lady_suitor_relation", 10),
		(lt, ":orig_relation", 10),
		(call_script, "script_add_log_entry", logent_lady_favors_suitor, ":lady", 0, ":suitor", 0),

		(try_begin),
			(eq, "$cheat_mode", 1),
			(display_message, "str_note__favor_event_logged"),
		(try_end),

	(else_try),
		(this_or_next|lt, ":lady_suitor_relation", -20),
			(ge, ":lady_suitor_relation", 20),

		(call_script, "script_get_kingdom_lady_social_determinants", ":lady"),
		(assign, ":guardian", reg0),
		(call_script, "script_troop_get_relation_with_troop", ":suitor", ":guardian"),
		(assign, ":suitor_guardian_relation", reg0),
		#things come to a head, one way or another

		(assign, ":highest_competitor_lady_score", -1),
		(assign, ":competitor_preferred_by_lady", -1),

		(assign, ":highest_competitor_guardian_score", ":suitor_guardian_relation"),
		(assign, ":competitor_preferred_by_guardian", -1),

		#log potential competitors
		(try_for_range, ":possible_competitor", lords_begin, lords_end),
			(neq, ":possible_competitor", ":suitor"),

			(this_or_next|troop_slot_eq, ":possible_competitor", slot_troop_love_interest_1, ":lady"),
			(this_or_next|troop_slot_eq, ":possible_competitor", slot_troop_love_interest_2, ":lady"),
				(troop_slot_eq, ":possible_competitor", slot_troop_love_interest_3, ":lady"),

			(try_begin),
				(call_script, "script_troop_get_relation_with_troop", ":possible_competitor", ":lady"),
				(gt, reg0, ":highest_competitor_lady_score"),
				(assign, ":competitor_preferred_by_lady", ":possible_competitor"),
				(assign, ":highest_competitor_lady_score", reg0),
			(try_end),

			(try_begin),
				(call_script, "script_troop_get_relation_with_troop", ":possible_competitor", ":guardian"),
				(gt, reg0, ":highest_competitor_guardian_score"),
				(assign, ":competitor_preferred_by_guardian", ":possible_competitor"),
				(assign, ":highest_competitor_guardian_score", reg0),
			(try_end),
		(try_end),

		#RESULTS
		#Guardian forces lady to be betrothed to suitor now
		(try_begin),
			(lt, ":lady_suitor_relation", -20),
			(this_or_next|troop_slot_eq, ":guardian", slot_lord_reputation_type, lrep_selfrighteous),
			(this_or_next|troop_slot_eq, ":guardian", slot_lord_reputation_type, lrep_debauched),
				(troop_slot_eq, ":guardian", slot_lord_reputation_type, lrep_quarrelsome),
			(eq, ":competitor_preferred_by_guardian", -1),

			(this_or_next|troop_slot_eq, ":suitor", slot_lord_reputation_type, lrep_selfrighteous),
			(this_or_next|troop_slot_eq, ":suitor", slot_lord_reputation_type, lrep_debauched),
				(troop_slot_eq, ":suitor", slot_lord_reputation_type, lrep_quarrelsome),

			(troop_slot_eq, ":suitor", slot_troop_betrothed, -1),
			(troop_slot_eq, ":lady", slot_troop_betrothed, -1),

			(call_script, "script_add_log_entry", logent_lady_betrothed_to_suitor_by_family, ":lady", 0, ":suitor", 0),
			(troop_set_slot, ":suitor", slot_troop_betrothed, ":lady"),
			(troop_set_slot, ":lady", slot_troop_betrothed, ":suitor"),
			(store_current_hours, ":hours"),
			(troop_set_slot, ":lady", slot_troop_betrothal_time, ":hours"),
			(troop_set_slot, ":suitor", slot_troop_betrothal_time, ":hours"),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_result_lady_forced_to_agree_to_engagement"),
			(try_end),

		#Lady rejects the suitor
		(else_try),
			(lt, ":lady_suitor_relation", -20),

			(call_script, "script_add_log_entry", logent_lady_rejects_suitor, ":lady", 0, ":suitor", 0),
			(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":lady", ":suitor"),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_result_lady_rejects_suitor"),
			(try_end),

		#A happy engagement, with parental blessing
		(else_try),
			(gt, ":lady_suitor_relation", 20),
			(gt, ":suitor_guardian_relation", 0),
			(eq, ":competitor_preferred_by_lady", -1),

			(troop_slot_eq, ":suitor", slot_troop_betrothed, -1),
			(troop_slot_eq, ":lady", slot_troop_betrothed, -1),

			(call_script, "script_add_log_entry", logent_lady_betrothed_to_suitor_by_choice, ":lady", 0, ":suitor", 0),
			(troop_set_slot, ":suitor", slot_troop_betrothed, ":lady"),
			(troop_set_slot, ":lady", slot_troop_betrothed, ":suitor"),
			(store_current_hours, ":hours"),
			(troop_set_slot, ":lady", slot_troop_betrothal_time, ":hours"),
			(troop_set_slot, ":suitor", slot_troop_betrothal_time, ":hours"),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":lady"),
				(str_store_troop_name, s5, ":suitor"),
				(display_message, "str_result_happy_engagement_between_s4_and_s5"),
			(try_end),

		#Lady elopes
		(else_try),
			(gt, ":lady_suitor_relation", 20),

			(eq, ":competitor_preferred_by_lady", -1),
			##diplomacy start+
			##Fix Native bug, the following line should be checking ":lady", not ":guardian"
			##OLD:
			#(this_or_next|troop_slot_eq, ":guardian", slot_lord_reputation_type, lrep_adventurous),
			#	(troop_slot_eq, ":guardian", slot_lord_reputation_type, lrep_ambitious),
			##NEW:
			(this_or_next|troop_slot_eq, ":lady", slot_lord_reputation_type, lrep_adventurous),
				(troop_slot_eq, ":lady", slot_lord_reputation_type, lrep_ambitious),
			##diplomacy end+

			(troop_slot_eq, ":suitor", slot_troop_betrothed, -1),
			(troop_slot_eq, ":lady", slot_troop_betrothed, -1),

			#lady elopes
			(call_script, "script_courtship_event_bride_marry_groom", ":lady", ":suitor", 1),
			#add elopements to quarrel descriptions

			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":lady"),
				(str_store_troop_name, s5, ":suitor"),
				(display_message, "str_result_s4_elopes_with_s5"),
			(try_end),

		#Lady reluctantly agrees to marry under pressure from family
		(else_try),
			(troop_slot_eq, ":lady", slot_lord_reputation_type, lrep_conventional),
			(eq, ":competitor_preferred_by_guardian", -1),
			(gt, ":suitor_guardian_relation", 4),

			(store_random_in_range, ":random", 0, 5),
			(eq, ":random", 0),

			(troop_slot_eq, ":suitor", slot_troop_betrothed, -1),
			(troop_slot_eq, ":lady", slot_troop_betrothed, -1),

			(call_script, "script_add_log_entry", logent_lady_betrothed_to_suitor_by_pressure, ":lady", 0, ":suitor", 0),
			(troop_set_slot, ":suitor", slot_troop_betrothed, ":lady"),
			(troop_set_slot, ":lady", slot_troop_betrothed, ":suitor"),
			(store_current_hours, ":hours"),
			(troop_set_slot, ":lady", slot_troop_betrothal_time, ":hours"),
			(troop_set_slot, ":suitor", slot_troop_betrothal_time, ":hours"),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(str_store_troop_name, s4, ":lady"),
				(str_store_troop_name, s5, ":suitor"),
				(display_message, "str_result_s4_reluctantly_agrees_to_engagement_with_s5"),
			(try_end),

		#Stalemate -- make patience roll
		(else_try),
			(gt, ":lady_suitor_relation", 20),

			(store_random_in_range, reg3, 0, 3),
			(try_begin),
				(eq, "$cheat_mode", 1),
				(display_message, "str_result_stalemate_patience_roll_=_reg3"),
			(try_end),

			(eq, reg3, 0),
			(call_script, "script_add_log_entry", logent_lady_rejected_by_suitor, ":lady", 0, ":suitor", 0),
			(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":lady", ":suitor"),
		(try_end),

	(try_end),

	]),



	("courtship_event_lady_break_relation_with_suitor", #parameters from dialog
	[
	(store_script_param, ":lady", 1),
	(store_script_param, ":suitor", 2),

	(try_for_range, ":love_interest_slot", slot_troop_love_interest_1, slot_troop_love_interests_end),
		(troop_slot_eq, ":suitor", ":love_interest_slot", ":lady"),
		##diplomacy start+ set to -1 instead, since 0 is the player (how annoying)
		#(troop_set_slot, ":suitor", ":love_interest_slot", 0),
		(troop_set_slot, ":suitor", ":love_interest_slot", -1),
		##diplomacy end+
	(try_end),
	(call_script, "script_assign_troop_love_interests", ":suitor"),

	(try_begin),
		(troop_slot_eq, ":lady", slot_troop_betrothed, ":suitor"),


		(troop_set_slot, ":lady", slot_troop_betrothed, -1),
	##diplomacy start+ perform the same check for the suitor that was done,
	#for the lady, so this script has no unfortunate consequences even if
	#called inappropriately.
	(try_end),
	(try_begin),
		(troop_slot_eq, ":suitor", slot_troop_betrothed, ":lady"),
		(troop_set_slot, ":suitor", slot_troop_betrothed, -1),
	##diplomacy end+
	(try_end),


	]),


	("courtship_event_bride_marry_groom", #parameters from dialog or scripts
	[
	(store_script_param, ":bride", 1),
	(store_script_param, ":groom", 2),
	(store_script_param, ":elopement", 3),

	(try_begin),
		(eq, ":bride", "trp_player"),
		(assign, ":venue", "$g_encountered_party"),
	(else_try),
		(troop_get_slot, ":venue", ":bride", slot_troop_cur_center),
		##diplomacy start+
		#Ensure there is a venue.
		(lt, ":venue", 1),
		(troop_get_slot, ":venue", ":groom", slot_troop_cur_center),
		##diplomacy end+
	(try_end),

	(store_faction_of_troop, ":groom_faction", ":groom"),


	(try_begin),
		(eq, ":elopement", 0),
		(call_script, "script_add_log_entry", logent_lady_marries_suitor, ":bride", ":venue", ":groom", 0),
	(else_try),
		(call_script, "script_add_log_entry", logent_lady_elopes_with_lord, ":bride", ":venue", ":groom", 0),
	(try_end),

	(str_store_troop_name, s3, ":bride"),
	(str_store_troop_name, s4, ":groom"),
	(str_store_party_name, s5, ":venue"),

	(try_begin),
	##diplomacy start+ this should be globally-visible for notable personages
	#    (this_or_next|is_between, ":groom_faction", kingdoms_begin, kingdoms_end),
	#    (this_or_next|troop_slot_ge, ":groom", slot_troop_met, 1),
	#    (troop_slot_ge, ":bride", slot_troop_met, 1),
		(display_log_message, "str_s3_marries_s4_at_s5"),
	#(else_try),
    #    (eq, "$cheat_mode", 1),
	#    (display_message, "str_s3_marries_s4_at_s5"),
	##diplomacy end+
    (try_end),

	(troop_set_slot, ":bride", slot_troop_spouse, ":groom"),
	(troop_set_slot, ":groom", slot_troop_spouse, ":bride"),

	#Break groom's romantic relations
	(try_for_range, ":love_interest_slot", slot_troop_love_interest_1, slot_troop_love_interests_end),
		(troop_set_slot, ":groom", ":love_interest_slot", 0),
	(try_end),

	#Break bride's romantic relations
	(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
		(try_for_range, ":love_interest_slot", slot_troop_love_interest_1, slot_troop_love_interests_end),
			(troop_slot_eq, ":active_npc", ":love_interest_slot", ":bride"),
			(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":bride", ":active_npc"),
		(try_end),
	(try_end),



	(troop_set_slot, ":bride", slot_troop_betrothed, -1),
	(troop_set_slot, ":groom", slot_troop_betrothed, -1),



    #change relations with family
	##diplomacy start+ Include kingdom ladies
	#(try_for_range, ":family_member", lords_begin, lords_end),
	(try_for_range, ":family_member", heroes_begin, heroes_end),
		(neq, ":family_member", ":bride"),
		(neq, ":family_member", ":groom"),
	##diplomacy end+
		(call_script, "script_troop_get_family_relation_to_troop", ":bride", ":family_member"),
		(gt, reg0, 0),
		(store_div, ":family_relation_boost", reg0, 3),
		(try_begin),
			(eq, ":elopement", 1),
			(val_mul, ":family_relation_boost", -2),
		(try_end),
		##diplomacy start+ Fix error!  Change relation between groom and family member, not groom and bride.
		#(call_script, "script_troop_change_relation_with_troop", ":groom", ":bride", ":family_relation_boost"),
			(call_script, "script_troop_change_relation_with_troop", ":groom", ":family_member", ":family_relation_boost"),
		##diplomacy end+
		(val_add, "$total_courtship_quarrel_changes", ":family_relation_boost"),
	(try_end),

	(try_begin),
		(this_or_next|eq, ":groom", "trp_player"),
			(eq, ":bride", "trp_player"),
		##diplomacy start+ fix bug where player didn't get right to rule
		(call_script, "script_change_player_right_to_rule", 15),##one argument, not two
		##diplomacy end+
	(try_end),


	(try_begin),
		(eq, ":groom", "trp_player"),
		(check_quest_active, "qst_wed_betrothed"),
		(call_script, "script_succeed_quest", "qst_wed_betrothed"),
		(call_script, "script_end_quest", "qst_wed_betrothed"),
	(try_end),


	(try_begin),
		(check_quest_active, "qst_visit_lady"),
		(quest_slot_eq, "qst_visit_lady", slot_quest_giver_troop, ":bride"),
		(call_script, "script_abort_quest", "qst_visit_lady", 0),
	(try_end),


	(try_begin),
		(eq, ":groom", "trp_player"),
		(neq, "$g_polygamy", 1),
		(check_quest_active, "qst_visit_lady"),
		(call_script, "script_abort_quest", "qst_visit_lady", 0),
	(try_end),
	(try_begin),
		(eq, ":groom", "trp_player"),
		(neq, "$g_polygamy", 1),
		(check_quest_active, "qst_duel_courtship_rival"),
		(call_script, "script_abort_quest", "qst_duel_courtship_rival", 0),
	(try_end),


	(try_begin),
		(eq, ":bride", "trp_player"),
	    (call_script, "script_player_join_faction", ":groom_faction"),
		(assign, "$player_has_homage", 1),
	(else_try),
		(eq, ":groom", "trp_player"),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":bride"),
			(display_message, "@{!} DEBUG - {s4} faction change in marriage case 5"),
		(try_end),
		(troop_set_faction, ":bride", "$players_kingdom"),
        (call_script, "script_troop_set_title_according_to_faction", ":bride", "$players_kingdom"),
	(else_try),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":bride"),
			(display_message, "@{!}DEBUG - {s4} faction changed by marriage, case 6"),
		(try_end),

		(troop_set_faction, ":bride", ":groom_faction"),
        (call_script, "script_troop_set_title_according_to_faction", ":bride", ":groom_faction"),
	(try_end),

    (try_begin),
        (this_or_next|eq, ":groom", "trp_player"),
           (eq, ":bride", "trp_player"),
        (unlock_achievement, ACHIEVEMENT_HAPPILY_EVER_AFTER),
		(try_begin),
			(eq, ":elopement", 1),
			(unlock_achievement, ACHIEVEMENT_HEART_BREAKER),
		(try_end),
    (try_end),



    (try_begin),
        (this_or_next|eq, ":groom", "trp_player"),
           (eq, ":bride", "trp_player"),

        (try_begin),
            (eq, ":elopement", 0),
            (call_script, "script_start_wedding_cutscene", ":groom", ":bride"),
        (else_try), #dckplmc: elope
             (assign, "$g_wedding_groom_troop", ":groom"),
             (assign, "$g_wedding_bride_troop", ":bride"),
             (assign, "$g_wedding_brides_dad_troop", "trp_nurse_for_lady"),
             (assign, "$g_wedding_bishop_troop", "trp_temporary_minister"),

             (modify_visitors_at_site,"scn_wedding"),
             (reset_visitors,0),
             (set_visitor, 0, ":groom"),
             (set_visitor, 1, ":bride"),
             (set_visitor, 2, "trp_nurse_for_lady"),
             (set_visitor, 3, "trp_temporary_minister"),
             (set_jump_mission,"mt_wedding"),
             (jump_to_scene,"scn_wedding"),
             (change_screen_mission),
         (try_end),
    (try_end),
	]),


    #script_npc_decision_checklist_party_ai
	# DECISION CHECKLISTS (OCT 14)
	# I was thinking of trying to convert as much AI decision-making as possible to the checklist format
	# While outcomes are not as nuanced and varied as a random decision using weighted chances for each outcoms,
	# the checklist has the advantage of being much more transparent, both to developers and to players
	# The checklist can yield a string (standardized to s14) which explains the rationale for the decision
	# When the script yields a yes/no/maybe result, than that is standardized from -3 to +3
    # INPUT: troop_no
    # OUTPUT: none
	("npc_decision_checklist_party_ai",
	[
	#this script can replace decide_kingdom_hero_ai and decide_kingdom_hero_ai_follow_or_not
	#However, it does not contain script_party_set_ai_state

	(store_script_param, ":troop_no", 1),

	(troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
    #(party_get_slot, ":our_strength", ":party_no", slot_party_cached_strength),
    #(store_div, ":min_strength_behind", ":our_strength", 2),
    #(party_get_slot, ":our_follower_strength", ":party_no", slot_party_follower_strength),

    (try_begin),
      (eq, "$cheat_mode", 1),
      (assign, "$g_talk_troop", ":troop_no"),
    (try_end),

    (store_troop_faction, ":faction_no", ":troop_no"),
    ##diplomacy start+
    #Get the centralization value for use below.  It should be a value in [-3,3].
    #A centralization value of 0 should not result in any behavior change.
    (try_begin),
       #If the player altered the kingdom policy, always apply its effects to
       #the AI of his kingdom's lords.
       (call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", ":faction_no"),
       (ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
       (faction_get_slot, ":centralization", ":faction_no", dplmc_slot_faction_centralization),
       (val_clamp, ":centralization", -3, 4),
    (else_try),
       #Currently, do not apply centralization to the AI for NPC kingdoms, since
       #NPC rulers set their policies randomly and do not gain the same monthly
       #relation bonuses/penalties from centralization that the player does.
       (assign, ":centralization", 0),
    (try_end),
    ##diplomacy end+

    (try_begin),
      (eq, ":troop_no", "$g_talk_troop"),
      (str_store_string, s15, "str__i_must_attend_to_this_matter_before_i_worry_about_the_affairs_of_the_realm"),
    (try_end),

    #find current center
    (party_get_attached_to, ":cur_center_no", ":party_no"),
    (try_begin),
      (lt, ":cur_center_no", 0),
      (party_get_cur_town, ":cur_center_no", ":party_no"),
    (try_end),
    (assign, ":besieger_party", -1),
    (try_begin),
      (neg|is_between, ":cur_center_no", centers_begin, centers_end),
      (assign, ":cur_center_no", -1),
    (else_try),
      (party_get_slot, ":besieger_party", ":cur_center_no", slot_center_is_besieged_by),
      (try_begin),
        (neg|party_is_active, ":besieger_party"),
        (assign, ":besieger_party", -1),
      (try_end),
    (try_end),

    #party_count
    (call_script, "script_party_count_fit_for_battle", ":party_no"),
    (assign, ":party_fit_for_battle", reg0),
    (call_script, "script_party_get_ideal_size", ":party_no"),
    (assign, ":ideal_size", reg0),
    (store_mul, ":party_strength_as_percentage_of_ideal", ":party_fit_for_battle", 100),
    (val_div, ":party_strength_as_percentage_of_ideal", ":ideal_size"),
    (try_begin),
      (faction_slot_eq, ":faction_no", slot_faction_num_towns, 0),
      (faction_slot_eq, ":faction_no", slot_faction_num_castles, 0),
      (assign, ":party_ratio_of_prisoners", 0), #do not let prisoners have an effect on ai calculation
    (else_try),
      (party_get_num_prisoners, ":num_prisoners", ":party_no"),
      (val_max, ":party_fit_for_battle", 1), #avoid division by zero error
      (store_div, ":party_ratio_of_prisoners", ":num_prisoners", ":party_fit_for_battle"),
    (try_end),

	(assign, ":faction_is_at_war", 0),
	(try_for_range, ":kingdom", kingdoms_begin, kingdoms_end),
	  (faction_slot_eq, ":kingdom", slot_faction_state, sfs_active),
	  (store_relation, ":relation", ":faction_no", ":kingdom"),
	  (lt, ":relation", 0),
	  (assign, ":faction_is_at_war", 1),
	(try_end),

	(assign, ":operation_in_progress", 0),
	(try_begin),
	  (this_or_next|party_slot_eq, ":party_no", slot_party_ai_state, spai_raiding_around_center),
	  (party_slot_eq, ":party_no", slot_party_ai_state, spai_besieging_center),

	  (party_get_slot, ":target_center", ":party_no", slot_party_ai_object),
	  (is_between, ":target_center", centers_begin, centers_end),

	  (store_faction_of_party, ":target_center_faction", ":target_center"),
	  (store_relation, ":relation", ":faction_no", ":target_center_faction"),
	  (lt, ":relation", 0),

	  (store_distance_to_party_from_party, ":distance", ":party_no", ":target_center"),
	  (lt, ":distance", 10),
	  (this_or_next|party_slot_eq, ":target_center", slot_village_state, svs_under_siege),
	  (this_or_next|party_slot_eq, ":target_center", slot_village_state, svs_normal),
	  (party_slot_eq, ":target_center", slot_village_state, svs_being_raided),

	  (assign, ":operation_in_progress", 1),
	(try_end),

	(troop_get_slot, ":troop_reputation", ":troop_no", slot_lord_reputation_type),

    (party_get_slot, ":old_ai_state", ":party_no", slot_party_ai_state),
    (party_get_slot, ":old_ai_object", ":party_no", slot_party_ai_object),

	(party_get_slot, ":party_cached_strength", ":party_no", slot_party_cached_strength),

	(store_current_hours, ":hours_since_last_rest"),
	(party_get_slot, ":last_rest_time", ":party_no", slot_party_last_in_any_center),
	(val_sub, ":hours_since_last_rest", ":last_rest_time"),

	(store_current_hours, ":hours_since_last_home"),
	(party_get_slot, ":last_home_time", ":party_no", slot_party_last_in_home_center),
	(val_sub, ":hours_since_last_home", ":last_home_time"),

	(store_current_hours, ":hours_since_last_combat"),
	(party_get_slot, ":last_combat_time", ":party_no", slot_party_last_in_combat),
	(val_sub, ":hours_since_last_combat", ":last_combat_time"),

	(store_current_hours, ":hours_since_last_courtship"),
	(party_get_slot, ":last_courtship_time", ":party_no", slot_party_leader_last_courted),
	(val_sub, ":hours_since_last_courtship", ":last_courtship_time"),

    (troop_get_slot, ":temp_ai_seed", ":troop_no", slot_troop_temp_decision_seed),
    (store_mod, ":aggressiveness", ":temp_ai_seed", 73), #To derive the
    (try_begin),
      (eq, ":troop_reputation", lrep_martial),
      (val_add, ":aggressiveness", 27),
    (else_try),
      (neq, ":troop_reputation", lrep_debauched),
      (neq, ":troop_reputation", lrep_quarrelsome),
      (val_add, ":aggressiveness", 14),
    (try_end),

    (try_begin),
      (gt, ":aggressiveness", ":hours_since_last_combat"),
      (val_add, ":aggressiveness", ":hours_since_last_combat"),
      (val_div, ":aggressiveness", 2),
    (try_end),

    (try_begin),
      (eq, "$cheat_mode", 1), #100
      (eq, ":troop_no", "$g_talk_troop"),
      (str_store_troop_name, s4, ":troop_no"),
      (assign, reg3, ":hours_since_last_rest"),
      (assign, reg4, ":hours_since_last_courtship"),
      (assign, reg5, ":hours_since_last_combat"),
      (assign, reg6, ":hours_since_last_home"),
      (assign, reg7, ":aggressiveness"),
      #(display_message, "@{!}{s4}: hours since rest {reg3}, courtship {reg4}, combat {reg5}, home {reg6}, aggressiveness {reg7}"),
    (try_end),

	##I am inspecting an estate (use slot_center_npc_volunteer_troop_amount)

	(str_store_string, s17, "str_the_other_matter_took_precedence"),

	(assign, ":do_only_collecting_rents", 0),

	#Wait in current city (dangerous to travel with less (<=10) men)
	(try_begin),
      #NOTE : I added also this condition to very top of list. Because if this condition does not exists in top then a bug happens.
      #Bug is about alone wounded lords without any troop near him travels between cities, sometimes it want to return his home city
      #to collect reinforcements, sometimes it want to patrol ext, but his party is so weak even without anyone. So we sometimes see
      #(0/1) parties in map with only one wounded lord inside. Because after wars completely defeated lords spawn again in a walled center
      #in 48 hours periods (by codes in module_simple_trigers). He spawns with only wounded himself. Then he should wait in there for
      #a time to collect new men to his (0/1) party. If a lord is the only one in his party and if he is at any walled center already then he
      #should stay where he is. He should not travel to anywhere because of any reason. If he is the only one and he is wounded and
      #he is not in any walled center this means this situation happens because of one another bug, because any lord cannot be out of
      #walled centers with wounded himself only. So I am adding this condition below.

      #SUMMARY : If lord has not got enought troops (<10 || <10%) with himself and he is currently at a walled center he should not leave
      #his current center because of any reason.

      (ge, ":cur_center_no", 0),

      (this_or_next|le, ":party_fit_for_battle", 10),
      (le, ":party_strength_as_percentage_of_ideal", 30),

      (assign, ":action", spai_holding_center),
      (assign, ":object", ":cur_center_no"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_need_to_raise_some_men_before_attempting_anything_else"),
	    (str_store_string, s16, "str_i_need_to_raise_some_men_before_attempting_anything_else"),
	  (try_end),

	#Stand in a siege
	(else_try),
	  (gt, ":besieger_party", -1),

	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":cur_center_no"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_cannot_leave_this_fortress_now_as_it_is_under_siege"),
	    (str_store_string, s16, "str_after_all_we_are_under_siege"),
	  (try_end),

	#Continue retreat to walled center
	(else_try),
	  (eq, ":old_ai_state", spai_retreating_to_center),
	  (neg|party_is_in_any_town, ":party_no"),

	  (ge, ":old_ai_object", 0),
	  (party_is_active, ":old_ai_object"),

	  (store_faction_of_party, ":retreat_center_faction", ":old_ai_object"),
	  (eq, ":faction_no", ":retreat_center_faction"),

	  (assign, ":action", spai_retreating_to_center),
	  (assign, ":object", ":old_ai_object"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_we_are_not_strong_enough_to_face_the_enemy_out_in_the_open"),
	    (str_store_string, s16, "str_i_should_probably_seek_shelter_behind_some_stout_walls"),
	  (try_end),

	#Stand by in current center against enemies
	(else_try),
	  (is_between, ":cur_center_no", walled_centers_begin, walled_centers_end),

	  (party_get_slot, ":enemy_strength_in_area", ":cur_center_no", slot_center_sortie_enemy_strength),
	  (party_get_slot, ":enemy_strength_in_area", ":cur_center_no", slot_center_sortie_enemy_strength),
	  (ge, ":enemy_strength_in_area", 50),

	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":cur_center_no"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_enemies_are_reported_to_be_nearby_and_we_should_stand_ready_to_either_man_the_walls_or_sortie_out_to_do_battle"),
	    (str_store_string, s16, "str_the_enemy_is_nearby"),
	  (try_end),

	#As the marshall, lead faction campaign
	(else_try),
	  (faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),
	  (str_clear, s15), #Does not say that overrides faction orders
	  (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_gathering_army),

	  (party_set_ai_initiative, ":party_no", 10),

	  #new ozan added - active gathering
	  #this code will allow marshal to travel around cities while gathering army if currently collected are less than 60%.
	  #By ratio increases travel distances become less. Travels will be only points around walled centers.
	  (party_get_slot, ":old_ai_object", ":party_no", slot_party_ai_object),
	  (assign, ":travel_target", ":old_ai_object"),

      (call_script, "script_find_center_to_defend", ":troop_no"),
	  (assign, ":most_threatened_center", reg0),
	  (assign, ":travel_target_new_assigned", 0),

      (try_begin),
        (lt, ":old_ai_object", 0),

        (store_random_in_range, ":random_value", 0, 8), #to eanble marshal to wait sometime during active gathering
        (this_or_next|eq, "$g_gathering_new_started", 1),
        (eq, ":random_value", 0),

        (assign, ":vassals_already_assembled", 0),
        (assign, ":total_vassals", 0),
        (try_for_range, ":lord", active_npcs_begin, active_npcs_end),
          (store_faction_of_troop, ":lord_faction", ":lord"),
          (eq, ":lord_faction", ":faction_no"),
          (troop_get_slot, ":led_party", ":lord", slot_troop_leaded_party),
          (party_is_active, ":led_party"),
          (val_add, ":total_vassals", 1),

          (party_slot_eq, ":led_party", slot_party_ai_state, spai_accompanying_army),
          (party_slot_eq, ":led_party", slot_party_ai_object, ":party_no"),

          (party_is_active, ":party_no"),
          (store_distance_to_party_from_party, ":distance_to_marshal", ":led_party", ":party_no"),
          (lt, ":distance_to_marshal", 15),
          (val_add, ":vassals_already_assembled", 1),
        (try_end),

        (assign, ":ratio_of_vassals_assembled", -1),
        (try_begin),
          (gt, ":total_vassals", 0),
          (store_mul, ":ratio_of_vassals_assembled", ":vassals_already_assembled", 100),
          (val_div, ":ratio_of_vassals_assembled", ":total_vassals"),
        (try_end),

        (try_begin),
          #if more than 35% of vassals already collected do not make any more active gathering, just hold and wait last vassals to participate.
          (le, ":ratio_of_vassals_assembled", 35),

          (assign, ":best_center_to_travel", ":most_threatened_center"),

          (try_begin),
            (eq, "$g_gathering_new_started", 1),

            (assign, ":minimum_distance", 100000),
            (try_for_range, ":center_no", centers_begin, centers_end),
              (store_faction_of_party, ":center_faction", ":center_no"),
              (eq, ":center_faction", ":faction_no"), #200
              (try_begin),
                (neq, ":center_no", ":most_threatened_center"),
                (store_distance_to_party_from_party, ":dist", ":party_no", ":center_no"),
                (lt, ":dist", ":minimum_distance"),
                (assign, ":minimum_distance", ":dist"),
                (assign, ":best_center_to_travel", ":center_no"),
              (try_end),
            (try_end),
          (else_try),
            #active gathering
            (assign, ":max_travel_distance", 150),
            (try_begin),
              (ge, ":ratio_of_vassals_assembled",15),
              (store_sub, ":max_travel_distance", 35, ":ratio_of_vassals_assembled"),
              (val_add, ":max_travel_distance", 5), #5..25
              (val_mul, ":max_travel_distance", 6), #30..150
            (try_end),

            (try_begin),
              (ge, ":most_threatened_center", 0),
              (store_distance_to_party_from_party, reg12, ":party_no", ":most_threatened_center"),
            (else_try),
              (assign, reg12, 0),
            (try_end),

            (assign, ":num_centers", 0),
            (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
              (store_faction_of_party, ":center_faction", ":center_no"),
              (eq, ":center_faction", ":faction_no"),
              (try_begin),
                #(ge, ":max_travel_distance", 0),
                (store_distance_to_party_from_party, ":dist", ":party_no", ":center_no"),

                (try_begin),
                  (ge, ":most_threatened_center", 0),
                  (store_distance_to_party_from_party, reg13, ":center_no", ":most_threatened_center"),
                (else_try),
                  (assign, reg13, 0),
                (try_end),

                (store_sub, reg11, reg13, reg12),

                (this_or_next|ge, reg11, 40),
                (this_or_next|ge, ":dist", ":max_travel_distance"),
                (eq, ":center_no", ":most_threatened_center"),
              (else_try),
                #this center is a candidate so increase num_centers by one.
                (val_add, ":num_centers", 1),
              (try_end),
            (try_end),

            (try_begin),
              (ge, ":num_centers", 0),
              (store_random_in_range, ":random_center_no", 0, ":num_centers"),
              (val_add, ":random_center_no", 1),
              (assign, ":num_centers", 0),
              (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
                (store_faction_of_party, ":center_faction", ":center_no"),
                (eq, ":center_faction", ":faction_no"),
                (try_begin),
                  (neq, ":center_no", ":most_threatened_center"),
                  (store_distance_to_party_from_party, ":dist", ":party_no", ":center_no"),
                  (lt, ":dist", ":max_travel_distance"),

                  (try_begin),
                    (ge, ":most_threatened_center", 0),
                    (store_distance_to_party_from_party, reg13, ":center_no", ":most_threatened_center"),
                  (else_try),
                    (assign, reg13, 0),
                  (try_end),

                  (store_sub, reg11, reg13, reg12),
                  (lt, reg11, 40),

                  (val_sub, ":random_center_no", 1),
                  (eq, ":random_center_no", 0),
                  (assign, ":best_center_to_travel", ":center_no"),
                (try_end),
              (try_end),
            (try_end),
          (try_end),

          (assign, ":travel_target", ":best_center_to_travel"),
          (assign, ":travel_target_new_assigned", 1),
        (try_end),
      (else_try),
        #if party has an ai object and they are close to that object while gathering army,
        #forget that ai object so they will select a new ai object next.
        (is_between, ":old_ai_object", centers_begin, centers_end),
        (party_get_position, pos1, ":party_no"),
        (party_get_position, pos2, ":old_ai_object"),
        (get_distance_between_positions, ":dist", pos1, pos2),
        (le, ":dist", 3),
        (assign, ":travel_target", -1),
      (try_end),
      #end ozan

      (try_begin),
        (eq, ":travel_target", -1),
        (assign, ":action", spai_undefined),
      (else_try),
        (assign, ":action", spai_visiting_village),
      (try_end),

      (assign, ":object", ":travel_target"),

      (try_begin),
        (eq, ":troop_no", "$g_talk_troop"),
        (try_begin),
          (eq, ":travel_target", -1),
          (str_store_string, s14, "str_as_the_marshall_i_am_assembling_the_army_of_the_realm"),
        (else_try),
          (try_begin),
            (eq, ":faction_no", "$players_kingdom"),
            (eq, ":travel_target_new_assigned", 1),
            (le, "$number_of_report_to_army_quest_notes", 13),
            (check_quest_active, "qst_report_to_army"),
            (str_store_party_name_link, s10, ":travel_target"),

            (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall), #300

            (str_store_troop_name_link, s11, ":faction_marshal"),
            (store_current_hours, ":hours"),
            (call_script, "script_game_get_date_text", 0, ":hours"),

            (str_store_string, s14, "str_as_the_marshall_i_am_assembling_the_army_of_the_realm_and_travel_to_lands_near_s10_to_inform_more_vassals"),
            (str_store_string, s14, "@({s1}) {s11}: {s14}"),
            (add_quest_note_from_sreg, "qst_report_to_army", "$number_of_report_to_army_quest_notes", s14, 0),
            (val_add, "$number_of_report_to_army_quest_notes", 1),
          (try_end),

          (assign, reg0, ":travel_target"),
          (str_store_party_name, s10, ":travel_target"),
          (str_store_string, s14, "str_as_the_marshall_i_am_assembling_the_army_of_the_realm_and_travel_to_lands_near_s10_to_inform_more_vassals"),
        (try_end),
        (str_store_string, s16, "str_i_intend_to_assemble_the_army_of_the_realm"),
      (try_end),
	(else_try),
	  (faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),
	  (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_center),
	  (faction_get_slot, ":faction_object", ":faction_no", slot_faction_ai_object),

	  (assign, ":action", spai_besieging_center),
	  (assign, ":object", ":faction_object"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_as_the_marshall_i_am_leading_the_siege"),
	    (str_store_string, s16, "str_i_intend_to_begin_the_siege"),
	  (try_end),

	(else_try),
	  (faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),
	  (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_raiding_village),
	  (faction_get_slot, ":faction_object", ":faction_no", slot_faction_ai_object),

	  (assign, ":action", spai_raiding_around_center),
	  (assign, ":object", ":faction_object"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_as_the_marshall_i_am_leading_our_raid"),
	    (str_store_string, s16, "str_i_intend_to_start_our_raid"),
	  (try_end),

	(else_try),
	  (faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),
	  (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemies_around_center),
	  (faction_get_slot, ":faction_object", ":faction_no", slot_faction_ai_object),
	  (party_is_active, ":faction_object"),

	  #moved (party_set_ai_initiative, ":party_no", 10), #new to avoid losing time of marshal with attacking unimportant targets while there is a threat in our centers.

	  (party_get_battle_opponent, ":besieger_party", ":faction_object"),

	  (try_begin),
	    (gt, ":besieger_party", 0),
        (party_is_active, ":besieger_party"),

	    (assign, ":action", spai_engaging_army),
	    (assign, ":object", ":besieger_party"),
	    (try_begin),
          (eq, ":troop_no", "$g_talk_troop"),
          (str_store_string, s14, "str_as_the_marshall_i_am_leading_our_forces_to_engage_the_enemy_in_battle"),
          (str_store_string, s16, "str_i_intend_to_lead_our_forces_out_to_engage_the_enemy"),
        (try_end),
      (else_try),
        (assign, ":action", spai_patrolling_around_center),
        (assign, ":object", ":faction_object"),
        (try_begin),
          (eq, ":troop_no", "$g_talk_troop"),
          (str_store_string, s14, "str_as_the_marshall_i_am_leading_our_forces_in_search_of_the_enemy"),
          (str_store_string, s16, "str_i_intend_to_lead_our_forces_out_to_find_the_enemy"),
        (try_end),
      (try_end),

    (else_try),
      (faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),
      (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemy_army),
      (faction_get_slot, ":faction_object", ":faction_no", slot_faction_ai_object),
      (party_is_active, ":faction_object"),

      (assign, ":action", spai_engaging_army),
      (assign, ":object", ":faction_object"),
      (try_begin),
        (eq, ":troop_no", "$g_talk_troop"),
        (str_store_string, s14, "str_as_the_marshall_i_am_leading_our_forces_to_engage_the_enemy_in_battle"),
        (str_store_string, s16, "str_i_intend_to_lead_our_forces_out_to_engage_the_enemy"),
      (try_end),

	#Get reinforcements
	(else_try),
	  (assign, ":lowest_acceptable_strength_percentage", 30),

	  #if troop has enought gold then increase by 10%
	  #(troop_get_slot, ":cur_wealth", ":troop_no", slot_troop_wealth),
	  #(try_begin),
	  #  (ge, ":cur_wealth", 2000),
	  #  (assign, ":wealth_addition", 10),
	  #(else_try),
	  #  (store_div, ":wealth_addition", ":cur_wealth", 200),
	  #(try_end),
	  #(val_add, ":lowest_acceptable_strength_percentage", ":wealth_addition"),

	  (call_script, "script_lord_get_home_center", ":troop_no"),
	  (assign, ":home_center", reg0),
	  (gt, ":home_center", -1),
	  (party_slot_eq, ":home_center", slot_town_lord, ":troop_no"), #newly added

	  #if troop is very close to its home center increase by 20%
	  (assign, ":distance_addition", 0),
	  (party_get_position, pos0, ":home_center"),
	  (party_get_position, pos1, ":party_no"),
	  (get_distance_between_positions, ":dist", pos0, pos1),

	  (try_begin),
	    (le, ":dist", 9000),
	    (store_div, ":distance_addition", ":dist", 600),
	    (store_sub, ":distance_addition", 15, ":distance_addition"),
	  (else_try),
	    (assign, ":distance_addition", 0),
	  (try_end),
	  (val_add, ":lowest_acceptable_strength_percentage", ":distance_addition"),

	  #if there is no campaign for faction increase by 35%
	  (assign, ":no_campaign_addition", 35),
	  (try_begin),
	    (this_or_next|faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemy_army),
	    (this_or_next|faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemies_around_center),
	    (this_or_next|faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_raiding_village),
	    (this_or_next|faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_center),
	    (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_gathering_army),
	    (assign, ":no_campaign_addition", 0),

	    #If marshal is player itself and if there is a campaign then lower lowest_acceptable_strength_percentage by 10 instead of not changing it.
	    #Because players become confused when they see very less participation from AI lords to their campaigns.
	    (try_begin), #400
	      (faction_slot_eq, ":faction_no", slot_faction_marshall, "trp_player"),
	      (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
	      (try_begin),
	        (eq, ":reduce_campaign_ai", 0), #hard
	        (assign, ":no_campaign_addition", 0),
	      (else_try),
	        (eq, ":reduce_campaign_ai", 1), #medium
	        (assign, ":no_campaign_addition", -10),
	      (else_try),
	        (eq, ":reduce_campaign_ai", 2), #easy
	        (assign, ":no_campaign_addition", -15),
	      (try_end),
	    (try_end),
	  (try_end),
	  (val_add, ":lowest_acceptable_strength_percentage", ":no_campaign_addition"),
  	  (val_max, ":lowest_acceptable_strength_percentage", 25),

	  #max : 30%+15%+35% = 80% (happens when there is no campaign and player is near to its home center.)
	  (lt, ":party_strength_as_percentage_of_ideal", ":lowest_acceptable_strength_percentage"),

	  (try_begin),
	    (store_div, ":lowest_acceptable_strength_percentage_div_3", ":lowest_acceptable_strength_percentage", 3),
	    (ge, ":party_strength_as_percentage_of_ideal", ":lowest_acceptable_strength_percentage_div_3"),
	    (troop_get_slot, ":troop_wealth", ":troop_no", slot_troop_wealth),
	    (le, ":troop_wealth", 1800),
	    (assign, ":do_only_collecting_rents", 1),
	  (try_end),

	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":home_center"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_dont_have_enough_troops_and_i_need_to_get_some_more"),

	    (str_store_string, s16, "str_i_am_running_low_on_troops"),
	  (try_end),

	  (eq, ":do_only_collecting_rents", 0),

	#follow player orders
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (party_slot_ge, ":party_no", slot_party_following_orders_of_troop, "trp_kingdom_heroes_including_player_begin"),

	  (party_get_slot, ":orders_type", ":party_no", slot_party_orders_type),
	  (party_get_slot, ":orders_object", ":party_no", slot_party_orders_object),
	  (party_get_slot, ":orders_time", ":party_no", slot_party_orders_time),

	  (ge, ":orders_object", 0),

	  (store_current_hours, ":hours_since_orders_given"),
	  (val_sub, ":hours_since_orders_given", ":orders_time"),
     ##diplomacy start+ If the player set the Centralization value, modify the
     #maximum time vassals will follow commands by a maximum of +/- 25%
     #(normally the maximum is 48 hours, so that would be +/- 12 hours).
     (store_mul, reg0, ":centralization", 4),
     (val_clamp, reg0, -12, 12),#<-- This should be unnecessary
     (val_sub, ":hours_since_orders_given", reg0),
     ##diplomacy end+

	  (party_is_active, ":orders_object"),
	  (party_get_slot, ":object_state", ":orders_object", slot_village_state),
	  (store_faction_of_party, ":object_faction", ":orders_object"),
	  (store_relation, ":relation_with_object", ":faction_no", ":object_faction"),

	  (assign, ":orders_are_appropriate", 1),
	  (try_begin),
	    (gt, ":hours_since_orders_given", 48),
	    (assign, ":orders_are_appropriate", 0),
	  (else_try),
	    (eq, ":orders_type", spai_raiding_around_center),
	    (this_or_next|ge, ":relation_with_object", 0),
	    (ge, ":object_state", 2),
	    (assign, ":orders_are_appropriate", 0),
	  (else_try),
	    (eq, ":orders_type", spai_besieging_center),
	    (ge, ":relation_with_object", 0),
	    (assign, ":orders_are_appropriate", 0),
	  (else_try),
	    (this_or_next|eq, ":orders_type", spai_holding_center),
	    (this_or_next|eq, ":orders_type", spai_retreating_to_center),
	    (this_or_next|eq, ":orders_type", spai_accompanying_army),
	    (eq, ":orders_type", spai_visiting_village),
	    (le, ":relation_with_object", 0),
	    (assign, ":orders_are_appropriate", 0),
	  (try_end),

	  (eq, ":orders_are_appropriate", 1),

	  (assign, ":action", ":orders_type"),
	  (assign, ":object", ":orders_object"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_we_are_following_your_direction"),
	  (try_end),

	#Host of player wedding
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (eq, ":operation_in_progress", 0),
	  (check_quest_active, "qst_wed_betrothed"),
	  (quest_slot_eq, "qst_wed_betrothed", slot_quest_giver_troop, ":troop_no"),
	  (quest_get_slot, ":bride", "qst_wed_betrothed", slot_quest_target_troop),
	  (call_script, "script_get_kingdom_lady_social_determinants", ":bride"),
	  (assign, ":wedding_venue", reg1),

	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":wedding_venue"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_need_to_make_preparations_for_your_wedding"),
	    (str_store_string, s16, "str_after_all_i_need_to_make_preparations_for_your_wedding"),
	  (try_end),

	#Bridegroom at player wedding
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (eq, ":operation_in_progress", 0),
	  (check_quest_active, "qst_wed_betrothed_female"),
	  (quest_slot_eq, "qst_wed_betrothed_female", slot_quest_giver_troop, ":troop_no"),

	  (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_feast),
	  (faction_get_slot, ":feast_venue", ":faction_no", slot_faction_ai_object),

	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":feast_venue"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_am_heading_to_the_site_of_our_wedding"), #500
	    (str_store_string, s16, "str_after_all_we_are_soon_to_be_wed"),
	  (try_end),

	#Host of other feast
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (eq, ":operation_in_progress", 0),
	  (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_feast),
	  (faction_get_slot, ":feast_venue", ":faction_no", slot_faction_ai_object),
	  (party_slot_eq, ":feast_venue", slot_town_lord, ":troop_no"),

	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":feast_venue"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_am_hosting_a_feast_there"),
	    (str_store_string, s16, "str_i_have_a_feast_to_host"),
	  (try_end),

	#I am the bridegroom at a feast
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (eq, ":operation_in_progress", 0),
	  (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_feast),
	  (troop_get_slot, ":troop_betrothed", ":troop_no", slot_troop_betrothed),
	  (is_between, ":troop_betrothed", kingdom_ladies_begin, kingdom_ladies_end),

	  (faction_get_slot, ":feast_venue", ":faction_no", slot_faction_ai_object),

	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":feast_venue"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_am_to_be_the_bridegroom_there"),
	    (str_store_string, s16, "str_my_wedding_day_draws_near"),
	  (try_end),

	#Drop off prisoners
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (gt,  ":party_ratio_of_prisoners", 35),
	  (eq, ":operation_in_progress", 0),

	  (call_script, "script_lord_get_home_center", ":troop_no"),
	  (assign, ":home_center", reg0),

	  (gt, ":home_center", -1),

	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":home_center"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_have_too_much_loot_and_too_many_prisoners_and_need_to_secure_them"),
	    (str_store_string, s16, "str_i_should_think_of_dropping_off_some_of_my_prisoners"),
	  (try_end),

	#Reinforce a weak center
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (assign, ":center_to_reinforce", -1),
	  (assign, ":center_reinforce_score", 100),
	  (eq, ":operation_in_progress", 0),

	  (try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
	    (party_slot_eq, ":walled_center", slot_town_lord, ":troop_no"),
	    (party_get_slot, ":center_strength", ":walled_center", slot_party_cached_strength),
	    (lt, ":center_strength", ":center_reinforce_score"),
	    (assign, ":center_to_reinforce", ":walled_center"),
	    (assign, ":center_reinforce_score", ":center_strength"),
	  (try_end),

	  (gt, ":center_to_reinforce", -1),

	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":center_to_reinforce"),
	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_need_to_reinforce_it_as_it_is_poorly_garrisoned"),
	    (str_store_string, s16, "str_there_is_a_hole_in_our_defenses"),
	  (try_end),

	#Continue screening, if already doing so
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (eq, ":old_ai_state", spai_screening_army), #566

	  (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),
          (ge, ":faction_marshal", 0),
	  (troop_get_slot, ":marshal_party", ":faction_marshal", slot_troop_leaded_party),
	  (party_is_active, ":marshal_party"),

	  (call_script, "script_npc_decision_checklist_troop_follow_or_not", ":troop_no"),
	  (eq, reg0, 1),

	  (assign, ":action", spai_screening_army),
	  (assign, ":object", ":marshal_party"),
	  (try_begin),
	    (eq, "$g_talk_troop", ":troop_no"),
	    (str_store_string, s14, "str_i_am_following_the_marshals_orders"),
	    (str_store_string, s16, "str_the_marshal_has_given_me_this_command"),
	  (try_end),

    (else_try), #special case for sfai_attacking_enemies_around_center for village raids
      (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemies_around_center),
      (is_between, ":faction_object", villages_begin, villages_end),

      (call_script, "script_npc_decision_checklist_troop_follow_or_not", ":troop_no"),
      (eq, reg0, 1),

      (faction_get_slot, ":faction_object", ":faction_no", slot_faction_ai_object),
      (party_get_slot, ":raider_party", ":faction_object", slot_village_raided_by),
      (party_is_active, ":raider_party"),

      #think about adding one more condition here, what if raider army is so powerfull, again lords will go and engage enemy one by one?
      (party_get_slot, ":enemy_strength_nearby", ":faction_object", slot_center_sortie_enemy_strength),
      (lt, ":enemy_strength_nearby", 4000),
      #end think

      (assign, ":action", spai_engaging_army),
      (assign, ":object", ":raider_party"),
      (try_begin),
        (eq, ":troop_no", "$g_talk_troop"),
        (str_store_string, s14, "str_our_realm_needs_my_support_there_is_enemy_raiding_one_of_our_villages_which_is_not_to_far_from_here_i_am_going_there"),
        (str_store_string, s16, "str_the_marshal_has_issued_a_summons"),
      (try_end),

	#Follow the marshall's orders - if on the offensive, and the campaign has not lasted too long. Readiness is currently randomly set
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (call_script, "script_npc_decision_checklist_troop_follow_or_not", ":troop_no"),
	  (eq, reg0, 1),

	  (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),
          (ge, ":faction_marshal", 0),
	  (troop_get_slot, ":marshal_party", ":faction_marshal", slot_troop_leaded_party),

	  (assign, ":action", spai_accompanying_army),
	  (assign, ":object", ":marshal_party"),

	  (try_begin),
	    (eq, "$g_talk_troop", ":troop_no"),
	    (str_store_string, s14, "str_i_am_answering_the_marshals_summons"),
	    (str_store_string, s16, "str_the_marshal_has_issued_a_summons"),
	  (try_end),

	#Support a nearby ally who is on the offensive
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (eq, ":faction_is_at_war", 1),

	  (assign, ":party_to_support", -1),
	  (try_for_range, ":allied_hero", active_npcs_begin, active_npcs_end),
	    (troop_slot_eq, ":allied_hero", slot_troop_occupation, slto_kingdom_hero),
	    (store_faction_of_troop, ":allied_hero_faction", ":allied_hero"),
	    (eq, ":allied_hero_faction", ":faction_no"),

	    (neq, ":allied_hero", ":troop_no"),

	    (troop_get_slot, ":allied_hero_party", ":allied_hero", slot_troop_leaded_party),
	    (gt, ":allied_hero_party", 1),
	    (party_is_active, ":allied_hero_party"),


	    (this_or_next|party_slot_eq, ":allied_hero_party", slot_party_ai_state, spai_raiding_around_center),
			(party_slot_eq, ":allied_hero_party", slot_party_ai_state, spai_besieging_center),

	    (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":allied_hero"),
	    (gt, reg0, 4),

	    (troop_get_slot, ":troop_renown", ":troop_no", slot_troop_renown),
	    (troop_get_slot, ":ally_renown", ":allied_hero", slot_troop_renown),
	    (le, ":troop_renown", ":ally_renown"), #Ally to support must have higher renown

	    (store_distance_to_party_from_party, ":distance", ":party_no", ":allied_hero_party"),

	    (lt, ":distance", 5),

 	    (assign, ":party_to_support", ":allied_hero_party"),
	  (try_end),
	  (gt, ":party_to_support", 0),

	  (assign, ":action", spai_accompanying_army),
	  (assign, ":object", ":party_to_support"),
	  (try_begin),
		  (eq, ":troop_no", "$g_talk_troop"),
		  (party_stack_get_troop_id, ":leader", ":object", 0),
		  (str_store_troop_name, s10, ":leader"),

		  (call_script, "script_troop_get_family_relation_to_troop", ":leader", "$g_talk_troop"),
		  (try_begin),
		    (eq, reg0, 0),
		    (str_store_string, s11, "str_comradeinarms"),
		  (try_end),
		  (str_store_string, s14, "str_i_am_supporting_my_s11_s10"),
		  (str_store_string, s16, "str_i_believe_that_one_of_my_comrades_is_in_need"),
	  (try_end),
    #I have decided to attack a vulnerable fortress
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (eq, ":faction_is_at_war", 1),
	  (eq, ":operation_in_progress", 0),

	  (assign, ":walled_center_to_attack", -1),
	  (assign, ":walled_center_score", 50),

	  (try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
	    (store_faction_of_party, ":walled_center_faction", ":walled_center"),
	    (store_relation, ":relation", ":faction_no", ":walled_center_faction"),
	    (lt, ":relation", 0),

	    (party_get_slot, ":center_cached_strength", ":walled_center", slot_party_cached_strength),
	    (val_mul, ":center_cached_strength", 3),
	    (val_mul, ":center_cached_strength", 2),

	    (lt, ":center_cached_strength", ":party_cached_strength"),
	    (lt, ":center_cached_strength", 750),

	    (party_slot_eq, ":walled_center", slot_village_state, svs_normal),
	    (store_distance_to_party_from_party, ":distance", ":walled_center", ":party_no"),
	    (lt, ":distance", ":walled_center_score"),

	    (assign, ":walled_center_to_attack", ":walled_center"),
	    (assign, ":walled_center_score", ":distance"),
	  (try_end),

	  (is_between, ":walled_center_to_attack", centers_begin, centers_end),

	  (assign, ":action", spai_besieging_center),
	  (assign, ":object", ":walled_center_to_attack"),
	  (try_begin),
	    (eq, "$cheat_mode", 1),
	    (str_store_faction_name, s20, ":faction_no"),
	    (str_store_party_name, s21, ":object"),
	    (display_message, "str_s20_decided_to_attack_s21"),
	  (try_end),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_a_fortress_is_vulnerable"),
	    (str_store_string, s16, "str_i_believe_that_the_enemy_may_be_vulnerable"),
	  (try_end),

	#I am visiting an estate
	(else_try),
	  (assign, ":center_to_visit", -1),
	  (assign, ":score_to_beat", 300), #at least 300 gold to pick up
	  (troop_get_slot, ":troop_wealth", ":troop_no", slot_troop_wealth), #average troop wealth is 2000
	  (val_div, ":troop_wealth", 10), #average troop wealth 10% is is 200
	  (val_add, ":score_to_beat", ":troop_wealth"), #average score to beat is 500
	  (eq, ":operation_in_progress", 0),

	  (try_begin),
	    (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),

	    (assign, reg17, 0),
	    (try_begin),
	      (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
	      (party_slot_eq, ":party_no", slot_party_ai_object, ":faction_marshal"),
	      (assign, reg17, 1),
	    (else_try),
	      (party_slot_eq, ":party_no", slot_party_following_player, 1),
	      (assign, reg17, 1),
	    (try_end),
	    (eq, reg17, 1),

	    (try_begin),
	      (neq, ":faction_marshal", "trp_player"),
	      (neg|party_slot_eq, ":party_no", slot_party_following_player, 1),
	      (val_add, ":score_to_beat", 125),
	    (else_try),
	      (val_add, ":score_to_beat", 250),
	    (try_end),
	  (try_end),

	  (try_for_range, ":center_no", centers_begin, centers_end),
	    (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),

	    (assign, reg17, 0),
	    (try_begin),
	      (is_between, ":center_no", villages_begin, villages_end),
	      (party_slot_eq, ":center_no", slot_village_state, svs_normal),
	      (assign, reg17, 1),
	    (else_try),
	      (party_slot_eq, ":center_no", slot_center_is_besieged_by, -1),
	      (assign, reg17, 1),
	    (try_end),
	    (eq, reg17, 1),

	    (party_get_slot, ":tariffs_available", ":center_no", slot_center_accumulated_tariffs),
	    (party_get_slot, ":rents_available", ":center_no", slot_center_accumulated_rents),
	    (store_add, ":money_available", ":rents_available", ":tariffs_available"),

	    (gt, ":money_available", ":score_to_beat"),
	    (assign, ":center_to_visit", ":center_no"),
	    (assign, ":score_to_beat", ":money_available"),
	  (try_end),

	  (is_between, ":center_to_visit", centers_begin, centers_end),

	  (try_begin),
	    (is_between, ":center_to_visit", walled_centers_begin, walled_centers_end),
	    (assign, ":action", spai_holding_center),
	    (assign, ":object", ":center_to_visit"),
	  (else_try),
        (assign, ":action", spai_visiting_village),
  	    (assign, ":object", ":center_to_visit"),
	  (try_end),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_need_to_inspect_my_properties_and_collect_my_dues"),
	    (str_store_string, s16, "str_it_has_been_too_long_since_i_have_inspected_my_estates"),
	  (try_end),

	#My men are weary, and I wish to return home
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (this_or_next|gt, ":hours_since_last_rest", 504), #Three weeks
	  (lt, ":aggressiveness", 25),
	  (gt, ":hours_since_last_rest", 168), #one week if aggressiveness < 25
	  (eq, ":operation_in_progress", 0),

	  (call_script, "script_lord_get_home_center", ":troop_no"),
	  (assign, ":home_center", reg0),

	  (gt, ":home_center", -1),
	  (assign, ":action", spai_holding_center),
	  (assign, ":object", ":home_center"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_my_men_are_weary_so_we_are_returning_home"),
	    (str_store_string, s16, "str_my_men_are_becoming_weary"),
	  (try_end),

	#I have a score to settle with the enemy
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (this_or_next|gt, ":hours_since_last_combat", 12),
	  (lt, ":hours_since_last_rest", 96),
	  (eq, ":operation_in_progress", 0),

	  (eq, ":faction_is_at_war", 1),
	  ##diplomacy start+ roguish lords can also do this, but humanitarian lords of any kind won't
	  (call_script, "script_dplmc_get_troop_morality_value", ":troop_no", tmt_humanitarian),
	  (lt, reg0, 1),
	  (this_or_next|eq, ":troop_reputation", lrep_roguish),
	  ##diplomacy end+
	  (this_or_next|eq, ":troop_reputation", lrep_debauched),
	  (eq, ":troop_reputation", lrep_quarrelsome),

	  (assign, ":target_village", -1),
	  (assign, ":score_to_beat", 0), #based on relation

	  (try_for_range, ":possible_target", villages_begin, villages_end),
	    (store_faction_of_party, ":village_faction", ":possible_target"),
	    (store_relation, ":relation", ":village_faction", ":faction_no"),
	    (lt, ":relation", 0),

	    (neg|party_slot_ge, ":possible_target", slot_village_state, svs_looted),
	    (party_get_slot, ":town_lord", ":possible_target", slot_town_lord),
	    (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":town_lord"),
	    (assign, ":village_score", reg0),

	    (lt, ":village_score", ":score_to_beat"),
	    (assign, ":score_to_beat", ":village_score"),
	    (assign, ":target_village", ":possible_target"),
	  (try_end),

	  (is_between, ":target_village", centers_begin, centers_end),
	  (assign, ":action", spai_raiding_around_center),
	  (assign, ":object", ":target_village"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_have_a_score_to_settle_with_the_lord_there"),
	    (str_store_string, s16, "str_i_am_thinking_of_settling_an_old_score"),
	  (try_end),

	#I need money, so I am raiding where the money is
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	  (eq, ":faction_is_at_war", 1),
	  (eq, ":operation_in_progress", 0),

	  (this_or_next|gt, ":hours_since_last_combat", 12),
	  (lt, ":hours_since_last_rest", 96),
	  (gt, ":aggressiveness", 40),

	  ##diplomacy start+
	  #Roguish lords can also do this.  Humanitarian companions will never
	  #do this, even if they otherwise have an eligible reputation.  Companions
	  #who actively enjoy raiding can also do this, regardless of whether they
	  #have an eligible reputation.
	  (call_script, "script_dplmc_get_troop_morality_value", ":troop_no", tmt_humanitarian),
	  (lt, reg0, 1),
	  (this_or_next|lt, reg0, 0),
	  (this_or_next|eq, ":troop_reputation", lrep_roguish),
	  ##diplomacy end+
	  (this_or_next|eq, ":troop_reputation", lrep_debauched),
	  (this_or_next|eq, ":troop_reputation", lrep_selfrighteous),
	  (this_or_next|eq, ":troop_reputation", lrep_cunning),
	  (eq, ":troop_reputation", lrep_quarrelsome),

	  (troop_get_slot, ":wealth", ":troop_no", slot_troop_wealth),
	  (lt, ":wealth", 500),

	  (assign, ":score_to_beat", 0),
	  (assign, ":target_village", -1),

	  (try_for_range, ":possible_target", villages_begin, villages_end),
	    (store_faction_of_party, ":village_faction", ":possible_target"),
	    (store_relation, ":relation", ":village_faction", ":faction_no"),
	    (lt, ":relation", 0),

	    (this_or_next|party_slot_eq, ":possible_target", slot_village_state, svs_normal),
	    (party_slot_eq, ":possible_target", slot_village_state, svs_being_raided),

	    (party_get_slot, reg17, ":possible_target", slot_town_prosperity),
	    (store_distance_to_party_from_party, ":distance", ":party_no", ":possible_target"),
	    (val_sub, reg17, ":distance"),

	    (gt, reg17, ":score_to_beat"),
	    (assign, ":score_to_beat", reg17),
	    (assign, ":target_village", ":possible_target"),
	  (try_end),

	  (gt, ":target_village", -1),

	  (assign, ":action", spai_raiding_around_center),
	  (assign, ":object", ":target_village"),

	  (try_begin),
	    (eq, ":troop_no", "$g_talk_troop"),
	    (str_store_string, s14, "str_i_am_short_of_money_and_i_hear_that_there_is_much_wealth_there"),
	    (str_store_string, s16, "str_i_need_to_refill_my_purse_preferably_with_the_enemys_money"),
	  (try_end),

	#Attacking wealthiest lands
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(eq, ":faction_is_at_war", 1),
		(eq, ":operation_in_progress", 0),
		(gt, ":aggressiveness", 65),

		(assign, ":score_to_beat", 0),
		(assign, ":target_village", -1),

		(try_for_range, ":possible_target", villages_begin, villages_end),
			(store_faction_of_party, ":village_faction", ":possible_target"),
			(store_relation, ":relation", ":village_faction", ":faction_no"),
			(lt, ":relation", 0),
			(neg|party_slot_eq, ":possible_target", slot_village_state, svs_looted),
			(party_get_slot, ":village_prosperity", ":possible_target", slot_town_prosperity),
			(val_mul, ":village_prosperity", 2),

			(store_distance_to_party_from_party, ":distance", ":party_no", ":possible_target"),
			(val_sub, ":village_prosperity", ":distance"),
			(gt, ":village_prosperity", ":score_to_beat"),

			(assign, ":score_to_beat", ":village_prosperity"),
			(assign, ":target_village", ":possible_target"),
		(try_end),

		##diplomacy start+ companions who hate raiding will not raid
		(call_script, "script_dplmc_get_troop_morality_value", ":troop_no", tmt_humanitarian),
		(lt, reg0, 1),
		##diplomacy end+
		(gt, ":target_village", -1),

		(assign, ":action", spai_raiding_around_center),
		(assign, ":object", ":target_village"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_by_striking_at_the_enemys_richest_lands_perhaps_i_can_draw_them_out_to_battle"),
			(str_store_string, s16, "str_i_am_thinking_of_going_on_the_attack"),
		(try_end),

	#End the war
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
	    ##diplomacy start+
		(assign, reg0, 0),
		(try_begin),
			#A liege in service to another lord or allied with the player can do this.
			(this_or_next|eq, ":troop_reputation", lrep_none),
			(this_or_next|is_between, ":troop_no", kings_begin, kings_end),
			(is_between, ":troop_no", pretenders_begin, pretenders_end),
			(this_or_next|neg|faction_slot_eq, ":faction_no", slot_faction_leader, ":troop_no"),
			(this_or_next|troop_slot_eq, ":troop_no", slot_troop_spouse, "trp_player"),
				(troop_slot_eq, "trp_player", slot_troop_spouse, ":troop_no"),
			(assign, reg0, 0),
		(else_try),
			#Lords who are simulatenously Martial and tmt_honest (such as Alayen),
			#or Custodian and tmt_honest (such as Artimenner) can also do this.
			(this_or_next|eq, ":troop_reputation", lrep_martial),
			(eq, ":troop_reputation", lrep_custodian),
			(call_script, "script_dplmc_get_troop_morality_value", ":troop_no", tmt_honest),
		(try_end),
		(this_or_next|ge, reg0, 1),
		##diplomacy end+
		(eq, ":troop_reputation", lrep_upstanding),
		(eq, ":faction_is_at_war", 1),
		(eq, ":operation_in_progress", 0),

		(assign, ":faction_to_attack", -1),
		(try_for_range, ":possible_faction_to_attack", kingdoms_begin, kingdoms_end),
			(store_relation, ":relation", ":faction_no", ":possible_faction_to_attack"),
			(lt, ":relation", 0),
			(faction_slot_eq, ":possible_faction_to_attack", slot_faction_state, sfs_active),

			(store_add, ":war_damage_inflicted_slot", ":possible_faction_to_attack", slot_faction_war_damage_inflicted_on_factions_begin),
			(val_sub, ":war_damage_inflicted_slot", kingdoms_begin),
			(faction_get_slot, ":war_damage_inflicted", ":faction_no", ":war_damage_inflicted_slot"),

			(store_add, ":war_damage_suffered_slot", ":faction_no", slot_faction_war_damage_inflicted_on_factions_begin),
			(val_sub, ":war_damage_suffered_slot", kingdoms_begin),
			(faction_get_slot, ":war_damage_suffered", ":possible_faction_to_attack", ":war_damage_suffered_slot"),

			(gt, ":war_damage_inflicted", 80),
			(lt, ":war_damage_inflicted", ":war_damage_suffered"),
			(assign, ":faction_to_attack", ":possible_faction_to_attack"),
		(try_end),

		(gt, ":faction_to_attack", -1),

		(assign, ":target_village", -1),
		(assign, ":score_to_beat", 50),

		(try_for_range, ":possible_target_village", villages_begin, villages_end),
			(store_faction_of_party, ":village_faction", ":possible_target_village"),
			(eq, ":village_faction", ":faction_to_attack"),
			(neg|party_slot_eq, ":possible_target_village", slot_village_state, svs_looted),
			(store_distance_to_party_from_party, ":distance", ":party_no", ":possible_target_village"),
			(lt, ":distance", ":score_to_beat"),

			(assign, ":score_to_beat", ":distance"),
			(assign, ":target_village", ":possible_target_village"),
		(try_end),

		(gt, ":target_village", -1),

		(assign, ":action", spai_raiding_around_center),
		(assign, ":object", ":target_village"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_perhaps_if_i_strike_one_more_blow_we_may_end_this_war_on_our_terms_"),
			(str_store_string, s16, "str_we_may_be_able_to_bring_this_war_to_a_close_with_a_few_more_blows"),
		(try_end),

	#I have a feast to attend
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_feast),
		(faction_get_slot, ":feast_venue", ":faction_no", slot_faction_ai_object),
		(party_get_slot, ":feast_host", ":feast_venue", slot_town_lord),
		(eq, ":operation_in_progress", 0),

		(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":feast_host"),
		(assign, ":relation_with_host", reg0),

        (ge, ":relation_with_host", 0),

		(assign, ":action", spai_holding_center),
		(assign, ":object", ":feast_venue"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_wish_to_attend_the_feast_there"),
			(str_store_string, s16, "str_there_is_a_feast_which_i_wish_to_attend"),
		(try_end),
	#A lady to court
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(neg|troop_slot_eq, "trp_player", slot_troop_betrothed, ":troop_no"),
		(troop_slot_eq, ":troop_no", slot_troop_spouse, -1),
		(neg|is_between, ":troop_no", kings_begin, kings_end),
		(neg|is_between, ":troop_no", pretenders_begin, pretenders_end),


		(gt, ":hours_since_last_courtship", 72),
		(eq, ":operation_in_progress", 0),

		(assign, ":center_to_visit", -1),
		(assign, ":score_to_beat", 150),

		(try_for_range, ":love_interest_slot", slot_troop_love_interest_1, slot_troop_love_interests_end),
			(troop_get_slot, ":love_interest", ":troop_no", ":love_interest_slot"),
			(is_between, ":love_interest", kingdom_ladies_begin, kingdom_ladies_end),
			(troop_get_slot, ":love_interest_center", ":love_interest", slot_troop_cur_center),
			(is_between, ":love_interest_center", centers_begin, centers_end),
			(store_faction_of_party, ":love_interest_faction_no", ":love_interest_center"),
			(eq, ":faction_no", ":love_interest_faction_no"),
            #(store_relation, ":relation", ":faction_no", ":love_interest_faction_no"),
            #(ge, ":relation", 0),

			(store_distance_to_party_from_party, ":distance", ":party_no", ":love_interest_center"),

			(lt, ":distance", ":score_to_beat"),
			(assign, ":center_to_visit", ":love_interest_center"),
			(assign, ":score_to_beat", ":distance"),
        (try_end),

		(gt, ":center_to_visit", -1),

		(assign, ":action", spai_holding_center),
		(assign, ":object", ":center_to_visit"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_there_is_a_fair_lady_there_whom_i_wish_to_court"),
			(str_store_string, s16, "str_i_have_the_inclination_to_pay_court_to_a_fair_lady"),
		(try_end),

	#Patrolling an alarmed center
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(assign, ":target_center", -1),
		(assign, ":score_to_beat", 60),
		(eq, ":operation_in_progress", 0),
		(gt, ":aggressiveness", 40),

		(try_for_range, ":center_to_patrol", centers_begin, centers_end), #find closest center that has spotted enemies.
            (store_faction_of_party, ":center_faction", ":center_to_patrol"),
            (eq, ":center_faction", ":faction_no"),
			(party_slot_ge, ":center_to_patrol", slot_center_last_spotted_enemy, 0),

			#new - begin
			(party_get_slot, ":sortie_strength", ":center_to_patrol", slot_center_sortie_strength),
			(party_get_slot, ":enemy_strength", ":center_to_patrol", slot_center_sortie_enemy_strength),
			(store_mul, ":enemy_strength_mul_14_div_10", ":enemy_strength", 14),
			(val_div, ":enemy_strength_mul_14_div_10", 10),
			(party_get_slot, ":party_strength", ":party_no", slot_party_cached_strength),

			(this_or_next|neg|party_is_in_town, ":party_no", ":center_to_patrol"),
			(gt, ":sortie_strength", ":enemy_strength_mul_14_div_10"),

			(ge, ":party_strength", 100),
			#new - end

			(party_get_slot, reg17, ":center_to_patrol", slot_town_lord),
			(call_script, "script_troop_get_relation_with_troop", reg17, ":troop_no"),

			(this_or_next|eq, ":troop_reputation", lrep_upstanding),
				(gt, reg0, -5),

            (store_distance_to_party_from_party, ":distance", ":party_no", ":center_to_patrol"),
			(lt, ":distance", ":score_to_beat"),

			(assign, ":target_center", ":center_to_patrol"),
			(assign, ":score_to_beat", ":distance"),
		(try_end),

		(is_between, ":target_center", centers_begin, centers_end),

		(assign, ":action", spai_patrolling_around_center),
		(assign, ":object", ":target_center"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_we_have_heard_reports_that_the_enemy_is_in_the_area"),
			(str_store_string, s16, "str_i_have_heard_reports_of_enemy_incursions_into_our_territory"),
		(try_end),

	#Time in household
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(gt, ":hours_since_last_home", 168),
		(eq, ":operation_in_progress", 0),

		(call_script, "script_lord_get_home_center", ":troop_no"),
		(assign, ":home_center", reg0),
		(gt, ":home_center", -1),

		(assign, ":action", spai_holding_center),
		(assign, ":object", ":home_center"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_need_to_spend_some_time_with_my_household"),
			(str_store_string, s16, "str_it_has_been_a_long_time_since_i_have_been_able_to_spend_time_with_my_household"),
		(try_end),

	#Patrolling the borders
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(eq, ":faction_is_at_war", 1),
		(gt, ":aggressiveness", 65),
		(eq, ":operation_in_progress", 0),

		(assign, ":center_to_patrol", -1),
		(assign, ":score_to_beat", 75),

		(try_for_range, ":village", villages_begin, villages_end),
			(store_faction_of_party, ":village_faction", ":village"),
			(store_relation, ":relation", ":village_faction", ":faction_no"),
			(lt, ":relation", 0),

			(store_distance_to_party_from_party, ":distance", ":village", ":party_no"),
			(lt, ":distance", ":score_to_beat"),

			(assign, ":score_to_beat", ":distance"),
			(assign, ":center_to_patrol", ":village"),
		(try_end),

		(is_between, ":center_to_patrol", villages_begin, villages_end),

		(assign, ":action", spai_patrolling_around_center),
		(assign, ":object", ":center_to_patrol"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_am_watching_the_borders"),
			(str_store_string, s16, "str_i_may_be_needed_to_watch_the_borders"),
		(try_end),

	#Visiting a friend - temporarily disabled
	(else_try),
		(eq, 1, 0),

	#Patrolling home
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(call_script, "script_lord_get_home_center", ":troop_no"),
		(assign, ":home_center", reg0),

		(is_between, ":home_center", centers_begin, centers_end),
		(eq, ":operation_in_progress", 0),

		(assign, ":action", spai_patrolling_around_center),
		(assign, ":object", ":home_center"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_will_guard_the_areas_near_my_home"),
			(str_store_string, s16, "str_i_am_perhaps_needed_most_at_home"),
		(try_end),

	#Default end
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(eq, ":operation_in_progress", 0),

		(call_script, "script_lord_get_home_center", ":troop_no"),
		(assign, ":home_center", reg0),
		(is_between, ":home_center", walled_centers_begin, walled_centers_end),

		(assign, ":action", spai_holding_center),
		(assign, ":object", ":home_center"),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_cant_think_of_anything_better_to_do"),
		(try_end),
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(eq, ":operation_in_progress", 1),

		(party_get_slot, ":action", ":party_no", slot_party_ai_state),
		(party_get_slot, ":object", ":party_no", slot_party_ai_object),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_am_completing_what_i_have_already_begun"),
		(try_end),
	(else_try),
	  (eq, ":do_only_collecting_rents", 0),
		(assign, ":action", spai_undefined),
		(assign, ":object", -1),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s14, "str_i_dont_even_have_a_home_to_which_to_return"),
		(try_end),
	(try_end),

	(try_begin),
		(eq, "$cheat_mode", 2),
		(str_store_troop_name, s10, ":troop_no"),
		(display_message, "str_debug__s10_decides_s14_faction_ai_s15"),
	(try_end),

    (assign, reg0, ":action"),
	(assign, reg1, ":object"),
	]),

	#script_npc_decision_checklist_troop_follow_or_not
    # INPUT: troop_no
    # OUTPUT: reg0
	(
	"npc_decision_checklist_troop_follow_or_not", [

	(store_script_param, ":troop_no", 1),
	(store_faction_of_troop, ":faction_no", ":troop_no"),
	(faction_get_slot, ":faction_ai_state", ":faction_no", slot_faction_ai_state),

	(troop_get_slot, ":troop_reputation", ":troop_no", slot_lord_reputation_type),
	(faction_get_slot, ":faction_marshall", ":faction_no", slot_faction_marshall),
    ##diplomacy start+
    #Get the centralization value for use below.  It should be a value in [-3,3].
    #A centralization value of 0 should not result in any behavior change.
    (try_begin),
       #If the player altered the kingdom policy, always apply its effects to
       #the AI of his kingdom's lords.
       (call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", ":faction_no"),
       (ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
       (faction_get_slot, ":centralization", ":faction_no", dplmc_slot_faction_centralization),
       (val_clamp, ":centralization", -3, 4),
    (else_try),
       #Currently, do not apply centralization to the AI for NPC kingdoms, since
       #NPC rulers set their policies randomly and do not gain the same monthly
       #relation bonuses/penalties from centralization that the player does.
       (assign, ":centralization", 0),
    (try_end),
    ##diplomacy end+

	(assign, ":result", 0),
	(try_begin),
		##diplomacy start+ add another check
		(this_or_next|lt, ":faction_marshall", 0),
		##diplomacy end+
		(eq, ":faction_marshall", -1),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__i_am_acting_independently_because_no_marshal_is_appointed"),
		(try_end),
	(else_try),
		(troop_get_slot, ":faction_marshall_party", ":faction_marshall", slot_troop_leaded_party),
		(neg|party_is_active, ":faction_marshall_party"),

		#Not doing an offensive
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__i_am_acting_independently_because_our_marshal_is_currently_indisposed"),
		(try_end),
	(else_try),
		(neq, ":faction_ai_state", sfai_attacking_center),
        (neq, ":faction_ai_state", sfai_raiding_village),
        (neq, ":faction_ai_state", sfai_attacking_enemies_around_center),
        (neq, ":faction_ai_state", sfai_attacking_enemy_army),
        (neq, ":faction_ai_state", sfai_gathering_army),

		#Not doing an offensive
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__i_am_acting_independently_because_our_realm_is_currently_not_on_campaign"),
		(try_end),
	(else_try),
		(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_marshall"),
		(assign, ":relation_with_marshall", reg0),

		(try_begin),
		  (le, ":relation_with_marshall", -10),
		  (assign, ":acceptance_level", 10000),
		(else_try),
		  (store_mul, ":acceptance_level", ":relation_with_marshall", -1000),
		(try_end),

		(val_add, ":acceptance_level", 1500),

        (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
		(try_begin),
		  (neq, ":faction_no", "$players_kingdom"),
          (try_begin),
            (eq, ":reduce_campaign_ai", 0), #hard
            (val_add, ":acceptance_level", -1250),
          (else_try),
            (eq, ":reduce_campaign_ai", 1), #moderate
          (else_try),
            (eq, ":reduce_campaign_ai", 2), #easy
            (val_add, ":acceptance_level", 1250),
          (try_end),
        (else_try),
          (faction_slot_eq, ":faction_no", slot_faction_marshall, "trp_player"),
          (try_begin),
            (eq, ":reduce_campaign_ai", 0), #hard/player's faction
            (val_add, ":acceptance_level", -1000),
          (else_try),
            (eq, ":reduce_campaign_ai", 1), #moderate/player's faction
            (val_add, ":acceptance_level", -1500),
          (else_try),
            (eq, ":reduce_campaign_ai", 2), #easy/player's faction
            (val_add, ":acceptance_level", -2000),
          (try_end),
		(try_end),

		(troop_get_slot, ":temp_ai_seed", ":troop_no", slot_troop_temp_decision_seed),

		(le, ":temp_ai_seed", ":acceptance_level"),

		#Very low opinion of marshall
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__i_am_not_accompanying_the_marshal_because_i_fear_that_he_may_lead_us_into_disaster"),
		(try_end),
		#Make nuanced, depending on personality type
	(else_try),
		(troop_get_slot, ":marshal_controversy", ":faction_marshall", slot_faction_marshall),

		(lt, ":relation_with_marshall", 0),
		(ge, ":marshal_controversy", 50),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str_i_am_not_accompanying_the_marshal_because_i_question_his_judgment"),
		(try_end),
	(else_try),
		(troop_get_slot, ":marshal_controversy", ":faction_marshall", slot_faction_marshall),
		(neg|faction_slot_eq, ":faction_no", slot_faction_leader, ":faction_marshall"),

		(lt, ":relation_with_marshall", 5),
		(ge, ":marshal_controversy", 80),

		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str_i_am_not_accompanying_the_marshal_because_will_be_reappointment"),
		(try_end),
	(else_try),
		#(lt, ":relation_with_marshall", 45),
		#(eq, ":faction_marshall", "trp_player"), #moved below as only effector. Search "think about this".

		(store_sub, ":relation_with_marshal_difference", 50, ":relation_with_marshall"),

		#for 50 relation with marshal ":acceptance_level" will be 0
		#for 20 relation with marshal ":acceptance_level" will be 2100
		#for 10 relation with marshal ":acceptance_level" will be 2800
		#for 0 relation with marshal ":acceptance_level" will be 3500
		#for -10 relation with marshal ":acceptance_level" will be 4200
		#average is about 2500
		(store_mul, ":acceptance_level", ":relation_with_marshal_difference", 70),

        (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
		(try_begin),
		  (neq, ":faction_no", "$players_kingdom"),

          (try_begin),
            (eq, ":reduce_campaign_ai", 0), #hard
            (val_add, ":acceptance_level", -1200),
          (else_try),
            (eq, ":reduce_campaign_ai", 1), #moderate
          (else_try),
            (eq, ":reduce_campaign_ai", 2), #easy
            (val_add, ":acceptance_level", 1200),
          (try_end),
		(else_try),
          (eq, ":faction_marshall", "trp_player"),

          (try_begin),
            (eq, ":reduce_campaign_ai", 0), #hard
            (val_add, ":acceptance_level", -1000),
          (else_try),
            (eq, ":reduce_campaign_ai", 1), #moderate
            (val_add, ":acceptance_level", -1500),
          (else_try),
            (eq, ":reduce_campaign_ai", 2), #easy
            (val_add, ":acceptance_level", -2000),
          (try_end),
		(try_end),

		(try_begin),
		  (eq, ":troop_reputation", lrep_selfrighteous),
		  (val_add, ":acceptance_level", 1500),
		(else_try),
		  (this_or_next|eq, ":troop_reputation", lrep_martial),
		  (this_or_next|eq, ":troop_reputation", lrep_roguish),
		  (eq, ":troop_reputation", lrep_quarrelsome),
		  (val_add, ":acceptance_level", 1000),
		(else_try),
		  (eq, ":troop_reputation", lrep_cunning),
		  (val_add, ":acceptance_level", 500),
		(else_try),
		  (eq, ":troop_reputation", lrep_upstanding), #neutral
		(else_try),
		  (this_or_next|eq, ":troop_reputation", lrep_benefactor), #helper
		  (eq, ":troop_reputation", lrep_goodnatured),
		  (val_add, ":acceptance_level", -500),
		(else_try),
		  (eq, ":troop_reputation", lrep_custodian), #very helper
		  (val_add, ":acceptance_level", -1000),
		(try_end),

		(try_begin),
		  (troop_slot_eq, ":faction_marshall", slot_lord_reputation_type, lrep_quarrelsome),
		  (val_add, ":acceptance_level", -750),
		(else_try),
		  (this_or_next|troop_slot_eq, ":faction_marshall", slot_lord_reputation_type, lrep_martial),
		  (troop_slot_eq, ":faction_marshall", slot_lord_reputation_type, lrep_upstanding),
		  (val_add, ":acceptance_level", -250),
		(try_end),

		(val_add, ":acceptance_level", 2000),
		#average become 2500 + 2000 = 4500, (45% of lords will not join campaign because of this reason. (33% for hard, 57% for easy, 30% for marshal player))

      ##diplomacy start+ Apply centralization.
      #Adjusting acceptance level seems a natural place to represent this.
      (store_mul, reg0, ":centralization", 100),
      (val_clamp, reg0, -300, 301),#should be unnecessary
      (val_sub, ":acceptance_level", reg0),#adjust the chance of following the marshall by +/- 1% for every step of centralization
      ##diplomacy end+
		(troop_get_slot, ":temp_ai_seed", ":troop_no", slot_troop_temp_decision_seed),

		(le, ":temp_ai_seed", ":acceptance_level"),

		(try_begin),
		  (eq, ":troop_no", "$g_talk_troop"),
		  (str_store_string, s15, "str_i_am_not_accompanying_the_marshal_because_i_can_do_greater_deeds"),
		(try_end),

		#(try_begin),
		#  (ge, "$cheat_mode", 1),
		#  (assign, reg7, ":acceptance_level"),
		#  (assign, reg8, ":relation_with_marshall"),
		#  (display_message, "@{!}DEBUGS : acceptance level : {reg7}, relation with marshal : {reg8}"),
		#(try_end),
	(else_try),
		(store_current_hours, ":hours_since_last_faction_rest"),
		(faction_get_slot, ":last_rest_time", ":faction_no", slot_faction_ai_last_rest_time),
		(val_sub, ":hours_since_last_faction_rest", ":last_rest_time"),

		#nine days on average, marshal will usually end after 10 days
		#ozan changed, 360 hours (15 days) in average, marshal cannot end it during a siege attack/defence anymore.
		(assign, ":troop_campaign_limit", 360),
		(store_mul, ":marshal_relation_modifier", ":relation_with_marshall", 6), #ozan changed 4 to 6.
		(val_add, ":troop_campaign_limit", ":marshal_relation_modifier"),

		(try_begin),
			(eq, ":troop_reputation", lrep_upstanding),
			(val_mul, ":troop_campaign_limit", 4),
			(val_div, ":troop_campaign_limit", 3),
		(try_end),

		(str_store_troop_name, s16, ":faction_marshall"),

		(gt, ":hours_since_last_faction_rest", ":troop_campaign_limit"),

		#Too long a campaign
		(try_begin),
			(eq, ":troop_no", "$g_talk_troop"),
			(str_store_string, s15, "str__s16_has_kept_us_on_campaign_on_far_too_long_and_there_are_other_pressing_matters_to_which_i_must_attend"),
		(try_end),
		#Also make nuanced, depending on personality type
	(else_try),
		(troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
		(neg|party_is_active, ":party_no"),
		#This string should not occur, as it will only happen if a lord is contemplating following the player
	(else_try),
		(troop_get_slot, ":marshal_party", ":faction_marshall", slot_troop_leaded_party),

		(assign, ":information_radius", 40),
		(try_begin),
		  (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_gathering_army),
		  (assign, ":information_radius", 50),
		(try_end),

        (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
		(try_begin),
		  (neq, ":faction_no", "fac_player_supporters_faction"),
		  (neq, ":faction_no", "$players_kingdom"),
		  ##diplomacy start+ the player may be able to become leader in other situations
		  (neg|faction_slot_eq, ":faction_no", slot_faction_leader, "trp_player"),
		  ##diplomacy end+
		  (try_begin),
		    (eq, ":reduce_campaign_ai", 2), #easy
		    (try_begin),
		      (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_gathering_army),
		      (val_add, ":information_radius", -10),
		    (else_try),
		      (val_add, ":information_radius", -8),
		    (try_end),
		  (else_try),
		    (eq, ":reduce_campaign_ai", 1), #moderate
		    (try_begin),
		      (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_gathering_army),
		      (val_add, ":information_radius", -5),
		    (else_try),
		      (val_add, ":information_radius", -4),
		    (try_end),
		  (try_end),
		(else_try),
		  (try_begin),
		    (eq, ":reduce_campaign_ai", 2), #easy
		    (try_begin),
		      (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_gathering_army),
		      (val_add, ":information_radius", 25),
		    (else_try),
		      (val_add, ":information_radius", 20),
		    (try_end),
		  (else_try),
		    (eq, ":reduce_campaign_ai", 1), #moderate
		    (try_begin),
		      (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_gathering_army),
		      (val_add, ":information_radius", 15),
		    (else_try),
		      (val_add, ":information_radius", 12),
		    (try_end),
		  (else_try),
		    (eq, ":reduce_campaign_ai", 0), #hard
		    (try_begin),
		      (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_gathering_army),
		      (val_add, ":information_radius", 5),
		    (else_try),
		      (val_add, ":information_radius", 4),
		    (try_end),
		  (try_end),
		(try_end),
      ##diplomacy start+ Apply centralization to the AI here.
      (store_add, reg0, 10, ":centralization"),
      (val_clamp, reg0, 7, 14),#should be unnecessary
      (val_mul, ":information_radius", reg0),
      (val_add, ":information_radius", 5),
      (val_div, ":information_radius", 10),#Adjust +/- 10% for every level of centralization
      ##diplomacy end+

		(faction_get_slot, ":faction_object", ":faction_no", slot_faction_ai_object),
		(assign, reg17, 0),
		(try_begin),
		  (try_begin),
		    (neg|is_between, ":faction_object", villages_begin, villages_end),
		    (assign, reg17, 1),
		  (try_end),
		  (try_begin),
		    (neg|faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_attacking_enemies_around_center),
		    (assign, reg17, 1),
		  (try_end),
		  (eq, reg17, 1),

		  (store_distance_to_party_from_party, ":distance", ":marshal_party", ":party_no"),

		  (gt, ":distance", ":information_radius"),

          (try_begin),
            (eq, ":troop_no", "$g_talk_troop"),
            (str_store_string, s15, "str__i_am_not_participating_in_the_marshals_campaign_because_i_do_not_know_where_to_find_our_main_army"),
  		  (try_end),
		(else_try),
		  (eq, reg17, 0),

          (assign, reg17, 1),
          (try_begin),
            #if we are already accompanying marshal forget below.
            (party_slot_eq, ":party_no", slot_party_ai_state, spai_accompanying_army),
            (party_slot_eq, ":party_no", slot_party_ai_object, ":marshal_party"),
            (assign, reg17, 0),
          (try_end),
          (eq, reg17, 1),

		  #if faction ai is "attacking enemies around a center" is then do not find and compare distance to marshal, find and compare distance to "attacked village"
		  (party_get_slot, ":enemy_strength_nearby", ":faction_object", slot_center_sortie_enemy_strength),

		  (try_begin), #changes between 70..x (as ":enemy_strength_nearby" increases, ":information_radius" increases too.),
		    (ge, ":enemy_strength_nearby", 4000),
		    (val_sub, ":enemy_strength_nearby", 4000),
		    (store_div, ":information_radius", ":enemy_strength_nearby", 200),
		    (val_add, ":information_radius", 70),
		  (else_try), #changes between 30..70
		    (store_div, ":information_radius", ":enemy_strength_nearby", 100),
		    (val_add, ":information_radius", 30),
		  (try_end),

		  (store_distance_to_party_from_party, ":distance", ":faction_object", ":party_no"),

		  (gt, ":distance", ":information_radius"),

          (try_begin),
            (eq, ":troop_no", "$g_talk_troop"),
            (str_store_string, s15, "str__i_am_acting_independently_although_some_enemies_have_been_spotted_within_our_borders_they_havent_come_in_force_and_the_local_troops_should_be_able_to_dispatch_them"),
  		  (try_end),
		(try_end),

		(gt, ":distance", ":information_radius"),
	(else_try),
		(try_begin),
		  (eq, ":troop_no", "$g_talk_troop"),
		  (str_store_string, s15, "str__the_needs_of_the_realm_must_come_first"),
		(try_end),
		(assign, ":result", 1),
	(try_end),

	(assign, reg0, ":result"),
	]),

	#script_find_total_prosperity_score
    # INPUT: center_no
    # OUTPUT: reg0 = total_prosperity_score
	(
	"find_total_prosperity_score",
	[
	  (store_script_param, ":center_no", 1),

      (try_begin), #":total_prosperity_score" changes between 10..100
        (is_between, ":center_no", walled_centers_begin, walled_centers_end),

        (party_get_slot, ":center_prosperity", ":center_no", slot_town_prosperity),
        (store_add, ":center_prosperity_add_200_div_10", ":center_prosperity", 200),
        (val_div, ":center_prosperity_add_200_div_10", 10),
        (try_begin),
          (is_between, ":center_no", towns_begin, towns_end),
          (store_mul, ":this_center_score", ":center_prosperity_add_200_div_10", 15),
        (else_try),
          (store_mul, ":this_center_score", ":center_prosperity_add_200_div_10", 5),
        (try_end),
        (assign, ":total_prosperity_score", ":this_center_score"),

        (try_for_range_backwards, ":village_no", villages_begin, villages_end),
          (party_slot_eq, ":village_no", slot_village_bound_center, ":center_no"),

          (party_get_slot, ":village_prosperity", ":village_no", slot_town_prosperity),
          (store_add, ":village_prosperity_add_200_div_10", ":village_prosperity", 200),
          (val_div, ":village_prosperity_add_200_div_10", 10),
          (store_mul, ":this_village_score", ":village_prosperity_add_200_div_10", 5),

          (val_add, ":total_prosperity_score", ":this_village_score"),
        (try_end),
      (else_try),
        (party_get_slot, ":center_prosperity", ":center_no", slot_town_prosperity),
        (store_add, ":center_prosperity_add_200_div_10", ":center_prosperity", 200),
        (val_div, ":center_prosperity_add_200_div_10", 10),
        (store_mul, ":this_center_score", ":center_prosperity_add_200_div_10", 5),
        (assign, ":total_prosperity_score", ":this_center_score"),
      (try_end),
      (val_div, ":total_prosperity_score", 10),

      (assign, reg0, ":total_prosperity_score"),
	]),

    #script_calculate_center_assailability_score
    # INPUT: faction_no
    # param1: faction_no
    # param2: all_vassals_included, (becomes 1 if we want to find attackable center if we collected 20% of vassals during gathering army phase)
    # OUTPUT:
    # reg0 = center_to_attack (-1 if none is logical)
    # reg1 = maximum_attack_score
    (
    "calculate_center_assailability_score",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":potential_target", 2),
      (store_script_param, ":all_vassals_included", 3),

      (assign, ":target_score", -1),

      (store_faction_of_troop, ":faction_no", ":troop_no"),

      (store_current_hours, ":hours_since_last_offensive"),
      (faction_get_slot, ":last_offensive_time", ":faction_no", slot_faction_last_offensive_concluded),
      (val_sub, ":hours_since_last_offensive", ":last_offensive_time"),

      (store_div, ":last_offensive_time_score", ":hours_since_last_offensive", 12), #30..50
      (val_add, ":last_offensive_time_score", 30),
      (val_min, ":last_offensive_time_score", 100),

      (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),

      (assign, ":marshal_party", -1),
      (assign, ":marshal_strength", 0),
      #(assign, ":strength_of_nearby_friend", 0),

      (try_begin),
        (gt, ":faction_marshal", 0),
        (troop_get_slot, ":marshal_party", ":faction_marshal", slot_troop_leaded_party),
        (party_is_active, ":marshal_party"),
        (party_get_slot, ":marshal_strength", ":marshal_party", slot_party_cached_strength),
        #(eq, ":all_vassals_included", 0),
        (party_get_slot, ":strength_of_current_followers", ":marshal_party", slot_party_follower_strength),
        #(party_get_slot, ":strength_of_nearby_friend", ":marshal_party", slot_party_nearby_friend_strength),
      (try_end),

      #(try_begin),
      #  (eq, ":all_vassals_included", 0),
      #
      #  (try_begin),
      #    (gt, ":faction_marshal", 0),
      #    (troop_get_slot, ":marshal_party", ":faction_marshal", slot_troop_leaded_party),
      #    (party_is_active, ":marshal_party"),
      #    (party_get_slot, ":strength_of_potential_followers", ":marshal_party", slot_party_follower_strength),
      #  (try_end),
      #(else_try),
      #  (eq, ":all_vassals_included", 1),
      #
      #  (assign, ":strength_of_potential_followers", 0),
      #
      #  (try_for_parties, ":party_no"),
      #    (store_faction_of_party, ":party_faction", ":party_no"),
      #    (eq, ":party_faction", ":faction_no"),
      #    (neq, ":party_no", ":marshal_party"),
      #    (party_slot_eq, ":party_no", slot_party_type, spt_kingdom_hero_party),
      #    (call_script, "script_party_calculate_strength", ":party_no", 0),
      #    (val_add, ":strength_of_potential_followers", reg0),
      #  (try_end),
      #
      #  (val_div, ":strength_of_potential_followers", 2), #Ozan - Think about this, will you divide strength_of_potential_followers to 3 or 2.5 or 2
      #(else_try),
      #  (assign, ":strength_of_potential_followers", 0),
      #(try_end),

      (faction_get_slot, ":last_attacked_center", ":faction_no", slot_faction_last_attacked_center),
      (faction_get_slot, ":last_attacked_hours", ":faction_no", slot_faction_last_attacked_hours),

      (try_begin),
        (store_current_hours, ":hours"),
        (store_add, ":last_attacked_hours_plus_24", ":last_attacked_hours", 24),
        (gt, ":hours", ":last_attacked_hours_plus_24"),
        (faction_set_slot, ":faction_no", slot_faction_last_attacked_center, 0),
        (assign, ":last_attacked_center", 0),
      (try_end),

      (try_begin),
        (this_or_next|eq, ":last_attacked_center", 0),
        (this_or_next|eq, ":last_attacked_center", ":potential_target"),
        (this_or_next|eq, "$g_do_not_skip_other_than_current_ai_object", 1),
        (neg|faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),

        (party_is_active, ":potential_target"),
        (store_faction_of_party, ":potential_target_faction", ":potential_target"),

        (store_relation, ":relation", ":potential_target_faction", ":faction_no"),
        (lt, ":relation", 0),

        #attack if and only if we are already besieging that center or anybody do not making besiege.
        (assign, ":faction_of_besieger_party", -1),
        (try_begin),
          (is_between, ":potential_target", walled_centers_begin, walled_centers_end),
          (neg|party_slot_eq, ":potential_target", slot_center_is_besieged_by, -1),
          (party_get_slot, ":besieger_party", ":potential_target", slot_center_is_besieged_by),
          (party_is_active, ":besieger_party"),
          (store_faction_of_party, ":faction_of_besieger_party", ":besieger_party"),
        (try_end),

        (this_or_next|eq, ":faction_of_besieger_party", -1),
        (eq, ":faction_of_besieger_party", ":faction_no"),

        #attack if and only if this center is not a village or if it is village it should not be raided or looted
        (assign, ":village_is_looted_or_raided_already", 0),
        (try_begin),
          (is_between, ":potential_target", villages_begin, villages_end),
          (try_begin),
            (party_slot_eq, ":potential_target", slot_village_state, svs_being_raided),
            (party_get_slot, ":raider_party", ":potential_target", slot_village_raided_by),
			(party_is_active, ":raider_party"),

            (store_faction_of_party, ":raider_faction", ":raider_party"),
            (neq, ":raider_faction", ":faction_no"),
            (assign, ":raiding_by_one_other_faction", 1),
          (else_try),
            (assign, ":raiding_by_one_other_faction", 0),
          (try_end),
          (this_or_next|party_slot_eq, ":potential_target", slot_village_state, svs_looted),
          (eq, ":raiding_by_one_other_faction", 1),
          (assign, ":village_is_looted_or_raided_already", 1),
        (try_end),
        (eq, ":village_is_looted_or_raided_already", 0),

        #if ":potential_target" is faction object of some other faction which is enemy to owner of
        #":potential_target" then this target cannot be new target we are looking for.
        (assign, ":this_potantial_target_is_target_of_some_other_faction", 0),
        (try_for_range, ":cur_faction", kingdoms_begin, kingdoms_end),
          (is_between, ":cur_faction", "fac_kingdom_1", kingdoms_end), #Excluding player kingdom
          (neq, ":cur_faction", ":faction_no"),
          (faction_get_slot, ":faction_object", ":cur_faction", slot_faction_ai_object),
          (eq, ":faction_object", ":potential_target"),
          (store_relation, ":rel", ":potential_target_faction", ":cur_faction"),
          (lt, ":rel", 0),
          (assign, ":this_potantial_target_is_target_of_some_other_faction", 1),
        (try_end),
        (eq, ":this_potantial_target_is_target_of_some_other_faction", 0),

        (try_begin),
          (is_between, ":potential_target", walled_centers_begin, walled_centers_end),
          (party_get_slot, ":potential_target_inside_strength", ":potential_target", slot_party_cached_strength),
          (party_get_slot, ":potential_target_nearby_enemy_strength", ":potential_target", slot_party_nearby_friend_strength),
          (val_div, ":potential_target_nearby_enemy_strength", 2),
          (store_add, ":potential_target_strength", ":potential_target_inside_strength", ":potential_target_nearby_enemy_strength"),

          #(try_begin),
            #(eq, ":faction_no", "fac_kingdom_4"),
            #(assign, reg0, ":potential_target_inside_strength"),
            #(assign, reg1, ":potential_target_nearby_enemy_strength"),
            #(assign, reg2, ":marshal_strength"),
            #(assign, reg3, ":strength_of_potential_followers"),
            #(assign, reg4, ":strength_of_nearby_friend"),
            #(assign, reg6, ":marshal_party"),
            #(str_store_party_name, s8, ":potential_target"),
            #(eq, ":all_vassals_included", 0),
            #(display_message, "@DEBUG : {s8}:{reg0}, neare {reg1}, our {reg2}, follow {reg3}, nearf {reg4}"),
          #(try_end),

          (val_mul, ":potential_target_strength", 4), #in walled centers defenders have advantage.
          (val_div, ":potential_target_strength", 3),

          #(store_add, ":army_strength", ":marshal_strength", ":strength_of_potential_followers"),
          (assign, ":army_strength", ":marshal_strength"),
          (val_add, ":army_strength", ":strength_of_current_followers"),
          (store_mul, ":power_ratio", ":army_strength", 100),

          #this ratio ":power_ratio" shows (our total army power) / (their total army power)
          (try_begin),
            (gt, ":potential_target_strength", 0),
            (val_div, ":power_ratio", ":potential_target_strength"),
          (else_try),
            (assign, ":power_ratio", 1000),
          (try_end),
        (else_try),
          (party_get_slot, ":potential_target_nearby_enemy_strength", ":potential_target", slot_party_nearby_friend_strength),
          (assign, ":potential_target_strength", 1000),

          #(store_add, ":army_strength", ":marshal_strength", ":strength_of_potential_followers"),
          (assign, ":army_strength", ":marshal_strength"),
          (val_add, ":army_strength", ":strength_of_current_followers"),
          (store_mul, ":power_ratio", ":army_strength", 100),

          (try_begin),
            (gt, ":potential_target_strength", 0),
            (val_div, ":power_ratio", ":potential_target_strength"),
          (else_try),
            (assign, ":power_ratio", 1000),
          (try_end),
        (try_end),

        (ge, ":power_ratio", 120), #attack if and only if our army is at least 1.2 times powerfull
        (store_sub, ":power_ratio_sub_120", ":power_ratio", 120),

        (try_begin),
          (lt, ":power_ratio_sub_120", 100), #changes between 20..120
          (store_add, ":power_ratio_score", ":power_ratio_sub_120", 20),
        (else_try),
          (lt, ":power_ratio_sub_120", 200), #changes between 120..170
          (store_sub, ":power_ratio_score", ":power_ratio_sub_120", 100),
          (val_div, ":power_ratio_score", 2),
          (val_add, ":power_ratio_score", 120),
        (else_try),
          (lt, ":power_ratio_sub_120", 400), #changes between 170..210
          (store_sub, ":power_ratio_score", ":power_ratio_sub_120", 200),
          (val_div, ":power_ratio_score", 5),
          (val_add, ":power_ratio_score", 170),
        (else_try),
          (lt, ":power_ratio_sub_120", 800), #changes between 210..250
          (store_sub, ":power_ratio_score", ":power_ratio_sub_120", 400),
          (val_div, ":power_ratio_score", 10),
          (val_add, ":power_ratio_score", 210),
        (else_try),
          (assign, ":power_ratio_score", 250),
        (try_end),

        (assign, ":number_of_walled_centers", 0),
        (assign, ":total_distance", 0),
        (try_for_range, ":walled_center", walled_centers_begin, walled_centers_end),
          (store_faction_of_party, ":walled_center_faction", ":walled_center"),
          (eq, ":walled_center_faction", ":faction_no"),

          (store_distance_to_party_from_party, ":dist", ":walled_center", ":potential_target"),
          (val_add, ":total_distance", ":dist"),

          (val_add, ":number_of_walled_centers", 1),
        (try_end),

        (try_begin),
          (gt, ":number_of_walled_centers", 0),
          (store_div, ":average_distance", ":total_distance", ":number_of_walled_centers"),
          #(assign, reg0, ":average_distance"),
          #(str_store_faction_name, s7, ":faction_no"),
          #(str_store_party_name, s8, ":potential_target"),
          #(display_message, "@average distance for {s7} for {s8} is {reg0}"),

          (try_begin),
            (ge, ":marshal_party", 0),
            (party_is_active, ":marshal_party"),
            (store_distance_to_party_from_party, ":marshal_dist_to_potential_target", ":marshal_party", ":potential_target"),
          (else_try),
            (assign, ":marshal_dist_to_potential_target", 100),
          (try_end),

          (try_begin),
            #if currently main aim of our faction is attacking to an enemy center and that center is already besieged/raided by one of
            #our parties then divide marshal_dist_to_potential_target_div_x score for current center to "3/2" instead of "3" and this
            #result in decrease at distance_score, and also decrease some scores from power_ratio_score in order to avoid frequently
            #changes at main aimed target city of our faction during sieges.

            (faction_get_slot, ":current_ai_state", ":faction_no", slot_faction_ai_state),
            (eq, ":current_ai_state", sfai_attacking_center),
            (faction_get_slot, ":current_ai_object", ":faction_no", slot_faction_ai_object),

            (ge, ":current_ai_object", 0),
            (neq, ":current_ai_object", ":potential_target"),

            (try_begin),
              (ge, ":power_ratio_score", 300), #200 max
              (assign, ":power_ratio_score", 200),
            (else_try),
              (ge, ":power_ratio_score", 100), #100..200
              (val_sub, ":power_ratio_score", 100),
              (val_div, ":power_ratio_score", 2),
              (val_add, ":power_ratio_score", 100),
            (try_end),

            (try_begin),
              (faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),
              (eq, "$g_do_not_skip_other_than_current_ai_object", 0),
              (assign, ":power_ratio_score", 0), #lets completely forget all other choices if we are already besieging one center.
            (try_end),

            (faction_set_slot, ":faction_no", slot_faction_last_attacked_center, ":current_ai_object"),
            (store_current_hours, ":hours"),
            (faction_set_slot, ":faction_no", slot_faction_last_attacked_hours, ":hours"),

            (eq, ":all_vassals_included", 0),

            (store_mul, ":marshal_dist_to_potential_target_div_x", ":marshal_dist_to_potential_target", 2),
            (val_div, ":marshal_dist_to_potential_target_div_x", 3),
          (else_try),
            (store_div, ":marshal_dist_to_potential_target_div_x", ":marshal_dist_to_potential_target", 3),
          (try_end),

          (store_add, ":total_distance", ":average_distance", ":marshal_dist_to_potential_target_div_x"), #in average ":total_distance" is about 150, min : 0, max : 1000
        (else_try),
          (assign, ":total_distance", 100),
        (try_end),

        (try_begin),
          #according to cautious troop distance is more important
          ##diplomacy start+ Take into account lady & companion personality types
		  ##OLD:
	      #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
	      #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
	      #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),
	      #(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),
		  #
		  ##NEW:
		  (call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		  (assign, ":troop_caution", reg0),
		  (gt, ":troop_caution", 0),
		  ##diplomacy end+

          (try_begin),
            (lt, ":total_distance", 30), #very close (100p)
            (assign, ":distance_score", 100),
          (else_try),
            (lt, ":total_distance", 80), #close (50p-100p)
            (store_sub, ":distance_score", ":total_distance", 30),
            (val_div, ":distance_score", 1),
            (store_sub, ":distance_score", 100, ":distance_score"),
          (else_try),
            (lt, ":total_distance", 160), #far (10p-50p)
            (store_sub, ":distance_score", ":total_distance", 80),
            (val_div, ":distance_score", 2),
            (store_sub, ":distance_score", 50, ":distance_score"),
          (else_try),
            (assign, ":distance_score", 10), #very far
          (try_end),
        (else_try),
          #according to agressive troop distance is less important

          (try_begin),
            (lt, ":total_distance", 40), #very close (100p)
            (assign, ":distance_score", 100),
          (else_try),
            (lt, ":total_distance", 140), #close (50p-100p)
            (store_sub, ":distance_score", ":total_distance", 40),
            (val_div, ":distance_score", 2),
            (store_sub, ":distance_score", 100, ":distance_score"),
          (else_try),
            (lt, ":total_distance", 300), #far (10p-50p)
            (store_sub, ":distance_score", ":total_distance", 140),
            (val_div, ":distance_score", 4),
            (store_sub, ":distance_score", 50, ":distance_score"),
          (else_try),
            (assign, ":distance_score", 10), #very far
          (try_end),
        (try_end),
		##diplomacy start+ If AI changes are enabled, reduce distance penalty (increase score)
		##for recently-lost fiefs.
		(try_begin),
			(lt, ":distance_score", 100),
			(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
			(party_slot_eq, ":potential_target", slot_center_ex_faction, ":faction_no"),
			(party_get_slot, reg0, ":potential_target", dplmc_slot_center_last_transfer_time),
			(gt, reg0, 0),#0 means the slot was uninitialized.  A negative number would be before the start of the game.
			(store_current_hours, ":hours_since_transfer"),
			(val_sub, ":hours_since_transfer", reg0),
			(try_begin),
				(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_HIGH),
				(assign, reg0, 24 * 21),#within last three weeks
			(else_try),
				(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
				(assign, reg0, 24 * 14),#within last two weeks
			(else_try),
				(assign, reg0, 24 * 7),#within last week
			(try_end),
			(lt, ":hours_since_transfer", reg0),
			(val_add, ":distance_score", 100),
			(val_div, ":distance_score", 2),
		(try_end),
		##diplomacy end+

        (store_mul, ":target_score", ":distance_score", ":power_ratio_score"),
        (val_mul, ":target_score", ":last_offensive_time_score"),
        (val_div, ":target_score", 100), #target score is between 0..10000 generally here

        (call_script, "script_find_total_prosperity_score", ":potential_target"),
        (assign, ":total_prosperity_score", reg0),

        #(try_begin), #new for increase attackability of villages by ai
          #(is_between, ":potential_target", villages_begin, villages_end),
          (val_mul, ":total_prosperity_score", 3),
          (val_div, ":total_prosperity_score", 2),
        #(try_end),

        (val_mul, ":target_score", ":total_prosperity_score"),

        (try_begin), #if both that center was our (original center) and (ex center) than bonus is 1.2x
          (party_slot_eq, ":potential_target", slot_center_ex_faction, ":faction_no"),
          (party_slot_eq, ":potential_target", slot_center_original_faction, ":faction_no"),
          (val_mul, ":target_score", 12),
          (val_div, ":target_score", 10),
        (else_try), #if either that center was our (original center) or (ex center) than bonus is 1.1x
          (this_or_next|party_slot_eq, ":potential_target", slot_center_ex_faction, ":faction_no"),
          (party_slot_eq, ":potential_target", slot_center_original_faction, ":faction_no"),
          (val_mul, ":target_score", 11),
          (val_div, ":target_score", 10),
        (try_end),

        (val_div, ":target_score", 1000), #target score is between 0..1000 generally here

        (try_begin),
          (eq, ":potential_target_faction", "fac_player_supporters_faction"),
          (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),

          (assign, ":number_of_walled_centers_player_have", 0),
          (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
            (store_faction_of_party, ":center_faction", ":center_no"),
            (eq, ":center_faction", "fac_player_supporters_faction"),
            (val_add, ":number_of_walled_centers_player_have", 1),
          (try_end),

          (try_begin),
            (eq, ":reduce_campaign_ai", 2), #easy

            (try_begin),
              (le, ":number_of_walled_centers_player_have", 2),
              (assign, ":hardness_score", 0),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 3),
              (assign, ":hardness_score", 20),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 4),
              (assign, ":hardness_score", 40),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 5),
              (eq, ":number_of_walled_centers_player_have", 6),
              (assign, ":hardness_score", 55),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 7),
              (eq, ":number_of_walled_centers_player_have", 8),
              (eq, ":number_of_walled_centers_player_have", 9),
              (assign, ":hardness_score", 70),
            (else_try),
              (assign, ":hardness_score", 85),
            (try_end),
          (else_try),
            (eq, ":reduce_campaign_ai", 1), #medium

            (try_begin),
              (le, ":number_of_walled_centers_player_have", 1),
              (assign, ":hardness_score", 25),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 2),
              (assign, ":hardness_score", 45),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 3),
              (assign, ":hardness_score", 60),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 4),
              (eq, ":number_of_walled_centers_player_have", 5),
              (assign, ":hardness_score", 75),
            (else_try),
              (eq, ":number_of_walled_centers_player_have", 6),
              (eq, ":number_of_walled_centers_player_have", 7),
              (eq, ":number_of_walled_centers_player_have", 8),
              (assign, ":hardness_score", 85),
            (else_try),
              (assign, ":hardness_score", 92),
            (try_end),
          (else_try), #hard
            (assign, ":hardness_score", 100),
          (try_end),

          (val_mul, ":target_score", ":hardness_score"),
          (val_div, ":target_score", 100),
        (try_end),

        (try_begin),
          (ge, "$cheat_mode", 1),
          (eq, ":faction_no", "fac_kingdom_4"),
          (ge, ":target_score", -1),
          (assign, reg0, ":target_score"),
          (assign, reg7, ":total_prosperity_score"),
          (assign, reg8, ":power_ratio_score"),
          (assign, reg9, ":distance_score"),
          (assign, reg10, ":last_offensive_time_score"),
          (str_store_party_name, s8, ":potential_target"),
          #(eq, ":all_vassals_included", 0),
          (assign, reg11, ":all_vassals_included"),
          #(display_message, "@DEBUG : attack of {s8} is {reg0}({reg11}), prs:{reg7}, pow:{reg8}, dis:{reg9}, lst:{reg10}"),
        (try_end),
      (try_end),

      (assign, reg0, ":target_score"),
      (assign, reg1, ":power_ratio"),
      (assign, reg2, ":distance_score"),
      (assign, reg3, ":total_prosperity_score"),
    ]),

    #script_find_center_to_defend
    # INPUT:
    # param1: faction_no
    # OUTPUT:
    # reg0 = center_to_defend (-1 if none is logical)
    # reg1 = maximum_defend_score
    # reg3 = enemy_strength_near_most_threatened_center
    (
    "find_center_to_defend",
    [
      (store_script_param, ":troop_no", 1),

	  (store_faction_of_troop, ":faction_no", ":troop_no"),

      (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),
      (faction_get_slot, ":current_ai_state", ":faction_no", slot_faction_ai_state),
      (assign, ":marshal_party", -1),
      (try_begin),
        (gt, ":faction_marshal", 0),
        (troop_get_slot, ":marshal_party", ":faction_marshal", slot_troop_leaded_party),
      (try_end),

      (assign, ":most_threatened_center", -1),
      (assign, ":maximum_threat_score", 0),
      (try_for_range, ":cur_center", centers_begin, centers_end),
        (store_faction_of_party, ":center_faction", ":cur_center"),
        (eq, ":center_faction", ":faction_no"),

        (party_get_slot, ":exact_enemy_strength", ":cur_center", slot_center_sortie_enemy_strength),
		#Distort this to account for questionable intelligence
		#(call_script, "script_reduce_exact_number_to_estimate", ":exact_enemy_strength"),
		#(assign, ":enemy_strength_nearby", reg0),
		(assign, ":enemy_strength_nearby", ":exact_enemy_strength"),

        (assign, ":threat_importance", 0),
        (try_begin),
          (is_between, ":cur_center", walled_centers_begin, walled_centers_end),
          (party_slot_ge, ":cur_center", slot_center_is_besieged_by, 0),

          (call_script, "script_find_total_prosperity_score", ":cur_center"),
          (assign, ":total_prosperity_score", reg0),

          (party_get_slot, ":cur_center_strength", ":cur_center", slot_party_cached_strength),
          (val_mul, ":cur_center_strength", 4),
          (val_div, ":cur_center_strength", 3), #give 33% bonus to insiders because they are inside a castle

          #I removed below line and assigned ":cur_center_nearby_strength" to 0, because if not when defender army comes to help
          #threat become less because of high defence power but not yet enemy cleared.
          #(party_get_slot, ":cur_center_nearby_strength", ":cur_center", slot_party_nearby_friend_strength),
          (assign, ":cur_center_nearby_strength", 0),

          (val_add, ":cur_center_strength", ":cur_center_nearby_strength"), #add nearby friends and find ":cur_center_strength"

          (store_mul, ":power_ratio", ":enemy_strength_nearby", 100),
          (val_add, ":cur_center_strength", 1),
		  (val_max, ":cur_center_strength", 1),
          (val_div, ":power_ratio", ":cur_center_strength"),

          (assign, ":player_is_attacking", 0),
          (party_get_slot, ":besieger_party", ":cur_center", slot_center_is_besieged_by),
          (try_begin),
            (party_is_active, ":besieger_party"),
            (try_begin),
              (eq, ":besieger_party", "p_main_party"),
              (assign, ":player_is_attacking", 1),
              #(display_message, "@{!}DEBUG : player is attacking a center (1)"),
            (else_try),
              (store_faction_of_party, ":besieger_faction", ":besieger_party"),
              (eq, ":besieger_faction", "fac_player_faction"),
              (assign, ":player_is_attacking", 1),
              #(display_message, "@{!}DEBUG : player is attacking a center (2)"),
            (else_try),
              (party_get_attached_to, ":player_is_attached_to", "p_main_party"),
              (ge, ":player_is_attached_to", 0),
              (eq, ":player_is_attached_to", ":besieger_party"),
              (assign, ":player_is_attacking", 1),
              #(display_message, "@{!}DEBUG : player is attacking a center (3)"),
            (try_end),
          (try_end),

          (try_begin),
            (eq, ":player_is_attacking", 0),

            (try_begin),
              (lt, ":power_ratio", 40), #changes between 1..1
              (assign, ":threat_importance", 1),
            (else_try),
              (lt, ":power_ratio", 80), #changes between 1..7
              (store_sub, ":threat_importance", ":power_ratio", 40),
              (val_div, ":threat_importance", 5),
              (val_add, ":threat_importance", 1), #1
            (else_try),
              (lt, ":power_ratio", 120), #changes between 7..17
              (store_sub, ":threat_importance", ":power_ratio", 80),
              (val_div, ":threat_importance", 4),
              (val_add, ":threat_importance", 7), #1 + 6
            (else_try),
              (lt, ":power_ratio", 200),
              (store_sub, ":threat_importance", ":power_ratio", 120),
              (val_div, ":threat_importance", 10),
              (val_add, ":threat_importance", 17), #1 + 6 + 10
            (else_try),
              (assign, ":threat_importance", 25),
            (try_end),
          (else_try),
            (try_begin),
              (lt, ":power_ratio", 200), #changes between 5..25
              (store_div, ":threat_importance", ":power_ratio", 10),    #MOTO correction (thanks MOTO:) (mexxico))
              (val_add, ":threat_importance", 6 ),
            (else_try),
              (assign, ":threat_importance", 26),
            (try_end),
          (try_end),
        (else_try),
          (is_between, ":cur_center", villages_begin, villages_end),
          (party_slot_eq, ":cur_center", slot_village_state, svs_being_raided),

          (gt, ":enemy_strength_nearby", 0),

          (call_script, "script_find_total_prosperity_score", ":cur_center"),
          (assign, ":power_ratio", 100), #useless
          (assign, ":total_prosperity_score", reg0),
          (assign, ":threat_importance", 10), #if faction village is looted they lose money for shorter time period. So importance is something low (6-8).
        (try_end),

        (gt, ":threat_importance", 0),

        (try_begin),
          (is_between, ":cur_center", walled_centers_begin, walled_centers_end),
          (assign, ":enemy_strength_nearby_score", 120),

          (try_begin),
            (ge, ":marshal_party", 0),
            (party_is_active, ":marshal_party"),
            (store_distance_to_party_from_party, ":marshal_dist_to_cur_center", ":marshal_party", ":cur_center"),
          (else_try),
            (assign, ":marshal_dist_to_cur_center", 100),
          (try_end),

          (try_begin),
            #if currently our target is ride to break a siege then
            #divide marshal_distance for other center's to "2" instead of "4" and add some small more distance to avoid easily
            #changing mind during siege because of small score differences.

	        #(faction_get_slot, ":current_ai_state", ":faction_no", slot_faction_ai_state),
            (eq, ":current_ai_state", sfai_attacking_enemies_around_center),
            (faction_get_slot, ":current_ai_object", ":faction_no", slot_faction_ai_object),
            (is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
            (neq, ":current_ai_object", ":cur_center"),
            (val_mul, ":marshal_dist_to_cur_center", 2),
            (val_add, ":marshal_dist_to_cur_center", 20),
          (try_end),

          (val_mul, ":marshal_dist_to_cur_center", 2), #standard multipication (1.5x) to adjust distance scoring same with formula at find_center_to_attack
          #(val_div, ":marshal_dist_to_cur_center", 2),

          (try_begin),
            (lt, ":marshal_dist_to_cur_center", 10), #very close (100p)
            (assign, ":distance_score", 100),
          (else_try),
            (lt, ":marshal_dist_to_cur_center", 160), #close (50p-100p)
            (store_sub, ":distance_score", ":marshal_dist_to_cur_center", 10),
            (val_div, ":distance_score", 3),
            (store_sub, ":distance_score", 100, ":distance_score"),
          (else_try),
            (lt, ":marshal_dist_to_cur_center", 360), #far (10p-50p)
            (store_sub, ":distance_score", ":marshal_dist_to_cur_center", 250),
            (val_div, ":distance_score", 5),
            (store_sub, ":distance_score", 50, ":distance_score"),
          (else_try),
            (assign, ":distance_score", 10), #very far
          (try_end),
        (else_try),
          (store_add, ":enemy_strength_nearby_score", ":enemy_strength_nearby", 20000),
          (val_div, ":enemy_strength_nearby_score", 200),
          (assign, ":distance_score", 70), #not related to marshal's position, because everybody is going same place (no gathering in most village raids)
        (try_end),

		##diplomacy start+
		(try_begin),
			#AI changes LOW: Give priority to defending centers with lords
			(le, DPLMC_AI_CHANGES_LOW, "$g_dplmc_ai_changes"),
			(party_slot_ge, ":cur_center", slot_town_lord, 0),
			(val_mul, ":threat_importance", 120),
			(val_div, ":threat_importance", 100),
		(try_end),
		##diplomacy end+
        (store_mul, ":threat_score", ":enemy_strength_nearby_score", ":total_prosperity_score"),
        (val_mul, ":threat_score", ":threat_importance"),
        (val_mul, ":threat_score", ":distance_score"),
        (val_div, ":threat_score", 10000),

        (try_begin),
		  (ge, "$cheat_mode", 1),
          (gt, ":threat_score", 0),
          (eq, ":faction_no", "fac_kingdom_6"),
          (assign, reg0, ":threat_score"),
          (str_store_party_name, s32, ":cur_center"),
          (assign, reg1,  ":total_prosperity_score"),
          (assign, reg2, ":enemy_strength_nearby_score"),
          (assign, reg3, ":threat_importance"),
          (assign, reg4, ":distance_score"),
          #(display_message, "@{!}DEBUG : defend of {s32} is {reg0}, prosperity:{reg1}, enemy nearby:{reg2}, threat importance:{reg3}, distance: {reg4}"),
        (try_end),

        (gt, ":threat_score", ":maximum_threat_score"),

        (assign, ":most_threatened_center", ":cur_center"),
        (assign, ":maximum_threat_score", ":threat_score"),
        (assign, ":enemy_strength_near_most_threatened_center", ":enemy_strength_nearby"),
      (try_end),

      (val_mul, ":maximum_threat_score", 3),
      (val_div, ":maximum_threat_score", 2),

      (assign, reg0, ":most_threatened_center"),
      (assign, reg1, ":maximum_threat_score"),
      (assign, reg2, ":enemy_strength_near_most_threatened_center"),
    ]),


	#script_npc_decision_checklist_peace_or_war
   ##diplomacy start+
   #Modified this to return additional information.
	##diplomacy end+
	(
	"npc_decision_checklist_peace_or_war",
	#this script is used to add a bit more color to diplomacy, particularly with regards to the player

	[
	(store_script_param, ":actor_faction", 1),
	(store_script_param, ":target_faction", 2),
	(store_script_param, ":envoy", 3),

	##diplomacy start+
	#Since "fac_player_supporters_faction" is used as a synonym for "the faction led by the player"
	#in many places, correct this here.
	(call_script, "script_dplmc_translate_inactive_player_supporter_faction_2", ":actor_faction", ":target_faction"),
	(assign, ":actor_faction", reg0),
	(assign, ":target_faction", reg1),
	##diplomacy end+

	(assign, ":actor_strength", 0),
	(assign, ":target_strength", 0),
	(assign, ":actor_centers_held_by_target", 0),

#	(assign, ":two_factions_share_border", 0),
	(assign, ":third_party_war", 0),
	(assign, ":num_third_party_wars", 0),

	(assign, ":active_mutual_enemy", 0), #an active enemy with which the target is at war
	(assign, "$g_concession_demanded", 0),
	##diplomacy start+
	(assign, ":last_center_lost", 0),#  last center lost to the target faction
	(assign, ":last_center_lost_time", 0),# time the last center was lost to the target faction

	#"Third party" after taking into account alliances
	#(assign, ":actual_third_party_war", 0),
	(assign, ":num_actual_third_party_wars", 0),
	##diplomacy end+

	(store_relation, ":current_faction_relation", ":actor_faction", ":target_faction"),

	(try_begin),
		(eq, ":target_faction", "fac_player_supporters_faction"),
		(assign, ":modified_honor_and_relation", "$player_honor"), #this can be affected by the emissary's skill

		(val_add, ":target_strength", 2), #for player party
	(else_try),
		(assign, ":modified_honor_and_relation", 0), #this can be affected by the emissary's skill
	(try_end),

	(faction_get_slot, ":actor_leader", ":actor_faction", slot_faction_leader),
	(faction_get_slot, ":target_leader", ":target_faction", slot_faction_leader),

	(call_script, "script_troop_get_relation_with_troop", ":actor_leader", ":target_leader"),

	(assign, ":relation_bonus", reg0),
	(val_min, ":relation_bonus", 10),
	(val_add, ":modified_honor_and_relation", ":relation_bonus"),

	(str_store_troop_name, s15, ":actor_leader"),
	(str_store_troop_name, s16, ":target_leader"),


	(assign, ":war_damage_suffered", 0),
	(assign, ":war_damage_inflicted", 0),

	(call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction", ":actor_faction", ":target_faction"),
	(assign, ":war_peace_truce_status", reg0),
	(str_clear, s12),
	(try_begin),
		(eq, ":war_peace_truce_status", -2),
		(str_store_string, s12, "str_s15_is_at_war_with_s16_"),

		(store_add, ":war_damage_inflicted_slot", ":target_faction", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":war_damage_inflicted_slot", kingdoms_begin),
		(faction_get_slot, ":war_damage_inflicted", ":actor_faction", ":war_damage_inflicted_slot"),

		(store_add, ":war_damage_suffered_slot", ":actor_faction", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":war_damage_suffered_slot", kingdoms_begin),
		(faction_get_slot, ":war_damage_suffered", ":target_faction", ":war_damage_suffered_slot"),


	(else_try),
		#truce in effect
		(eq, ":war_peace_truce_status", 1),
		(str_store_string, s12, "str_in_the_short_term_s15_has_a_truce_with_s16_as_a_matter_of_general_policy_"),
	(else_try),
		#provocation noted
		(eq, ":war_peace_truce_status", -1),
		(str_store_string, s12, "str_in_the_short_term_s15_was_recently_provoked_by_s16_and_is_under_pressure_to_declare_war_as_a_matter_of_general_policy_"),
	(try_end),

	#clear for dialog with lords
	(try_begin),
		(is_between, "$g_talk_troop", active_npcs_begin, active_npcs_end),
		(str_clear, s12),
	(try_end),

	(try_begin),
		(gt, ":envoy", -1),
		(store_skill_level, ":persuasion_x_2", "skl_persuasion", ":envoy"),
		(val_mul, ":persuasion_x_2", 2),
		(val_add, ":modified_honor_and_relation", ":persuasion_x_2"),

		(try_begin),
			(eq, "$cheat_mode", 1),
			(assign, reg4, ":modified_honor_and_relation"),
			(display_message, "str_envoymodified_diplomacy_score_honor_plus_relation_plus_envoy_persuasion_=_reg4"),
		(try_end),

	(try_end),


	(try_for_range, ":kingdom_to_reset", kingdoms_begin, kingdoms_end),
		(faction_set_slot, ":kingdom_to_reset", slot_faction_temp_slot, 0),
	(try_end),

	(try_for_parties, ":party_no"),
		(assign, ":party_value", 0),
		(try_begin),
			(is_between, ":party_no", towns_begin, towns_end),
			(assign, ":party_value", 3),
		(else_try),
			(is_between, ":party_no", castles_begin, castles_end),
			(assign, ":party_value", 2),
		(else_try),
			(is_between, ":party_no", villages_begin, villages_end),
			(assign, ":party_value", 1),
		(else_try),
			(party_get_template_id, ":template", ":party_no"),
			(eq, ":template", "pt_kingdom_hero_party"),
			(assign, ":party_value", 2),
		(try_end),


		(store_faction_of_party, ":party_current_faction", ":party_no"),
		(party_get_slot, ":party_original_faction", ":party_no", slot_center_original_faction),
		(party_get_slot, ":party_ex_faction", ":party_no", slot_center_ex_faction),


		#total strengths
		(try_begin),
			(is_between, ":party_current_faction", kingdoms_begin, kingdoms_end),
			(faction_get_slot, ":faction_strength", ":party_current_faction", slot_faction_temp_slot),
			(val_add, ":faction_strength", ":party_value"),
			(faction_set_slot, ":party_current_faction", slot_faction_temp_slot, ":faction_strength"),
		(try_end),


		(try_begin),
			(eq, ":party_current_faction", ":target_faction"),
			(val_add, ":target_strength", ":party_value"),

			(try_begin),
				(this_or_next|eq, ":party_original_faction", ":actor_faction"),
					(eq, ":party_ex_faction", ":actor_faction"),
				(val_add, ":actor_centers_held_by_target", 1),
				(try_begin),
					(is_between, ":party_no", walled_centers_begin, walled_centers_end),
					(assign, "$g_concession_demanded", ":party_no"),
					(str_store_party_name, s18, "$g_concession_demanded"),
					##diplomacy start+ Also track the most recently taken walled center
					(eq, ":party_ex_faction", ":actor_faction"),
					(this_or_next|lt, ":last_center_lost", 1),
						(party_slot_ge, ":party_no", dplmc_slot_center_last_transfer_time, ":last_center_lost_time"),
					(assign, ":last_center_lost", ":party_no"),
					(party_get_slot, ":last_center_lost_time", ":party_no", dplmc_slot_center_last_transfer_time),
					##diplomacy end+
				(try_end),
			(try_end),

# Could include two factions share border, but war is unlikely to break out in the first place unless there is a common border

#			(try_begin),
#				(is_between, ":party_no", walled_centers_begin, walled_centers_end),
#				(try_for_range, ":other_center", walled_centers_begin, walled_centers_end),
#					(assign, ":two_factions_share_border", 0),
#					(store_faction_of_party, ":other_faction", ":other_center"),
#					(eq, ":other_faction", ":actor_faction"),
#					(store_distance_to_party_from_party, ":distance", ":party_no", ":other_center"),
#					(le, ":distance", 15),
#					(assign, ":two_factions_share_border", 1),
#				(try_end),
#			(try_end),
		(else_try),
			(eq, ":party_current_faction", ":actor_faction"),
			(val_add, ":actor_strength", ":party_value"),
		(try_end),
	(try_end),

	#Total Calradia strength = 110 x 1 (villages,), 48? x 2 castles, 22 x 3 towns, 88 x 2 lord parties = 272 + 176 = 448
	(assign, ":strongest_kingdom", -1),
	(assign, ":score_to_beat", 60), #Maybe raise once it works
	##diplomacy start+
	#Take into account alliances
	(assign, ":strongest_kingdom_offensive", -1),
	(assign, ":strongest_kingdom_offensive_score", -1),

	(assign, ":strongest_kingdom_defensive", -1),
	(assign, ":strongest_kingdom_defensive_score", -1),

	(faction_get_slot, ":actor_offensive_score", ":actor_faction", slot_faction_temp_slot),
	(faction_get_slot, ":actor_defensive_score", ":actor_faction", slot_faction_temp_slot),

	#(faction_get_slot, ":target_offensive_score", ":target_faction", slot_faction_temp_slot),
	(faction_get_slot, ":target_defensive_score", ":target_faction", slot_faction_temp_slot),

	#Use these instead of just counting the number of factions
    (assign, ":strength_against_actor", 0),
	(assign, ":strength_against_target", 0),

	##diplomacy end+
	(try_for_range, ":strongest_kingdom_candidate", kingdoms_begin, kingdoms_end),
		(faction_get_slot, ":candidate_strength", ":strongest_kingdom_candidate", slot_faction_temp_slot),
		##diplomacy start+
		#Take into account allies
		(assign, ":candidate_offensive_score", ":candidate_strength"),
		(assign, ":candidate_defensive_score", ":candidate_strength"),
		(try_for_range, ":other_kingdom", kingdoms_begin, kingdoms_end),
		   (neq, ":other_kingdom", ":strongest_kingdom_candidate"),
			(faction_get_slot, ":other_kingdom_strength", ":other_kingdom", slot_faction_temp_slot),
			(call_script, "script_dplmc_get_faction_truce_length_with_faction", ":strongest_kingdom_candidate", ":other_kingdom"),
			#Add 90% rather than 100%, because otherwise, if several kingdoms are
			#allied all of them will have the same strength by this measurement.
			(try_begin),
					 #Full alliance
					 (gt, reg0, dplmc_treaty_alliance_days_expire),
					 (store_mul, reg0, ":other_kingdom_strength", 9),
					 (val_div, reg0, 10),
					 (val_add, ":candidate_offensive_score", reg0),
					 (val_add, ":candidate_defensive_score", reg0),
			(else_try),
					 #Defensive alliance
					 (gt, reg0, dplmc_treaty_defense_days_expire),
					 (store_mul, reg0, ":other_kingdom_strength", 9),
					 (val_div, reg0, 10),
					 (val_add, ":candidate_defensive_score", reg0),
			(try_end),
		(try_end),
		#Update actor/target strengths with alliances, and "strength against"
		(try_begin),
			(eq, ":strongest_kingdom_candidate", ":actor_faction"),
			(assign, ":actor_offensive_score", ":candidate_offensive_score"),
			(assign, ":actor_defensive_score", ":candidate_defensive_score"),
		(else_try),
			(store_relation, ":relation", ":strongest_kingdom_candidate", ":actor_faction"),
			(lt, ":relation", 0),
			(val_add, ":strength_against_actor", ":other_kingdom_strength"),
		(try_end),
		(try_begin),
			(eq, ":strongest_kingdom_candidate", ":target_faction"),
			#(assign, ":target_offensive_score", ":candidate_offensive_score"),
			(assign, ":target_defensive_score", ":candidate_defensive_score"),
		(else_try),
			(store_relation, ":relation", ":strongest_kingdom_candidate", ":target_faction"),
			(lt, ":relation", 0),
			(val_add, ":strength_against_target", ":other_kingdom_strength"),
		(try_end),
		#Update global max/min
		(try_begin),
			(gt, ":candidate_offensive_score", ":strongest_kingdom_offensive_score"),
			(assign, ":strongest_kingdom_offensive", ":strongest_kingdom_candidate"),
			(assign, ":strongest_kingdom_offensive_score", ":candidate_offensive_score"),
		(try_end),
		(try_begin),
			(gt, ":candidate_defensive_score", ":strongest_kingdom_defensive_score"),
			(assign, ":strongest_kingdom_defensive", ":strongest_kingdom_candidate"),
			(assign, ":strongest_kingdom_defensive_score", ":candidate_defensive_score"),
		(try_end),
		##diplomacy end+
		(gt, ":candidate_strength", ":score_to_beat"),
		(assign, ":strongest_kingdom", ":strongest_kingdom_candidate"),
		(assign, ":score_to_beat", ":candidate_strength"),
	(try_end),


	(try_begin),
		(eq, "$cheat_mode", 2),
		(gt, ":strongest_kingdom", 1),
		(str_store_faction_name, s4, ":strongest_kingdom"),
		(assign, reg3, ":score_to_beat"),
		(display_message, "@{!}DEBUG - {s4} strongest kingdom with {reg3} strength"),
		##diplomacy start+ Show strongest counting alliances if it's different
		(try_begin),
			(gt, ":strongest_kingdom_offensive", 0),
			(neq, ":strongest_kingdom_offensive", ":strongest_kingdom"),
			(str_store_faction_name, s4, ":strongest_kingdom_offensive"),
			(assign, reg3, ":strongest_kingdom_offensive_score"),
			(display_message, "@{!}DEBUG - including offensive and defensive alliances {s4} strongest kingdom with {reg3} strength"),
		(try_end),
		(try_begin),
			(gt, ":strongest_kingdom_defensive", 0),
			(neq, ":strongest_kingdom_defensive", ":strongest_kingdom"),
			(neq, ":strongest_kingdom_defensive", ":strongest_kingdom_offensive"),
			(str_store_faction_name, s4, ":strongest_kingdom_defensive"),
			(assign, reg3, ":strongest_kingdom_defensive_score"),
			(display_message, "@{!}DEBUG - including only defensive alliances {s4} strongest kingdom with {reg3} strength"),
		(try_end),
		#Revert values
		(assign, reg3, ":score_to_beat"),
		(str_store_faction_name, s4, ":strongest_kingdom"),
		##diplomacy end+
	(try_end),


	(assign, ":strength_ratio", 1),
	(try_begin),
		(gt, ":actor_strength", 0),
		(store_mul, ":strength_ratio", ":target_strength", 100),
		(val_div, ":strength_ratio", ":actor_strength"),
	(try_end),
	##diplomacy start+
	#Other strength ratios using strengths counting alliances
	(assign, ":strength_ratio_new_attack", 1),
	(try_begin),
		(gt, ":actor_offensive_score", 0),
		(store_mul, ":strength_ratio_new_attack", ":target_defensive_score", 100),
		(val_div, ":strength_ratio_new_attack", ":actor_offensive_score"),
	(try_end),
	(assign, ":strength_ratio_current_war", 1),
	(try_begin),
		(gt, ":actor_defensive_score", 0),
		(store_mul, ":strength_ratio_current_war", ":target_defensive_score", 100),
		(val_div, ":strength_ratio_current_war", ":actor_defensive_score"),
	(try_end),
	#Calculate the total magnitude of the forces hostile to the faction versus its allies
	(assign, ":strength_ratio_all_enemies_actor", 1),
	(try_begin),
		(gt, ":actor_defensive_score", 0),
		(store_mul, ":strength_ratio_all_enemies_actor", ":strength_against_actor", 100),
		(val_div, ":strength_ratio_all_enemies_actor", ":actor_defensive_score"),
	(try_end),
	##diplomacy end+

	(try_for_range, ":possible_mutual_enemy", kingdoms_begin, kingdoms_end),
		(neq, ":possible_mutual_enemy", ":target_faction"),
		(neq, ":possible_mutual_enemy", ":actor_faction"),
		(faction_slot_eq, ":possible_mutual_enemy", slot_faction_state, sfs_active),

		(store_relation, ":relation", ":possible_mutual_enemy", ":actor_faction"),
		(lt, ":relation", 0),
		(assign, ":third_party_war", ":possible_mutual_enemy"),
		(val_add, ":num_third_party_wars", 1),

		##diplomacy start+
		##ACTUAL third-party wars (i.e. not allied to the target faction)
		(call_script, "script_dplmc_get_faction_truce_length_with_faction", ":target_faction", ":possible_mutual_enemy"),
		(try_begin),
			(neg|gt, reg0, dplmc_treaty_defense_days_expire),
			#(assign, ":actual_third_party_war", ":possible_mutual_enemy"),
			(val_add, ":num_actual_third_party_wars", 1),
		(try_end),
		##diplomacy end+

		(store_relation, ":relation", ":possible_mutual_enemy", ":target_faction"),
		(lt, ":relation", 0),
		(assign, ":active_mutual_enemy", ":possible_mutual_enemy"),
	(try_end),

	(store_current_hours, ":cur_hours"),
    (faction_get_slot, ":faction_ai_last_decisive_event", ":actor_faction", slot_faction_ai_last_decisive_event),
    (store_sub, ":hours_since_last_decisive_event", ":cur_hours", ":faction_ai_last_decisive_event"),

	##diplomacy start+ use gender script
	(call_script, "script_dplmc_store_troop_is_female_reg", ":actor_leader", 4),
	##diplomacy end+

	(try_begin),
		(gt, "$supported_pretender", 0),
		(this_or_next|eq, "$supported_pretender", ":actor_leader"),
			(eq, "$supported_pretender", ":target_leader"),
		(this_or_next|eq, ":actor_faction", "$supported_pretender_old_faction"),
            (eq, ":target_faction", "$supported_pretender_old_faction"),

		(assign, ":result", -3),
		##diplomacy start+
		#(troop_get_type, reg4, ":actor_leader"),#<- commented out
		##diplomacy end+
		(assign, ":explainer_string", "str_s12s15_cannot_negotiate_with_s16_as_to_do_so_would_undermine_reg4herhis_own_claim_to_the_throne_this_civil_war_must_almost_certainly_end_with_the_defeat_of_one_side_or_another"),
	(else_try),
		(lt, ":modified_honor_and_relation", -20),
		##diplomacy start+ Take into account strengths including alliances
		(this_or_next|lt, ":strength_ratio_current_war", 125),
		##diplomacy end+
		(lt, ":strength_ratio", 125),
		(lt, ":war_damage_suffered", 400),
		(this_or_next|neq, ":war_peace_truce_status", -2),
			(lt, ":hours_since_last_decisive_event", 720),
		##diplomacy start+ Examine strength of enemies versus allies
		(this_or_next|lt, ":strength_ratio_all_enemies_actor", 125),
		##diplomacy end+
		(eq, ":num_third_party_wars", 0),

		(assign, ":result", -3),
		##diplomacy start+
		#(troop_get_type, reg4, ":actor_leader"),#<- commented out
		##diplomacy end+
		(assign, ":explainer_string", "str_s12s15_considers_s16_to_be_dangerous_and_untrustworthy_and_shehe_wants_to_bring_s16_down"),
	(else_try),
		(gt, ":actor_centers_held_by_target", 0),
		(try_begin),
		  (eq, "$cheat_mode", 1),
		  (display_message, "@{!}Actor centers held by target noted"),
		(try_end),

		(lt, ":war_damage_suffered", 200),
		(try_begin),
		  (eq, "$cheat_mode", 1),
          (display_message, "@{!}War damage under minimum"),
		(try_end),

		##diplomacy start+ Take into account strengths including alliances
		(this_or_next|lt, ":strength_ratio_current_war", 125),
		##diplomacy end+
		(lt, ":strength_ratio", 125),
		(try_begin),
		  (eq, "$cheat_mode", 1),
          (display_message, "@{!}Strength ratio correct"),
		(try_end),
		##diplomacy start+ Examine strength of enemies versus allies
		(this_or_next|lt, ":strength_ratio_all_enemies_actor", 125),
		##diplomacy end+
		(eq, ":num_third_party_wars", 0),
		(try_begin),
		  (eq, "$cheat_mode", 1),
          (display_message, "@{!}Third party wars"),
		(try_end),

		(assign, ":result", -2),
		(assign, ":explainer_string", "str_s12s15_is_anxious_to_reclaim_old_lands_such_as_s18_now_held_by_s16"),
	(else_try),
		(eq, ":war_peace_truce_status", -2),
		##diplomacy start+ Take into account strengths including alliances
		(this_or_next|lt, ":strength_ratio_current_war", 125),
		##diplomacy end+
		(lt, ":strength_ratio", 125),
		(le, ":num_third_party_wars", 1),
		(ge, ":war_damage_inflicted", 5),
		(this_or_next|neq, ":war_peace_truce_status", -2),
			(lt, ":hours_since_last_decisive_event", 720),

		(store_mul, ":war_damage_suffered_x_2", ":war_damage_suffered", 2),
		(gt, ":war_damage_inflicted", ":war_damage_suffered_x_2"),

		(assign, ":result", -2),
		##diplomacy start+
		#(troop_get_type, reg4, ":actor_leader"),#<- commented out
		##diplomacy end+
		(assign, ":explainer_string", "str_s12s15_feels_that_reg4shehe_is_winning_the_war_against_s16_and_sees_no_reason_not_to_continue"),
	(else_try),
		(le, ":war_peace_truce_status", -1),

		(this_or_next|eq, ":war_peace_truce_status", -1), #either a war is just beginning, or there is a provocation
			(le, ":war_damage_inflicted", 1),
		##diplomacy start+ Take into account strengths including alliances
		(this_or_next|lt, ":strength_ratio_new_attack", 150),
		##diplomacy end+
		(lt, ":strength_ratio", 150),
		##diplomacy start+ Examine strength of enemies versus allies
		(this_or_next|lt, ":strength_ratio_all_enemies_actor", 150),
		##diplomacy end+
		(eq, ":num_third_party_wars", 0),

		(faction_slot_ge, ":actor_faction", slot_faction_instability, 60),

		(assign, ":result", -1),
		(assign, ":explainer_string", "str_s12s15_faces_too_much_internal_discontent_to_feel_comfortable_ignoring_recent_provocations_by_s16s_subjects"),
	(else_try),
		(eq, ":war_peace_truce_status", -2),
		(lt, ":war_damage_inflicted", 100),
		(eq, ":num_third_party_wars", 1),

		(assign, ":result", -1),
		##diplomacy start+
		#(troop_get_type, reg4, ":actor_leader"),#<- commented out
		##diplomacy end+
		(assign, ":explainer_string", "str_s12even_though_reg4shehe_is_fighting_on_two_fronts_s15_is_inclined_to_continue_the_war_against_s16_for_a_little_while_longer_for_the_sake_of_honor"),

	(else_try),
		(eq, ":war_peace_truce_status", -2),
		(lt, ":war_damage_inflicted", 100),
		(eq, ":num_third_party_wars", 0),

		(assign, ":result", -1),
		##diplomacy start+
		#(troop_get_type, reg4, ":actor_leader"),#<- commented out
		##diplomacy end+
		(assign, ":explainer_string", "str_s12s15_feels_that_reg4shehe_must_pursue_the_war_against_s16_for_a_little_while_longer_for_the_sake_of_honor"),
	(else_try),
		(this_or_next|faction_slot_eq, ":actor_faction", slot_faction_ai_state, sfai_attacking_center),
		(this_or_next|faction_slot_eq, ":actor_faction", slot_faction_ai_state, sfai_raiding_village),
			(faction_slot_eq, ":actor_faction", slot_faction_ai_state, sfai_attacking_enemy_army),
		(faction_get_slot, ":offensive_object", ":actor_faction", slot_faction_ai_object),
		(party_is_active, ":offensive_object"),
		(store_faction_of_party, ":offensive_object_faction", ":offensive_object"),
		(eq, ":offensive_object_faction", ":target_faction"),
		(str_store_party_name, s17, ":offensive_object"),

		(assign, ":result", -1),
		(assign, ":explainer_string", "str_s12s15_is_currently_on_the_offensive_against_s17_now_held_by_s16_and_reluctant_to_negotiate"),


	(else_try),
		#Attack strongest kingdom, if it is also at war
		##diplomacy start+ Take into account strengths including alliances
		(this_or_next|eq, ":strongest_kingdom_offensive", ":target_faction"),
		##diplomacy end+
		(eq, ":strongest_kingdom", ":target_faction"),
		(eq, ":num_third_party_wars", 0),

		#Either not at war, or at war for two months
		(this_or_next|ge, ":war_peace_truce_status", -1),
			(lt, ":hours_since_last_decisive_event", 1440),

#		(eq, ":two_factions_share_border", 0),

		(assign, ":at_least_one_other_faction_at_war_with_strongest", 0),
		(try_for_range, ":kingdom_to_check", kingdoms_begin, kingdoms_end),
			(neq, ":kingdom_to_check", ":actor_faction"),
			(neq, ":kingdom_to_check", ":target_faction"),
			(faction_slot_eq, ":kingdom_to_check", slot_faction_state, sfs_active),
			(store_relation, ":relation_of_factions", ":kingdom_to_check", ":target_faction"),
			(lt, ":relation_of_factions", 0),
			(assign, ":at_least_one_other_faction_at_war_with_strongest", 1),
		(try_end),
		(eq, ":at_least_one_other_faction_at_war_with_strongest", 1),


		(assign, ":result", -1),
		(assign, ":explainer_string", "str_s12s15_is_alarmed_by_the_growing_power_of_s16"),

	#bid to conquer all Calradia
	(else_try),
		(eq, ":num_third_party_wars", 0),
		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- No third party wars for {s15}"),
		(try_end),
		(eq, ":actor_faction", ":strongest_kingdom"),
		#peace with no truce or provocation

		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- {s15} is strongest kingdom"),
		(try_end),


		(faction_get_slot, ":actor_strength", ":actor_faction", slot_faction_temp_slot),
		(faction_get_slot, ":target_strength", ":target_faction", slot_faction_temp_slot),
		(store_sub, ":strength_difference", ":actor_strength", ":target_strength"),
		##diplomacy start+ Include bonus from alliance
		(store_sub, reg0, ":actor_offensive_score", ":target_defensive_score"),
		(this_or_next|ge, reg0, 30),
		##diplomacy end+
		(ge, ":strength_difference", 30),

		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- {s15} has 30 point advantage over {s16}"),
		(try_end),


		(assign, ":nearby_center_found", 0),
		(try_for_range, ":actor_faction_walled_center", walled_centers_begin, walled_centers_end),
			(store_faction_of_party, ":walled_center_faction_1", ":actor_faction_walled_center"),
			(eq, ":walled_center_faction_1", ":actor_faction"),
			(try_for_range, ":target_faction_walled_center", walled_centers_begin, walled_centers_end),
				(store_faction_of_party, ":walled_center_faction_2", ":target_faction_walled_center"),
				(eq, ":walled_center_faction_2", ":target_faction"),
				(store_distance_to_party_from_party, ":distance", ":target_faction_walled_center", ":actor_faction_walled_center"),
				(lt, ":distance", 25),
				(assign, ":nearby_center_found", 1),
			(try_end),
		(try_end),
		(eq, ":nearby_center_found", 1),


		(try_begin),
			(ge, "$cheat_mode", 1),
			(display_message, "@{!}DEBUG -- {s15} has proximity to {s16}"),
		(try_end),

		(assign, ":result", -1),
		(assign, ":explainer_string", "str_s12s15_declared_war_to_control_calradia"),

	(else_try),
		(lt, ":modified_honor_and_relation", -20),

		(assign, ":result", 0),
		(assign, ":explainer_string", "str_s12s15_distrusts_s16_and_fears_that_any_deals_struck_between_the_two_realms_will_not_be_kept"),


	#wishes to deal
	(else_try),
		(lt, ":current_faction_relation", 0),
		(ge, ":num_third_party_wars", 2),
		(assign, ":result", 3),

		(assign, ":explainer_string", "str_s12s15_is_at_war_on_too_many_fronts_and_eager_to_make_peace_with_s16"),
	(else_try),
		(gt, ":active_mutual_enemy", 0),
		(eq, ":actor_centers_held_by_target", 0),
		(this_or_next|ge, ":current_faction_relation", 0),
#			(eq, ":two_factions_share_border", 0),
			(eq, 1, 1),

		(assign, ":result", 3),
		(str_store_faction_name, s17, ":active_mutual_enemy"),
		##diplomacy start+
		#(troop_get_type, reg4, ":actor_leader"),#<- commented out
		##diplomacy end+
		(assign, ":explainer_string", "str_s12s15_seems_to_think_that_s16_and_reg4shehe_have_a_common_enemy_in_the_s17"),

	(else_try),
		(eq, ":war_peace_truce_status", -2),
		(ge, ":hours_since_last_decisive_event", 720),

		##diplomacy start+
		#(troop_get_type, reg4, ":actor_leader"),#<- commented out
		##diplomacy end+

		(assign, ":result", 2),
		(assign, ":explainer_string", "str_s12s15_feels_frustrated_by_reg4herhis_inability_to_strike_a_decisive_blow_against_s16"),


	(else_try),
		(lt, ":current_faction_relation", 0),
		(gt, ":war_damage_suffered", 100),

		(val_mul, ":war_damage_suffered_x_2", 2),
		(lt, ":war_damage_inflicted", ":war_damage_suffered_x_2"),

		(assign, ":result", 2),
		(assign, ":explainer_string", "str_s12s15_has_suffered_enough_in_the_war_with_s16_for_too_little_gain_and_is_ready_to_pursue_a_peace"),

	(else_try),
		(gt, ":third_party_war", 0),
		(ge, ":modified_honor_and_relation", 0),
		(lt, ":current_faction_relation", 0),

		(assign, ":result", 1),
		(str_store_faction_name, s17, ":third_party_war"),
		(assign, ":explainer_string", "str_s12s15_would_like_to_firm_up_a_truce_with_s16_to_respond_to_the_threat_from_the_s17"),
	(else_try),
		(gt, ":third_party_war", 0),
		(ge, ":modified_honor_and_relation", 0),

		(assign, ":result", 1),
		(str_store_faction_name, s17, ":third_party_war"),
		(assign, ":explainer_string", "str_s12s15_wishes_to_be_at_peace_with_s16_so_as_to_pursue_the_war_against_the_s17"),
	(else_try),
		(gt, ":strength_ratio", 175),
#		(eq, ":two_factions_share_border", 1),

		(assign, ":result", 1),
		(assign, ":explainer_string", "str_s12s15_seems_to_be_intimidated_by_s16_and_would_like_to_avoid_hostilities"),
	(else_try),
		(lt, ":current_faction_relation", 0),

		(assign, ":result", 1),
		(assign, ":explainer_string", "str_s12s15_has_no_particular_reason_to_continue_the_war_with_s16_and_would_probably_make_peace_if_given_the_opportunity"),
	(else_try),
		(assign, ":result", 1),
		(assign, ":explainer_string", "str_s12s15_seems_to_be_willing_to_improve_relations_with_s16"),
	(try_end),
	##diplomacy start+
	#Possibly change the concession demanded
	(try_begin),
		(gt, "$g_concession_demanded", 0),
		(gt, ":last_center_lost", 0),
		(neq, "$g_concession_demanded", ":last_center_lost"),
		(try_begin),
			#This logically can't happen due to the order centers appear in
			(is_between, "$g_concession_demanded", towns_begin, towns_end),
			(neg|is_between, ":last_center_lost", towns_begin, towns_end),#Do not replace
		(else_try),
			(is_between, ":last_center_lost", towns_begin, towns_end),
			(neg|is_between, "$g_concession_demanded", towns_begin, towns_end),
			(assign, "$g_concession_demanded", ":last_center_lost"),
		(else_try),
			(party_slot_eq, ":last_center_lost", slot_center_original_faction, ":actor_faction"),
			(neg|party_slot_eq, "$g_concession_demanded", slot_center_original_faction, ":actor_faction"),
			(assign, "$g_concession_demanded", ":last_center_lost"),
		(try_end),
		(eq, "$g_concession_demanded", ":last_center_lost"),
		(str_store_party_name, s18, "$g_concession_demanded"),#change s18 to match
	(try_end),
	##diplomacy end+
	(str_store_string, s14, ":explainer_string"),
	(assign, reg0, ":result"),
	(assign, reg1, ":explainer_string"),

	]),

	("npc_decision_checklist_male_guardian_assess_suitor", #parameters from dialog
	[
	(store_script_param, ":lord", 1),
	(store_script_param, ":suitor", 2),

	(troop_get_slot, ":lord_reputation", ":lord", slot_lord_reputation_type),
	(store_faction_of_troop, ":lord_faction", ":lord"),

	(try_begin),
		(eq, ":suitor", "trp_player"),
		(assign, ":suitor_faction", "$players_kingdom"),
	(else_try),
		(store_faction_of_troop, ":suitor_faction", ":suitor"),
	(try_end),
	(store_relation, ":faction_relation_with_suitor", ":lord_faction", ":suitor_faction"),

	(call_script, "script_troop_get_relation_with_troop", ":lord", ":suitor"),
	(assign, ":lord_suitor_relation", reg0),



	(troop_get_slot, ":suitor_renown", ":suitor", slot_troop_renown),


	(assign, ":competitor_found", -1),

	(try_begin),
		(eq, ":suitor", "trp_player"),
		(gt, "$marriage_candidate", 0),

		(try_for_range, ":competitor", lords_begin, lords_end),
			(store_faction_of_troop, ":competitor_faction", ":competitor"),
			(eq, ":competitor_faction", ":lord_faction"),
			(this_or_next|troop_slot_eq, ":competitor", slot_troop_love_interest_1, "$marriage_candidate"),
			(this_or_next|troop_slot_eq, ":competitor", slot_troop_love_interest_2, "$marriage_candidate"),
				(troop_slot_eq, ":competitor", slot_troop_love_interest_3, "$marriage_candidate"),

			(call_script, "script_troop_get_relation_with_troop", ":competitor", ":lord"),
			(gt, reg0, 5),

			(troop_slot_ge, ":competitor", slot_troop_renown, ":suitor_renown"),  #higher renown than player

			(assign, ":competitor_found", ":competitor"),
			(str_store_troop_name, s14, ":competitor"),
			(str_store_troop_name, s16, "$marriage_candidate"),
		(try_end),
	(try_end),

	#renown
	(try_begin),
		(lt, ":suitor_renown", 50),
		(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_quarrelsome),
		(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_debauched),
			(troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_selfrighteous),
		(assign, ":explainer_string", "str_excuse_me_how_can_you_possibly_imagine_yourself_worthy_to_marry_into_our_family"),
		(assign, ":result", -3),
	(else_try),
		(lt, ":suitor_renown", 50),
		(troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_goodnatured),

		(assign, ":explainer_string", "str_em_with_regard_to_her_ladyship_we_were_looking_specifically_for_a_groom_of_some_distinction_fight_hard_count_your_dinars_and_perhaps_some_day_in_the_future_we_may_speak_of_such_things_my_good_man"),
		(assign, ":result", -1),
	(else_try),
		(lt, ":suitor_renown", 50),

		(assign, ":explainer_string", "str_em_with_regard_to_her_ladyship_we_were_looking_specifically_for_a_groom_of_some_distinction"),
		(assign, ":result", -2),

	(else_try),
		(lt, ":suitor_renown", 200),
		(neg|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_goodnatured),
		(assign, ":explainer_string", "str_it_is_too_early_for_you_to_be_speaking_of_such_things_you_are_still_making_your_mark_in_the_world"),

		(assign, ":result", -1),

	(else_try), #wrong faction
		(eq, ":suitor", "trp_player"),
		(neq, ":suitor_faction", "$players_kingdom"),
		(str_store_faction_name, s4, ":lord_faction"),
		(this_or_next|eq, ":lord_reputation", lrep_quarrelsome),
			(eq, ":lord_reputation", lrep_debauched),
		(assign, ":explainer_string", "str_you_dont_serve_the_s4_so_id_say_no_one_day_we_may_be_at_war_and_i_prefer_not_to_have_to_kill_my_inlaws_if_at_all_possible"),

		(assign, ":result", -1),

	(else_try),
		(eq, ":suitor", "trp_player"),
		(neq, ":suitor_faction", "$players_kingdom"),
		(neq, ":lord_reputation", lrep_goodnatured),
		(neq, ":lord_reputation", lrep_cunning),

		(assign, ":explainer_string", "str_as_you_are_not_a_vassal_of_the_s4_i_must_decline_your_request_the_twists_of_fate_may_mean_that_we_will_one_day_cross_swords_and_i_would_hope_not_to_make_a_widow_of_a_lady_whom_i_am_obligated_to_protect"),

		(assign, ":result", -1),
	(else_try),
		(eq, ":suitor", "trp_player"),
		(lt, ":faction_relation_with_suitor", 0),

		(assign, ":explainer_string", "str_as_you_are_not_a_vassal_of_the_s4_i_must_decline_your_request_the_twists_of_fate_may_mean_that_we_will_one_day_cross_swords_and_i_would_hope_not_to_make_a_widow_of_a_lady_whom_i_am_obligated_to_protect"),

		(assign, ":result", -1),

	(else_try),
		(eq, ":suitor", "trp_player"),
		(neq, "$player_has_homage", 1),
		(neg|faction_slot_eq, "fac_player_supporters_faction", slot_faction_state, sfs_active),

		(assign, ":explainer_string", "str_as_you_are_not_a_pledged_vassal_of_our_liege_with_the_right_to_hold_land_i_must_refuse_your_request_to_marry_into_our_family"),

		(assign, ":result", -1),
	(else_try),
		(gt, ":competitor_found", -1),

		(this_or_next|eq, ":lord_reputation", lrep_selfrighteous),
		(this_or_next|eq, ":lord_reputation", lrep_debauched),
		(this_or_next|eq, ":lord_reputation", lrep_martial),
			(eq, ":lord_reputation", lrep_quarrelsome),

		(assign, ":explainer_string",	"str_look_here_lad__the_young_s14_has_been_paying_court_to_s16_and_youll_have_to_admit__hes_a_finer_catch_for_her_than_you_so_lets_have_no_more_of_this_talk_shall_we"),
		(assign, ":result", -1),

	(else_try),
		(lt, ":lord_suitor_relation", -4),



		(assign, ":explainer_string", "str_i_do_not_care_for_you_sir_and_i_consider_it_my_duty_to_protect_the_ladies_of_my_household_from_undesirable_suitors"),
		(assign, ":result", -3),
	(else_try),
		(lt, ":lord_suitor_relation", 5),

		(assign, ":explainer_string",	"str_hmm_young_girls_may_easily_be_led_astray_so_out_of_a_sense_of_duty_to_the_ladies_of_my_household_i_think_i_would_like_to_get_to_know_you_a_bit_better_we_may_speak_of_this_at_a_later_date"),
		(assign, ":result", -1),
	(else_try),

		(assign, ":explainer_string",	"str_you_may_indeed_make_a_fine_match_for_the_young_mistress"),
		(assign, ":result", 1),
	(try_end),

	(assign, reg0, ":result"),
	(assign, reg1, ":explainer_string"),

	]),

	("npc_decision_checklist_marry_female_pc", #
	[
	(store_script_param, ":npc", 1),
    #diplomacy start+ (players of either gender may marry opposite-gender lords)
    #  Note that many of the strings used here have been altered to change based on the player's gender.
	#  Also, it should be mention that reason is written to s14.
	(assign, ":save_reg1", reg1),
	#Use gender script
	(call_script, "script_dplmc_store_is_female_troop_1_troop_2", "trp_player", ":npc"),
	(assign, ":is_female", reg0),
	(assign, ":npc_female", reg1),
    #diplomacy end+

	(troop_get_slot, ":npc_reputation_type", ":npc", slot_lord_reputation_type),

	(call_script, "script_troop_get_romantic_chemistry_with_troop", ":npc", "trp_player"),
	(assign, ":romantic_chemistry", reg0),

	(call_script, "script_troop_get_relation_with_troop", ":npc", "trp_player"),
	(assign, ":relation_with_player", reg0),

	(assign, ":competitor", -1),
	(try_for_range, ":competitor_candidate", kingdom_ladies_begin, kingdom_ladies_end),
		(this_or_next|troop_slot_eq, ":npc", slot_troop_love_interest_1, ":competitor_candidate"),
		(this_or_next|troop_slot_eq, ":npc", slot_troop_love_interest_2, ":competitor_candidate"),
			(troop_slot_eq, ":npc", slot_troop_love_interest_3, ":competitor_candidate"),
		(call_script, "script_troop_get_relation_with_troop", ":npc", ":competitor"),
		(assign, ":competitor_relation", reg0),

		(gt, ":competitor_relation", ":relation_with_player"),
		(assign, ":competitor", ":competitor_candidate"),
	(try_end),

	(assign, ":player_possessions", 0),
	(try_for_range, ":center", centers_begin, centers_end),
		(troop_slot_eq, ":center", slot_town_lord, "trp_player"),
		(val_add, ":player_possessions", 1),
	(try_end),

	(assign, ":lord_agrees", 0),
	#reasons for refusal
	(try_begin),
		(troop_slot_ge, "trp_player", slot_troop_betrothed, active_npcs_begin),
		(neg|troop_slot_eq, "trp_player", slot_troop_betrothed, ":npc"),

		(str_store_string, s14, "str_my_lady_engaged_to_another"),
	(else_try),
		#bad relationship - minor
		(lt, ":relation_with_player", -3),
		(this_or_next|eq, ":npc_reputation_type", lrep_upstanding),
		(this_or_next|eq, ":npc_reputation_type", lrep_cunning),
		##diplomacy start+ also test commoner types
		(this_or_next|eq, ":npc_reputation_type", lrep_roguish),
		(this_or_next|eq, ":npc_reputation_type", lrep_custodian),
		(this_or_next|eq, ":npc_reputation_type", lrep_benefactor),
		#And certain lady types?
		(this_or_next|eq, ":npc_reputation_type", lrep_ambitious),
		(this_or_next|eq, ":npc_reputation_type", lrep_moralist),
		##diplomacy end+
			(eq, ":npc_reputation_type", lrep_goodnatured),

		(str_store_string, s14, "str_madame__given_our_relations_in_the_past_this_proposal_is_most_surprising_i_do_not_think_that_you_are_the_kind_of_woman_who_can_be_bent_to_a_hushands_will_and_i_would_prefer_not_to_have_our_married_life_be_a_source_of_constant_acrimony"),

	(else_try), #really bad relationship
		(lt, ":relation_with_player", -10),

		(this_or_next|eq, ":npc_reputation_type", lrep_quarrelsome),
		(this_or_next|eq, ":npc_reputation_type", lrep_debauched),
			(eq, ":npc_reputation_type", lrep_selfrighteous),

		(str_store_string, s14, "str_i_would_prefer_to_marry_a_proper_maiden_who_will_obey_her_husband_and_is_not_likely_to_split_his_head_with_a_sword"),
	(else_try),
		(lt, ":romantic_chemistry", 5),

		(str_store_string, s14, "str_my_lady_not_sufficient_chemistry"),

	(else_try), #would prefer someone more ladylike
		(this_or_next|eq, ":npc_reputation_type", lrep_upstanding),
			(eq, ":npc_reputation_type", lrep_martial),
        #diplomacy start+ (players of either gender may marry opposite-gender lords)
        #I tried to keep this as symmetric as possible, but this sentence is ridiculous with reversed genders
		(neq, ":npc_female", 1),
        (eq, ":is_female", 1),
		#To reduce annoyance, I've changed this away from an absolute prohibition.
		(troop_get_slot, ":veto", ":npc", slot_troop_set_decision_seed),
		(val_add, ":veto", "$romantic_attraction_seed"),
		(val_mod, ":veto", 5),#4 out of 5 will still automatically refuse
		(try_begin),#make an exception for companions
			(is_between, ":npc", companions_begin, companions_end),
			(assign, ":veto", 0),
		(else_try),
			#On diminished prejudice mode, get rid of the "80% automatically refuse" condition.
			(ge, "$g_disable_condescending_comments", 2),
			(assign, ":veto", 0),
		(try_end),
		(try_begin),
			#Skip the subsequent checks if there's no way for them to pass
			(neq, ":veto", 0),
		(else_try),
			#Requires high chemistry, high relation, and positive honor
			(this_or_next|lt, ":romantic_chemistry", 15),
			(this_or_next|lt, ":relation_with_player", 30),
				(lt, "$player_honor", 10),
			(assign, ":veto", 1),
		(else_try),
			#Relation must be above some arbitrary threshold (only if prejudice settings are not "low")
			(lt, "$g_disable_condescending_comments", 2),
			(store_sub, reg0, 100, ":romantic_chemistry"),
			(lt, ":relation_with_player", reg0),
			(assign, ":veto", 1),
		(else_try),
			#The lord's level must not be less than 75% of the player's (only if prejudice settings are not "low")
			(lt, "$g_disable_condescending_comments", 2),
			(store_character_level, reg0, "trp_player"),
			(val_mul, reg0, 3),
			(val_div, reg0, 4),
			(store_character_level, reg1, ":npc"),
			(lt, reg1, reg0),
			(assign, ":veto", 1),
		(else_try),
			#One of the lord's female relatives must like the player, if any such lords exist.
			(lt, "$g_disable_condescending_comments", 2),
			(troop_get_slot, ":npc_mother", ":npc", slot_troop_mother),
			(assign, reg1, 0),#3 = some disapproved, 2 = some approved, 1 = some existed and had no opinion, 0 = there were none
			(try_for_range, ":kingdom_lady", kingdom_ladies_begin, kingdom_ladies_end),
				(neg|troop_slot_ge, ":kingdom_lady", slot_troop_occupation, slto_retirement),
				(assign, reg0, 0),
				(try_begin),
					(troop_slot_eq, ":kingdom_lady", slot_troop_guardian, ":npc"),
					(assign, reg0, 1),
				(else_try),
					(is_between, ":npc_mother", heroes_begin, heroes_end),
					(this_or_next|eq, ":kingdom_lady", ":npc_mother"),
						(troop_slot_eq, ":kingdom_lady", slot_troop_mother, ":npc_mother"),
					(assign, reg0, 1),
				(try_end),
				(neq, reg0, 0),
				(call_script, "script_troop_get_player_relation", ":kingdom_lady"),
				(try_begin),#some were found and like the player
					(ge, reg0, 1),
					(val_max, reg1, 2),
				(else_try),#some were found and have no opinion
					(eq, reg0, 0),
					(val_max, reg1, 1),
				(else_try),#some were found and dislike the player
					(val_max, reg1, 3),
				(try_end),
			(try_end),
			(neq, reg0, 0),
			(neq, reg0, 2),
			(assign, ":veto", 1),
		(try_end),
		#Check if the veto holds
		(neq, ":veto", 0),
        #diplomacy end+

		(str_store_string, s14, "str_my_lady_while_i_admire_your_valor_you_will_forgive_me_if_i_tell_you_that_a_woman_like_you_does_not_uphold_to_my_ideal_of_the_feminine_of_the_delicate_and_of_the_pure"),
	(else_try),
		(eq, ":npc_reputation_type", lrep_quarrelsome),
		(lt, ":romantic_chemistry", 15),

		(str_store_string, s14, "str_nah_i_want_a_woman_wholl_keep_quiet_and_do_what_shes_told_i_dont_think_thats_you"),
	(else_try), #no properties
		(this_or_next|eq, ":npc_reputation_type", lrep_selfrighteous),
			(eq, ":npc_reputation_type", lrep_debauched),

		(ge, ":romantic_chemistry", 10),
		(eq, ":player_possessions", 0),

		(str_store_string, s14, "str_my_lady_you_are_possessed_of_great_charms_but_no_properties_until_you_obtain_some_to_marry_you_would_be_an_act_of_ingratitude_towards_my_ancestors_and_my_lineage"),

	(else_try), #you're a nobody - I can do better
		(this_or_next|eq, ":npc_reputation_type", lrep_selfrighteous),
			(eq, ":npc_reputation_type", lrep_debauched),

		(eq, ":player_possessions", 0),

		(str_store_string, s14, "str_my_lady_you_are_a_woman_of_no_known_family_of_no_possessions__in_short_a_nobody_do_you_think_that_you_are_fit_to_marry_into_may_family"),
	(else_try), #just not that into you
		(lt, ":romantic_chemistry", 5),
		(lt, ":relation_with_player", 20),

		(neq, ":npc_reputation_type", lrep_debauched),
		(neq, ":npc_reputation_type", lrep_selfrighteous),

		(str_store_string, s14, "str_my_lady__forgive_me__the_quality_of_our_bond_is_not_of_the_sort_which_the_poets_tell_us_is_necessary_to_sustain_a_happy_marriage"),

	(else_try), #you're a liability, given your relation with the liege
		(eq, ":npc_reputation_type", lrep_cunning),
		(faction_get_slot, ":leader", slot_faction_leader, "$g_talk_troop_faction"),
		(str_store_troop_name, s4, ":leader"),
		(call_script, "script_troop_get_relation_with_troop", ":leader", "trp_player"),
		(lt, reg0, -10),

		(str_store_string, s14, "str_um_i_think_that_if_i_want_to_stay_on_s4s_good_side_id_best_not_marry_you"),
	(else_try),	#part of another faction
		(gt, "$players_kingdom", 0),
		(neq, "$players_kingdom", "$g_talk_troop_faction"),
		(faction_get_slot, ":leader", slot_faction_leader, "$g_talk_troop_faction"),
		##diplomacy start+ use gender script
		#(troop_get_type, reg4, ":leader"),
		(call_script, "script_dplmc_store_troop_is_female_reg", ":leader", 4),
		##diplomacy end+

		(str_store_string, s14, "str_you_serve_another_realm_i_dont_see_s4_granting_reg4herhis_blessing_to_our_union"),
	(else_try), #there's a competitor
		(gt, ":competitor", -1),
		(str_store_troop_name, s4, ":competitor"),

		(str_store_string, s14, "str_madame_my_heart_currently_belongs_to_s4"),
    ##diplomacy start+
	#By default these should not be reachable, but future changes may expose them
	#unintentionally.
	(else_try),#redundant: shouldn't be called for betrothed lords
	   (troop_slot_ge, ":npc", slot_troop_betrothed, 1),
	   (troop_get_slot, ":competitor", ":npc", slot_troop_betrothed),
	   (str_store_troop_name, s4, ":competitor"),
	   (str_store_string, s14, "str_madame_my_heart_currently_belongs_to_s4"),
	(else_try),#redundant: shouldn't be called for married lords
	   (troop_slot_ge, ":npc", slot_troop_spouse, 1),
	   (troop_get_slot, ":competitor", ":npc", slot_troop_spouse),
	   (str_store_troop_name, s4, ":competitor"),
	   (str_store_string, s14, "str_madame_my_heart_currently_belongs_to_s4"),
	(else_try),#redundant: shouldn't be called for claimants or kings
	   (this_or_next|is_between, ":npc", kings_begin, kings_end),
	      (is_between, ":npc", pretenders_begin, pretenders_end),
	   #This probably wouldn't ever occur, but put a string here just in case.
	   #The male version is ridiculous.
	   (str_store_string, s14, "str_my_lady_while_i_admire_your_valor_you_will_forgive_me_if_i_tell_you_that_a_woman_like_you_does_not_uphold_to_my_ideal_of_the_feminine_of_the_delicate_and_of_the_pure"),
	##diplomacy end+
	(else_try),
		(lt, ":relation_with_player", 10),
		(assign, ":lord_agrees", 2),

		(str_store_string, s14, "str_my_lady_you_are_a_woman_of_great_spirit_and_bravery_possessed_of_beauty_grace_and_wit_i_shall_give_your_proposal_consideration"),
	(else_try),
		(assign, ":lord_agrees", 1),

		(str_store_string, s14, "str_my_lady_you_are_a_woman_of_great_spirit_and_bravery_possessed_of_beauty_grace_and_wit_i_would_be_most_honored_were_you_to_become_my_wife"),
	(try_end),

    ##diplomacy start+ revert register
	(assign, reg1, ":save_reg1"),
	##diplomacy end+
	(assign, reg0, ":lord_agrees"),

	]
	),


#	(
#	"npc_decision_checklist_king_chooses_lord_for_center",
#	[
#	(store_script_param, ":center", 1),

#	(store_faction_of_party, ":faction", ":center"),
#	(faction_get_slot, ":king", ":faction", slot_faction_leader),

#	(assign, ":total_renown_in_faction"),
#	(try_for_range, ":lord_iterator", active_npcs_including_player_begin, active_npcs_end),
#		(assign, ":lord", ":lord_iterator"),
#		(store_faction_of_troop, ":lord_faction", ":lord"),
#		(try_begin),
#			(eq, ":lord_iterator", "trp_kingdom_heroes_including_player_begin"),
#			(assign, ":lord", "trp_player"),
#			(assign, ":lord_faction", "$players_kingdom"),
#		(try_end),
#		(troop_get_slot, ":renown", ":lord", slot_troop_renown),
#		(val_add, ":total_renown_in_faction", ":renown"),

#		(troop_set_slot, ":lord", slot_troop_temp_slot, 0),
#	(try_end),

#	(assign, ":total_property_points_in_faction"),
#	(try_for_range, ":village", villages_begin, villages_end),

#	(try_end),



#	(try_begin),

	#I needed it for myself

	#The one who captured it was suitably deserving

	#I had not sufficiently recognized Lord X for his service

#	(try_end),


#	]),



	("courtship_poem_reactions", #parameters from dialog
	[
	(store_script_param, ":lady", 1),
	(store_script_param, ":poem", 2),

	(troop_get_slot, ":lady_reputation", ":lady", slot_lord_reputation_type),

	(try_begin),
		(eq, "$cheat_mode", 1),
		(assign, reg4, ":poem"),
		(assign, reg5, ":lady_reputation"),
		(display_message, "str_poem_choice_reg4_lady_rep_reg5"),
	(try_end),

	(try_begin), #conventional ++, ambitious -, adventurous -
		(eq, ":poem", courtship_poem_tragic),
		(eq, ":lady_reputation", lrep_conventional),
		(str_store_string, s11, "str_ah__kais_and_layali__such_a_sad_tale_many_a_time_has_it_been_recounted_for_my_family_by_the_wandering_poets_who_come_to_our_home_and_it_has_never_failed_to_bring_tears_to_our_eyes"),
		(assign, ":result", 5),
	(else_try),
		(eq, ":poem", courtship_poem_tragic),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_kais_and_layali_three_hundred_stanzas_of_pathetic_sniveling_if_you_ask_me_if_kais_wanted_to_escape_heartbreak_he_should_have_learned_to_live_within_his_station_and_not_yearn_for_what_he_cannot_have"),
		(assign, ":result", 0),
	(else_try),
		(eq, ":poem", courtship_poem_tragic),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_kais_and_layali_no_one_should_ever_have_written_such_a_sad_poem_if_it_was_the_destiny_of_kais_and_layali_to_be_together_than_their_love_should_have_conquered_all_obstacles"),
		(assign, ":result", 1),
	(else_try),
		(eq, ":poem", courtship_poem_tragic),
#		moralizing and adventurous
		(str_store_string, s11, "str_ah_kais_and_layali_a_very_old_standby_but_moving_in_its_way"),
		(assign, ":result", 3),
	#Heroic
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_adventurous),
		(str_store_string, s11, "str_the_saga_of_helgered_and_kara_such_happy_times_in_which_our_ancestors_lived_women_like_kara_could_venture_out_into_the_world_like_men_win_a_name_for_themselves_and_not_linger_in_their_husbands_shadow"),
		(assign, ":result", 5),
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_ah_the_saga_of_helgered_and_kara_now_there_was_a_lady_who_knew_what_she_wanted_and_was_not_afraid_to_obtain_it"),
		(assign, ":result", 2),
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_the_saga_of_helgered_and_kara_a_terrible_tale__but_it_speaks_of_a_very_great_love_if_she_were_willing_to_make_war_on_her_own_family"),
		(assign, ":result", 2),
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_moralist),
		(str_store_string, s11, "str_the_saga_of_helgered_and_kara_as_i_recall_kara_valued_her_own_base_passions_over_duty_to_her_family_that_she_made_war_on_her_own_father_i_have_no_time_for_a_poem_which_praises_such_a_woman"),
		(assign, ":result", 0),
	(else_try), #adventurous ++, conventional -1, moralizing -1
		(eq, ":poem", courtship_poem_heroic),
		(eq, ":lady_reputation", lrep_conventional),
		(str_store_string, s11, "str_the_saga_of_helgered_and_kara_how_could_a_woman_don_armor_and_carry_a_sword_how_could_a_man_love_so_ungentle_a_creature"),
		(assign, ":result", 0),
	#Comic
	(else_try), #ambitious ++, romantic -, moralizing 0
		(eq, ":poem", courtship_poem_comic),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_a_conversation_in_the_garden_i_cannot_understand_the_lady_in_that_poem_if_she_loves_the_man_why_does_she_tease_him_so"),
		(assign, ":result", 0),
	(else_try), #ambitious ++, romantic -, moralizing 0
		(eq, ":poem", courtship_poem_comic),
		(eq, ":lady_reputation", lrep_moralist),
		(str_store_string, s11, "str_a_conversation_in_the_garden_let_us_see__it_is_morally_unedifying_it_exalts_deception_it_ends_with_a_maiden_surrendering_to_her_base_passions_and_yet_i_cannot_help_but_find_it_charming_perhaps_because_it_tells_us_that_love_need_not_be_tragic_to_be_memorable"),
		(assign, ":result", 1),
	(else_try), #ambitious ++, romantic -, moralizing 0
		(eq, ":poem", courtship_poem_comic),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_a_conversation_in_the_garden_now_that_is_a_tale_every_lady_should_know_by_heart_to_learn_the_subtleties_of_the_politics_she_must_practice"),
		(assign, ":result", 5),
	(else_try), #ambitious ++, romantic -, moralizing 0
		(eq, ":poem", courtship_poem_comic),
		#adventurous, conventional
		(str_store_string, s11, "str_a_conversation_in_the_garden_it_is_droll_i_suppose__although_there_is_nothing_there_that_truly_stirs_my_soul"),
		(assign, ":result", 3),

	#Allegoric
	(else_try), #moralizing ++, adventurous -, romantic -
		(eq, ":poem", courtship_poem_allegoric),
		(eq, ":lady_reputation", lrep_adventurous),
		(str_store_string, s11, "str_storming_the_fortress_of_love_ah_yes_the_lady_sits_within_doing_nothing_while_the_man_is_the_one_who_strives_and_achieves_i_have_enough_of_that_in_my_daily_life_why_listen_to_poems_about_it"),
		(assign, ":result", 0),
	(else_try), #moralizing ++, adventurous -, romantic -
		(eq, ":poem", courtship_poem_allegoric),
		(this_or_next|eq, ":lady_reputation", lrep_conventional),
			(eq, ":lady_reputation", lrep_moralist),
		(str_store_string, s11, "str_storming_the_fortress_of_love_ah_yes_an_uplifting_tribute_to_the_separate_virtues_of_man_and_woman"),
		(assign, ":result", 3),
	(else_try), #moralizing ++, adventurous -, romantic -
		(eq, ":poem", courtship_poem_allegoric),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_storming_the_fortress_of_love_ah_yes_but_although_it_is_a_fine_tale_of_virtues_it_speaks_nothing_of_passion"),
		(assign, ":result", 1),
	(else_try), #moralizing ++, adventurous -, romantic -
		(eq, ":poem", courtship_poem_allegoric),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_storming_the_fortress_of_love_ah_a_sermon_dressed_up_as_a_love_poem_if_you_ask_me"),
		(assign, ":result", 1),

	(else_try), #romantic ++, moralizing 0, ambitious -
		(eq, ":poem", courtship_poem_mystic),
		(eq, ":lady_reputation", lrep_otherworldly),
		(str_store_string, s11, "str_a_hearts_desire_ah_such_a_beautiful_account_of_the_perfect_perfect_love_to_love_like_that_must_be_to_truly_know_rapture"),
		(assign, ":result", 4),

	(else_try), #romantic ++, moralizing 0, ambitious -
		(eq, ":poem", courtship_poem_mystic),
		(eq, ":lady_reputation", lrep_ambitious),
		(str_store_string, s11, "str_a_hearts_desire_silly_if_you_ask_me_if_the_poet_desires_a_lady_then_he_should_endeavor_to_win_her__and_not_dress_up_his_desire_with_a_pretense_of_piety"),
		(assign, ":result", 0),

	(else_try), #romantic ++, moralizing 0, ambitious -
		(eq, ":poem", courtship_poem_mystic),
		(eq, ":lady_reputation", lrep_moralist),
		(str_store_string, s11, "str_a_hearts_desire_hmm__it_is_an_interesting_exploration_of_earthly_and_divine_love_it_does_speak_of_the_spiritual_quest_which_brings_out_the_best_in_man_but_i_wonder_if_the_poet_has_not_confused_his_yearning_for_higher_things_with_his_baser_passions"),
		(assign, ":result", 2),

	(else_try), #romantic ++, moralizing 0, ambitious -
		(eq, ":poem", courtship_poem_mystic),
		(str_store_string, s11, "str_a_hearts_desire_oh_yes__it_is_very_worthy_and_philosophical_but_if_i_am_to_listen_to_a_bard_strum_a_lute_for_three_hours_i_personally_prefer_there_to_be_a_bit_of_a_story"),
		(assign, ":result", 1),
	(try_end),


	(try_begin),
		(eq, "$cheat_mode", 1),
		(assign, reg4, ":result"),
		(display_message, "str_result_reg4_string_s11"),
	(try_end),


	(assign, reg0, ":result"),

	]),

	(
	"diplomacy_faction_get_diplomatic_status_with_faction",
	#result: -1 faction_1 has a casus belli against faction_2. 1, faction_1 has a truce with faction_2, -2, the two factions are at war
	[
	(store_script_param, ":actor_faction", 1),
	(store_script_param, ":target_faction", 2),
	##diplomacy start+
	#Since "fac_player_supporters_faction" is used as a shorthand for the faction
	#run by the player, intercept that here instead of the various places this is
	#called from.
	(call_script, "script_dplmc_translate_inactive_player_supporter_faction_2", ":actor_faction", ":target_faction"),
	(assign, ":actor_faction", reg0),
	(assign, ":target_faction", reg1),
	##diplomacy end+

	(store_add, ":truce_slot", ":target_faction", slot_faction_truce_days_with_factions_begin),
	(store_add, ":provocation_slot", ":target_faction", slot_faction_provocation_days_with_factions_begin),
	(val_sub, ":truce_slot", kingdoms_begin),
	(val_sub, ":provocation_slot", kingdoms_begin),

	(assign, ":result", 0),
	(assign, ":duration", 0),

	(try_begin),
		(store_relation, ":relation", ":actor_faction", ":target_faction"),
		(lt, ":relation", 0),
		(assign, ":result", -2),
	(else_try),
		(faction_slot_ge, ":actor_faction", ":truce_slot", 1),
		(assign, ":result", 1),

		(faction_get_slot, ":duration", ":actor_faction", ":truce_slot"),
	(else_try),
		(faction_slot_ge, ":actor_faction", ":provocation_slot", 1),
		(assign, ":result", -1),

		(faction_get_slot, ":duration", ":actor_faction", ":provocation_slot"),
	(try_end),

	(assign, reg0, ":result"),
	(assign, reg1, ":duration"),
	]),

	("faction_follows_controversial_policy",
	[
	(store_script_param, ":faction_no", 1),
	(store_script_param, ":policy_type", 2),

	(faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),

	(try_begin),
		(ge, "$cheat_mode", 1),
		(str_store_faction_name, s3, ":faction_no"),
		(display_message, "str_calculating_effect_for_policy_for_s3"),

		(val_add, "$number_of_controversial_policy_decisions", 1),
	(try_end),

	(try_begin),
		(eq, ":policy_type", logent_policy_ruler_attacks_without_provocation),
		(assign, ":hawk_relation_effect", 0),
		(assign, ":honorable_relation_effect", -2),
		(assign, ":honor_change", -1),

	(else_try),
		(eq, ":policy_type", logent_policy_ruler_ignores_provocation),
		(assign, ":hawk_relation_effect", -3),
		(assign, ":honorable_relation_effect", 0),
		(assign, ":honor_change", 0),

	(else_try),
		(eq, ":policy_type", logent_policy_ruler_declares_war_with_justification),
		(assign, ":hawk_relation_effect", 3),
		(assign, ":honorable_relation_effect", 1),
		(assign, ":honor_change", 0),

	(else_try),
		(eq, ":policy_type", logent_policy_ruler_breaks_truce),
		(assign, ":hawk_relation_effect", 0),
		(assign, ":honorable_relation_effect", -3),
		(assign, ":honor_change", -5),

	(else_try),
		(eq, ":policy_type", logent_policy_ruler_makes_peace_too_soon),
		(assign, ":hawk_relation_effect", -5),
		(assign, ":honorable_relation_effect", 0),
		(assign, ":honor_change", 0),

	##diplomacy start+ If none of the preceeding match, don't use random memory
	(else_try),
		(assign, ":hawk_relation_effect", 0),
		(assign, ":honorable_relation_effect", 0),
		(assign, ":honor_change", 0),
	##diplomacy end+
	(try_end),

	(try_begin),
		(eq, ":faction_leader", "trp_player"),
		(call_script, "script_change_player_honor", ":honor_change"),
	(try_end),

   ##diplomacy start+ add support for promoted kingdom ladies
	#(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
	(try_for_range, ":lord", heroes_begin, heroes_end),
	##diplomacy end+
		(troop_slot_eq, ":lord", slot_troop_occupation, slto_kingdom_hero),
		(store_faction_of_troop, ":lord_faction", ":lord"),
		(eq, ":lord_faction", ":faction_no"),
		(neq, ":lord", ":faction_leader"),

		(try_begin),
		   ##diplomacy start+ Add support for lady personality type
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_adventurous),
			##diplomacy end+
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_martial),
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_quarrelsome),
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_selfrighteous),
				(troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_debauched),
			(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":lord", ":hawk_relation_effect"),
			(val_add, "$total_policy_dispute_changes", ":hawk_relation_effect"),
		(try_end),

		(try_begin),
		   ##diplomacy start+ Add support for lady personality type
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_moralist),
			##diplomacy end+
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_martial),
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_goodnatured),
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_selfrighteous),
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_benefactor), #new for enfiefed commoners
			(this_or_next|troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_custodian), #new for enfiefed commoners
				(troop_slot_eq, ":lord", slot_lord_reputation_type, lrep_upstanding),
			(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":lord", ":honorable_relation_effect"),
			(val_add, "$total_policy_dispute_changes", ":honorable_relation_effect"),

		(try_end),

	(try_end),

	]),


	("internal_politics_rate_feast_to_s9",
	[
	(store_script_param, ":householder", 1),
	(store_script_param, ":num_servings", 2),
#	(store_script_param, ":faction", 3),
	(store_script_param, ":consume_items", 4),

	(val_max, ":num_servings", 1),

	(try_for_range, ":item", trade_goods_begin, trade_goods_end),
		(item_set_slot, ":item", slot_item_amount_available, 0), #had no "item"
	(try_end),

	(troop_get_inventory_capacity, ":capacity", ":householder"),
	(try_for_range, ":inventory_slot", ek_food + 1, ":capacity"), #SB : skip equipment
		(troop_get_inventory_slot, ":item", ":householder", ":inventory_slot"),
		(is_between, ":item", trade_goods_begin, trade_goods_end),
	    (troop_inventory_slot_get_item_amount, ":slot_amount", ":householder", ":inventory_slot"),
        #SB : TODO : evaluate quality of food, for now just make sure it's not rotten
        (troop_get_inventory_slot_modifier, ":imod", ":householder", ":inventory_slot"),
        (neq, ":imod", imod_rotten),
		(item_get_slot, ":item_amount", ":item", slot_item_amount_available),
		(val_add, ":item_amount", ":slot_amount"),
		(item_set_slot, ":item", slot_item_amount_available, ":item_amount"),
	(try_end),
	#food
	(assign, ":food_amount", 0),
	(assign, ":food_variety", 0),

	(store_div, ":servings_div_by_12", ":num_servings", 12),
	(try_for_range, ":food_item", food_begin, food_end),
		(item_get_slot, ":food_in_slot", ":food_item", slot_item_amount_available),
		(val_add, ":food_amount", ":food_in_slot"),


##		(str_store_item_name, s4, ":food_item"),
##		(assign, reg3, ":food_in_slot"),
##		(assign, reg5, ":servings_div_by_12"),
##		(display_message, "str_reg3_units_of_s4_for_reg5_guests_and_retinue"),


		(ge, ":food_in_slot", ":servings_div_by_12"),
		(val_add, ":food_variety", 1),
	(try_end),

	(val_mul, ":food_amount", 100),
	(val_div, ":food_amount", ":num_servings"), #1 to 100 for each
	(val_min, ":food_amount", 100),

	(val_mul, ":food_variety", 85), #1 to 100 for each
	(val_div, ":food_variety", 10),
	(val_min, ":food_variety", 100),

	#drink
	(assign, ":drink_amount", 0),
	(assign, ":drink_variety", 0),
	(store_div, ":servings_div_by_4", ":num_servings", 4),
	(try_for_range, ":drink_iterator", "itm_wine", "itm_smoked_fish"),
		(assign, ":drink_item", ":drink_iterator"),
		(item_get_slot, ":drink_in_slot", ":drink_item", slot_item_amount_available),

		(val_add, ":drink_amount", ":drink_in_slot"),

		(ge, ":drink_in_slot", ":servings_div_by_4"),
		(val_add, ":drink_variety", 1),
	(try_end),

	(val_mul, ":drink_amount", 200), #amount needed is 50% of the number of guests
	(val_max, ":num_servings", 1),

	(val_div, ":drink_amount", ":num_servings"), #1 to 100 for each
	(val_min, ":drink_amount", 100),
	(val_mul, ":drink_variety", 50), #1 to 100 for each

	#in the future, it might be worthwhile to add different varieties of spices
	(item_get_slot, ":spice_amount", "itm_spice", slot_item_amount_available),
	(store_mul, ":spice_percentage", ":spice_amount", 100),
	(val_max, ":servings_div_by_12", 1),
	(val_div, ":spice_amount", ":servings_div_by_12"),
	(val_min, ":spice_percentage", 100),
##	(assign, reg3, ":spice_amount"),
##	(assign, reg5, ":servings_div_by_12"),
##	(assign, reg6, ":spice_percentage"),
##	(display_message, "str_reg3_units_of_spice_of_reg5_to_be_consumed"),

	#oil availability. In the future, this may become an "atmospherics" category, including incenses
	(item_get_slot, ":oil_amount", "itm_oil", slot_item_amount_available),
	(store_mul, ":oil_percentage", ":oil_amount", 100),
	(val_max, ":servings_div_by_12", 1),
	(val_div, ":oil_amount", ":servings_div_by_12"),
	(val_min, ":oil_percentage", 100),
##	(assign, reg3, ":oil_amount"),
##	(assign, reg5, ":servings_div_by_12"),
##	(assign, reg6, ":oil_percentage"),
##	(display_message, "str_reg3_units_of_oil_of_reg5_to_be_consumed"),

    #SB : salt + date fruit probably useful too
	(store_div, ":food_amount_string", ":food_amount", 20),
	(val_add, ":food_amount_string", "str_feast_description"),
	(str_store_string, s8, ":food_amount_string"),
	(str_store_string, s9, "str_of_food_which_must_come_before_everything_else_the_amount_is_s8"),

	(store_div, ":food_variety_string", ":food_variety", 20),
	(val_add, ":food_variety_string", "str_feast_description"),
	(str_store_string, s8, ":food_variety_string"),
	(str_store_string, s9, "str_s9_and_the_variety_is_s8_"),

	(store_div, ":drink_amount_string", ":drink_amount", 20),
	(val_add, ":drink_amount_string", "str_feast_description"),
	(str_store_string, s8, ":drink_amount_string"),
	(str_store_string, s9, "str_s9_of_drink_which_guests_will_expect_in_great_abundance_the_amount_is_s8"),

	(store_div, ":drink_variety_string", ":drink_variety", 20),
	(val_add, ":drink_variety_string", "str_feast_description"),
	(str_store_string, s8, ":drink_variety_string"),
	(str_store_string, s9, "str_s9_and_the_variety_is_s8_"),

	(store_div, ":spice_string", ":spice_percentage", 20),
	(val_add, ":spice_string", "str_feast_description"),
	(str_store_string, s8, ":spice_string"),
	(str_store_string, s9, "str_s9_of_spice_which_is_essential_to_demonstrate_that_we_spare_no_expense_as_hosts_the_amount_is_s8_"),

	(store_div, ":oil_string", ":oil_percentage", 20),
	(val_add, ":oil_string", "str_feast_description"),
	(str_store_string, s8, ":oil_string"),
	(str_store_string, s9, "str_s9_of_oil_which_we_shall_require_to_light_the_lamps_the_amount_is_s8"),

	(store_mul, ":food_amount_cap", ":food_amount", 8),
	(store_add, ":total", ":food_amount", ":food_variety"),
	(val_mul, ":total", 2), #x4
	(val_add, ":total", ":drink_variety"),
	(val_add, ":total", ":drink_amount"), #x6
	(val_add, ":total", ":spice_amount"), #x7
	(val_add, ":total", ":oil_amount"), #x8
	(val_min, ":total", ":food_amount_cap"),
	(val_div, ":total", 8),
	(val_clamp, ":total", 1, 101),
	(store_div, ":total_string", ":total", 20),
	(val_add, ":total_string", "str_feast_description"),
	(str_store_string, s8, ":total_string"),
	(str_store_string, s9, "str_s9_overall_our_table_will_be_considered_s8"),

	(assign, reg0, ":total"), #zero to 100



	(try_begin),
		(eq, ":consume_items", 1),

		(assign, ":num_of_servings_to_serve", ":num_servings"),
		(try_for_range, ":unused", 0, 1999),
			(gt, ":num_of_servings_to_serve", 0),

			(try_for_range, ":item", trade_goods_begin, trade_goods_end),
				(item_set_slot, ":item", slot_item_is_checked, 0),
			(try_end),

			(troop_get_inventory_capacity, ":inv_size", ":householder"),
			(try_for_range, ":i_slot", 0, ":inv_size"),
				(troop_get_inventory_slot, ":item", ":householder", ":i_slot"),
				(this_or_next|eq, ":item", "itm_spice"),
				(this_or_next|eq, ":item", "itm_oil"),
				(this_or_next|eq, ":item", "itm_wine"),
				(this_or_next|eq, ":item", "itm_ale"),
					(is_between, ":item",  food_begin, food_end),
				(item_slot_eq, ":item", slot_item_is_checked, 0),
				(troop_inventory_slot_get_item_amount, ":cur_amount", ":householder", ":i_slot"),
				(gt, ":cur_amount", 0),

				(val_sub, ":cur_amount", 1),
				(troop_inventory_slot_set_item_amount, ":householder", ":i_slot", ":cur_amount"),
				(val_sub, ":num_of_servings_to_serve", 1),
				(item_set_slot, ":item", slot_item_is_checked, 1),
			(try_end),
                ##diplomacy start+ Fix Native bug: "try_begin" to "try_end"
		#(try_begin),
                (try_end),
                ##diplomacy end+
	(try_end),
	]),


	("faction_get_adjective_to_s10",
	[
	(store_script_param, ":faction_no", 1),

	(try_begin),
		(eq, ":faction_no", "fac_player_faction"),
		(assign, ":faction_no", "$players_kingdom"),
	(try_end),


	(try_begin),
		(eq, ":faction_no", "fac_player_supporters_faction"),
		(str_store_string, s10, "str_rebel"),
	(else_try),
		(this_or_next|eq, ":faction_no", "fac_outlaws"),
		(this_or_next|eq, ":faction_no", "fac_mountain_bandits"),
		(this_or_next|eq, ":faction_no", "fac_forest_bandits"),
			(eq, ":faction_no", "fac_deserters"),
		(str_store_string, s10, "str_bandit"),
	(else_try),
		(faction_get_slot, ":adjective_string", ":faction_no", slot_faction_adjective),
		(str_store_string, s10, ":adjective_string"),
	(try_end),
	]),

	("setup_tavern_attacker",
	[
	  (store_script_param, ":cur_entry", 1),

	  (try_begin),
	    (neg|troop_slot_eq, "trp_hired_assassin", slot_troop_cur_center, "$g_encountered_party"),
	    (troop_slot_eq, "trp_belligerent_drunk", slot_troop_cur_center, "$g_encountered_party"),
	    (set_visitor, ":cur_entry", "trp_belligerent_drunk"),
	  (try_end),

	  (try_begin),
	    (troop_slot_eq, "trp_hired_assassin", slot_troop_cur_center, "$g_encountered_party"),
	    (set_visitor, ":cur_entry", "trp_hired_assassin"),
	  (try_end),
	]),

	("activate_tavern_attackers",
	[
	  (set_party_battle_mode),
	  (try_for_agents, ":cur_agent"),
	    (agent_get_troop_id, ":cur_agent_troop", ":cur_agent"),
	    (this_or_next|eq, ":cur_agent_troop", "trp_fugitive"),
	    (this_or_next|eq, ":cur_agent_troop", "trp_belligerent_drunk"),
	    (eq, ":cur_agent_troop", "trp_hired_assassin"),
	    (agent_set_team, ":cur_agent", 1),
	    (assign, "$g_main_attacker_agent", ":cur_agent"),
	    (agent_ai_set_aggressiveness, ":cur_agent", 199),
	  (try_end),
	]),

	("deactivate_tavern_attackers",
	[
	  (finish_party_battle_mode),
	  (try_for_agents, ":cur_agent"),
	    (agent_get_troop_id, ":cur_agent_troop", ":cur_agent"),
	    (this_or_next|eq, ":cur_agent_troop", "trp_fugitive"),
	    (this_or_next|eq, ":cur_agent_troop", "trp_belligerent_drunk"),
	    (eq, ":cur_agent_troop", "trp_hired_assassin"),
	    (agent_set_team, ":cur_agent", 0),
	    (agent_ai_set_aggressiveness, ":cur_agent", 0),
	  (try_end),
	]),

	("activate_town_guard",
	[
	  (set_party_battle_mode),
	  #(get_player_agent_no, ":player_agent"),
	  #(agent_get_team, ":player_team", ":player_agent"),

	  (try_for_agents, ":cur_agent"),
	    (agent_get_troop_id, ":troop_type", ":cur_agent"),
	    (is_between, ":troop_type", soldiers_begin, soldiers_end), #dckplmc
        (agent_set_team, ":cur_agent", 1),
        #(team_give_order, 1, grc_everyone, mordr_charge), - for some reason, this freezes everyone if the player is not yet spawned
		#(try_begin),
		#	(eq, "$g_main_attacker_agent", 0),
		#	(assign, "$g_main_attacker_agent", ":cur_agent"),
		#(try_end),
	(else_try),
		(this_or_next|is_between, ":troop_type", walkers_begin, walkers_end),
		(is_between, ":troop_type", armor_merchants_begin, mayors_end),

		(agent_clear_scripted_mode, ":cur_agent"),
		#(agent_set_team, ":cur_agent", 2), #dckplmc don't want town guards to massacre townsfolk
	(try_end),
	]),


	#this determines whether or not a lord is thrown into a dungeon by his captor, or is kept out on parole
	#Not currently used (ie, it always fails)
	("cf_prisoner_offered_parole",
	[
	  (store_script_param, ":prisoner", 1),

	  (eq, 1, 0), #disabled, this will always return false

	  (troop_get_slot, ":captor_party", ":prisoner", slot_troop_prisoner_of_party),
	  (party_is_active, ":captor_party"),
	  (is_between, ":captor_party", walled_centers_begin, walled_centers_end),
	  (party_get_slot, ":captor", ":captor_party", slot_town_lord),

	  (troop_get_slot, ":prisoner_rep", ":prisoner", slot_lord_reputation_type),
	  (troop_get_slot, ":captor_rep", ":captor", slot_lord_reputation_type),

	  (neq, ":prisoner_rep", lrep_debauched),
	  (neq, ":captor_rep", lrep_debauched),
	  (neq, ":captor_rep", lrep_quarrelsome),

     #Prisoner is a noble, or lord is goodnatured
    (this_or_next|eq, ":captor_rep", lrep_goodnatured),
    (this_or_next|troop_slot_eq, ":prisoner", slot_troop_occupation, slto_kingdom_hero),
    (troop_slot_eq, ":prisoner", slot_troop_occupation, slto_kingdom_lady),

	(call_script, "script_troop_get_relation_with_troop", ":captor", ":prisoner"),
##	(display_message, "str_relation_of_prisoner_with_captor_is_reg0"),
	(ge, reg0, -10),
	]),

	("neutral_behavior_in_fight",
	[
      (get_player_agent_no, ":player_agent"),
      (agent_get_position, pos3, ":player_agent"),
      (agent_get_team, ":player_team", ":player_agent"),

      (try_begin),
        (gt, "$g_main_attacker_agent", 0),
        (agent_get_team, ":attacker_team_no", "$g_main_attacker_agent"),
        (agent_get_position, pos5, "$g_main_attacker_agent"),
      (else_try),
        (eq, ":attacker_team_no", -1),
        (agent_get_position, pos5, ":player_agent"),
      (try_end),

      (set_fixed_point_multiplier, 100),

      (try_for_agents, ":agent"),
        (agent_get_team, ":other_team", ":agent"),
        (neq, ":other_team", ":attacker_team_no"),
        (neq, ":other_team", ":player_team"),

        (agent_get_troop_id, ":troop_id", ":agent"),
        #SB : better range checks
        (this_or_next|eq, ":troop_id", "trp_farmer"), #farmers are "neutral"
        (neg|is_between, ":troop_id", soldiers_begin, soldiers_end), #but lie within this range
        (troop_slot_eq, ":troop_id", slot_troop_mission_participation, mp_unaware), #neutral prisoners?

        (agent_get_position, pos4, ":agent"),

        (assign, ":best_position_score", 0),
        (assign, ":best_position", -1),

        (try_begin),
          (neg|agent_slot_eq, ":agent", slot_agent_is_running_away, 0), #if agent is running away
          (agent_get_slot, ":target_entry_point_plus_one",  ":agent", slot_agent_is_running_away),
          (store_sub, ":target_entry_point", ":target_entry_point_plus_one", 1),
          (entry_point_get_position, pos6, ":target_entry_point"),
          (get_distance_between_positions, ":agent_distance_to_target", pos6, pos4),
          (lt, ":agent_distance_to_target", 100),
          (agent_set_slot, ":agent", slot_agent_is_running_away, 0),
        (try_end),

        (agent_slot_eq, ":agent", slot_agent_is_running_away, 0), #if agent is not already running away

        (try_begin), #stand in place
          (get_distance_between_positions, ":distance", pos4, pos5),
          (get_distance_between_positions, ":distance_to_player", pos4, pos3),

          (val_min, ":distance", ":distance_to_player"),

          (this_or_next|gt, ":distance", 700), #7 meters away from main belligerents
          (main_hero_fallen),

          (agent_set_scripted_destination, ":agent", pos4),
        (else_try), #get out of the way
          (try_for_range, ":target_entry_point", 0, 64),
            (neg|entry_point_is_auto_generated, ":target_entry_point"),
            (entry_point_get_position, pos6, ":target_entry_point"),
            (get_distance_between_positions, ":agent_distance_to_target", pos6, pos4),
            (get_distance_between_positions, ":player_distance_to_target", pos6, pos3),
            (store_sub, ":position_score", ":player_distance_to_target", ":agent_distance_to_target"),
            (ge, ":position_score", 0),
            (try_begin),
              (ge, ":agent_distance_to_target", 2000),
              (store_sub, ":extra_distance", ":agent_distance_to_target", 2000),
              (val_min, ":extra_distance", 1000),
              (val_min, ":agent_distance_to_target", 2000), #if more than 10 meters assume it is 10 meters far while calculating best run away target
              (val_sub, ":agent_distance_to_target", ":extra_distance"),
            (try_end),
            (val_mul, ":position_score", ":agent_distance_to_target"),
            (try_begin),
              (ge, ":position_score", ":best_position_score"),
              (assign, ":best_position_score", ":position_score"),
              (assign, ":best_position", ":target_entry_point"),
            (try_end),
          (try_end),

          (try_begin),
            (ge, ":best_position", 0),
            (entry_point_get_position, pos6, ":best_position"),
            (agent_set_speed_limit, ":agent", 10),
            (agent_set_scripted_destination, ":agent", pos6),
            (store_add, ":best_position_plus_one", ":best_position", 1),
            (agent_set_slot, ":agent", slot_agent_is_running_away, ":best_position_plus_one"),
          (try_end),
        (try_end),
	  (try_end),
	]),

	("party_inflict_attrition", #parameters from dialog
	[
	(store_script_param, ":party", 1),
	(store_script_param, ":attrition_rate", 2),
#	(store_script_param, ":attrition_type", 3), #1 = desertion, 2 = sickness
##diplomacy start+
	(store_script_param, ":unused", 3), #1 = desertion, 2 = sickness
##diplomacy end+

    (party_clear, "p_temp_casualties"),

	(party_get_num_companion_stacks, ":num_stacks", ":party"),

	#add to temp casualties
	(try_for_range, ":stack", 0, ":num_stacks"),
		(party_stack_get_troop_id, ":troop_type", ":party", ":stack"),
		(neg|troop_is_hero, ":troop_type"),
		(party_stack_get_size, ":size", ":party", ":stack"),
		(store_mul, ":casualties_x_100", ":attrition_rate", ":size"),
		(store_div, ":casualties", ":casualties_x_100", 100),
		(party_add_members, "p_temp_casualties", ":troop_type", ":casualties"),

		(store_mul, ":subtractor", ":casualties", 100),
		(store_sub, ":chance_of_additional_casualty", ":casualties_x_100", ":subtractor"),

		(try_begin),
			(gt, ":chance_of_additional_casualty", 0),
			(store_random_in_range, ":random", 0, 100),
			(lt, ":random", ":chance_of_additional_casualty"),
			(party_add_members, "p_temp_casualties", ":troop_type", ":casualties"),
		(try_end),

#		(try_begin),
#			(eq, "$cheat_mode", 1),
#			(str_store_party_name, s7, ":party"),
#           		...
#		(try_end),
	(try_end),

	#take temp casualties from main party
	(party_get_num_companion_stacks, ":num_stacks", "p_temp_casualties"),

	#add to temp casualties
	(try_for_range, ":stack", 0, ":num_stacks"),
		(party_stack_get_troop_id, ":troop_type", "p_temp_casualties", ":stack"),
		(party_stack_get_size, ":size", "p_temp_casualties", ":stack"),
		(party_remove_members, ":party", ":troop_type", ":size"),

		(eq, "$cheat_mode", 1),
		(assign, reg3, ":size"),
		(str_store_troop_name, s4, ":troop_type"),
		(str_store_party_name, s5, ":party"),
#		(display_message, "str_s5_suffers_attrition_reg3_x_s4"),
		(str_store_string, s65, "str_s5_suffers_attrition_reg3_x_s4"),
		(display_message, "str_s65"),
		(try_begin),
			(eq, "$debug_message_in_queue", 0),
			(call_script, "script_add_notification_menu", "mnu_debug_alert_from_s65", 0, 0),
			(assign, "$debug_message_in_queue", 1),
		(try_end),
	(try_end),

	]),


##diplomacy start+ (documentation only)
#
# Registers changed:
#   reg4 - (sometimes, cheat only) current troop rumor of :object_1 or :object_2
#
# String registers changed:
#    s10 - speaker name
#    s11 - the third argument
#     s1 - the date
#     s5 - str_s10_said_on_s1_s11__
#     s3 - (sometimes, cheat only) the troop name of :object_1 or :object_2
#
#
# Diplomacy+ mod change:
# - Use reg4 to contain the gender of the subject of a rumor string
##diplomacy end+ (documentation only)
	("add_rumor_string_to_troop_notes", #parameters from dialog
	[
      (store_script_param, ":object_1", 1),
      (store_script_param, ":object_2", 2),
      (store_script_param, ":string", 3),

      (str_store_troop_name, s10, "$g_talk_troop"),
      (str_store_string_reg, s11, ":string"),

      (store_current_hours, ":hours"),
      (call_script, "script_game_get_date_text", 0, ":hours"),

      (str_store_string, s5, "str_s10_said_on_s1_s11__"),

      (try_begin),
        (is_between, ":object_1", active_npcs_begin, kingdom_ladies_end),
        (troop_get_slot, ":current_rumor_note", ":object_1", slot_troop_current_rumor),
        (val_add, ":current_rumor_note", 1),
        (try_begin),
        # Lav modifications start (custom lord notes)
                  (neg|is_between, ":current_rumor_note", 3, 15), # Was 16 in original Native, thus using notes slot #15 as well. Now it will leave notes slot #15 for custom notes.
        # Lav modifications end (custom lord notes)
          (assign, ":current_rumor_note", 3),
        (try_end),
        (troop_set_slot, ":object_1", slot_troop_current_rumor, ":current_rumor_note"),

        (add_troop_note_from_sreg, ":object_1", ":current_rumor_note", s5, 0), #troop, note slot, string, show

        (try_begin),
          (eq, "$cheat_mode", 1),
          (str_store_troop_name, s3, ":object_1"),
          (assign, reg4, ":current_rumor_note"),
          (display_message, "str_rumor_note_to_s3s_slot_reg4_s5"),
        (try_end),
      (try_end),

      (try_begin),
        (is_between, ":object_2", active_npcs_begin, kingdom_ladies_end),
        (troop_get_slot, ":current_rumor_note", ":object_2", slot_troop_current_rumor),
        (val_add, ":current_rumor_note", 1),
        (try_begin),
# Lav modifications start (custom lord notes)
          (neg|is_between, ":current_rumor_note", 3, 15), # Was 16 in original Native, thus using notes slot #15 as well. Now it will leave notes slot #15 for custom notes.
# Lav modifications end (custom lord notes)
          (assign, ":current_rumor_note", 3),
        (try_end),
        (troop_set_slot, ":object_2", slot_troop_current_rumor, ":current_rumor_note"),

        (add_troop_note_from_sreg, ":object_2", ":current_rumor_note", s5, 0), #troop, note slot, string, show

        (try_begin),
          (eq, "$cheat_mode", 1),
          (str_store_troop_name, s3, ":object_2"),
          (assign, reg4, ":current_rumor_note"),
          (display_message, "str_rumor_note_to_s3s_slot_reg4_s5"),
        (try_end),
      (try_end),
	]),

	("character_can_wed_character", #empty now, but might want to add mid-game
	[
	]),

	("troop_change_career", #empty now, but might want to add mid-game
	[
	]),

	("center_get_goods_availability",
	[
	(store_script_param, ":center_no", 1),

	(str_store_party_name, s4, ":center_no"),
	##diplomacy start+ Determine whether the center should use "desert" consumption values.
  	#Native uses the following logic:
	#  (this_or_next|is_between, ":center_no", "p_town_19", "p_castle_1"),
	#  (ge, ":center_no", "p_village_91"),
	##This is very vulnerable to map changes, though, so I would prefer to check the terrain type.
	(party_get_current_terrain, ":terrain_type", ":center_no"),
	(try_begin),
	   (eq, reg0, rt_desert_forest),
	   (assign, ":terrain_type", rt_desert),
	(try_end),
	(try_begin),
	   (lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
	   #To be consistent with script_center_get_consumption and script_initialize_economic_information
	   #use the Native desert-determination scheme when economic changes are disabled.
	   (assign, ":terrain_type", rt_plain),
  	   (this_or_next|is_between, ":center_no", "p_town_19", "p_castle_1"),
	   (ge, ":center_no", "p_village_91"),
	   (assign, ":terrain_type", rt_desert),
	(try_end),
	##diplomacy end+

	(assign, ":hardship_index", 0),
	(try_for_range, ":cur_good", trade_goods_begin, trade_goods_end),

		#Must have consumption of at least 4 to be relevant
		#This prevents perishables and raw materials from having a major impact
		(try_begin),
		##diplomacy start+ Use the "desert" slot when applicable
			(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
			(eq, ":terrain_type", rt_desert),
			(item_slot_ge, ":cur_good", slot_item_desert_demand, 0), #Otherwise use rural or urban
			(item_get_slot, ":consumer_consumption", ":cur_good", slot_item_desert_demand),
		(else_try),
		##diplomacy end+
			(is_between, ":center_no", villages_begin, villages_end),
			(item_get_slot, ":consumer_consumption", ":cur_good", slot_item_rural_demand),
		(else_try),
			(item_get_slot, ":consumer_consumption", ":cur_good", slot_item_urban_demand),
		(try_end),
		(gt, ":consumer_consumption", 2),

		(store_div, ":max_impact", ":consumer_consumption", 4), #was 4, dropped 3 again 4 now

		#High-demand items like grain tend to have much more dramatic price differentiation, so they yield substantially higher results than low-demand items

        (store_sub, ":cur_good_price_slot", ":cur_good", trade_goods_begin),
        (val_add, ":cur_good_price_slot", slot_town_trade_good_prices_begin),
        (party_get_slot, ":price", ":center_no", ":cur_good_price_slot"),

		(store_sub, ":price_differential", ":price", 1000),
		(gt, ":price_differential", 200), #was 100

		(val_div, ":price_differential", 200),
		(val_min, ":price_differential", ":max_impact"),

		(val_add, ":hardship_index", ":price_differential"),
	(try_end),

	(assign, reg0, ":hardship_index"),

	(try_begin),
		(eq, "$cheat_mode", 1),
		(display_message, "@{!}DEBUG -- hardship index for {s4} = {reg0}"),
	(try_end),
	]),

	("lord_find_alternative_faction", #Also, make it so that lords will try to keep at least one center unassigned
	[
	  (store_script_param, ":troop_no", 1),
	  (store_faction_of_troop, ":orig_faction", ":troop_no"),

	  (assign, ":new_faction", -1),
	  (assign, ":score_to_beat", -5),
	  ##diplomacy start+
	  (troop_get_slot, ":true_original_faction", ":troop_no", slot_troop_original_faction),#not necessarily ":orig_faction"
	  (try_begin),
	     (neg|is_between, ":true_original_faction", kingdoms_begin, kingdoms_end),
	     (troop_get_slot, reg0, ":troop_no", slot_troop_home),
	     (is_between, reg0, centers_begin, centers_end),
	     (party_get_slot, reg0, reg0, slot_center_original_faction),
	     (gt, reg0, 0),
	     (assign, ":true_original_faction", reg0),
	  (try_end),
	  (assign, ":original_culture", -2),
	  (try_begin),
	     (gt, ":true_original_faction", 0),
		 (faction_get_slot, ":original_culture", ":true_original_faction", slot_faction_culture),
		 (lt, ":original_culture", 1),
		 (assign, ":original_culture", ":true_original_faction"),
	  (try_end),
	  ##diplomacy end+

	  #Factions with an available center
	  (try_for_range, ":center_no", centers_begin, centers_end),
	    (this_or_next|party_slot_eq, ":center_no", slot_town_lord, stl_unassigned),
	    (party_slot_eq, ":center_no", slot_town_lord, stl_rejected_by_player),
	    (store_faction_of_party, ":center_faction", ":center_no"),
	    ##diplomacy start+ In Warband 1.142 / 1.143, this variable was added.
	    #To make certain kinds of mistakes or saved-game issues less likely,
	    #instead of checking for value 1 I'll check if the value matches the troop.
	    (this_or_next|eq, "$g_give_advantage_to_original_faction", ":troop_no"),
	    ##diplomacy end+
	    (neq, ":center_faction", ":orig_faction"),
	    (faction_get_slot, ":liege", ":center_faction", slot_faction_leader),
	    (this_or_next|neq, ":liege", "trp_player"),
	    (ge, "$player_right_to_rule", 25),
	    (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":liege"),
	    (assign, ":liege_relation", reg0),

		##diplomacy start+
		(try_begin),
			(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
			#If behavioral changes are enabled, bias heavily towards joining the
			#faction that contains your home (if you have one), or that has the
			#greatest cultural similarity.
			(ge, reg0, 0),
			(try_begin),
				(this_or_next|troop_slot_eq, ":troop_no", slot_troop_original_faction, ":center_faction"),
				(this_or_next|party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":troop_no"),
					(troop_slot_eq, ":troop_no", slot_troop_home, ":center_no"),
				(val_add, ":liege_relation", 20),
			(else_try),
				(gt, ":true_original_faction", 0),
				(party_slot_eq, ":center_no", slot_center_original_faction, ":true_original_faction"),
				(val_add, ":liege_relation", 5),
			(else_try),
				(gt, ":original_culture", 0),
				(faction_slot_eq, ":center_faction", slot_faction_culture, ":original_culture"),
				(val_add, ":liege_relation", 5),
			(try_end),
		(try_end),
		##diplomacy end+

	    (gt, ":liege_relation", ":score_to_beat"),
	    (assign, ":new_faction", ":center_faction"),
	    (assign, ":score_to_beat", ":liege_relation"),
	  (try_end),

	  #Factions without an available center
	  (try_begin),
	    (eq, ":new_faction", -1),
	    (assign, ":score_to_beat", 0),
	     #diplomacy start+
	     #If AI changes are explicitly enabled, slightly ease the requirements for entry.
	     (try_begin),
		    (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
	        (assign, ":score_to_beat", -5),
	     (try_end),
		 (store_add, ":min_acceptable_score", ":score_to_beat", 1),#used below
	     ##diplomacy end+

	    (try_for_range, ":kingdom", kingdoms_begin, kingdoms_end),
	      (faction_slot_eq, ":kingdom", slot_faction_state, sfs_active),
	      (faction_get_slot, ":liege", ":kingdom", slot_faction_leader),
	      (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":liege"),
	      (assign, ":liege_relation", reg0),

		  ##diplomacy start+
		  (try_begin),
				#In Warband 1.142 / 1.143, this variable was added.
				#To make certain kinds of mistakes or saved-game issues less likely,
				#instead of checking for value 1 I'll check if the value matches the troop.
				(this_or_next|eq, "$g_give_advantage_to_original_faction", ":troop_no"),
				(neq, ":kingdom", ":orig_faction"),
				(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
				#If behavioral changes are enabled, base your decision in part
				#on how many friends you have in the faction.
				(ge, reg0, ":min_acceptable_score"),
				(try_for_range, ":lord", heroes_begin, heroes_end),
					(troop_slot_eq, ":lord", slot_troop_occupation, slto_kingdom_hero),
					(neq, ":lord", ":troop_no"),
					(neq, ":lord", ":liege"),
					(store_faction_of_troop, ":lord_faction", ":lord"),
					(eq, ":lord_faction", ":kingdom"),
					(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":lord"),
					(try_begin),
						(ge, reg0, 20),
						(val_add, ":liege_relation", 1),
					(else_try),
						(lt, reg0, -19),
						(val_sub, ":liege_relation", 1),
					(try_end),
				(try_end),
				#Also give a bonus towards rejoining the lord's original faction.
				#if it isn't the one the lord has just left.
				(try_begin),
					(eq, ":true_original_faction", ":kingdom"),
					(val_add, ":liege_relation", 5),
				(else_try),
					#Not the same but similar
					(gt, ":original_culture", 0),
					(faction_slot_eq, ":kingdom", slot_faction_culture, ":original_culture"),
					(val_add, ":liege_relation", 2),
				(try_end),
				#The next bit is to prevent this change from increasing the number of
				#lords who find all kingdoms unacceptable.
				(val_max, ":liege_relation", ":min_acceptable_score"),
		  (try_end),
		  ##diplomacy end+

	      (gt, ":liege_relation", ":score_to_beat"),

	      (assign, ":new_faction", ":kingdom"),
	      (assign, ":score_to_beat", ":liege_relation"),
	    (try_end),
	  (try_end),

	  (assign, reg0, ":new_faction"),
	]),

	("set_up_duel_with_troop", #now the setup is handled through the menu
	[
	  (store_script_param, "$g_duel_troop", 1),
      #SB : change by parameter instead of always one
	  (store_script_param, "$g_start_arena_fight_at_nearest_town", 2),
	  (store_faction_of_troop, ":troop_faction", "$g_duel_troop"),
	  (try_begin),
	    (eq, "$g_start_arena_fight_at_nearest_town", 1),
        # (assign, ":closest_town", -1),
        (assign, ":minimum_dist", 500),
        (try_for_range, ":cur_town", walled_centers_begin, walled_centers_end),
          (store_distance_to_party_from_party, ":dist", ":cur_town", "$g_encountered_party"),
          (lt, ":dist", ":minimum_dist"),
          #make sure it's at least neutral, so we don't fight in an enemy town's arena
          (store_faction_of_party, ":center_faction", ":cur_town"),
          (store_relation, ":relation", ":troop_faction", ":center_faction"),
          (ge, ":relation", 0),
          (assign, ":minimum_dist", ":dist"),
          (assign, "$g_start_arena_fight_at_nearest_town", ":cur_town"),
        (try_end),
	  (try_end),
	  (unlock_achievement, ACHIEVEMENT_PUGNACIOUS_D),
      (jump_to_menu, "mnu_arena_duel_fight"),
	  (finish_mission),

	]),

	("test_player_for_career_and_marriage_incompatability", #empty now, but might want to add mid-game
	[
	#Married to a lord of one faction, while fighting for another
	#Married to one lord while holding a stipend from the king
	]),

	("deduct_casualties_from_garrison", #after a battle in a center, deducts any casualties from "$g_encountered_party"
	[
	##(display_message, "str_totalling_casualties_caused_during_mission"),

	(try_for_agents, ":agent"),
		(agent_get_troop_id, ":troop_type", ":agent"),
		(is_between, ":troop_type", regular_troops_begin, regular_troops_end),

		(neg|agent_is_alive, ":agent"),

		(try_begin), #if troop not present, search for another type which is
			(store_troop_count_companions, ":number", ":troop_type", "$g_encountered_party"),
			(eq, ":number", 0),
			(assign, ":troop_type", 0),
			(try_for_range, ":new_tier", slot_faction_tier_1_troop, slot_faction_tier_5_troop),
			(faction_get_slot, ":troop_type", "$g_encountered_party_faction", ":new_tier"),
				(faction_get_slot, ":new_troop_type", "$g_encountered_party_faction", ":new_tier"),
				(store_troop_count_companions, ":number", ":new_troop_type", "$g_encountered_party"),
				(gt, ":number", 0),
				(assign, ":troop_type", ":new_troop_type"),
			(try_end),
		(try_end),

		(gt, ":troop_type", 0),

		(party_remove_members, "$g_encountered_party", ":troop_type", 1),
		(str_store_troop_name, s4, ":troop_type"),
		(str_store_party_name, s5, "$g_encountered_party"),
	(try_end),
	]),

	("npc_decision_checklist_take_stand_on_issue",
	#Called from dialogs, and from simple_triggers

	#This a very inefficient checklist, and if I did it again, I would score for each troop. That way the troop could answer "why not" to an individual lord
	[
	(store_script_param, ":troop_no", 1),
	(store_faction_of_troop, ":troop_faction", ":troop_no"),

	(assign, ":result", -1),
	(faction_get_slot, ":faction_issue", ":troop_faction", slot_faction_political_issue),

	(assign, ":player_declines_honor", 0),
	(try_begin),
		(is_between, ":faction_issue", centers_begin, centers_end),
	    (gt, "$g_dont_give_fief_to_player_days", 1),
		(assign, ":player_declines_honor", 1),
	(else_try),
	    (gt, "$g_dont_give_marshalship_to_player_days", 1),
		(assign, ":player_declines_honor", 1),
	(try_end),

	##diplomacy start+
	(faction_get_slot, ":faction_leader", ":troop_faction", slot_faction_leader),
	(call_script, "script_dplmc_is_affiliated_family_member", ":troop_no"),
	(assign, ":affiliated_with_player", reg0),

	(assign, ":subaltern_gender", -1),#The gender subject to sexism (as far as leadership is concerned).
	(try_begin),
		(lt, "$g_disable_condescending_comments", 2),#Prejudice not disabled
		(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),#Don't bother with the rest of the check
		(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),#if the lord has an unbiased outlook.
		(neg|troop_slot_ge, ":troop_no", slot_lord_reputation_type, lrep_roguish),
		(call_script, "script_dplmc_store_troop_is_female", ":troop_no"),
		(store_sub, ":subaltern_gender", 1, reg0),
		(try_begin),
			(call_script, "script_cf_dplmc_faction_has_bias_against_gender", ":troop_faction", ":subaltern_gender"),
		(else_try),
			(assign, ":subaltern_gender", -1),
		(try_end),
	(try_end),

	(assign, ":faction_lord_count", 0),#Keep track of the number of lords in the faction
	##diplomacy end+

	(assign, ":total_faction_renown", 0),
	(troop_set_slot, "trp_player", slot_troop_temp_slot, 0),
	(try_begin),
		(eq, "$players_kingdom", ":troop_faction"),
		(eq, "$player_has_homage", 1),
		(troop_get_slot, ":total_faction_renown", "trp_player", slot_troop_renown),
		##diplomacy start+
		#Increment the faction lord count
		(val_add, ":faction_lord_count", 1),

		(try_begin),
			(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
			(eq, ":subaltern_gender", "$character_gender"),
			(val_mul, ":total_faction_renown", 4),
			(val_add, ":total_faction_renown", 3),
			(val_div, ":total_faction_renown", 5),
		(try_end),
		##diplomacy end+
	(try_end),

##diplomacy start+
	(try_for_range, ":active_npc", heroes_begin, heroes_end),#Changed range to include kingdom ladies
	    (troop_set_slot, ":active_npc", dplmc_slot_troop_temp_slot, 0), #this will hold distance to closest owned fief
##diplomacy end+
		(troop_set_slot, ":active_npc", slot_troop_temp_slot, 0), #reset to zero

		(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
		(eq, ":active_npc_faction", ":troop_faction"),
		(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),

		(troop_get_slot, ":renown", ":active_npc", slot_troop_renown),
		##diplomacy start+
		#Increment the faction lord count
		(val_add, ":faction_lord_count", 1),

		(try_begin),#If the player has set the prejudice mode to "high".
			(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
			(call_script, "script_dplmc_store_troop_is_female", ":active_npc"),
			(eq, reg0, ":subaltern_gender"),
			(val_mul, ":renown", 4),
			(val_add, ":renown", 3),
			(val_div, ":renown", 5),
		(try_end),
		##diplomacy end+
		(val_add, ":total_faction_renown", ":renown"),
	(try_end),


	(assign, ":total_faction_center_value", 0),
	(try_for_range, ":center", centers_begin, centers_end),
		(store_faction_of_party, ":center_faction", ":center"),
		(eq, ":center_faction", ":troop_faction"),

		(assign, ":center_value", 1),
		(try_begin),
		##diplomacy start+
		#Use different scoring scheme
			(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
			(try_begin),
			   (party_slot_eq, ":center", slot_party_type, spt_town),
  			   (assign, ":center_value", 3),
			(else_try),
			   (neg|party_slot_eq, ":center", slot_party_type, spt_village),
			   (this_or_next|party_slot_eq, ":center", slot_party_type, spt_castle),
				(is_between, ":center", walled_centers_begin, walled_centers_end),
			   (assign, ":center_value", 2),
			(try_end),
		#Otherwise fall through to old behavior
		(else_try),
		##diplomacy end+
			(is_between, ":center", towns_begin, towns_end),
			(assign, ":center_value", 2),
		(try_end),

		(val_add, ":total_faction_center_value", ":center_value"),

		(party_get_slot, ":town_lord", ":center", slot_town_lord),
		##diplomacy start+
		#The rest of the script assumes that non-player lords are heroes,
		#so add that condition here to get the count right.
		#(gt, ":town_lord", -1),
		(this_or_next|eq, ":town_lord", "trp_player"),
			(is_between, ":town_lord", heroes_begin, heroes_end),

		#Calculate distance for alternate scoring if the issue is a center
		(try_begin),
			(is_between, ":faction_issue", centers_begin, centers_end),
			(neq, ":center", ":faction_issue"),
			(troop_get_slot, ":dplmc_temp_slot", ":town_lord", dplmc_slot_troop_temp_slot),
			(store_distance_to_party_from_party, reg0, ":center", ":faction_issue"),
			(gt, reg0, 0),
			(try_begin),
				(eq, ":dplmc_temp_slot", 0),
				(assign, ":dplmc_temp_slot", reg0),
			(else_try),
				(val_min, ":dplmc_temp_slot", reg0),
			(try_end),
			(troop_set_slot, ":town_lord", dplmc_slot_troop_temp_slot, ":dplmc_temp_slot"),
		(try_end),
		##diplomacy end+

		(troop_get_slot, ":temp_slot", ":town_lord", slot_troop_temp_slot),
		(val_add, ":temp_slot", ":center_value"),
		(troop_set_slot, ":town_lord", slot_troop_temp_slot, ":temp_slot"),
	(try_end),
	(val_max, ":total_faction_center_value", 1),

	(store_div, ":average_renown_per_center_point", ":total_faction_renown", ":total_faction_center_value"),
	##diplomacy start+
	(val_max, ":faction_lord_count", 1),

#	(store_mul, ":avg_renown_plus_500_per_cp", ":faction_lord_count", 500),
#	(val_add, ":avg_renown_plus_500_per_cp", ":total_faction_renown"),
#	(store_add, reg0, ":total_faction_center_value", ":faction_lord_count"),
#	(val_div, ":avg_renown_plus_500_per_cp", reg0),

	#Get the standard deviation of renown per center point
	(assign, ":renown_per_center_point_variance", 0),
#	(assign, ":renown_plus_500_per_center_point_variance", 0),

	(try_for_range, ":active_npc", active_npcs_including_player_begin, heroes_end),
		(store_sub, ":active_npc_faction", ":troop_faction", 1),#guaranteed not to equal
		(try_begin),
			#handle player
			(eq, ":active_npc", active_npcs_including_player_begin),
			(assign, ":active_npc", "trp_player"),
			(eq, "$players_kingdom", ":troop_faction"),
			(eq, "$player_has_homage", 1),
			(assign, ":active_npc_faction", ":troop_faction"),
		(else_try),
			#handle kingdom heroes
			(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
		(try_end),

		(eq, ":active_npc_faction", ":troop_faction"),

		(troop_get_slot, ":renown", ":active_npc", slot_troop_renown),
		(try_begin),
			(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
			(call_script, "script_dplmc_store_troop_is_female", ":active_npc"),
			(eq, reg0, ":subaltern_gender"),
			(val_mul, ":renown", 4),
			(val_add, ":renown", 3),
			(val_div, ":renown", 5),
		(try_end),
		(troop_get_slot, ":center_points", ":active_npc", slot_troop_temp_slot),
		#Variance for renown / center points
		(val_max, ":center_points", 1),
		(store_div, reg0, ":renown", ":center_points"),
		(val_sub, reg0, ":average_renown_per_center_point"),
		(val_mul, reg0, reg0),
		(val_add, ":renown_per_center_point_variance", reg0),

#		#Variance for renown + 500 / center points + 1
#		(troop_get_slot, ":center_points", ":active_npc", slot_troop_temp_slot),
#		(val_add, ":center_points", 1),
#		(store_add, reg0, ":renown", 500),
#		(val_div, reg0, ":center_points"),
#		(val_sub, reg0, ":avg_renown_plus_500_per_cp"),
#		(val_mul, reg0, reg0),
#		(val_add, ":renown_plus_500_per_center_point_variance", reg0),
	(try_end),

	#Get renown per center point standard deviation, or 10%, whichever is greater
	(store_div, reg0, ":faction_lord_count", 2),#for rounding
	(val_add, ":renown_per_center_point_variance", reg0),
	(val_div, ":renown_per_center_point_variance", 	":faction_lord_count"),

	(assign, reg0, ":renown_per_center_point_variance"),
	(convert_to_fixed_point, reg0),
	(store_sqrt, reg0, reg0),
	(convert_from_fixed_point, reg0),
	(assign, ":renown_per_center_point_standard_deviation", reg0),
	(val_add, reg0, 5),
	(val_div, reg0, 10),
	(val_max, ":renown_per_center_point_standard_deviation", reg0),
	(store_sub, ":renown_low_target", ":average_renown_per_center_point", ":renown_per_center_point_standard_deviation"),
	(val_max, ":renown_low_target", 0),

#	#Get (renown + 500) per (center point plus one) standard deviation, or 10%, whichever is greater
#	(store_div, reg0, ":faction_lord_count", 2),#for rounding
#	(val_add, ":renown_plus_500_per_center_point_variance", reg0),
#	(val_div, ":renown_plus_500_per_center_point_variance", ":faction_lord_count"),
#
#	(assign, reg0, ":renown_plus_500_per_center_point_variance"),
#	(convert_to_fixed_point, reg0),
#	(store_sqrt, reg0, reg0),
#	(convert_from_fixed_point, reg0),
#	(assign, ":renown_plus_500_per_center_point_standard_deviation", reg0),
#	(val_add, reg0, 5),
#	(val_div, reg0, 10),
#	(val_max, ":renown_plus_500_per_center_point_standard_deviation", reg0),
#	(store_sub, ":renown_500_low_target", ":avg_renown_plus_500_per_cp", ":renown_plus_500_per_center_point_standard_deviation"),
#	(val_max, ":renown_500_low_target", 0),
	##diplomacy end+

	(try_begin),
		(is_between, ":faction_issue", centers_begin, centers_end),
		#NOTE -- The algorithms here might seem a bit repetitive, but are designed that way to create internal cliques among the lords in a faction.



		(try_begin),#If the center is a village, and a lord has no fief, choose him
			(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
			(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_selfrighteous),
			(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_quarrelsome),

			(is_between, ":faction_issue", villages_begin, villages_end),
			(assign, ":favorite_lord_without_center", -1),
			(assign, ":score_to_beat", -1),
			##diplomacy start+
			(try_begin),
				#With changes enabled, widen the range of scores to check for certain personality types
				(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
				(try_begin),
					(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),
					(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
					(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_benefactor),
					(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_conventional),
					(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_moralist),
					(this_or_next|is_between, ":troop_no", kings_begin, kings_end),
						(is_between, ":troop_no", pretenders_begin, pretenders_end),
					(assign, ":score_to_beat", -6),#-5 or better is indifferent
				(else_try),
					(ge, ":faction_leader", 0),
					(this_or_next|eq, ":faction_leader", ":troop_no"),
					(this_or_next|troop_slot_eq, ":faction_leader", slot_troop_spouse, ":troop_no"),
						(troop_slot_eq, ":troop_no", slot_troop_spouse, ":faction_leader"),
					(assign, ":score_to_beat", -6),#-5 or better is indifferent
				(try_end),
			(try_end),
			##diplomacy end+

			(try_begin),
				(eq, "$players_kingdom", ":troop_faction"),
				(eq, "$player_has_homage", 1),
				(eq, ":player_declines_honor", 0),

				(troop_slot_eq, "trp_player", slot_troop_temp_slot, 0),
				(call_script, "script_troop_get_relation_with_troop", "trp_player", ":troop_no"),
				(assign, ":relation", reg0),
				##diplomacy start+
				#If the player doesn't have prejudice disabled, don't automatically support for a first fief
				(try_begin),
					(this_or_next|neq, ":subaltern_gender", "$character_gender"),
					(this_or_next|is_between, ":troop_no", companions_begin, companions_end),#Former companions will support the player
					(this_or_next|troop_slot_eq, ":troop_no", slot_troop_spouse, "trp_player"),#Spouses will support the player
						(troop_slot_eq, "trp_player", slot_troop_spouse, ":troop_no"),
				(else_try),
					(val_sub, ":relation", 20),
				(try_end),
				##diplomacy end+

				(gt, ":relation", ":score_to_beat"),
				(neg|troop_slot_ge, "trp_player", slot_troop_controversy, 75),
				(assign, ":favorite_lord_without_center", "trp_player"),
				(assign, ":score_to_beat", ":relation"),
			(try_end),
			##diplomacy start+  Support promoted kingdom ladise
			#(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),  #<-- replace this
			(try_for_range, ":active_npc", heroes_begin, heroes_end),
			##diplomacy end+
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":troop_faction"),
				(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),

				(troop_slot_eq, ":active_npc", slot_troop_temp_slot, 0),
				(try_begin),
					(eq, ":active_npc", ":troop_no"),
					(assign, ":relation", 50),
				(else_try),
					(call_script, "script_troop_get_relation_with_troop", ":active_npc", ":troop_no"),
					(assign, ":relation", reg0),
				(try_end),
				##diplomacy start+ Disadvantage the subaltern gender
				(call_script, "script_dplmc_store_troop_is_female", ":troop_no"),
				(try_begin),
					(eq, reg0, ":subaltern_gender"),
					(val_sub, ":relation", 20),
				(try_end),
				##diplomacy end+
				(neg|troop_slot_ge, ":active_npc", slot_troop_controversy, 75),

				(gt, ":relation", ":score_to_beat"),
				(assign, ":favorite_lord_without_center", ":active_npc"),
				(assign, ":score_to_beat", ":relation"),
			(try_end),

			(gt, ":favorite_lord_without_center", -1),
			(assign, ":result", ":favorite_lord_without_center"),
			(assign, ":result_explainer", "str_political_explanation_lord_lacks_center"),
		##diplomacy start+
		##Faction leaders are more rational about whom they support.
	   (else_try),
			(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
			(call_script, "script_dplmc_get_troop_standing_in_faction", ":troop_no", ":troop_faction"),
			(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
			(assign, ":best_candidate", -1),
			(assign, ":best_score", -1),
			(assign, ":explanation", 0),
			(try_begin),
			   (eq,"$players_kingdom", ":troop_faction"),
				(eq, "$player_has_homage", 1),
				(eq, ":player_declines_honor", 0),
				(call_script, "script_dplmc_calculate_troop_score_for_center_aux", ":troop_no", "trp_player", ":faction_issue"),#reg0 = score, reg1 = explanation
				(assign, ":best_candidate", "trp_player"),
				(assign, ":best_score", reg0),
				(assign, ":explanation", reg1),
			(try_end),
			(try_for_range, ":active_npc", heroes_begin, heroes_end),
			   (store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":troop_faction"),
				(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),
				(call_script, "script_dplmc_calculate_troop_score_for_center_aux", ":troop_no", ":active_npc", ":faction_issue"),#reg0 = score, reg1 = explanation
				(this_or_next|eq, ":best_candidate", -1),
				   (gt, reg0, ":best_score"),
				(assign, ":best_candidate", ":active_npc"),
				(assign, ":best_score", reg0),
				(assign, ":explanation", reg1),
			(try_end),
			(gt, ":best_candidate", -1),
			(assign, ":result", ":best_candidate"),
			(assign, ":result_explainer", ":explanation"),
		##diplomacy end+
		(else_try),	#taken by troop
			(is_between, ":faction_issue", walled_centers_begin, walled_centers_end),
			(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
			(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_selfrighteous),
			(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),

			(party_get_slot, ":last_taken_by_troop", ":faction_issue", slot_center_last_taken_by_troop),
			(try_begin),
				(try_begin),
					(neq, ":troop_faction", "$players_kingdom"),
					(assign, ":last_taken_by_troop", -1),
				(else_try),
					(eq, "$player_has_homage", 0),
					(assign, ":last_taken_by_troop", -1),
				(else_try),
					(eq, ":faction_issue", "$g_castle_requested_by_player"),
					(assign, ":last_taken_by_troop", "trp_player"),
				(else_try),
					(eq, ":faction_issue", "$g_castle_requested_for_troop"),
					(assign, ":last_taken_by_troop", "trp_player"),
				(else_try), #ie, the fellow who took it is no longer in the faction
					(gt, ":last_taken_by_troop", -1),
					(store_faction_of_troop, ":last_take_by_troop_faction", ":last_taken_by_troop"),
					(neq, ":last_take_by_troop_faction", ":troop_faction"),
					(assign, ":last_taken_by_troop", -1),
				(try_end),
			(try_end),
			(gt, ":last_taken_by_troop", -1),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(gt, ":last_taken_by_troop", -1),
				(str_store_troop_name, s3, ":last_taken_by_troop"),
				(display_message, "@{!}Castle taken by {s3}"),
			(try_end),


			(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":last_taken_by_troop"),
			##diplomacy start+
			#If behavior changes are enabled, increase the accepted range for certain personality types.
			(assign, ":relation", reg0),
			(try_begin),
				(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
				(try_begin),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_martial),
					(val_add, reg0, 5),#i.e. accept at -5 (indifferent) or higher
				(else_try),
					(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
					(val_add, reg0, 5),#i.e. accept at -5 (indifferent) or higher
				(try_end),
			(try_end),
			##diplomacy end+
			(ge, reg0, 0),

			(neg|troop_slot_ge, ":last_taken_by_troop", slot_troop_controversy, 25),

			(troop_get_slot, ":renown", ":last_taken_by_troop", slot_troop_renown),
			##diplomacy start+
			(try_begin),
				(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
				(call_script, "script_dplmc_store_troop_is_female", ":last_taken_by_troop"),
				(eq, reg0, ":subaltern_gender"),
				(val_mul, ":renown", 4),
				(val_add, ":renown", 3),
				(val_div, ":renown", 5),
			(try_end),
			##diplomacy end+
			(troop_get_slot, ":center_points", ":last_taken_by_troop", slot_troop_temp_slot),
			(val_max, ":center_points", 1),
			(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),
			(val_mul, ":renown_divided_by_center_points", 6), #was five
			(val_div, ":renown_divided_by_center_points", 4),

			##diplomacy start+
			(try_begin),
				(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
				#Possibly raise renown_divided_by_center_points
				(store_div, reg0, ":renown", ":center_points"),
				(val_add, reg0, ":renown_per_center_point_standard_deviation"),
				(val_max, ":renown_divided_by_center_points", reg0),
			(try_end),
			##diplomacy end+
			(ge, ":renown_divided_by_center_points", ":average_renown_per_center_point"),


			(assign, ":result", ":last_taken_by_troop"),
			(assign, ":result_explainer", "str_political_explanation_lord_took_center"),


		#Check self, immediate family
		#This is done instead of a single weighted score to create cliques -- groups of NPCs who support one another
		(else_try),
			(assign, ":most_deserving_close_friend", -1),
			(assign, ":score_to_beat", ":average_renown_per_center_point"),
			(val_div, ":score_to_beat", 3),
			(val_mul, ":score_to_beat", 2),

			(try_begin),
				(eq, "$cheat_mode", 1),
				(assign, reg3, ":score_to_beat"),
				(display_message, "@{!}Two-thirds average_renown = {reg3}"),
			(try_end),

			###diplomacy start+
			#(try_begin),
			#	(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
			#	(try_begin),
			#		(eq, "$cheat_mode", 1),
			#		(assign, reg3, ":renown_low_target"),
			#		(display_message, "@{!}Average renown per center minus one standard deviation = {reg3}"),
			#	(try_end),
			#(try_end),
			###diplomacy end+

			(try_begin),
				(eq, "$players_kingdom", ":troop_faction"),
				(eq, "$player_has_homage", 1),
				(eq, ":player_declines_honor", 0),

				(call_script, "script_troop_get_relation_with_troop", "trp_player", ":troop_no"),
				(assign, ":relation", reg0),
				##diplomacy start+
				#If affiliated with player
				(this_or_next|gt, ":affiliated_with_player", 0),
				##diplomacy end+
				(ge, ":relation", 20),
				(neg|troop_slot_ge, "trp_player", slot_troop_controversy, 50),

				(troop_get_slot, ":renown", "trp_player", slot_troop_renown),
				##diplomacy start+
				(try_begin),
					(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
					(eq, ":subaltern_gender", "$character_gender"),
					(val_mul, ":renown", 4),
					(val_add, ":renown", 3),
					(val_div, ":renown", 5),
				(try_end),
				(troop_get_slot, ":center_points", "trp_player", slot_troop_temp_slot),
				(val_max, ":center_points", 1),
				(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),


				(assign, ":most_deserving_close_friend", "trp_player"),
				(assign, ":score_to_beat", ":renown_divided_by_center_points"),
			(try_end),
			##diplomacy start+  Support promoted kingdom ladies
			#(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end), #<- replace
			(try_for_range, ":active_npc", heroes_begin, heroes_end),
			##diplomacy end+
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":troop_faction"),
				(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),

				(call_script, "script_troop_get_relation_with_troop", ":active_npc", ":troop_no"),
				(assign, ":relation", reg0),
				##diplomacy start+
				(assign, reg0, 0),
				#If affiliated with player
				(try_begin),
					(lt, ":relation", 20),
					(gt, ":affiliated_with_player", 0),
					(neq, ":active_npc", ":troop_no"),
					(call_script, "script_dplmc_is_affiliated_family_member", ":troop_no"),
				(try_end),
				(this_or_next|gt, reg0, 0),#<-- both affiliated
				##diplomacy end+
				(this_or_next|eq, ":active_npc", ":troop_no"),
					(ge, ":relation", 20),
				(neg|troop_slot_ge, ":active_npc", slot_troop_controversy, 50),

				(troop_get_slot, ":renown", ":active_npc", slot_troop_renown),
				##diplomacy start+
				(try_begin),
					(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
					(call_script, "script_dplmc_store_troop_is_female", ":active_npc"),
					(eq, reg0, ":subaltern_gender"),
					(val_mul, ":renown", 4),
					(val_add, ":renown", 3),
					(val_div, ":renown", 5),
				(try_end),
				##diplomacy end+
				(troop_get_slot, ":center_points", ":active_npc", slot_troop_temp_slot),
				(val_max, ":center_points", 1),
				(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),


				(try_begin),
					(eq, "$cheat_mode", 1),
					(str_store_troop_name, s10, ":active_npc"),
					(assign, reg3, ":renown_divided_by_center_points"),
					(display_message, "@{!}DEBUG -- Colleague test: score for {s10} = {reg3}"),
				(try_end),


				(gt, ":renown_divided_by_center_points", ":score_to_beat"),

				(assign, ":most_deserving_close_friend", ":active_npc"),
				(assign, ":score_to_beat", ":renown_divided_by_center_points"),
			(try_end),

			(gt, ":most_deserving_close_friend", -1),


			(assign, ":result", ":most_deserving_close_friend"),
			(assign, ":result_explainer", "str_political_explanation_most_deserving_friend"),



		(else_try),
		#Most deserving in entire faction, minus those with no relation
			(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
			(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_selfrighteous),
			(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_quarrelsome),

			(assign, ":most_deserving_in_faction", -1),
			(assign, ":score_to_beat", 0),

			(try_begin),
				(eq, "$players_kingdom", ":troop_faction"),
				(eq, "$player_has_homage", 1),
				(eq, ":player_declines_honor", 0),

				(call_script, "script_troop_get_relation_with_troop", "trp_player", ":troop_no"),
				(assign, ":relation", reg0),
				(ge, ":relation", 0),
				(troop_get_slot, ":renown", "trp_player", slot_troop_renown),
				##diplomacy start+
				(try_begin),
					(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
					(eq, ":subaltern_gender", "$character_gender"),
					(val_mul, ":renown", 4),
					(val_add, ":renown", 3),
					(val_div, ":renown", 5),
				(try_end),
				##diplomacy end+
				(troop_get_slot, ":center_points", "trp_player", slot_troop_temp_slot),
				(neg|troop_slot_ge, "trp_player", slot_troop_controversy, 25),

				(val_max, ":center_points", 1),
				(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),

				(assign, ":most_deserving_in_faction", "trp_player"),
				(assign, ":score_to_beat", ":renown_divided_by_center_points"),
			(try_end),
			##diplomacy start+ add support for promoted kingdom ladies
			#(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
			(try_for_range, ":active_npc", heroes_begin, heroes_end),
			   (this_or_next|is_between, ":active_npc", active_npcs_begin, active_npcs_end),
			      (troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),
			##diplomacy end+
				(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(eq, ":active_npc_faction", ":troop_faction"),
				(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),

				(call_script, "script_troop_get_relation_with_troop", ":active_npc", ":troop_no"),
				(assign, ":relation", reg0),
				(this_or_next|eq, ":active_npc", ":troop_no"),
					(ge, ":relation", 0),
				(neg|troop_slot_ge, ":active_npc", slot_troop_controversy, 25),

				(troop_get_slot, ":renown", ":active_npc", slot_troop_renown),
				##diplomacy start+
				(try_begin),
					(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
					(call_script, "script_dplmc_store_troop_is_female", ":active_npc"),
					(eq, reg0, ":subaltern_gender"),
					(val_mul, ":renown", 4),
					(val_add, ":renown", 3),
					(val_div, ":renown", 5),
				(try_end),
				##diplomacy end+
				(troop_get_slot, ":center_points", ":active_npc", slot_troop_temp_slot),
				(val_max, ":center_points", 1),

				(store_div, ":renown_divided_by_center_points", ":renown", ":center_points"),
				(gt, ":renown_divided_by_center_points", ":score_to_beat"),

				(try_begin),
					(eq, "$cheat_mode", 1),
					(str_store_string, s10, ":active_npc"),
					(assign, reg3, ":renown_divided_by_center_points"),
					(display_message, "@{!}DEBUG -- Open test: score for {s10} = {reg3}"),
				(try_end),


				(assign, ":most_deserving_in_faction", ":active_npc"),
				(assign, ":score_to_beat", ":renown_divided_by_center_points"),
			(try_end),


			(gt, ":most_deserving_in_faction", -1),
			(assign, ":result", ":most_deserving_in_faction"),
			(assign, ":result_explainer", "str_political_explanation_most_deserving_in_faction"),
		##diplomacy start+
		(else_try),
			#The lord wasn't able to find any suitable candidates,
			#so now we perform the evaluation from another perspective.
			(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
			#DPLMC_AI_CHANGES >= LOW
			#DPLMC_AI_CHANGES >= MEDIUM   XOR   status >= DPLMC_FACTION_STANDING_LEADER_SPOUSE
			(call_script, "script_dplmc_get_troop_standing_in_faction", ":troop_no", ":troop_faction"),
			(this_or_next|ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
				(ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
			(this_or_next|lt, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
				(lt, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
			(assign, ":save_reg1", reg1),

			(assign, ":score_to_beat", 0),
			(assign, ":most_deserving_in_faction", -1),
			#(assign, ":tmp_explanation", 0),

			(try_for_range, ":active_npc", active_npcs_including_player_begin, heroes_end),
				(store_sub, ":active_npc_faction", ":troop_faction", 1),
				(try_begin),
					(eq, ":active_npc", active_npcs_including_player_begin),
					(assign, ":active_npc", "trp_player"),
					(eq, "$players_kingdom", ":troop_faction"),
					(eq, "$player_has_homage", 1),
					(assign, ":active_npc_faction", ":troop_faction"),
				(else_try),
					(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),
					(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
				(try_end),
				(eq, ":active_npc_faction", ":troop_faction"),

				#(call_script, "script_dplmc_aux_troop_evaluate_troop_for_center", ":troop_no", ":active_npc", ":faction_issue"),#reg0 = score, reg1 = explanation
				(call_script, "script_dplmc_calculate_troop_score_for_center_aux", ":troop_no", ":active_npc", ":faction_issue"),#reg0 = score, reg1 = explanation

				(this_or_next|eq, ":most_deserving_in_faction", -1),
					(ge, reg0, ":score_to_beat"),
				(assign, ":score_to_beat", reg0),
            (assign, ":result_explainer", reg1),
				(assign, ":most_deserving_in_faction", ":active_npc"),
			(try_end),

			(gt, ":most_deserving_in_faction", -1),
			(assign, ":result", ":most_deserving_in_faction"),
			#(assign, ":result_explainer", ":result_explainer"),#unneeded
         (assign, reg1, ":save_reg1"),
		##diplomacy end+
		(else_try),
			(assign, ":result", ":troop_no"),
			(assign, ":result_explainer", "str_political_explanation_self"),
		(try_end),


	(else_try),
		(eq, ":faction_issue", 1),

		(assign, ":relationship_threshhold", 15),
		(try_begin),
			(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
			(assign, ":relationship_threshhold", 5),
		(else_try),
			(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
			(assign, ":relationship_threshhold", 25),
		(try_end),

		#For marshals, score marshals according to renown divided by controversy - first for friends and family, then for everyone
		(assign, ":marshal_candidate", -1),
		(assign, ":score_to_beat", 0),
		(try_begin),
			(eq, "$players_kingdom", ":troop_faction"),
			(eq, "$player_has_homage", 1),
			(eq, "$g_player_is_captive", 0),
			(eq, ":player_declines_honor", 0),


			(call_script, "script_troop_get_relation_with_troop", "trp_player", ":troop_no"),
			(ge, reg0, ":relationship_threshhold"),
			(assign, ":marshal_candidate", "trp_player"),
			(troop_get_slot, ":renown", "trp_player", slot_troop_renown),
			##diplomacy start+
			(try_begin),
				(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
				(eq, ":subaltern_gender", "$character_gender"),
				(val_mul, ":renown", 4),
				(val_add, ":renown", 3),
				(val_div, ":renown", 5),
			(try_end),
			##diplomacy end+
			(troop_get_slot, ":controversy_divisor", "trp_player", slot_troop_controversy),
			(val_add, ":controversy_divisor", 50),
			(store_div, ":score_to_beat", ":renown", ":controversy_divisor"),
		(try_end),

      ##diplomacy start+ Support promoted ladies
		#(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
		(try_for_range, ":active_npc", heroes_begin, heroes_end),
      ##diplomacy end+
			(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
			(eq, ":active_npc_faction", ":troop_faction"),
			(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),
			(troop_slot_eq, ":active_npc", slot_troop_prisoner_of_party, -1),

			(neg|faction_slot_eq, ":troop_faction", slot_faction_leader, ":active_npc"),

			(call_script, "script_troop_get_relation_with_troop", ":active_npc", ":troop_no"),
			(assign, ":relation", reg0),
			(this_or_next|eq, ":active_npc", ":troop_no"),
				(ge, ":relation", ":relationship_threshhold"),

			(troop_get_slot, ":renown", ":active_npc", slot_troop_renown),
			##diplomacy start+
			(try_begin),
				(lt, "$g_disable_condescending_comments", 0),#If the player has set the prejudice mode to "high"
				(call_script, "script_dplmc_store_troop_is_female", ":troop_no"),
				(eq, reg0, ":subaltern_gender"),
				(val_mul, ":renown", 4),
				(val_add, ":renown", 3),
				(val_div, ":renown", 5),
			(try_end),
			##diplomacy end+
			(troop_get_slot, ":controversy_divisor", ":active_npc", slot_troop_controversy),
			(val_add, ":controversy_divisor", 50),
			(store_div, ":score", ":renown", ":controversy_divisor"),

			(gt, ":score", ":score_to_beat"),

			(assign, ":marshal_candidate", ":active_npc"),
			(assign, ":score_to_beat", ":score"),

		(try_end),

		(assign, ":result", ":marshal_candidate"),
		(assign, ":result_explainer", "str_political_explanation_marshal"),
	(try_end),

	(try_begin),
		(eq, "$cheat_mode", 1),
		(gt, ":result", -1),
		(str_store_troop_name, s8, ":troop_no"),
		(str_store_troop_name, s9, ":result"),
		(str_store_string, s10, ":result_explainer"),
		(display_message, "@{!}DEBUG -- {s8} backs {s9}:{s10}"),
	(try_end),

	(assign, reg0, ":result"),
	(assign, reg1, ":result_explainer"),

	]),


	("npc_decision_checklist_evaluate_faction_strategy",
	[
	#Decides whether the strategy is good or bad -- to be added
	]),


	("process_player_enterprise",
    #reg0: Profit per cycle
	##diplomacy start+
	#Actual documentation of original parameters and outputs.
	# INPUTS:
	#   arg1: item_type
	#   arg2: center
	# OUTPUTS:
    #   reg0:  profit_per_cycle"),
	#   reg1:  final_price_for_total_produced_goods"),
	#   reg2:  final_price_for_total_inputs"),
	#   reg3:  price_of_labor"),
	#   reg4:  final_price_for_single_produced_good"),
	#   reg5:  final_price_for_single_input"),
	#	reg10: final_price_for_secondary_input"),
	#
	# Further, if experimental changes are enabled, modify the price.
	##diplomacy end+
	[
	  (store_script_param, ":item_type", 1),
	  (store_script_param, ":center", 2),

	  (item_get_slot, ":price_of_labor", ":item_type", slot_item_overhead_per_run),

	  (item_get_slot, ":base_price", ":item_type", slot_item_base_price),
	  (store_sub, ":cur_good_price_slot", ":item_type", trade_goods_begin),
	  (val_add, ":cur_good_price_slot", slot_town_trade_good_prices_begin),
	  (party_get_slot, ":cur_price_modifier", ":center", ":cur_good_price_slot"),
	  ##diplomacy start+
	  (val_clamp, ":cur_price_modifier", minimum_price_factor, maximum_price_factor + 1),#Added enforcement of minimum/maximum
	  (store_mul, ":final_price_for_single_produced_good", ":base_price", ":cur_price_modifier"),#<- (Unchanged)
	  (val_div, ":final_price_for_single_produced_good", average_price_factor),#Replaced "1000" with "average_price_factor"
	  ##diplomacy end+
	  (item_get_slot, ":number_of_outputs_produced", ":item_type", slot_item_output_per_run),
	  (store_mul, ":final_price_for_total_produced_goods", ":number_of_outputs_produced", ":final_price_for_single_produced_good"),

	  (item_get_slot, ":primary_raw_material", ":item_type", slot_item_primary_raw_material),
	  (item_get_slot, ":base_price", ":primary_raw_material", slot_item_base_price),
	  (store_sub, ":cur_good_price_slot", ":primary_raw_material", trade_goods_begin),
	  (val_add, ":cur_good_price_slot", slot_town_trade_good_prices_begin),
	  (party_get_slot, ":cur_price_modifier", ":center", ":cur_good_price_slot"),
	  ##diplomacy start+
	  (try_begin),
	     (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_MEDIUM),#<-- experimental changes must be enabled
		 (call_script, "script_dplmc_assess_ability_to_purchase_good_from_center", ":primary_raw_material", ":center"),
		 (val_max, ":cur_price_modifier", reg0),
	  (try_end),
	  (val_clamp, ":cur_price_modifier", minimum_price_factor, maximum_price_factor + 1),#Added enforcement of minimum/maximum
	  (store_mul, ":final_price_for_single_input", ":base_price", ":cur_price_modifier"),#<- (Unchanged)
	  (val_div, ":final_price_for_single_input", average_price_factor),#Replaced "1000" with "average_price_factor"
	  ##diplomacy end+
	  (item_get_slot, ":number_of_inputs_required", ":item_type", slot_item_input_number),
	  (try_begin),
	    (lt, ":number_of_inputs_required", 0),
	    (store_div, ":final_price_for_total_inputs", ":final_price_for_single_input", 2),
	  (else_try),
	    (store_mul, ":final_price_for_total_inputs", ":final_price_for_single_input", ":number_of_inputs_required"),
	  (try_end),

	  (try_begin),
	    (item_slot_ge, ":item_type", slot_item_secondary_raw_material, 1),
	    (item_get_slot, ":secondary_raw_material", ":item_type", slot_item_secondary_raw_material),
	    (item_get_slot, ":base_price", ":secondary_raw_material", slot_item_base_price),
	    (store_sub, ":cur_good_price_slot", ":secondary_raw_material", trade_goods_begin),
	    (val_add, ":cur_good_price_slot", slot_town_trade_good_prices_begin),
	    (party_get_slot, ":cur_price_modifier", ":center", ":cur_good_price_slot"),
		##diplomacy start+
		(try_begin),
	      (ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_MEDIUM),#<-- experimental changes must be enabled
		  (call_script, "script_dplmc_assess_ability_to_purchase_good_from_center", ":secondary_raw_material", ":center"),
		  (val_max, ":cur_price_modifier", reg0),
	    (try_end),
	    (val_clamp, ":cur_price_modifier", minimum_price_factor, maximum_price_factor + 1),#Added enforcement of minimum/maximum
		##diplomacy end+
		(store_mul, ":final_price_for_secondary_input", ":base_price", ":cur_price_modifier"),#fixes
	    (try_begin),
	      (lt, ":number_of_inputs_required", 0),
	      (val_div, ":final_price_for_secondary_input", 2),
	    (else_try),
	      (val_mul, ":final_price_for_secondary_input", ":number_of_inputs_required"),
	    (try_end),

		##diplomacy start+
	    (val_div, ":final_price_for_secondary_input", average_price_factor),#Replaced "1000" with "average_price_factor"
		##diplomacy end+
	  (else_try),
	    (assign, ":final_price_for_secondary_input", 0),
	  (try_end),

	  (store_sub, ":profit_per_cycle", ":final_price_for_total_produced_goods", ":final_price_for_total_inputs"),
	  (val_sub, ":profit_per_cycle", ":price_of_labor"),
	  (val_sub, ":profit_per_cycle", ":final_price_for_secondary_input"),

	  (assign, reg0, ":profit_per_cycle"),
	  (assign, reg1, ":final_price_for_total_produced_goods"),
	  (assign, reg2, ":final_price_for_total_inputs"),
	  (assign, reg3, ":price_of_labor"),
	  (assign, reg4, ":final_price_for_single_produced_good"),
	  (assign, reg5, ":final_price_for_single_input"),
	  (assign, reg10, ":final_price_for_secondary_input"),
	]),

  # script_replace_scene_items_with_spawn_items_before_ms
  # Input: none
  # Output: none
  ("replace_scene_items_with_spawn_items_before_ms",
    [
      (try_for_range, ":item_no", all_items_begin, all_items_end),
        (item_get_type, ":item_type", ":item_no"),
        (neq, ":item_type", itp_type_goods),
        (neq, ":item_type", itp_type_book),
        (scene_item_get_num_instances, ":num_instances", ":item_no"),
        (item_set_slot, ":item_no", slot_item_num_positions, 0),
        (assign, ":num_positions", 0),
        (try_for_range, ":cur_instance", 0, ":num_instances"),
          (scene_item_get_instance, ":scene_item", ":item_no", ":cur_instance"),
          (prop_instance_get_position, "$g_position_to_use_for_replacing_scene_items", ":scene_item"),
          (store_add, ":cur_slot", slot_item_positions_begin, ":num_positions"),
          (item_set_slot, ":item_no", ":cur_slot", "$g_position_to_use_for_replacing_scene_items"),
          (val_add, ":num_positions", 1),
          (val_add, "$g_position_to_use_for_replacing_scene_items", 1),
          (item_set_slot, ":item_no", slot_item_num_positions, ":num_positions"),
        (try_end),
        (replace_scene_items_with_scene_props, ":item_no", "spr_empty"),
      (try_end),
     ]),

  # script_replace_scene_items_with_spawn_items_after_ms
  # Input: none
  # Output: none
  ("replace_scene_items_with_spawn_items_after_ms",
    [
      (try_for_range, ":item_no", all_items_begin, all_items_end),
        (item_get_slot,  ":num_positions", ":item_no", slot_item_num_positions),
        (item_get_type, ":item_type",":item_no"),
        (try_for_range, ":cur_position", 0, ":num_positions"),
          (store_add, ":cur_slot", slot_item_positions_begin, ":cur_position"),
          (item_get_slot, ":pos_no", ":item_no", ":cur_slot"),
          (set_spawn_position, ":pos_no"),
          (try_begin),
            (eq, ":item_type", itp_type_horse),
            (spawn_horse, ":item_no"),
          (else_try),
            (spawn_item, ":item_no", 0),
          (try_end),
        (try_end),
      (try_end),
     ]),

  # script_cf_is_melee_weapon_for_tutorial
  # Input: arg1 = item_no
  # Output: none (can fail)
  ("cf_is_melee_weapon_for_tutorial",
    [
      (store_script_param, ":item_no", 1),
      (assign, ":result", 0),
      (try_begin),
        (this_or_next|eq, ":item_no", "itm_quarter_staff"),
        (eq, ":item_no", "itm_practice_sword"),
        (assign, ":result", 1),
      (try_end),
      (eq, ":result", 1),
     ]),

  # script_iterate_pointer_arrow
  # Input: none
  # Output: none
  ("iterate_pointer_arrow",
    [
      (store_mission_timer_a_msec, ":cur_time"),
      (try_begin),
        (assign, ":up_down", ":cur_time"),
        (assign, ":turn_around", ":cur_time"),
        (val_mod, ":up_down", 1080),
        (val_div, ":up_down", 3),
        (scene_prop_get_instance, ":prop_instance", "spr_pointer_arrow", 0),
        (prop_instance_get_position, pos0, ":prop_instance"),
        (position_set_z_to_ground_level, pos0),
        (position_move_z, pos0, "$g_pointer_arrow_height_adder", 1),
        (set_fixed_point_multiplier, 100),
        (val_mul, ":up_down", 100),
        (store_sin, ":up_down_sin", ":up_down"),
        (position_move_z, pos0, ":up_down_sin", 1),
        (position_move_z, pos0, 100, 1),
        (val_mod, ":turn_around", 2880),
        (val_div, ":turn_around", 8),
        (init_position, pos1),
        (position_rotate_z, pos1, ":turn_around"),
        (position_copy_rotation, pos0, pos1),
        (prop_instance_set_position, ":prop_instance", pos0),
      (try_end),
     ]),

   ("find_center_to_attack_alt",
    [
      (store_script_param, ":troop_no", 1),
      (store_script_param, ":attack_by_faction", 2),
      (store_script_param, ":all_vassals_included", 3),

      (assign, ":result", -1),
      (assign, ":score_to_beat", 0),

      (try_for_range, ":center_no", centers_begin, centers_end),
        (call_script, "script_npc_decision_checklist_evaluate_enemy_center_for_attack",	":troop_no", ":center_no", ":attack_by_faction", ":all_vassals_included"),
        (assign, ":score", reg0),

        (gt, ":score", ":score_to_beat"),

        (assign, ":result", ":center_no"),
        (assign, ":score_to_beat", ":score"),
      (try_end),

      (assign, reg0, ":result"),
      (assign, reg1, ":score_to_beat"),
	]),

  ("npc_decision_checklist_evaluate_enemy_center_for_attack",
    [
      #NOTES -- LAST OFFENSIVE TIME SCORE IS NOT USED

      (store_script_param, ":troop_no", 1),
      (store_script_param, ":potential_target", 2),
      (store_script_param, ":attack_by_faction", 3),
      (store_script_param, ":all_vassals_included", 4),

      (assign, ":result", -1),
      (assign, ":explainer_string", -1),
      #(assign, ":reason_is_obvious", 0),
      (assign, ":power_ratio", 0),
      #(assign, ":hours_since_last_recce", -1),

      #(assign, ":value_of_target", 0),
      #(assign, ":difficulty_of_capture", 0),
      (store_faction_of_troop, ":faction_no", ":troop_no"),

      (try_begin),
        (eq, ":attack_by_faction", 1),
        (faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),
        (ge, ":faction_marshal", 0), #STEVE ADDITION TO AVOID MESSAGE SPAM
        (troop_get_slot, ":party_no", ":faction_marshal", slot_troop_leaded_party),
      (else_try),
        (troop_get_slot, ":party_no", ":troop_no", slot_troop_leaded_party),
      (try_end),

      (assign, "$g_use_current_ai_object_as_s8", 0),
	  ##diplomacy start+ Use this if AI changes are enabled.
	  (party_get_slot, ":hours_since_capture", ":potential_target", dplmc_slot_center_last_transfer_time),
	  (try_begin),
	     #If the slot was uninitialized, set it to negative to indicate invalid.
	     (eq, ":hours_since_capture", 0),
		 (assign, ":hours_since_capture", -1),
	  (else_try),
	     (store_current_hours, reg0),
	     (val_sub, ":hours_since_capture", reg0),
	  (try_end),
	  #How recent counts as "recent" depends on the AI settings.
	  (try_begin),
	     (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_HIGH),
		 (assign, ":recency_maximum", 24 * 21),#The last three weeks
	  (else_try),
		 (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_MEDIUM),
		 (assign, ":recency_maximum", 24 * 14),#The last two weeks
	  (else_try),
	     (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		 (assign, ":recency_maximum", 24 * 7),#The last week
	  (else_try),
	     (assign, ":recency_maximum", 0),
	  (try_end),
	  ##diplomacy end+

      #THE FIRST BATCH OF DISQUALIFYING CONDITIONS DO NOT REQUIRE THE ATTACKING PARTY TO HAVE CURRENT INTELLIGENCE ON THE TARGET
      (try_begin),
        (neg|party_is_active, ":party_no"),

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_party_not_active"),
        #(assign, ":reason_is_obvious", 1),
      (else_try),
        (store_faction_of_party, ":potential_target_faction", ":potential_target"),
        (store_relation, ":relation", ":potential_target_faction", ":faction_no"),
        (ge, ":relation", 0),

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_is_friendly"),
        #(assign, ":reason_is_obvious", 1),
      (else_try),
        (is_between, ":potential_target", walled_centers_begin, walled_centers_end),
        (assign, ":faction_of_besieger_party", -1),
        (try_begin),
          (neg|party_slot_eq, ":potential_target", slot_center_is_besieged_by, -1),
          (party_get_slot, ":besieger_party", ":potential_target", slot_center_is_besieged_by),
          (party_is_active, ":besieger_party"),
          (store_faction_of_party, ":faction_of_besieger_party", ":besieger_party"),
        (try_end),

        (neq, ":faction_of_besieger_party", -1),
        (neq, ":faction_of_besieger_party", ":faction_no"),

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_is_already_besieged"),
        #(assign, ":reason_is_obvious", 1),
      (else_try),
        (is_between, ":potential_target", villages_begin, villages_end),
        (assign, ":village_is_looted_or_raided_already", 0),
        (try_begin),
          (party_slot_eq, ":potential_target", slot_village_state, svs_being_raided),
          (party_get_slot, ":raider_party", ":potential_target", slot_village_raided_by),
		  (party_is_active, ":raider_party"),
          (store_faction_of_party, ":raider_faction", ":raider_party"),
          (neq, ":raider_faction", ":faction_no"),
          (assign, ":raiding_by_one_other_faction", 1),
        (else_try),
          (assign, ":raiding_by_one_other_faction", 0),
        (try_end),

        (try_begin),
          (this_or_next|party_slot_eq, ":potential_target", slot_village_state, svs_looted),
          (eq, ":raiding_by_one_other_faction", 1),
          (assign, ":village_is_looted_or_raided_already", 1),
        (try_end),

        (eq, ":village_is_looted_or_raided_already", 1),

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_is_looted_or_raided_already"),
        #(assign, ":reason_is_obvious", 1),
      (else_try),
	    ##diplomacy start+ Add support for companion / lady personality types: does not want to attack innocents
		(call_script, "script_dplmc_get_troop_morality_value", ":troop_no", tmt_humanitarian),
		(this_or_next|gt, reg0, 0),
		(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_benefactor),
		(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_moralist),
		#diplomacy end+
        (this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),

        (is_between, ":potential_target", villages_begin, villages_end),
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_marshal_does_not_want_to_attack_innocents"),
      (else_try),
        (assign, ":distance_from_our_closest_walled_center", 1000),
        (try_for_range, ":cur_center", walled_centers_begin, walled_centers_end),
           (store_faction_of_party, ":cur_center_faction", ":cur_center"),
           (eq, ":cur_center_faction", ":faction_no"),
           (store_distance_to_party_from_party, ":distance_from_cur_center", ":cur_center", ":potential_target"),
           (lt, ":distance_from_cur_center", ":distance_from_our_closest_walled_center"),
           (assign, ":distance_from_our_closest_walled_center", ":distance_from_cur_center"),
        (try_end),

        (gt, ":distance_from_our_closest_walled_center", 75),
		##diplomacy start+ Add support for companion / lady personality types: cautious
		##OLD:
        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),
        #(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),
		##NEW:
		(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		(gt, reg0, 0),
		##Do not apply the check to recently-lost centers if AI changes are on.
		(this_or_next|lt, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		(this_or_next|neg|party_slot_eq,":potential_target", slot_center_ex_faction, ":faction_no"),
		(this_or_next|lt, ":hours_since_capture", 0), #i.e. invalid
		(ge, ":hours_since_capture", ":recency_maximum"),#hasn't been taken recently
		##diplomacy end+

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_far_away_our_cautious_marshal_does_not_wish_to_reconnoiter"),
      #RECONNOITERING BEGINS HERE - VALUE WILL BE TEN OR LESS
      (else_try),
        (gt, ":distance_from_our_closest_walled_center", 90),
		##diplomacy start+ Do not apply the check to recently-lost centers if AI changes are on.
		(this_or_next|lt, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		(this_or_next|neg|party_slot_eq,":potential_target", slot_center_ex_faction, ":faction_no"),
		(this_or_next|lt, ":hours_since_capture", 0), #i.e. invalid
		(ge, ":hours_since_capture", ":recency_maximum"),#hasn't been taken recently
		##diplomacy end+

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_far_away_even_for_our_aggressive_marshal_to_reconnoiter"),
        #(assign, ":reason_is_obvious", 1),
      (else_try),
        (is_between, ":potential_target", walled_centers_begin, walled_centers_end),
		##diplomacy start+ Add support for companion / lady personality types: aggessive
		##OLD:
        #(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_martial),
        #(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_quarrelsome),
        #(neg|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_selfrighteous),
		##NEW:
		(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		(lt, reg0, 0),
		##Do not apply the check to recently-lost centers if AI changes are on.
		(this_or_next|lt, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_LOW),
		(this_or_next|neg|party_slot_eq,":potential_target", slot_center_ex_faction, ":faction_no"),
		(this_or_next|lt, ":hours_since_capture", 0), #i.e. invalid
		(ge, ":hours_since_capture", ":recency_maximum"),#hasn't been taken recently
		##diplomacy end+

        (assign, ":close_center_found", 0),
        (try_for_range, ":friendly_walled_center", walled_centers_begin, walled_centers_end),
          (eq, ":close_center_found", 0),
          (store_faction_of_party, ":friendly_walled_center_faction", ":friendly_walled_center"),
          (eq, ":friendly_walled_center_faction", ":faction_no"),
          (store_distance_to_party_from_party, ":distance_from_walled_center", ":potential_target", ":friendly_walled_center"),
          (lt, ":distance_from_walled_center", 60),
          (assign, ":close_center_found", 1),
        (try_end),
        (eq, ":close_center_found", 0),

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_is_indefensible"),
      #(else_try),
        #For now it is removed as Armagan's decision, we can add this option in later patchs. I and Armagan accept it has good potential. But this system needs also
        #scouting quests and scouting AI added together. If we only add this then we limit AI very much, it can attack only very few of centers, this damages
        #variability of game and surprise attacks of AI. Player can predict where AI will attack and he can full garnisons of only this center.
        #We can add asking travellers about how good defended center X by paying 100 denars for example to equalize situations of AI and human player.
        #But these needs much work and detailed AI tests so Armagan decided to skip this for now.

        #(store_sub, ":faction_recce_slot", ":faction_no", kingdoms_begin),
        #(val_add, ":faction_recce_slot", slot_center_last_reconnoitered_by_faction_time),
        #(party_get_slot, ":last_recce_time", ":potential_target", ":faction_recce_slot"),
        #(store_current_hours, ":hours_since_last_recce"),
        #(val_sub, ":hours_since_last_recce", ":last_recce_time"),

        #(this_or_next|eq, ":last_recce_time", 0),
        #(gt, ":hours_since_last_recce", 96), #Information is presumed to be accurate for four days

        #(store_sub, ":150_minus_distance_div_by_10", 150, ":distance_from_party"),
        #(val_div, ":150_minus_distance_div_by_10", 10),

        #(assign, ":result", ":150_minus_distance_div_by_10"),
        #(assign, ":explainer_string", "str_center_has_not_been_scouted"),
      #DECISIONS BASED ON ENEMY STRENGTH BEGIN HERE
      (else_try),
        (party_get_slot, ":party_strength", ":party_no", slot_party_cached_strength),
        (party_get_slot, ":follower_strength", ":party_no", slot_party_follower_strength),
        (party_get_slot, ":strength_of_nearby_friend", ":party_no", slot_party_nearby_friend_strength),

        (store_add, ":total_strength", ":party_strength", ":follower_strength"),
        (val_add, ":total_strength", ":strength_of_nearby_friend"),

        #(party_get_slot, ":potential_target_nearby_enemy_exact_strength", ":potential_target", slot_party_nearby_friend_strength),
        #(assign, ":potential_target_nearby_enemy_strength", ":potential_target_nearby_enemy_exact_strength"),
        (try_begin),
          (is_between, ":potential_target", villages_begin, villages_end),
          (assign, ":enemy_strength", 10),
        (else_try),
          (party_get_slot, ":enemy_strength", ":potential_target", slot_party_cached_strength),
          (party_get_slot, ":enemy_strength_nearby", ":potential_target", slot_party_nearby_friend_strength),
          (val_add, ":enemy_strength", ":enemy_strength_nearby"),
        (try_end),
        (val_max, ":enemy_strength", 1),
		##diplomacy start+  Add support for lady/companion personalities: aggressive
		##OLD:
        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_martial),
        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_quarrelsome),
        #(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_selfrighteous),
		##NEW:
		(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		(lt, reg0, 0),
		###xxx yyy zzz TODO: The logic here seems backwards!
		###Later look at this and verify that it's what we want.
		##diplomacy end+

        (store_mul, ":power_ratio", ":total_strength", 100),
        (val_div, ":power_ratio", ":enemy_strength"),
        (lt, ":power_ratio", 150),

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_protected_by_enemy_army_aggressive"),
      (else_try),
        (ge, ":enemy_strength", ":total_strength"), #if enemy is powerful

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_protected_by_enemy_army_cautious"),
      (else_try),
        (store_mul, ":power_ratio", ":total_strength", 100),
        (val_div, ":power_ratio", ":enemy_strength"),
        (lt, ":power_ratio", 185),
		##diplomacy start+ Add support for companion/lady personalities: cautious
		##OLD:
        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),
        #(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),
		##NEW:
		(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
		(gt, reg0, 0),
		##diplomacy end+

        #equations here
        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_cautious_marshal_believes_center_too_difficult_to_capture"),
      (else_try),
        (lt, ":power_ratio", 140), #it was 140

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_even_aggressive_marshal_believes_center_too_difficult_to_capture"),
      #To Steve - I moved below two if statement here from upper places, to enable in answering different different answers even
      #if we are close to an unlooted enemy village. For example now it can say "center X" is too far too while our army is
      #looting a village because of its closeness.
      (else_try),
        #if the party has already started the siege
        (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_raiding_village),
        (faction_get_slot, ":current_object", ":faction_no", slot_faction_ai_object),
        (is_between, ":current_object", villages_begin, villages_end),
        (neq, ":potential_target", ":current_object"),
        (party_slot_eq, ":current_object", slot_village_state, svs_under_siege),

        (store_current_hours, ":hours_since_siege_began"),
        (party_get_slot, ":hour_that_siege_began", ":current_object", slot_center_siege_begin_hours),
        (val_sub, ":hours_since_siege_began", ":hour_that_siege_began"),
        (gt, ":hours_since_siege_began", 4),

        (call_script, "script_npc_decision_checklist_evaluate_enemy_center_for_attack", ":troop_no", ":current_object", ":attack_by_faction", 0),
        (gt, reg0, -1),

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_we_have_already_committed_too_much_time_to_our_present_siege_to_move_elsewhere"),
      (else_try),
        #If the party is close to an unlooted village
        (faction_slot_eq, ":faction_no", slot_faction_ai_state, sfai_raiding_village),
        (faction_get_slot, ":current_object", ":faction_no", slot_faction_ai_object),
        (neq, ":potential_target", ":current_object"),
        (is_between, ":current_object", villages_begin, villages_end),
        (store_distance_to_party_from_party, ":distance_to_cur_object", ":party_no", ":current_object"),
        (lt, ":distance_to_cur_object", 10),

        (call_script, "script_npc_decision_checklist_evaluate_enemy_center_for_attack", ":troop_no", ":current_object", ":attack_by_faction", 0),
        (gt, reg0, -1),

        (assign, "$g_use_current_ai_object_as_s8", 1),

        (assign, ":result", -1),
        (assign, ":explainer_string", "str_center_we_are_already_here_we_should_at_least_loot_the_village"),
      #DECISION TO ATTACK IS HERE
      #(else_try),
        #To Steve - I removed below lines, as here decided. We will use pre-function to evaluate assailability scores for centers rather than below lines to make AI
        #selecting better targets. If you want to make some marshals to select not-best options I can add that option into script_calculate_center_assailability_score,
        #for that we can need seed values for each center and for each lord, so we can add these seed values to create variability, clever marshals have seeds with less
        #standard deviation and less values and less-clever marshals have bigger seeds. Then probability of some lords to disagree marshal increases because their seed
        #values will be different from marshal's. If Steve wants it from me to implement I can add this.

        #(try_begin),
        #  (is_between, ":potential_target", villages_begin, villages_end),
        #  (party_get_slot, ":score", ":potential_target", slot_town_prosperity),
        #  (val_add, ":score", 50), #average 100
        #(else_try),
        #  (is_between, ":potential_target", castles_begin, castles_end),
        #  (assign, ":score", ":power_ratio"), #ie, at least 140
        #(else_try),
        #  (party_get_slot, ":score", ":potential_target", slot_town_prosperity),
        #  (val_add, ":score", 75),
        #  (val_mul, ":score", ":power_ratio"),
        #  (val_div, ":score", 100), #ie, at least about 200
        #(try_end),
        #
        #(val_sub, ":score", ":distance_from_party"),
        #(lt, ":score", -1),

        #(assign, ":result", -1),
        #(assign, ":explainer_string", "str_center_value_outweighed_by_difficulty_of_capture"),
      (else_try),
        (try_begin),
          (eq, "$cheat_mode", 1),
          (eq, ":faction_no", "fac_kingdom_3"),
          (store_faction_of_party, ":potential_target_faction", ":potential_target"),
          (store_relation, ":relation", ":potential_target_faction", ":faction_no"),
          (lt, ":relation", 0),
        (try_end),

        (call_script, "script_calculate_center_assailability_score", ":troop_no", ":potential_target", ":all_vassals_included"),
        (assign, ":score", reg0),
        (assign, ":power_ratio", reg1),
        #(assign, ":distance_score", reg2),

        (assign, ":result", ":score"),

        (try_begin),
          (le, ":power_ratio", 100),
          (try_begin),
			##diplomacy start+ Add support for companion / lady personalities: cautious
			##OLD:
            #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
            #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
            #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),
            #(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),
			##NEW:
			(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
			(gt, reg0, 0),
			##diplomacy end+
            (assign, ":explainer_string", "str_center_cautious_marshal_believes_center_too_difficult_to_capture"),
          (else_try),
            (assign, ":explainer_string", "str_center_even_aggressive_marshal_believes_center_too_difficult_to_capture"),
          (try_end),
        (else_try),
          (le, ":power_ratio", 150),

          (try_begin),
			##diplomacy start+ Add support for companion / lady personalities: cautious
			##OLD
	        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
	        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
	        #(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),
	        #(troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),
			##NEW:
			(call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
			(lt, reg0, 0),
			##diplomacy end+
	        (assign, ":explainer_string", "str_center_protected_by_enemy_army_cautious"),
	      (else_try),
	        (assign, ":explainer_string", "str_center_protected_by_enemy_army_aggressive"),
	      (try_end),
	    (else_try),
	      (try_begin),
	        (le, ":score", "$g_faction_object_score"),
	        (assign, ":explainer_string", "str_center_value_outweighed_by_difficulty_of_capture"),
	      (else_try),
	        #To Steve, does not this sentence needs to explain why we are not attacking that city?
	        #This sentence says it justifies, so why we are not attacking?
	        (assign, ":explainer_string", "str_center_value_justifies_the_difficulty_of_capture"),
	      (try_end),
	    (try_end),
	  (try_end),

	  (assign, reg0, ":result"),
	  (assign, reg1, ":explainer_string"),
	  (assign, reg2, ":power_ratio"),
     ]),

 	(
	"npc_decision_checklist_faction_ai_alt", #This is called from within decide_faction_ai, or from
	[
		(store_script_param, ":troop_no", 1),

		(store_faction_of_troop, ":faction_no", ":troop_no"),

		(str_store_troop_name, s4, ":troop_no"),
		(str_store_faction_name, s33, ":faction_no"),
		(try_begin),
			(eq, "$cheat_mode", 1),
		    (display_message, "@{!}DEBUG -- {s4} produces a faction strategy for {s33}"),
		(try_end),

		#INFORMATIONS COLLECTING STEP 0: Here we obtain general information about current faction like how much parties that faction has, which lord is the marshall, current ai state and current ai target object
		#(faction_get_slot, ":faction_strength", ":faction_no", slot_faction_number_of_parties),
		(faction_get_slot, ":faction_marshal", ":faction_no", slot_faction_marshall),
		(faction_get_slot, ":current_ai_state", ":faction_no", slot_faction_ai_state),
		(faction_get_slot, ":current_ai_object", ":faction_no", slot_faction_ai_object),

		(assign, ":marshal_party", -1),
		(assign, ":marshal_party_strength", 0),

		(try_begin),
		  (gt, ":faction_marshal", 0),
		  (troop_get_slot, ":marshal_party", ":faction_marshal", slot_troop_leaded_party),
		  (party_is_active, ":marshal_party"),
		  (party_get_slot, ":marshal_party_itself_strength", ":marshal_party", slot_party_cached_strength),
		  (party_get_slot, ":marshal_party_follower_strength", ":marshal_party", slot_party_follower_strength),
		  (store_add, ":marshal_party_strength", ":marshal_party_itself_strength", ":marshal_party_follower_strength"),
	    (try_end),

	    #INFORMATIONS COLLECTING STEP 1: Here we are learning how much hours past from last offensive situation/feast concluded/current state started
	    (store_current_hours, ":hours_since_last_offensive"),
	    (faction_get_slot, ":last_offensive_time", ":faction_no", slot_faction_last_offensive_concluded),
	    (val_sub, ":hours_since_last_offensive", ":last_offensive_time"),

	    (store_current_hours, ":hours_since_last_feast_start"),
	    (faction_get_slot, ":last_feast_time", ":faction_no", slot_faction_last_feast_start_time),
	    (val_sub, ":hours_since_last_feast_start", ":last_feast_time"),

	    (store_current_hours, ":hours_at_current_state"),
	    (faction_get_slot, ":current_state_started", ":faction_no", slot_faction_ai_current_state_started),
	    (val_sub, ":hours_at_current_state", ":current_state_started"),

	    (store_current_hours, ":hours_since_last_faction_rest"),
	    (faction_get_slot, ":last_rest_time", ":faction_no", slot_faction_ai_last_rest_time),
	    (val_sub, ":hours_since_last_faction_rest", ":last_rest_time"),

	    (try_begin), #calculating ":last_offensive_time_score", this will be used in #11 and #12
	        (ge, ":hours_since_last_offensive", 1080), #more than 45 days (100p)
	        (assign, ":last_offensive_time_score", 100),
	    (else_try),
	        (ge, ":hours_since_last_offensive", 480), #more than 20 days (65p..99p)
	        (store_sub, ":last_offensive_time_score", ":hours_since_last_offensive", 480),
	        (val_div, ":last_offensive_time_score", 20),
	        (val_add, ":last_offensive_time_score", 64),
	    (else_try),
	        (ge, ":hours_since_last_offensive", 240), #more than 10 days (41p..64p)
	        (store_sub, ":last_offensive_time_score", ":hours_since_last_offensive", 240),
	        (val_div, ":last_offensive_time_score", 10),
	        (val_add, ":last_offensive_time_score", 40),
	    (else_try), #less than 10 days (0p..40p)
	        (store_div, ":last_offensive_time_score", ":hours_since_last_offensive", 6), #0..40
	    (try_end),

	    #INFORMATION COLLECTING STEP 3: Here we are finding the most threatened center
	    (call_script, "script_find_center_to_defend", ":troop_no"),
	    (assign, ":most_threatened_center", reg0),
	    (assign, ":threat_danger_level", reg1),
	    (assign, ":enemy_strength_near_most_threatened_center", reg2), #NOTE! This will be off by as much as 50%

	    #INFORMATION COLLECTING STEP 4: Here we are finding number of vassals who are already following the marshal, and the assigned vassal ratio of current faction.
	    (assign, ":vassals_already_assembled", 0),
	    (assign, ":total_vassals", 0),
		##diplomacy start+ add support for promoted kingdom ladies
	    #(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
		(try_for_range, ":lord", heroes_begin, heroes_end),
			(this_or_next|is_between, ":lord", active_npcs_begin, active_npcs_end),
				(troop_slot_eq, ":lord", slot_troop_occupation, slto_kingdom_hero),
		##diplomacy end+
	        (store_faction_of_troop, ":lord_faction", ":lord"),
	        (eq, ":lord_faction", ":faction_no"),
	        (troop_get_slot, ":led_party", ":lord", slot_troop_leaded_party),
	        (party_is_active, ":led_party"),
	        (val_add, ":total_vassals", 1),

	        (party_slot_eq, ":led_party", slot_party_ai_state, spai_accompanying_army),
	        (party_slot_eq, ":led_party", slot_party_ai_object, ":marshal_party"),

	        (party_is_active, ":marshal_party"),
	        (store_distance_to_party_from_party, ":distance_to_marshal", ":led_party", ":marshal_party"),
	        (lt, ":distance_to_marshal", 15),
	        (val_add, ":vassals_already_assembled", 1),
	    (try_end),
	    (assign, ":ratio_of_vassals_assembled", -1),
	    (try_begin),
	        (gt, ":total_vassals", 0),
	        (store_mul, ":ratio_of_vassals_assembled", ":vassals_already_assembled", 100),
	        (val_div, ":ratio_of_vassals_assembled", ":total_vassals"),
	    (try_end),

	    #50% of vassals means that the campaign hour limit is ten days
	    (store_mul, ":campaign_hour_limit", ":ratio_of_vassals_assembled", 3),
	    (val_add, ":campaign_hour_limit", 90),

	    #To Steve - I understand your concern about some marshals will gather army and some will not be able to find any valueable center to attack after gathering,
	    #and these marshals will be questioned by other marshals ext. This is ok but if we search for a target without adding all other vassals what if
	    #AI cannot find any target for long time because of its low power ratio if enemy cities are equal defended? Do not forget if we do not count other vassals in
	    #faction while making target search we can only add marshal army's power and vassals around him. And if there is any threat in our centers even it is smaller,
	    #its threat_danger_level will be more than target_value_level if marshal new started gathering for ofensive. Because we only assume marshal and around vassals
	    #will join attack. And in our scenarios currently there are less vassals are around him. So power ratio will be low and any small threat will be enought to stop
	    #an offensive. Then when players finds out this they periodically will take under siege to enemy's any center and they will be saved from any kind of newly started
	    #offensive they will be faced. So we have to calculate both attack levels and select highest one to compare with threat level. Please do not change this part.

		(try_begin),
		  (ge, ":faction_marshal", 0),
		  (ge, ":marshal_party", 0),
		  (party_is_active, ":marshal_party"),

		  (call_script, "script_party_count_fit_for_battle", ":marshal_party"),
		  (assign, ":number_of_fit_soldiers_in_marshal_party", reg0),
		  (ge, ":number_of_fit_soldiers_in_marshal_party", 40),

		  (call_script, "script_find_center_to_attack_alt", ":troop_no", 1, 0),
		  (assign, ":center_to_attack_all_vassals_included", reg0),
		  (assign, ":target_value_level_all_vassals_included", reg1),

		  (call_script, "script_find_center_to_attack_alt", ":troop_no", 1, 1),
		  (assign, ":center_to_attack_only_marshal_and_followers", reg0),
		  (assign, ":target_value_level_only_marshal_and_followers", reg1),
		(else_try),
		  (assign, ":target_value_level_all_vassals_included", 0),
		  (assign, ":target_value_level_only_marshal_and_followers", 0),
		  (assign, ":center_to_attack_all_vassals_included", -1),
		  (assign, ":center_to_attack_only_marshal_and_followers", -1),
		(try_end),

		(try_begin),
		  (ge, ":target_value_level_all_vassals_included", ":center_to_attack_only_marshal_and_followers"),
		  (assign, ":center_to_attack", ":center_to_attack_all_vassals_included"),
		  (assign, ":target_value_level", ":target_value_level_all_vassals_included"),
		(else_try),
		  (assign, ":center_to_attack", ":center_to_attack_only_marshal_and_followers"),
		  (assign, ":target_value_level", ":target_value_level_only_marshal_and_followers"),
		(try_end),

		(try_begin),
		  (eq, ":current_ai_state", sfai_attacking_center),
		  (val_mul, ":target_value_level", 3),
		  (val_div, ":target_value_level", 2),
		(try_end),

		(try_begin),
		  (eq, "$cheat_mode", 1),
		  (try_begin),
		    (is_between, ":center_to_attack", centers_begin, centers_end),
		    (str_store_party_name, s4, ":center_to_attack"),
		    (display_message, "@{!}Best offensive target {s4} has value level of {reg1}"),
		  (else_try),
		    (display_message, "@{!}No center found to attack"),
		  (try_end),

		  (try_begin),
		    (is_between, ":most_threatened_center", centers_begin, centers_end),
		    (str_store_party_name, s4, ":most_threatened_center"),
		    (assign, reg1, ":threat_danger_level"),
		    (display_message, "@{!}Best threat of {s4} has value level of {reg1}"),
		  (else_try),
		    (display_message, "@{!}No center found to defend"),
		  (try_end),
		(try_end),

		(try_begin),
		  (eq, "$cheat_mode", 1),

		  (try_begin),
  		    (is_between, ":most_threatened_center", centers_begin, centers_end),
 		    (str_store_party_name, s4, ":most_threatened_center"),
		    (assign, reg1, ":threat_danger_level"),
		    (display_message, "@Best threat of {s4} has value level of {reg1}"),
		  (else_try),
		    (display_message, "@No center found to defend"),
		  (try_end),
		(try_end),

	    (assign, "$g_target_after_gathering", -1),

	    (store_current_hours, ":hours"),
	    (try_begin),
	      (ge, ":target_value_level", ":threat_danger_level"),
	      (faction_set_slot, ":faction_no", slot_faction_last_safe_hours, ":hours"),
	    (try_end),
	    (faction_get_slot, ":last_safe_hours", ":faction_no", slot_faction_last_safe_hours),
	    (try_begin),
	      (eq, ":last_safe_hours", 0),
	      (faction_set_slot, ":faction_no", slot_faction_last_safe_hours, ":hours"),
	    (try_end),
	    (faction_get_slot, ":last_safe_hours", ":faction_no", slot_faction_last_safe_hours),
	    (store_sub, ":hours_since_days_defensive_started", ":hours", ":last_safe_hours"),
	    (str_store_faction_name, s7, ":faction_no"),

		(assign, ":at_peace_with_everyone", 1),
		(try_for_range, ":faction_at_war", kingdoms_begin, kingdoms_end),
			(store_relation, ":relation", ":faction_no", ":faction_at_war"),
			(lt, ":relation", 0),
			(assign, ":at_peace_with_everyone", 0),
		(try_end),


	    #INFORMATIONS ARE COLLECTED, NOW CHECK ALL POSSIBLE ACTIONS AND DECIDE WHAT TO DO	NEXT
		#Player marshal
		(try_begin), # a special case to end long-running feasts
			(eq, ":troop_no", "trp_player"),

			(eq, ":current_ai_state", sfai_feast),
			(ge, ":hours_at_current_state", 72),

			(assign, ":action", sfai_default),
			(assign, ":object", -1),

			#Normally you are not supposed to set permanent values in this state, but this is a special case to end player-called feasts
			(assign, "$player_marshal_ai_state", sfai_default),
			(assign, "$player_marshal_ai_object", -1),
		(else_try), #another special state, to make player-called feasts last for a while when the player is the leader of the faction, but not the marshal
			(eq, "$players_kingdom", "fac_player_supporters_faction"),
			(faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
			(neq, ":troop_no", "trp_player"),

			(eq, ":current_ai_state", sfai_feast),
			(le, ":hours_at_current_state", 48),

			(party_slot_eq, ":current_ai_object", slot_town_lord, "trp_player"),
			(store_faction_of_party, ":current_ai_object_faction", ":current_ai_object"),
			(eq, ":current_ai_object_faction", "$players_kingdom"),

			(assign, ":action", sfai_feast),
			(assign, ":object", ":current_ai_object"),


		(else_try), #this is the main player marshal state
			(eq, ":troop_no", "trp_player"),

			(str_clear, s14),
			(assign, ":action", "$player_marshal_ai_state"),
			(assign, ":object", "$player_marshal_ai_object"),

	    #1-RESTING IF NEEDED
	    #If not currently attacking a besieging a center and vassals did not rest for long time, let them rest.
	    #If we do not take this part to toppest level, tired vassals already did not accept any order, so that
	    #faction cannot do anything already. So first let vassals rest if they need. Thats why it should be toppest.
		(else_try),
			(neq, ":current_ai_state", sfai_default),
			(neq, ":current_ai_state", sfai_feast),
			(party_is_active, ":marshal_party"),

			(party_slot_eq, ":marshal_party", slot_party_ai_state, spai_retreating_to_center),

			(assign, ":action", sfai_default),
			(assign, ":object", -1),
			(str_store_string, s14, "str_the_enemy_temporarily_has_the_field"),

		(else_try),
		    (neq, ":current_ai_state", sfai_feast),

		    (assign, ":currently_besieging", 0),
		    (try_begin),
			    (eq, ":current_ai_state", sfai_attacking_center),
			    (is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
			    (party_get_slot, ":besieger_party", ":current_ai_object", slot_center_is_besieged_by),
			    (party_is_active, ":besieger_party"),
			    (store_faction_of_party, ":besieger_faction", ":besieger_party"),
			    (eq, ":besieger_faction", ":faction_no"),
			    (assign, ":currently_besieging", 1),
		    (try_end),

		    (assign, ":currently_defending_center", 0),
	        (try_begin),
		        (eq, ":current_ai_state", sfai_attacking_enemies_around_center),
		        (gt, ":marshal_party", 0),
		        (party_is_active, ":marshal_party"),

				(assign, ":besieged_center", -1),
				(try_begin),
					(party_slot_eq, ":marshal_party", slot_party_ai_state, spai_holding_center), #if commander is holding a center
					(party_get_slot, ":marshal_object", ":marshal_party", slot_party_ai_object), #get commander's ai object (center they are holding)
					(party_get_battle_opponent, ":besieger_enemy", ":marshal_object"), #get this object's battle opponent
					(ge, ":besieger_enemy", 0),
					(assign, ":besieged_center", ":marshal_object"),
				(else_try),
					(party_slot_eq, ":marshal_party", slot_party_ai_state, spai_engaging_army), #if commander is engaging an army
					(party_get_slot, ":marshal_object", ":marshal_party", slot_party_ai_object), #get commander's ai object (army which they engaded)
					(ge, ":marshal_object", 0), #if commander has an object
					(neg|is_between, ":marshal_object", centers_begin, centers_end), #if this object is not a center, so it is a party
					(party_is_active, ":marshal_object"),
					(party_get_battle_opponent, ":besieged_center", ":marshal_object"), #get this object's battle opponent
				(try_end),

				(eq, ":besieged_center", ":current_ai_object"),
				(assign, ":currently_defending_center", 1),
	        (try_end),

		    (eq, ":currently_besieging", 0),
		    (eq, ":currently_defending_center", 0),
		    (ge, ":hours_since_last_faction_rest", 1240),

			(assign, ":action", sfai_default),
			(assign, ":object", -1),
			(str_store_string, s14, "str_the_vassals_are_tired_we_let_them_rest_for_some_time"),

	  #2-DEFENSIVE ACTIONS : GATHERING ARMY FOR DEFENDING
          (else_try),
            (party_is_active, ":marshal_party"),
			(eq, ":at_peace_with_everyone", 0),

            (is_between, ":most_threatened_center", centers_begin, centers_end),
            (this_or_next|eq, ":current_ai_state", sfai_default),    #MOTO not going to attack anyway
            (this_or_next|eq, ":current_ai_state", sfai_feast),    #MOTO not going to attack anyway (THIS is the emergency to stop feast)
            (gt, ":threat_danger_level", ":target_value_level"),

            (assign, ":continue_gathering", 0),
            (assign, ":start_gathering", 0),

            (try_begin),
              (is_between, ":most_threatened_center", villages_begin, villages_end),

              (assign, ":continue_gathering", 0),
            (else_try),
              (try_begin),
                (lt, ":hours_since_days_defensive_started", 3),
                (assign, ":multiplier", 150),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 6),
                (assign, ":multiplier", 140),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 9),
                (assign, ":multiplier", 132),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 12),
                (assign, ":multiplier", 124),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 15),
                (assign, ":multiplier", 118),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 18),
                (assign, ":multiplier", 114),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 21),
                (assign, ":multiplier", 110),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 24),
                (assign, ":multiplier", 106),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 27),
                (assign, ":multiplier", 102),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 31),
                (assign, ":multiplier", 98),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 34),
                (assign, ":multiplier", 94),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 37),
                (assign, ":multiplier", 90),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 40),
                (assign, ":multiplier", 86),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 43),
                (assign, ":multiplier", 82),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 46),
                (assign, ":multiplier", 79),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 49),
                (assign, ":multiplier", 76),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 52),
                (assign, ":multiplier", 73),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 56),
                (assign, ":multiplier", 70),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 60),
                (assign, ":multiplier", 68),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 66),
                (assign, ":multiplier", 66),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 72),
                (assign, ":multiplier", 64),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 80),
                (assign, ":multiplier", 62),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 90),
                (assign, ":multiplier", 60),
              (else_try),
                (lt, ":hours_since_days_defensive_started", 100),
                (assign, ":multiplier", 58),
              (else_try),
                (assign, ":multiplier", 56),
              (try_end),

              (store_mul, ":enemy_strength_multiplied", ":enemy_strength_near_most_threatened_center", ":multiplier"),
              (val_div, ":enemy_strength_multiplied", 100),

              (try_begin),
                (lt, ":marshal_party_strength", ":enemy_strength_multiplied"),
                (assign, ":continue_gathering", 1),
              (try_end),
            (else_try),
              (eq, ":current_ai_state", sfai_attacking_enemies_around_center),
              (neq, ":most_threatened_center", ":current_ai_object"),

              (assign, ":marshal_is_already_defending_a_center", 0),
              (try_begin),
                (gt, ":marshal_party", 0),
                (party_is_active, ":marshal_party"),

                (assign, ":besieged_center", -1),
                (try_begin),
                  (party_slot_eq, ":marshal_party", slot_party_ai_state, spai_holding_center), #if commander is holding a center
                  (party_get_slot, ":marshal_object", ":marshal_party", slot_party_ai_object), #get commander's ai object (center they are holding)
                  (party_get_battle_opponent, ":besieger_enemy", ":marshal_object"), #get this object's battle opponent
                  (ge, ":besieger_enemy", 0),
                  (assign, ":besieged_center", ":marshal_object"),
                (else_try),
                  (party_slot_eq, ":marshal_party", slot_party_ai_state, spai_engaging_army), #if commander is engaging an army
                  (party_get_slot, ":marshal_object", ":marshal_party", slot_party_ai_object), #get commander's ai object (army which they engaded)
                  (ge, ":marshal_object", 0), #if commander has an object
                  (neg|is_between, ":marshal_object", centers_begin, centers_end), #if this object is not a center, so it is a party
				  (party_is_active, ":marshal_object"),
                  (party_get_battle_opponent, ":besieged_center", ":marshal_object"), #get this object's battle opponent
                (try_end),

                (eq, ":besieged_center", ":current_ai_object"),

                (assign, ":marshal_is_already_defending_a_center", 1),
              (try_end),

              (eq, ":marshal_is_already_defending_a_center", 0),

              (store_mul, ":enemy_strength_multiplied", ":enemy_strength_near_most_threatened_center", 80),
              (val_div, ":enemy_strength_multiplied", 100),
              (lt, ":marshal_party_strength", ":enemy_strength_multiplied"),

              (this_or_next|is_between, ":most_threatened_center", walled_centers_begin, walled_centers_end),
              (neq, ":faction_no", "$players_kingdom"),

              (assign, ":start_gathering", 1),
            (try_end),

            (this_or_next|eq, ":continue_gathering", 1),
            (eq, ":start_gathering", 1),

            (assign, ":action", sfai_gathering_army),
            (assign, ":object", -1),
            (str_store_party_name, s21, ":most_threatened_center"),
            (str_store_string, s14, "str_we_should_prepare_to_defend_s21_but_we_should_gather_our_forces_until_we_are_strong_enough_to_engage_them"),

            (try_begin),
              (eq, ":faction_no", "$players_kingdom"),
              (assign, "$g_gathering_reason", ":most_threatened_center"),
            (try_end),

	    #3-DEFENSIVE ACTIONS : RIDE TO BREAK ENEMY SIEGE / DEFEAT ENEMIES NEAR OUR CENTER
		(else_try),
			(party_is_active, ":marshal_party"),
			(is_between, ":most_threatened_center", walled_centers_begin, walled_centers_end),
                        (this_or_next|eq, ":current_ai_state", sfai_default),    #MOTO not going to attack anyway
                        (this_or_next|eq, ":current_ai_state", sfai_feast),    #MOTO not going to attack anyway (THIS is the emergency to stop feast)
			(ge, ":threat_danger_level", ":target_value_level"),
			(party_slot_ge, ":most_threatened_center", slot_center_is_besieged_by, 0),

			(assign, ":action", sfai_attacking_enemies_around_center),
			(assign, ":object", ":most_threatened_center"),

			(str_store_party_name, s21, ":most_threatened_center"),
			(str_store_string, s14, "str_we_should_ride_to_break_the_siege_of_s21"),

		#3b - DEFEAT ENEMIES NEAR CENTER - similar to above, but a different string
		(else_try),
			(party_is_active, ":marshal_party"),
                        (this_or_next|eq, ":current_ai_state", sfai_default),    #MOTO not going to attack anyway
                        (this_or_next|eq, ":current_ai_state", sfai_feast),    #MOTO not going to attack anyway (THIS is the emergency to stop feast)
			(ge, ":threat_danger_level", ":target_value_level"),
			(is_between, ":most_threatened_center", villages_begin, villages_end),

			(assign, ":action", sfai_attacking_enemies_around_center),
			(assign, ":object", ":most_threatened_center"),
			(str_store_party_name, s21, ":most_threatened_center"),
			(str_store_string, s14, "str_we_should_ride_to_defeat_the_enemy_gathered_near_s21"),

		#4-DEMOBILIZATION
		#Let vassals attend their own business
		(else_try),
			(this_or_next|eq, ":current_ai_state", sfai_gathering_army),
			(this_or_next|eq, ":current_ai_state", sfai_attacking_center),
			(eq, ":current_ai_state", sfai_raiding_village),

			(ge, ":hours_since_last_faction_rest", ":campaign_hour_limit"), #Effected by ratio of vassals
			(ge, ":hours_at_current_state", 24),

			#Ozan : I am adding some codes here because sometimes armies demobilize during last seconds of an important event like taking a castle, ext.
			(assign, ":there_is_an_important_situation", 0),
			(try_begin), #do not demobilize during taking a castle/town (fighting in the castle)
				(is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
				(party_get_battle_opponent, ":besieger_party", ":current_ai_object"),
				(party_is_active, ":besieger_party"),
				(store_faction_of_party, ":besieger_faction", ":besieger_party"),
				(this_or_next|eq, ":besieger_faction", ":faction_no"),
				(eq, ":besieger_faction", "fac_player_faction"),
				(assign, ":there_is_an_important_situation", 1),
			(else_try), #do not demobilize during besieging a siege (holding around castle)
				(is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
				(party_get_slot, ":besieger_party", ":current_ai_object", slot_center_is_besieged_by),
				(party_is_active, ":besieger_party"),
				(store_faction_of_party, ":besieger_faction", ":besieger_party"),
				(this_or_next|eq, ":besieger_faction", ":faction_no"),
				(eq, ":besieger_faction", "fac_player_faction"),
				(assign, ":there_is_an_important_situation", 1),
			(else_try), #do not demobilize during raiding a village (holding around village)
				(is_between, ":current_ai_object", centers_begin, centers_end),
				(neg|is_between, ":current_ai_object", walled_centers_begin, walled_centers_end),
				(party_slot_eq, ":current_ai_object", slot_village_state, svs_being_raided),
				(assign, ":there_is_an_important_situation", 1),
			(try_end),

			(eq, ":there_is_an_important_situation", 0),
			#end addition ozan

			(assign, reg7, ":hours_since_last_faction_rest"),
			(assign, reg8, ":campaign_hour_limit"),

			(str_store_string, s14, "str_this_offensive_needs_to_wind_down_soon_so_the_vassals_can_attend_to_their_own_business"),
			(assign, ":action", sfai_default),
			(assign, ":object", -1),

		#6-GATHERING BECAUSE OF NO REASON
		#Start to gather the army
		(else_try),
			(party_is_active, ":marshal_party"),
			(eq, ":at_peace_with_everyone", 0),


			(eq, ":current_ai_state", sfai_default),
			(ge, ":hours_since_last_offensive", 60),
			(lt, ":hours_since_last_faction_rest", 120),

			#There should not be a center as a precondition for attack
			#Otherwise, we are unlikely to have a situation in which the army gathers, but does nothing -- which is important to have for role-playing purposes

			(assign, ":action", sfai_gathering_army),
			(assign, ":object", -1),
			(str_store_string, s14, "str_it_is_time_to_go_on_the_offensive_and_we_must_first_assemble_the_army"),

            (try_begin),
              (eq, ":faction_no", "$players_kingdom"),
              (assign, "$g_gathering_reason", -1),
            (try_end),

		#7-OFFENSIVE ACTIONS : CONTINUE GATHERING
		(else_try),
			(party_is_active, ":marshal_party"),
			(eq, ":current_ai_state", sfai_gathering_army),
			(eq, ":at_peace_with_everyone", 0),

			(lt, ":hours_at_current_state", 54), #gather army for 54 hours

			(lt, ":ratio_of_vassals_assembled", 12),

			(str_store_string, s14, "str_we_must_continue_to_gather_the_army_before_we_ride_forth_on_an_offensive_operation"),
			(assign, ":action", sfai_gathering_army),
			(assign, ":object", -1),

		#7-OFFENSIVE ACTIONS PART 2 : CONTINUE GATHERING
		(else_try),
		    (assign, ":minimum_possible_attackable_target_value_level", 50),
			(eq, ":at_peace_with_everyone", 0),

            (try_begin), #agressive marshal
			  ##diplomacy start+
			  ##OLD:
			  #(troop_get_slot, ":reputation", ":troop_no", slot_lord_reputation_type),
			  #(this_or_next|eq, ":reputation", lrep_martial),
			  #(this_or_next|eq, ":reputation", lrep_quarrelsome),
			  #(eq, ":reputation", lrep_selfrighteous),
			  ##NEW:
			  (call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
			  (lt, reg0, 0),
			  ##diplomacy end+
			  (val_mul, ":minimum_possible_attackable_target_value_level", 9),
			  (val_div, ":minimum_possible_attackable_target_value_level", 10),
            (try_end),

			(party_is_active, ":marshal_party"),
			(eq, ":current_ai_state", sfai_gathering_army),

			(try_begin),
				(lt, ":hours_at_current_state", 6),
				(assign, ":minimum_needed_target_value_level", 1500),
			(else_try),
				(lt, ":hours_at_current_state", 10),
				(assign, ":minimum_needed_target_value_level", 1000),
			(else_try),
		        (lt, ":hours_at_current_state", 14),
		        (assign, ":minimum_needed_target_value_level", 720),
			(else_try),
				(lt, ":hours_at_current_state", 18),
				(assign, ":minimum_needed_target_value_level", 480),
			(else_try),
				(lt, ":hours_at_current_state", 22),
				(assign, ":minimum_needed_target_value_level", 360),
			(else_try),
				(lt, ":hours_at_current_state", 26),
				(assign, ":minimum_needed_target_value_level", 240),
			(else_try),
				(lt, ":hours_at_current_state", 30),
				(assign, ":minimum_needed_target_value_level", 180),
			(else_try),
				(lt, ":hours_at_current_state", 34),
				(assign, ":minimum_needed_target_value_level", 120),
			(else_try),
				(lt, ":hours_at_current_state", 38),
				(assign, ":minimum_needed_target_value_level", 100),
			(else_try),
				(lt, ":hours_at_current_state", 42),
				(assign, ":minimum_needed_target_value_level", 80),
			(else_try),
				(lt, ":hours_at_current_state", 46),
				(assign, ":minimum_needed_target_value_level", 65),
			(else_try),
				(lt, ":hours_at_current_state", 50),
				(assign, ":minimum_needed_target_value_level", 55),
			(else_try),
				(assign, ":minimum_needed_target_value_level", ":minimum_possible_attackable_target_value_level"),
			(try_end),

            (try_begin), #agressive marshal
			  ##diplomacy start+
			  ##OLD:
			  #(troop_get_slot, ":reputation", ":troop_no", slot_lord_reputation_type),
			  #(this_or_next|eq, ":reputation", lrep_martial),
			  #(this_or_next|eq, ":reputation", lrep_quarrelsome),
			  #(eq, ":reputation", lrep_selfrighteous),
			  ##NEW:
			  (call_script, "script_dplmc_store_troop_personality_caution_level", ":troop_no"),
			  (lt, reg0, 0),
			  ##diplomacy end+
			  (val_mul, ":minimum_needed_target_value_level", 9),
			  (val_div, ":minimum_needed_target_value_level", 10),
            (try_end),

			(le, ":target_value_level", ":minimum_needed_target_value_level"),
			(le, ":hours_at_current_state", 54),

			(str_store_string, s14, "str_we_have_assembled_some_vassals"),
			(assign, ":action", sfai_gathering_army),
			(assign, ":object", -1),

		#8-ATTACK AN ENEMY CENTER case 1, reconnaissance against walled center
		#(else_try),
			#(party_is_active, ":marshal_party"),
			#(neq, ":current_ai_state", sfai_default),
			#(neq, ":current_ai_state", sfai_feast),
			#(is_between, ":center_to_attack", walled_centers_begin, walled_centers_end),

			#(store_sub, ":faction_recce_slot", ":faction_no", kingdoms_begin),
			#(val_add, ":faction_recce_slot", slot_center_last_reconnoitered_by_faction_time),
			#(store_current_hours, ":hours_since_last_recon"),
			#(party_get_slot, ":last_recon_time", ":center_to_attack", ":faction_recce_slot"),
			#(val_sub, ":hours_since_last_recon", ":last_recon_time"),
			#(this_or_next|eq, ":last_recon_time", 0),
			#(gt, ":hours_since_last_recon", 96),

		    #(assign, ":action", sfai_attacking_center),
			#(assign, ":object", ":center_to_attack"),
			#(str_store_string, s14, "str_we_are_conducting_recce"),

		#8-ATTACK AN ENEMY CENTER case 2, reconnaissance against village
		#(else_try),
			#(party_is_active, ":marshal_party"),
			#(neq, ":current_ai_state", sfai_default),
			#(neq, ":current_ai_state", sfai_feast),
			#(is_between, ":center_to_attack", villages_begin, villages_end),

			#(store_sub, ":faction_recce_slot", ":faction_no", kingdoms_begin),
			#(val_add, ":faction_recce_slot", slot_center_last_reconnoitered_by_faction_time),
			#(store_current_hours, ":hours_since_last_recon"),
			#(party_get_slot, ":last_recon_time", ":center_to_attack", ":faction_recce_slot"),
			#(val_sub, ":hours_since_last_recon", ":last_recon_time"),
			#(this_or_next|eq, ":last_recon_time", 0),
			#(gt, ":hours_since_last_recon", 96),


			#(assign, ":action", sfai_raiding_village),
			#(assign, ":object", ":center_to_attack"),
			#(str_store_string, s14, "str_we_are_conducting_recce"),
		(else_try),
			(party_is_active, ":marshal_party"),
			(neq, ":current_ai_state", sfai_default),
			(neq, ":current_ai_state", sfai_feast),

			(assign, ":center_to_attack", ":center_to_attack_only_marshal_and_followers"),

			(is_between, ":center_to_attack", walled_centers_begin, walled_centers_end),

			(ge, ":target_value_level", ":minimum_possible_attackable_target_value_level"),

		    (assign, ":action", sfai_attacking_center),
			(assign, ":object", ":center_to_attack"),
			(str_store_string, s14, "str_we_believe_the_fortress_will_be_worth_the_effort_to_take_it"),
		(else_try),
			(party_is_active, ":marshal_party"),
			(neq, ":current_ai_state", sfai_default),
			(neq, ":current_ai_state", sfai_feast),

			(assign, ":center_to_attack", ":center_to_attack_only_marshal_and_followers"),

			(is_between, ":center_to_attack", villages_begin, villages_end),

			(ge, ":target_value_level", ":minimum_possible_attackable_target_value_level"),

			(assign, ":action", sfai_raiding_village),
			(assign, ":object", ":center_to_attack"),
			(str_store_string, s14, "str_we_shall_leave_a_fiery_trail_through_the_heart_of_the_enemys_lands_targeting_the_wealthy_settlements_if_we_can"),

		#9 -- DISBAND THE ARMY
		(else_try),
			(eq, ":current_ai_state", sfai_gathering_army),

			(str_store_string, s14, "str_the_army_will_be_disbanded_because_we_have_been_waiting_too_long_without_a_target"),

			(assign, ":action", sfai_default),
			(assign, ":object", -1),
		#OFFENSIVE OPERATIONS END

		#FEAST-RELATED OPERATIONS BEGIN
		#10-CONCLUDE CURRENT FEAST
		(else_try),
			(eq, ":current_ai_state", sfai_feast),
			(gt, ":hours_at_current_state", 72),

			(assign, ":action", sfai_default),
			(assign, ":object", -1),
			(str_store_string, s14, "str_it_is_time_for_the_feast_to_conclude"),

		#11-CONTINE FEAST UNLESS THERE IS AN EMERGENCY
		(else_try),
			(eq, ":current_ai_state", sfai_feast),
			(le, ":hours_at_current_state", 72),

			(assign, ":action", sfai_feast),
			(assign, ":object", ":current_ai_object"),
			(str_store_string, s14, "str_we_should_continue_the_feast_unless_there_is_an_emergency"),

		#12-HOLD A FEAST BECAUSE THE PLAYER WANTS TO ORGANIZE ONE
		(else_try),
			(check_quest_active, "qst_organize_feast"),
			(eq, "$players_kingdom", ":faction_no"),

			(quest_get_slot, ":target_center", "qst_organize_feast", slot_quest_target_center),

			(assign, ":action", sfai_feast),
			(assign, ":object", ":target_center"),
			(str_store_string, s14, "str_you_had_wished_to_hold_a_feast"),

		#13-HOLD A FEAST BECAUSE FEMALE PLAYER SCHEDULED TO GET MARRIED
		(else_try),
			(check_quest_active, "qst_wed_betrothed_female"),

			(quest_get_slot, ":groom", "qst_wed_betrothed_female", slot_quest_giver_troop),
			(troop_slot_eq, ":groom", slot_troop_prisoner_of_party, -1),

			(store_faction_of_troop, ":groom_faction", ":groom"),
			(eq, ":groom_faction", ":faction_no"),

			(faction_get_slot, ":faction_leader", ":groom_faction", slot_faction_leader),

			(assign, ":location_feast", -1),
			(try_for_range, ":possible_location", walled_centers_begin, walled_centers_end),
			   (eq, ":location_feast", -1),
			    (party_slot_eq, ":possible_location", slot_town_lord, ":groom"),
			    (party_slot_ge, ":possible_location", slot_center_is_besieged_by, 0),
			    (assign, ":location_feast", ":possible_location"),
			(try_end),

			(try_for_range, ":possible_location", walled_centers_begin, walled_centers_end),
				(eq, ":location_feast", -1),
				(party_slot_eq, ":possible_location", slot_town_lord, ":faction_leader"),
				(party_slot_ge, ":possible_location", slot_center_is_besieged_by, 0),
				(assign, ":location_feast", ":possible_location"),
			(try_end),

			(is_between, ":location_feast", walled_centers_begin, walled_centers_end),

			(assign, ":action", sfai_feast),
			(assign, ":object", ":location_feast"),
			(str_store_string, s14, "str_your_wedding_day_approaches_my_lady"),

		#14-HOLD A FEAST BECAUSE A MALE CHARACTER WANTS TO GET MARRIED
		(else_try),
			(check_quest_active, "qst_wed_betrothed"),
			(neg|quest_slot_ge, "qst_wed_betrothed", slot_quest_expiration_days, 362),

			(quest_get_slot, ":bride", "qst_wed_betrothed", slot_quest_target_troop),
			(call_script, "script_get_kingdom_lady_social_determinants", ":bride"),
			(assign, ":feast_host", reg0),
			(store_faction_of_troop, ":feast_host_faction", ":feast_host"),
			(eq, ":feast_host_faction", ":faction_no"),

			(troop_slot_eq, ":feast_host", slot_troop_prisoner_of_party, -1),
			(assign, ":wedding_venue", reg1),

			(is_between, ":wedding_venue", centers_begin, centers_end),
			(party_slot_eq, ":wedding_venue", slot_center_is_besieged_by, -1),

			(assign, ":action", sfai_feast),
			(assign, ":object", ":wedding_venue"),
			(str_store_string, s14, "str_your_wedding_day_approaches"),

		#15-HOLD A FEAST BECAUSE AN NPC WANTS TO GET MARRIED
		(else_try),
            (ge, ":hours_since_last_feast_start", 192), #If at least eight days past last feast start time

			(assign, ":location_feast", -1),

			(try_for_range, ":kingdom_lady", kingdom_ladies_begin, kingdom_ladies_end),
				(troop_get_slot, ":groom", ":kingdom_lady", slot_troop_betrothed),
				(gt, ":groom", 0), #not the player

				(store_faction_of_troop, ":lady_faction", ":kingdom_lady"),
				(store_faction_of_troop, ":groom_faction", ":groom"),

				(try_begin), #The groom checks if he wants to continue or break off relations. This causes actions, rather than just returns a value, so it probably should be moved elsewhere
					(troop_slot_ge, ":groom", slot_troop_prisoner_of_party, 0),
				(else_try),
					(neq, ":groom_faction", ":lady_faction"),
					(neq, ":groom_faction", "fac_player_faction"),
					(call_script, "script_courtship_event_lady_break_relation_with_suitor", ":kingdom_lady", ":groom"),
				(else_try),
					(eq, ":lady_faction", ":faction_no"),
			        ##diplomacy start+
					#neither the bride nor the groom is in retirement, dead, etc.
					(neg|troop_slot_ge, ":groom", slot_troop_occupation, slto_retirement),
					(neg|troop_slot_ge, ":kingdom_lady", slot_troop_occupation, slto_retirement),
					##diplomacy end+
		            (store_current_hours, ":hours_since_betrothal"),
		            (troop_get_slot, ":betrothal_time", ":kingdom_lady", slot_troop_betrothal_time),
		            (val_sub, ":hours_since_betrothal", ":betrothal_time"),
		            (ge, ":hours_since_betrothal", 719), #30 days

					(call_script, "script_get_kingdom_lady_social_determinants", ":kingdom_lady"),
					(assign, ":wedding_venue", reg1),

		            (assign, ":location_feast", ":wedding_venue"),
		            (assign, ":final_bride", ":kingdom_lady"),
		            (assign, ":final_groom", ":groom"),
				(try_end),
			(try_end),

			(ge, ":location_feast", centers_begin),

			(assign, ":action", sfai_feast),
			(assign, ":object", ":location_feast"),

			(str_store_troop_name, s22, ":final_bride"),
			(str_store_troop_name, s23, ":final_groom"),
			(str_store_string, s14, "str_s22_and_s23_wish_to_marry"),

		#16-HOLD A FEAST ANYWAY
		(else_try),
			(eq, ":current_ai_state", sfai_default),
            (gt, ":hours_since_last_feast_start", 240), #If at least 10 days past after last feast. (added by ozan)

			(assign, ":location_high_score", 0),
			(assign, ":location_feast", -1),

			(try_for_range, ":location", walled_centers_begin, walled_centers_end),
				(store_faction_of_party, ":location_faction", ":location"),
				(eq, ":location_faction", ":faction_no"),

				(try_begin),
			        (neg|party_slot_eq, ":location", slot_village_state, svs_under_siege),
		            (party_get_slot, ":location_lord", ":location", slot_town_lord),
		            (is_between, ":location_lord", active_npcs_begin, active_npcs_end),
		            (troop_get_slot, ":location_score", ":location_lord", slot_troop_renown),
		            (store_random_in_range, ":random", 0, 1000), #will probably be king or senior lord
		            (val_add, ":location_score", ":random"),
		            (gt, ":location_score", ":location_high_score"),
		            (assign, ":location_high_score", ":location_score"),
		            (assign, ":location_feast", ":location"),
				(else_try), #do not start new feasts if any place is under siege or being raided
		            (this_or_next|party_slot_eq, ":location", slot_village_state, svs_under_siege),
						(party_slot_eq, ":location", slot_village_state, svs_being_raided),
		            (assign, ":location_high_score", 9999),
		            (assign, ":location_feast", -1),
				(try_end),
			(try_end),

			(is_between, ":location_feast", walled_centers_begin, walled_centers_end),
			(party_get_slot, ":feast_host", ":location_feast", slot_town_lord),
			(troop_slot_eq, ":feast_host", slot_troop_prisoner_of_party, -1),

			(assign, ":action", sfai_feast),
			(assign, ":object", ":location_feast"),
			(str_store_string, s14, "str_it_has_been_a_long_time_since_the_lords_of_the_realm_gathered_for_a_feast"),

		#17-DO NOTHING
		(else_try),
			(neq, ":current_ai_state", sfai_default),

			(assign, ":action", sfai_default),
			(assign, ":object", -1),
			(str_store_string, s14, "str_the_circumstances_which_led_to_this_decision_no_longer_apply_so_we_should_stop_and_reconsider_shortly"),

		#18-DO NOTHING
		(else_try),
			(eq, ":current_ai_state", sfai_default),

			(eq, ":at_peace_with_everyone", 1),

		    (assign, ":action", sfai_default),
		    (assign, ":object", -1),
			(str_store_string, s14, "str_we_are_currently_at_peace"),
		(else_try),
			(eq, ":current_ai_state", sfai_default),
			(faction_slot_eq, ":faction_no", slot_faction_marshall, -1),
		    (assign, ":action", sfai_default),
		    (assign, ":object", -1),
			(str_store_string, s14, "str_we_are_waiting_for_selection_of_marshal"),

		(else_try),
			(eq, ":current_ai_state", sfai_default),

		    (assign, ":action", sfai_default),
		    (assign, ":object", -1),
			(str_store_string, s14, "str_the_vassals_still_need_time_to_attend_to_their_own_business"),
		(try_end),

		(assign, reg0, ":action"),
		(assign, reg1, ":object"),
	]),

 	(
	"faction_last_reconnoitered_center", #This is called from within decide_faction_ai, or from
	[
		(store_script_param, ":faction_no", 1),
		(store_script_param, ":center_no", 2),

		(store_sub, ":faction_recce_slot", ":faction_no", kingdoms_begin),
		(val_add, ":faction_recce_slot", slot_center_last_reconnoitered_by_faction_time),
		(store_current_hours, ":hours_since_last_recon"),
		(party_get_slot, ":last_recon_time", ":center_no", ":faction_recce_slot"),

		(try_begin),
			(lt, ":last_recon_time", 1),
			(assign, ":hours_since_last_recon", 1000),
		(else_try),
			(val_sub, ":hours_since_last_recon", ":last_recon_time"),
		(try_end),

		(assign, reg0, ":hours_since_last_recon"),
		(assign, reg1, ":last_recon_time"),
	]),

 	(
	"reduce_exact_number_to_estimate",
	#This is used to simulate limited intelligence
	#It is roughly analogous to the descriptive strings which the player will receive from alarms
	#Information is presumed to be accurate for four days
	#This is obviously cheating for the AI, as the AI will have exact info for four days, and no info at all after that.
	#It would be fairly easy to log the strength at a center when it is scouted, if we want, but I have not done that at this point,
	#The AI also has a hive mind -- ie, each party knows what its allies are thinking. In this, AI factions have an advantage over the player
	#It would be a simple matter to create a set of arrays in which each party's knowledge is individually updated, but that would also take up a lot of data space

	[
		(store_script_param, ":exact_number", 1),

		(try_begin),
			(lt, ":exact_number", 500),
			(assign, ":estimate", 0),
		(else_try),
			(lt, ":exact_number", 1000),
			(assign, ":estimate", 750),
		(else_try),
			(lt, ":exact_number", 2000),
			(assign, ":estimate", 1500),
		(else_try),
			(lt, ":exact_number", 4000),
			(assign, ":estimate", 3000),
		(else_try),
			(lt, ":exact_number", 8000),
			(assign, ":estimate", 6000),
		(else_try),
			(lt, ":exact_number", 16000),
			(assign, ":estimate", 12000),
		(else_try),
			(assign, ":estimate", 24000),
		(try_end),
		##diplomacy start+
		#This currently isn't used anywhere, but modify it if we're thinking about changing that.
		#Take into account campaign AI difficulty -- assume that the difference is either a good
		#spy network or intelligent inference.
		(game_get_reduce_campaign_ai, reg0),
		(try_begin),
			(lt, reg0, 1),#Hard mode
			(assign, ":estimate", ":exact_number"),
		(else_try),
			(eq, reg0, 1),#Medium Mode
			(val_add, ":estimate", ":exact_number"),
			(val_div, ":estimate", 2),
		(try_end),
		##diplomacy end+

		(assign, reg0, ":estimate"),
	]),

   #script_calculate_castle_prosperities_by_using_its_villages
 	(
	"calculate_castle_prosperities_by_using_its_villages", #This is called from within decide_faction_ai, or from
	[
	  (try_for_range, ":cur_castle", castles_begin, castles_end),
	    (assign, ":total_prosperity", 0),
	    (assign, ":total_villages", 0),

	    (try_for_range, ":cur_village", villages_begin, villages_end),
	      (party_get_slot, ":bound_center", ":cur_village", slot_village_bound_center),
	      (eq, ":cur_castle", ":bound_center"),

	      (party_get_slot, ":village_prosperity", ":cur_village", slot_town_prosperity),

	      (val_add, ":total_prosperity", ":village_prosperity"),
	      (val_add, ":total_villages", 1),
	    (try_end),

	    (try_begin),
	      (store_div, ":castle_prosperity", ":total_prosperity", ":total_villages"),
	    (else_try),
	      (assign, ":castle_prosperity", 50),
	    (try_end),

	    (party_set_slot, ":cur_castle", slot_town_prosperity, ":castle_prosperity"),
	  (try_end),
	]),

   #script_initialize_tavern_variables
   (
   "initialize_tavern_variables",
   [
     (assign, "$g_main_attacker_agent", 0),
     (assign, "$g_attacker_drawn_weapon", 0),
     (assign, "$g_start_belligerent_drunk_fight", 0),
     (assign, "$g_start_hired_assassin_fight", 0),
     (assign, "$g_belligerent_drunk_leaving", 0),
   ]),

   #script_prepare_alley_to_fight
   (
   "prepare_alley_to_fight",
   [
     (party_get_slot, ":scene_no", "$current_town", slot_town_alley),

     #(store_faction_of_party, ":faction_no", "$current_town"),

     (modify_visitors_at_site, ":scene_no"),

     (reset_visitors),
     (set_visitor, 0, "trp_player"),

     #(set_visitor, 3, ":bandit_troop"),
     (set_visitor, 3, "trp_bandit"),

     (assign, "$talked_with_merchant", 0),
     (set_jump_mission, "mt_alley_fight"),
     (jump_to_scene, ":scene_no"),
     (change_screen_mission),
   ]),

   #script_prepare_town_to_fight
   (
   "prepare_town_to_fight",
   [
     (str_store_party_name_link, s9, "$g_starting_town"),
     (str_store_string, s2, "str_save_town_from_bandits"),
     (call_script, "script_start_quest", "qst_save_town_from_bandits", "$g_talk_troop"),

     (assign, "$g_mt_mode", tcm_default),
     (store_faction_of_party, ":town_faction", "$current_town"),
     (faction_get_slot, ":tier_2_troop", ":town_faction", slot_faction_tier_3_troop),
     (faction_get_slot, ":tier_3_troop", ":town_faction", slot_faction_tier_3_troop),
     (faction_get_slot, ":tier_4_troop", ":town_faction", slot_faction_tier_4_troop),

     (party_get_slot, ":town_scene", "$current_town", slot_town_center),

     (set_jump_mission,"mt_town_fight"), #dckplmc

     (modify_visitors_at_site, ":town_scene"),
     (reset_visitors),

     #people spawned at #32, #33, #34, #35, #36, #37, #38 and #39 are town walkers.
     (try_begin),
       #(eq, "$town_nighttime", 0),
       (try_for_range, ":walker_no", 0, num_town_walkers),
         (store_add, ":troop_slot", slot_center_walker_0_troop, ":walker_no"),
         (party_get_slot, ":walker_troop_id", "$current_town", ":troop_slot"),
         (gt, ":walker_troop_id", 0),
         (store_add, ":entry_no", town_walker_entries_start, ":walker_no"),

		 #dckplmc - add daggers and clubs
		 (mission_tpl_entry_set_override_flags, "mt_town_fight", ":entry_no", af_override_weapons),
		 (store_random_in_range, ":r", 0,2),
		 (try_begin),
			(eq, ":r", 0),
			(mission_tpl_entry_add_override_item, "mt_town_fight", ":entry_no", "itm_dagger"),
		 (else_try),
			(mission_tpl_entry_add_override_item, "mt_town_fight", ":entry_no", "itm_club"),
		 (try_end),

         (set_visitor, ":entry_no", ":walker_troop_id"),
       (try_end),
     (try_end),

     #guards will be spawned at #25, #26 and #27
     (set_visitors, 25, ":tier_2_troop", 1),
     (set_visitors, 26, ":tier_3_troop", 1),
     (set_visitors, 27, ":tier_4_troop", 1),

     (set_visitors, 10, "trp_looter", 1),
     (set_visitors, 11, "trp_bandit", 1),
     (set_visitors, 12, "trp_looter", 1),

     # (store_faction_of_party, ":starting_town_faction", "$g_starting_town"),
     #SB : add a few bandits alongside the looters
     (call_script, "script_center_get_bandits", "$g_starting_town", 0),
     (assign, ":bandit_troop", reg0),
     (call_script, "script_get_troop_of_merchant"),
     (assign, ":troop_of_merchant", reg0),
     (str_store_troop_name, s10, ":troop_of_merchant"),

     (set_visitors, 24, "trp_looter", 1),
     (set_visitors, 2, ":bandit_troop", 2),
     (set_visitors, 4, "trp_looter", 1),
     (set_visitors, 5, "trp_looter", 2),
     (set_visitors, 6, "trp_looter", 1),
     (set_visitors, 7, ":bandit_troop", 1),

	 #dckplmc
	 (mission_tpl_entry_set_override_flags, "mt_town_fight", 3, af_override_weapons),
	 (mission_tpl_entry_add_override_item, "mt_town_fight", 3, "itm_dagger"),
     (set_visitors, 3, ":troop_of_merchant", 1),


     #(set_jump_mission,"mt_town_fight"),
     (jump_to_scene, ":town_scene"),
     (change_screen_mission),
   ]),

   (
   "change_player_right_to_rule",
   [
     (store_script_param_1, ":right_to_rule_dif"),
     (val_add, "$player_right_to_rule", ":right_to_rule_dif"),
     (val_clamp, "$player_right_to_rule", 0, 100),
     (try_begin),
       (gt, ":right_to_rule_dif", 0),
       (display_message, "@You gain right to rule.", message_positive),
     (else_try),
       (lt, ":right_to_rule_dif", 0),
       (display_message, "@You lose right to rule.", message_negative),
     (try_end),
   ]),

   ("indict_lord_for_treason",#originally included in simple_triggers. Needed to be moved here to allow player to indict
   [
    (store_script_param, ":troop_no", 1),
    (store_script_param, ":faction", 2),

	##diplomacy start+ use gender script
	#(troop_get_type, reg4, ":troop_no"),
	(assign, ":save_reg0", reg0),
	(assign, ":save_reg3", reg3),
	(assign, ":save_reg4", reg4),
	##diplomacy end+

	(try_for_range, ":center", centers_begin, centers_end), #transfer properties to liege
		(party_slot_eq, ":center", slot_town_lord, ":troop_no"),
		(party_set_slot, ":center", slot_town_lord, stl_unassigned),
	(try_end),

	(faction_get_slot, ":faction_leader", ":faction", slot_faction_leader),
	(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_leader"),
	(assign, ":liege_to_lord_relation", reg0),
	(store_sub, ":base_relation_modifier", -150, ":liege_to_lord_relation"),
	(val_div, ":base_relation_modifier", 40),#-1 at -100, -2 at -70, -3 at -30,etc.
	(val_min, ":base_relation_modifier", -1),

    # #SB : redistribute wealth to faction ruler
    (try_begin),
      (ge, "$g_dplmc_ai_changes", DPLMC_AI_CHANGES_HIGH),
    # (troop_get_slot, ":cur_wealth", ":troop_no", slot_troop_wealth),
    # (troop_set_slot, ":troop_no", slot_troop_wealth, 0),
    # (call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", ":cur_wealth", ":faction_leader"), #add to ruler
    (try_end),
	#Indictments, cont: Influence relations
	##diplomacy start+ Alter to include promoted ladies
	##OLD:
	#(try_for_range, ":active_npc", active_npcs_begin, active_npcs_end), #this effects all lords in all factions
	##NEW:
	(try_for_range, ":active_npc", heroes_begin, heroes_end), #this effects all lords in all factions
		(this_or_next|is_between, ":active_npc", active_npcs_begin, active_npcs_end),
			(troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),
	##diplomacy end+
		(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
		(eq, ":faction", ":active_npc_faction"),

		(call_script, "script_troop_get_family_relation_to_troop", ":troop_no", ":active_npc"),
		(assign, ":family_relation", reg0),

		##diplomacy start+
		(val_max, ":family_relation", 0),
		#Take into account friendship or enmity
		(call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_leader"),
		(assign, ":liking_relation", reg0),
		(try_begin),
			(ge, ":liking_relation", 20),
			(store_div, reg0, ":liking_relation", 20),
			(val_add, ":family_relation", reg0),
		(else_try),
			(lt, ":liking_relation", 0),
			(store_div, reg0, ":liking_relation", 20),
			(val_sub, reg0, 1),
			(val_add, ":family_relation", reg0),
		(try_end),
		(store_random_in_range, reg0, 0, 3),#+0, +1, or +2 (because below we divide by three...)
		(val_add, ":family_relation", reg0),
		(assign, reg0, ":family_relation"),
		##diplomacy end+
		(assign, ":relation_modifier", ":base_relation_modifier"),
		(try_begin),
			##diplomacy start+
			#(gt, ":family_relation", 1),##OLD
			(neq, ":family_relation", 0),##NEW (allow lessening penalty for hated characters)
			##diplomacy end+
			(store_div, ":family_multiplier", reg0, 3),
			(val_sub, ":relation_modifier", ":family_multiplier"),
		(try_end),

		(lt, ":relation_modifier", 0),

		(call_script, "script_troop_change_relation_with_troop", ":faction_leader", ":active_npc", ":relation_modifier"),
		(val_add, "$total_indictment_changes", ":relation_modifier"),
		(try_begin),
			(eq, "$cheat_mode", 1),
			(str_store_troop_name, s17, ":active_npc"),
			(str_store_troop_name, s18, ":faction_leader"),

			(assign, reg3, ":relation_modifier"),
			(display_message, "str_trial_influences_s17s_relation_with_s18_by_reg3"),
		(try_end),
	(try_end),

	#Indictments, cont: Check for other factions
	(assign, ":new_faction", "fac_outlaws"),
	(try_begin),
		(eq, ":troop_no", "trp_player"),
		(assign, ":new_faction", 0), #kicked out of faction
	(else_try),
		(call_script, "script_lord_find_alternative_faction", ":troop_no"),
		(assign, ":new_faction", reg0),
	(try_end),

	#Indictments, cont: Finalize where the lord goes
	(try_begin),
		(is_between, ":new_faction", kingdoms_begin, kingdoms_end),


		(try_begin),
			(ge, "$cheat_mode", 1),
			(str_store_troop_name, s4, ":troop_no"),
			(display_message, "@{!}DEBUG - {s4} faction changed in indictment"),
		(try_end),

		(call_script, "script_change_troop_faction", ":troop_no", ":new_faction"),
		(try_begin), #new-begin
		  (neq, ":new_faction", "fac_player_supporters_faction"),
		  (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_inactive),
		  (troop_set_slot, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
		(try_end), #new-end
		(str_store_faction_name_link, s10, ":new_faction"),
		(str_store_string, s11, "str_with_the_s10"),
	(else_try),
		(neq, ":troop_no", "trp_player"),
		##diplomacy start+
		#Set "exile" occupation to differentiate between someone outside of Calradia
		#and an outlaw lord leading a party of bandits.
		(troop_set_slot, ":troop_no", slot_troop_occupation, dplmc_slto_exile),
		##diplomacy end+
		(call_script, "script_change_troop_faction", ":troop_no", "fac_outlaws"),
		(str_store_string, s11, "str_outside_calradia"),
	(else_try),
		(eq, ":troop_no", "trp_player"),
		(call_script, "script_player_leave_faction", 1),
	(try_end),

	#Indictments, cont: Set up string
	(try_begin),
		(eq, ":troop_no", "trp_player"),
		(str_store_string, s9, "str_you_have_been_indicted_for_treason_to_s7_your_properties_have_been_confiscated_and_you_would_be_well_advised_to_flee_for_your_life"),
	(else_try),
		# (str_store_troop_name_plural, s4, ":troop_no"), #this now holds the new faction title, need to be changed
		(str_store_faction_name_link, s5, ":faction"),
		(str_store_troop_name_link, s6, ":faction_leader"),

		##diplomacy start+
		#(troop_get_type, reg4, ":troop_no"),
		(call_script, "script_dplmc_store_troop_is_female", ":troop_no"),
		(assign, reg4, reg0),
		(store_sub, ":title", ":faction", kingdoms_begin),
		(try_begin),
		  (eq, reg4, tf_male),
		  (val_add, ":title", kingdom_titles_male_begin),
		(else_try),
		  (eq, reg4, tf_female),
		  (val_add, ":title", kingdom_titles_female_begin),
		(else_try), #default to lord
		  (assign, ":title", kingdom_titles_male_begin),
		(try_end),
		(str_store_troop_name_plural, s0, ":troop_no"),
		(str_store_string, s4, ":title"),
		##diplomacy end+
		(str_store_string, s9, "str_by_order_of_s6_s4_of_the_s5_has_been_indicted_for_treason_the_lord_has_been_stripped_of_all_reg4herhis_properties_and_has_fled_for_reg4herhis_life_he_is_rumored_to_have_gone_into_exile_s11"),
	(try_end),
	##diplomacy start+ important political events should be in the log
    #SB : colorize with former faction
    (faction_get_color, ":color", s9),
	(display_log_message, s9, ":color"),#display_message changed to display_log_message
	##diplomacy end+

	#Indictments, cont: Remove party
	(troop_get_slot, ":led_party", ":troop_no", slot_troop_leaded_party),
	(try_begin),
		(party_is_active, ":led_party"),
		(neq, ":led_party", "p_main_party"),
		(remove_party, ":led_party"),
		(troop_set_slot, ":troop_no", slot_troop_leaded_party, -1),
	(try_end),

	(try_begin),
		(eq, "$cheat_mode", 1),
		##diplomacy start+
		(this_or_next|eq, ":faction", "fac_player_supporters_faction"),
		(this_or_next|eq, ":new_faction", "fac_player_supporters_faction"),
		##diplomacy end+
		(this_or_next|eq, ":faction", "$players_kingdom"),
			(eq, ":new_faction", "$players_kingdom"),
		(call_script, "script_add_notification_menu", "mnu_notification_treason_indictment", ":troop_no", ":faction"),
	(try_end),
	##diplomacy start+
	(assign, reg0, ":save_reg0"),
	(assign, reg3, ":save_reg3"),
	(assign, reg4, ":save_reg4"),
	##diplomacy end+
   ]),


  # script_give_center_to_faction_while_maintaining_lord
  # Input: arg1 = center_no, arg2 = faction
  ("give_center_to_faction_while_maintaining_lord",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":faction_no"),

      (store_faction_of_party, ":old_faction", ":center_no"),
	  ##diplomacy start+
	  #If the player, previously the head of his own faction, is now joining
	  #an NPC faction, don't reset the "last taken" time or the "ex faction"
	  #slots.
	  (try_begin),
		#Friendly transfer: don't update transfer time or ex-faction
		(eq, ":old_faction", "fac_player_supporters_faction"),
		(eq, ":faction_no", "$players_kingdom"),
	  (else_try),
		#Defection: update transfer time and ex-faction
		(party_set_slot, ":center_no", slot_center_ex_faction, ":old_faction"),
		(store_current_hours, ":cur_hours"),
		(party_set_slot, ":center_no", dplmc_slot_center_last_transfer_time, ":cur_hours"),
	  (try_end),
	  ##diplomacy end+
      (party_set_faction, ":center_no", ":faction_no"),

      (try_begin),
        (party_slot_eq, ":center_no", slot_party_type, spt_village),
        #SB : reinforcement
        (try_begin),
          (party_get_slot, ":farmer_party", ":center_no", slot_village_farmer_party),
          (gt, ":farmer_party", 0),
          (party_is_active, ":farmer_party"),
          (party_set_faction, ":farmer_party", ":faction_no"),
        (try_end),
        (try_begin),
          (party_get_slot, ":reinf_party", ":center_no", slot_village_reinforcement_party),
          (gt, ":reinf_party", 0),
          (party_is_active, ":reinf_party"),
          (party_set_faction, ":reinf_party", ":faction_no"),
        (try_end),
      (try_end),

      (call_script, "script_update_faction_notes", ":faction_no"),
      (call_script, "script_update_center_notes", ":center_no"),

      (try_for_range, ":other_center", centers_begin, centers_end),
        (party_slot_eq, ":other_center", slot_village_bound_center, ":center_no"),
        (call_script, "script_give_center_to_faction_while_maintaining_lord", ":other_center", ":faction_no"),
      (try_end),
  ]),

  # script_check_concilio_calradi_achievement
  ("check_concilio_calradi_achievement",
  [
   (try_begin),
     (eq, "$players_kingdom", "fac_player_supporters_faction"),
     (faction_get_slot, ":player_faction_king", "fac_player_supporters_faction", slot_faction_leader),
     (eq, ":player_faction_king", "trp_player"),
     (assign, ":number_of_vassals", 0),
     (try_for_range, ":cur_troop", active_npcs_begin, active_npcs_end),
       (troop_slot_eq, ":cur_troop", slot_troop_occupation, slto_kingdom_hero),
       (store_faction_of_troop, ":cur_faction", ":cur_troop"),
       (eq, ":cur_faction", "fac_player_supporters_faction"),
       (val_add, ":number_of_vassals", 1),
     (try_end),
     (ge, ":number_of_vassals", 3),
     (unlock_achievement, ACHIEVEMENT_CONCILIO_CALRADI),
   (try_end),
  ]),

  # script_refresh_center_inventories
  ("refresh_center_inventories",
  [
  (set_merchandise_modifier_quality,150),
  (reset_item_probabilities,100),

  # Add trade goods to merchant inventories
  (try_for_range,":cur_center",towns_begin,towns_end),
    (party_get_slot,":cur_merchant",":cur_center",slot_town_merchant),
    (reset_item_probabilities,100),
      (assign, ":total_production", 0),
    (try_for_range, ":cur_goods", trade_goods_begin, trade_goods_end),
        (call_script, "script_center_get_production", ":cur_center", ":cur_goods"),
		(assign, ":cur_production", reg0),

        (try_for_range, ":cur_village", villages_begin, villages_end),
		  (party_slot_eq, ":cur_village", slot_village_bound_center, ":cur_center"),
          (call_script, "script_center_get_production", ":cur_village", ":cur_goods"),
		  (val_div, reg0, 3),
		  (val_add, ":cur_production", reg0),
		(try_end),

		(val_max, ":cur_production", 1),
		(val_mul, ":cur_production", 4),

		(val_add, ":total_production", ":cur_production"),
      (try_end),

	  (party_get_slot, ":town_prosperity", ":cur_center", slot_town_prosperity),
	  (assign, ":number_of_items_in_town", 25),

	  (try_begin), #1.0x - 2.0x (50 - 100 prosperity)
	    (ge, ":town_prosperity", 50),
		(store_sub, ":ratio", ":town_prosperity", 50),
		(val_mul, ":ratio", 2),
		(val_add, ":ratio", 100),
		(val_mul, ":number_of_items_in_town", ":ratio"),
		(val_div, ":number_of_items_in_town", 100),
	  (else_try), #0.5x - 1.0x (0 - 50 prosperity)
		(store_sub, ":ratio", ":town_prosperity", 50),
		(val_add, ":ratio", 100),
		(val_mul, ":number_of_items_in_town", ":ratio"),
		(val_div, ":number_of_items_in_town", 100),
	  (try_end),

	  (val_clamp, ":number_of_items_in_town", 10, 40),

	  (try_begin),
	    (is_between, ":cur_center", castles_begin, castles_end),
	    (val_div, ":number_of_items_in_town", 2),
      (try_end),

      (try_for_range, ":cur_goods", trade_goods_begin, trade_goods_end),
	  (call_script, "script_center_get_production", ":cur_center", ":cur_goods"),
		(assign, ":cur_production", reg0),

        (try_for_range, ":cur_village", villages_begin, villages_end),
		  (party_slot_eq, ":cur_village", slot_village_bound_center, ":cur_center"),
          (call_script, "script_center_get_production", ":cur_village", ":cur_goods"),
		  (val_div, reg0, 3),
		  (val_add, ":cur_production", reg0),
		(try_end),

		(val_max, ":cur_production", 1),
		(val_mul, ":cur_production", 4),

        (val_mul, ":cur_production", ":number_of_items_in_town"),
		(val_mul, ":cur_production", 100),
		(val_div, ":cur_production", ":total_production"),
        (set_item_probability_in_merchandise, ":cur_goods", ":cur_production"),
    (try_end),

	  (troop_clear_inventory, ":cur_merchant"),
      (troop_add_merchandise, ":cur_merchant", itp_type_goods, ":number_of_items_in_town"),

      (troop_ensure_inventory_space, ":cur_merchant", 20),
    (troop_sort_inventory, ":cur_merchant"),
    (store_troop_gold, ":cur_gold",":cur_merchant"),
    ##diplomacy start+
	#Option: scaling gold additions by the prosperity of the town.
	(try_begin),
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),#this must be explicitly enabled
	    (party_get_slot, ":prosperity_75", ":cur_center", slot_town_prosperity),
		(val_add, ":prosperity_75", 75),
		(store_mul, ":target_gold", ":prosperity_75", 1500),
		(val_add, ":target_gold", 62),
		(val_div, ":target_gold", 125),#average 1500
		(lt, ":cur_gold", ":target_gold"),
		(store_random_in_range,":new_gold",500,1000),
		(val_mul, ":new_gold", ":prosperity_75"),
		(val_add, ":new_gold", 62),
		(val_div, ":new_gold", 125),
		(call_script, "script_troop_add_gold", ":cur_merchant", ":new_gold"),
	(else_try),
		(lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
	    #fall through to default behavior
	    ##diplomacy end+
    (lt,":cur_gold",1500),
    (store_random_in_range,":new_gold",500,1000),
    (call_script, "script_troop_add_gold", ":cur_merchant", ":new_gold"),
    ##diplomacy start+
    (try_end),
	##diplomacy end+
  (try_end),
  ]),

  # script_refresh_center_armories
  ("refresh_center_armories",
  [
	  (reset_item_probabilities,100),
	  (set_merchandise_modifier_quality,150),
	  (try_for_range, ":cur_merchant", armor_merchants_begin, armor_merchants_end),
		(store_sub, ":cur_town", ":cur_merchant", armor_merchants_begin),
		(val_add, ":cur_town", towns_begin),
		(troop_clear_inventory, ":cur_merchant"),
		(party_get_slot, ":cur_faction", ":cur_town", slot_center_original_faction),
		(troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_body_armor, 16),
		(troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_head_armor, 16),
		(troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_foot_armor, 8),
		(troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_hand_armor, 4),
		(try_begin), # Add extra armors
			(gt, "$g_sexual_content", 0),
			(troop_add_merchandise_with_faction, ":cur_merchant", fac_undeads, itp_type_body_armor, 3),
			(troop_add_merchandise_with_faction, ":cur_merchant", fac_undeads, itp_type_head_armor, 1),
			(troop_add_merchandise_with_faction, ":cur_merchant", fac_undeads, itp_type_foot_armor, 2),
		(try_end),
		(troop_ensure_inventory_space, ":cur_merchant", merchant_inventory_space),
		(troop_sort_inventory, ":cur_merchant"),
		(store_troop_gold, reg6, ":cur_merchant"),

	    ##diplomacy start+
		#Option: scaling gold additions by the prosperity of the town.
		(try_begin),
			(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),#this must be explicitly enabled
		    (party_get_slot, ":prosperity_75", ":cur_town", slot_town_prosperity),
			(val_add, ":prosperity_75", 75),
			(store_mul, ":target_gold", ":prosperity_75", 900),
			(val_add, ":target_gold", 62),
			(val_div, ":target_gold", 125),#average 900
			(lt, reg(6), ":target_gold"),
			(store_random_in_range,":new_gold",200,400),
			(val_mul, ":new_gold", ":prosperity_75"),
			(val_add, ":new_gold", 62),
			(val_div, ":new_gold", 125),
			(call_script, "script_troop_add_gold", ":cur_merchant", ":new_gold"),
		(else_try),
			(lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		    #fall through to default behavior
		    ##diplomacy end+
	    (lt,reg6,1000),
	    (store_random_in_range,":new_gold",250,500),
	    (call_script, "script_troop_add_gold", ":cur_merchant", ":new_gold"),
		##diplomacy start+
		(try_end),
		##diplomacy end+
	  (end_try),
  ]),

  # script_refresh_center_weaponsmiths
  ("refresh_center_weaponsmiths",
  [
	  (reset_item_probabilities,100),
	  (set_merchandise_modifier_quality,150),
    (try_for_range, ":cur_merchant", weapon_merchants_begin, weapon_merchants_end),
	  (store_sub, ":cur_town", ":cur_merchant", weapon_merchants_begin),
	    (val_add, ":cur_town", towns_begin),
	  (troop_clear_inventory, ":cur_merchant"),
	    (party_get_slot, ":cur_faction", ":cur_town", slot_center_original_faction),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_one_handed_wpn, 5),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_two_handed_wpn, 5),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_polearm, 5),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_shield, 6),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_bow, 4),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_crossbow, 3),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_thrown, 5),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_arrows, 2),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_bolts, 2),
      #Guns and gun related items
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_pistol, 1),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_musket, 1),
      (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_bullets, 1),
      (troop_ensure_inventory_space, ":cur_merchant", merchant_inventory_space),
      (troop_sort_inventory, ":cur_merchant"),
      (store_troop_gold, reg6, ":cur_merchant"),

	    ##diplomacy start+
		#Option: scaling gold additions by the prosperity of the town.
		(try_begin),
			(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),#this must be explicitly enabled
		    (party_get_slot, ":prosperity_75", ":cur_town", slot_town_prosperity),
			(val_add, ":prosperity_75", 75),
			(store_mul, ":target_gold", ":prosperity_75", 900),
			(val_add, ":target_gold", 62),
			(val_div, ":target_gold", 125),#average 900
			(lt, reg6, ":target_gold"),
			(store_random_in_range,":new_gold",200,400),
			(val_mul, ":new_gold", ":prosperity_75"),
			(val_add, ":new_gold", 62),
			(val_div, ":new_gold", 125),
			(call_script, "script_troop_add_gold", ":cur_merchant", ":new_gold"),
		(else_try),
			(lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		    #fall through to default behavior
		    ##diplomacy end+
	    (lt,reg6,1000),
	    (store_random_in_range,":new_gold",250,500),
	  (call_script, "script_troop_add_gold", ":cur_merchant", ":new_gold"),
	  ##diplomacy start+
	  (try_end),
	  ##diplomacy end+
	  (try_end),
  ]),

  # script_refresh_center_stables
  ("refresh_center_stables",
  [
      (reset_item_probabilities,100),
      (set_merchandise_modifier_quality,150),
      (try_for_range,":cur_merchant",horse_merchants_begin,horse_merchants_end),
	  (troop_clear_inventory, ":cur_merchant"),
      (store_sub, ":cur_town", ":cur_merchant", horse_merchants_begin),
      (val_add, ":cur_town", towns_begin),
      (party_get_slot, ":cur_faction", ":cur_town", slot_center_original_faction),
      (troop_add_merchandise_with_faction,":cur_merchant", ":cur_faction",itp_type_horse,5),
      (troop_ensure_inventory_space,":cur_merchant",65),
      (troop_sort_inventory, ":cur_merchant"),
      (store_troop_gold, ":cur_gold",":cur_merchant"),
	##diplomacy start+
	#Option: scaling gold additions by the prosperity of the town.
	(try_begin),
		(ge, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),#this must be explicitly enabled
	    (party_get_slot, ":prosperity_75", ":cur_town", slot_town_prosperity),
		(val_add, ":prosperity_75", 75),
		(store_mul, ":target_gold", ":prosperity_75", 600),
		(val_add, ":target_gold", 62),
		(val_div, ":target_gold", 125),#average 600
		(lt, ":cur_gold", ":target_gold"),
		(store_random_in_range,":new_gold",200,400),
		(val_mul, ":new_gold", ":prosperity_75"),
		(val_add, ":new_gold", 62),
		(val_div, ":new_gold", 125),
		(call_script, "script_troop_add_gold", ":cur_merchant", ":new_gold"),
	(else_try),
		(lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
	    #fall through to default behavior
	    ##diplomacy end+
    (lt,":cur_gold",600),
    (store_random_in_range, ":new_gold", 250, 500),
    (call_script, "script_troop_add_gold", ":cur_merchant", ":new_gold"),
    ##diplomacy start+
    (try_end),
    ##diplomacy end+
  (try_end),
  ]),

##diplomacy begin
  #recruiter kit begin
  ("dplmc_send_recruiter",
    [
    (store_script_param, ":number_of_recruits", 1),
#daedalus begin
   (store_script_param, ":faction_of_recruits", 2),
#daedalus end
   (assign, ":expenses", ":number_of_recruits"),
   (val_mul, ":expenses", 20),
   (val_add, ":expenses", 10),
   (call_script, "script_dplmc_withdraw_from_treasury", ":expenses"),
   (set_spawn_radius, 1),
    (spawn_around_party, "$current_town", "pt_dplmc_recruiter"),
    (assign,":spawned_party",reg0),
    (party_set_ai_behavior, ":spawned_party", ai_bhvr_hold),
    (party_set_slot, ":spawned_party", slot_party_type, dplmc_spt_recruiter),
    (party_set_slot, ":spawned_party", dplmc_slot_party_recruiter_needed_recruits, ":number_of_recruits"),
   #daedalus begin
   (party_set_slot, ":spawned_party", dplmc_slot_party_recruiter_needed_recruits_faction, ":faction_of_recruits"),
   #daedalus end
   (party_set_slot, ":spawned_party", dplmc_slot_party_recruiter_origin, "$current_town"),
   (assign, ":faction", "$players_kingdom"),
   (party_set_faction, ":spawned_party", ":faction"),
    ]),
#recruiter kit end

####################################################################################
#
# Autoloot Scripts begin
# ---------------------------------------------------
####################################################################################

  #### Autoloot improved by rubik begin
  # ("dplmc_init_item_difficulties", set_item_difficulty()),
  #### Autoloot improved by rubik end


###################################
   # Can a troop qualify to use this item?
   # Returns 1 = yes, 0 = no.
   ("dplmc_troop_can_use_item",
   [
      (store_script_param, ":troop", 1),
      (store_script_param, ":item", 2),
      (store_script_param, ":item_modifier", 3),

      # (item_get_slot, ":difficulty", ":item", dplmc_slot_item_difficulty),
      (item_get_difficulty, ":difficulty", ":item"),
      (item_get_type, ":type", ":item"),
      (try_begin),
        (eq, ":difficulty", 0), # don't apply imod modifiers if item has no requirement
      (else_try),
        (eq, ":item_modifier", imod_stubborn),
        (val_add, ":difficulty", 1),
      (else_try),
        (eq, ":item_modifier", imod_timid),
        (val_sub, ":difficulty", 1),
      (else_try),
        (eq, ":item_modifier", imod_heavy),
        (neq, ":type", itp_type_horse), #heavy horses don't increase difficulty
        (val_add, ":difficulty", 1),
      (else_try),
        (eq, ":item_modifier", imod_strong),
        (val_add, ":difficulty", 2),
      (else_try),
        (eq, ":item_modifier", imod_masterwork),
        (val_add, ":difficulty", 4),
      (try_end),

      (item_get_type, ":type", ":item"),
      (try_begin),
        (eq, ":type", itp_type_horse),
        (store_skill_level, ":skill", skl_riding, ":troop"),
      (else_try),
        (this_or_next|eq, ":type", itp_type_crossbow),
        (this_or_next|eq, ":type", itp_type_one_handed_wpn),
        (this_or_next|eq, ":type", itp_type_two_handed_wpn),
        (this_or_next|eq, ":type", itp_type_polearm),
        (this_or_next|eq, ":type", itp_type_head_armor),
        (this_or_next|eq, ":type", itp_type_body_armor),
        (this_or_next|eq, ":type", itp_type_foot_armor),
        (eq, ":type", itp_type_hand_armor),
        (store_attribute_level, ":skill", ":troop", ca_strength),
      (else_try),
        (eq, ":type", itp_type_shield),
        (store_skill_level, ":skill", skl_shield, ":troop"),
      (else_try),
        (eq, ":type", itp_type_bow),
        (store_skill_level, ":skill", skl_power_draw, ":troop"),
      (else_try),
        (eq, ":type", itp_type_thrown),
        (store_skill_level, ":skill", skl_power_throw, ":troop"),
      (try_end),

      (try_begin),
        (lt, ":skill", ":difficulty"),
        (assign, reg0, 0),
      (else_try),
        (assign, reg0, 1),
      (try_end),
   ]),

#####################################################################
# gets an item's value
# Param1: item ID
# Param2: item modifier
#####################################################################
("dplmc_get_item_value_with_imod", [  # returns the sell price based on the item's money value and its imod
	(store_script_param, ":item", 1),
	(store_script_param, ":imod", 2),
	(store_item_value, ":score", ":item"),
	(try_begin),
		(eq, ":imod", imod_plain),
		(val_mul, ":score", 100),
	(else_try),
		(eq, ":imod", imod_cracked),
		(val_mul, ":score", 50),
	(else_try),
		(eq, ":imod", imod_rusty),
		(val_mul, ":score", 55),
	(else_try),
		(eq, ":imod", imod_bent),
		(val_mul, ":score", 65),
	(else_try),
		(eq, ":imod", imod_chipped),
		(val_mul, ":score", 72),
	(else_try),
		(eq, ":imod", imod_battered),
		(val_mul, ":score", 75),
	(else_try),
		(eq, ":imod", imod_poor),
		(val_mul, ":score", 80),
	(else_try),
		(eq, ":imod", imod_crude),
		(val_mul, ":score", 83),
	(else_try),
		(eq, ":imod", imod_old),
		(val_mul, ":score", 86),
	(else_try),
		(eq, ":imod", imod_cheap),
		(val_mul, ":score", 90),
	(else_try),
		(eq, ":imod", imod_fine),
		(val_mul, ":score", 190),
	(else_try),
		(eq, ":imod", imod_well_made),
		(val_mul, ":score", 250),
	(else_try),
		(eq, ":imod", imod_sharp),
		(val_mul, ":score", 160),
	(else_try),
		(eq, ":imod", imod_balanced),
		(val_mul, ":score", 350),
	(else_try),
		(eq, ":imod", imod_tempered),
		(val_mul, ":score", 670),
	(else_try),
		(eq, ":imod", imod_deadly),
		(val_mul, ":score", 850),
	(else_try),
		(eq, ":imod", imod_exquisite),
		(val_mul, ":score", 1450),
	(else_try),
		(eq, ":imod", imod_masterwork),
		(val_mul, ":score", 1750),
	(else_try),
		(eq, ":imod", imod_heavy),
		(val_mul, ":score", 190),
	(else_try),
		(eq, ":imod", imod_strong),
		(val_mul, ":score", 490),
	(else_try),
		(eq, ":imod", imod_powerful),
		(val_mul, ":score", 320),
	(else_try),
		(eq, ":imod", imod_tattered),
		(val_mul, ":score", 50),
	(else_try),
		(eq, ":imod", imod_ragged),
		(val_mul, ":score", 70),
	(else_try),
		(eq, ":imod", imod_rough),
		(val_mul, ":score", 60),
	(else_try),
		(eq, ":imod", imod_sturdy),
		(val_mul, ":score", 170),
	(else_try),
		(eq, ":imod", imod_thick),
		(val_mul, ":score", 260),
	(else_try),
		(eq, ":imod", imod_hardened),
		(val_mul, ":score", 390),
	(else_try),
		(eq, ":imod", imod_reinforced),
		(val_mul, ":score", 650),
	(else_try),
		(eq, ":imod", imod_superb),
		(val_mul, ":score", 250),
	(else_try),
		(eq, ":imod", imod_lordly),
		(val_mul, ":score", 1150),
	(else_try),
		(eq, ":imod", imod_lame),
		(val_mul, ":score", 40),
	(else_try),
		(eq, ":imod", imod_swaybacked),
		(val_mul, ":score", 60),
	(else_try),
		(eq, ":imod", imod_stubborn),
		(val_mul, ":score", 90),
	(else_try),
		(eq, ":imod", imod_timid),
		(val_mul, ":score", 180),
	(else_try),
		(eq, ":imod", imod_meek),
		(val_mul, ":score", 180),
	(else_try),
		(eq, ":imod", imod_spirited),
		(val_mul, ":score", 650),
	(else_try),
		(eq, ":imod", imod_champion),
		(val_mul, ":score", 1450),
	(else_try),
		(eq, ":imod", imod_fresh),
		(val_mul, ":score", 100),
	(else_try),
		(eq, ":imod", imod_day_old),
		(val_mul, ":score", 100),
	(else_try),
		(eq, ":imod", imod_two_day_old),
		(val_mul, ":score", 90),
	(else_try),
		(eq, ":imod", imod_smelling),
		(val_mul, ":score", 40),
	(else_try),
		(eq, ":imod", imod_rotten),
		(val_mul, ":score", 5),
	(else_try),
		(eq, ":imod", imod_large_bag),
		(val_mul, ":score", 190),
	(try_end),

	(assign, reg0, ":score"),
]),

  #### Autoloot improved by rubik begin
  # ("dplmc_init_item_base_score", set_item_base_score()),

  ("dplmc_get_item_score_with_imod",
    [# returns the score on the item's base score and its imod
      (store_script_param, ":item", 1),
      (store_script_param, ":imod", 2),

      (item_get_type, ":type", ":item"),
      (assign, ":imod_effect", 0), #default modifier
      (try_begin),
        # horse score = horse_speed*horse_armor*horse_sell_price
        (eq, ":type", itp_type_horse),
        # (item_get_slot, ":horse_speed", ":item", dplmc_slot_item_horse_speed),
        # (item_get_slot, ":horse_armor", ":item", dplmc_slot_item_horse_armor),
        (item_get_horse_speed, ":horse_speed", ":item"),
        (item_get_body_armor, ":horse_armor", ":item"),
        # (call_script, "script_dplmc_get_item_value_with_imod", ":item", ":imod"),
        (item_get_value, ":i_score", ":item"),
        # (assign, ":i_score", reg0),

        ## SB : price now secondary (additive) instead of multiplicative with actual attributes
        (item_get_horse_speed, ":horse_speed", ":item"),
        (item_get_horse_maneuver, ":horse_manu", ":item"),
        (item_get_body_armor, ":horse_armor", ":item"),
        (item_get_horse_charge_damage, ":horse_charge", ":item"),
        (item_get_hit_points, ":horse_health", ":item"),

        #imodbits_horse_basic = imodbit_swaybacked|imodbit_lame|imodbit_spirited|imodbit_heavy|imodbit_stubborn
        #imodbits_horse_good = imodbit_spirited|imodbit_heavy
        (try_begin),
          (eq, ":imod", imod_swaybacked),
          (val_sub, ":horse_speed", 2),
          (val_sub, ":horse_manu", 2),
        (else_try), #do not pick lame horses at all other than last resort
          (eq, ":imod", imod_lame),
          (assign, ":horse_speed", 0),
        (else_try),
          (eq, ":imod", imod_heavy),
          (val_add, ":horse_armor", 3),
          (val_add, ":horse_charge", 4),
          (val_add, ":horse_health", 10),
        (else_try),
          (eq, ":imod", imod_stubborn),
          (val_add, ":horse_health", 5),
        (else_try),
          (eq, ":imod", imod_spirited),
          (val_add, ":horse_speed", 1),
          (val_add, ":horse_manu", 1),
          (val_add, ":horse_armor", 1),
          (val_add, ":horse_charge", 1),
        (else_try),
          (eq, ":imod", imod_champion),
          (val_add, ":horse_speed", 2),
          (val_add, ":horse_manu", 2),
          (val_add, ":horse_armor", 2),
          (val_add, ":horse_charge", 2),
        (try_end),

        (val_mul, ":horse_speed", ":horse_manu"),
        (val_add, ":i_score", ":horse_speed"),

        (val_mul, ":horse_charge", ":horse_armor"),
        (val_mul, ":horse_charge", ":horse_health"),
        (val_div, ":horse_charge", 100),#baseline hp
        (val_add, ":i_score", ":horse_charge"),
      (else_try),
        # shield score = shield_size*shield_armor
        (eq, ":type", itp_type_shield),
        # (item_get_slot, ":shield_size", ":item", dplmc_slot_item_shield_size),
        # (item_get_slot, ":shield_armor", ":item", dplmc_slot_item_shield_armor),

        ## SB : factor in speed and height
        (item_get_shield_height, ":shield_height", ":item"),
        (item_get_weapon_length, ":shield_width", ":item"),
        (item_get_body_armor, ":shield_armor", ":item"),
        (item_get_speed_rating, ":shield_speed", ":item"),
        (item_get_hit_points, ":shield_health", ":item"),

        (try_begin),
          (gt, ":shield_height", 0),
          (val_mul, ":shield_width",  ":shield_height"),
          (set_fixed_point_multiplier, 100),
          (store_mul, ":i_score", ":shield_width", 100),
          (store_sqrt, ":i_score", ":i_score"),
          (val_div, ":i_score", 100),
        (else_try),
          # (val_mul, ":shield_width", ":shield_width"),
          (assign, ":i_score", ":shield_width"),
        (try_end),


        #imodbits_shield  = imodbit_cracked | imodbit_battered |imodbit_thick | imodbit_reinforced
        (try_begin),
          # (eq, ":imod", imod_plain),
          # (assign, ":imod_effect", 0),
        # (else_try),
          (eq, ":imod", imod_cracked),
          (assign, ":imod_effect", -4),
          (val_sub, ":shield_health", 56),
        (else_try),
          (eq, ":imod", imod_battered),
          (assign, ":imod_effect", -2),
          (val_sub, ":shield_health", 26),
        (else_try),
          (eq, ":imod", imod_hardened),
          (assign, ":imod_effect", 3),
        (else_try),
          (eq, ":imod", imod_heavy),
          (assign, ":imod_effect", 3),
          (val_add, ":shield_health", 10),
        (else_try),
          (eq, ":imod", imod_thick),
          (assign, ":imod_effect", 2),
          (val_add, ":shield_health", 47),
        (else_try),
          (eq, ":imod", imod_reinforced),
          (assign, ":imod_effect", 4),
          (val_add, ":shield_health", 83),
        (else_try),
          (eq, ":imod", imod_lordly),
          (assign, ":imod_effect", 6),
          (val_add, ":shield_health", 155),
        (try_end),

        (val_add, ":shield_armor", ":imod_effect"),
        (val_add, ":shield_armor", 5), # add 5 to make sure shield_armor greater than 0
        (val_mul, ":i_score", ":shield_armor"),
        (val_mul, ":i_score", ":shield_speed"),
        (val_div, ":i_score", 92), #average speed of all Native's tableau
        (val_add, ":i_score", ":shield_health"), #tie-breaker
      (else_try),
        # armor score = head_armor + body_armor + foot_armor
        (this_or_next|eq, ":type", itp_type_head_armor),
        (this_or_next|eq, ":type", itp_type_body_armor),
        (this_or_next|eq, ":type", itp_type_foot_armor),
        (eq, ":type", itp_type_hand_armor),
        # (item_get_slot, ":head_armor", ":item", dplmc_slot_item_head_armor),
        # (item_get_slot, ":body_armor", ":item", dplmc_slot_item_body_armor),
        # (item_get_slot, ":leg_armor", ":item", dplmc_slot_item_leg_armor),
        (item_get_head_armor, ":head_armor", ":item"),
        (item_get_body_armor, ":body_armor", ":item"),
        (item_get_leg_armor, ":leg_armor", ":item"),
        (store_add, ":i_score", ":head_armor", ":body_armor"),
        (val_add, ":i_score", ":leg_armor"), # get total base score

        (try_begin),
          # (eq, ":imod", imod_plain),
          # (assign, ":imod_effect", 0),
        # (else_try),
          (eq, ":imod", imod_cracked),
          (assign, ":imod_effect", -4),
        (else_try),
          (eq, ":imod", imod_rusty),
          (assign, ":imod_effect", -3),
        (else_try),
          (eq, ":imod", imod_battered),
          (assign, ":imod_effect", -2),
        (else_try),
          (eq, ":imod", imod_crude),
          (assign, ":imod_effect", -1),
        (else_try),
          (eq, ":imod", imod_tattered),
          (assign, ":imod_effect", -3),
        (else_try),
          (eq, ":imod", imod_ragged),
          (assign, ":imod_effect", -2),
        (else_try),
          (eq, ":imod", imod_sturdy),
          (assign, ":imod_effect", 1),
        (else_try),
          (eq, ":imod", imod_thick),
          (assign, ":imod_effect", 2),
        (else_try),
          (eq, ":imod", imod_hardened),
          (assign, ":imod_effect", 3),
        (else_try),
          (eq, ":imod", imod_reinforced),
          (assign, ":imod_effect", 4),
        (else_try),
          (eq, ":imod", imod_lordly),
          (assign, ":imod_effect", 6),
        (try_end),

        (try_begin), # for armors have 2 or 3 defence of different part
          (neq, ":imod_effect", 0), # and item modifers that matter
          (assign, ":imod_effect_mul", 0),
          (try_begin), #do nothing if no armor part at all
            (gt, ":head_armor", 0),
            (store_add, ":temp_armor", ":head_armor", ":imod_effect"),
            (try_begin), #only calculate if imod degrades item's rating
              (gt, ":temp_armor", 0),
              (val_add, ":imod_effect_mul", 1),
            (else_try), #downgrade armor rating to 0 from bad armor instead of going negative
              (val_sub, ":i_score", ":head_armor"),
            (try_end),
          (try_end),
          (try_begin),
            (gt, ":body_armor", 0),
            (store_add, ":temp_armor", ":body_armor", ":imod_effect"),
            (try_begin),
              (gt, ":temp_armor", 0),
              (val_add, ":imod_effect_mul", 1),
            (else_try),
              (val_sub, ":i_score", ":body_armor"),
            (try_end),
          (try_end),
          (try_begin),
            (gt, ":leg_armor", 0),
            (store_add, ":temp_armor", ":leg_armor", ":imod_effect"),
            (try_begin),
              (gt, ":temp_armor", 0),
              (val_add, ":imod_effect_mul", 1),
            (else_try),
              (val_sub, ":i_score", ":leg_armor"),
            (try_end),
          (try_end),

          (val_mul, ":imod_effect", ":imod_effect_mul"),
          (val_add, ":i_score", ":imod_effect"),
        (try_end),
      (else_try),
        # weapon score = max(swing_damage , thrust_damage)
        (this_or_next|eq, ":type", itp_type_one_handed_wpn),
        (this_or_next|eq, ":type", itp_type_two_handed_wpn),
        (this_or_next|eq, ":type", itp_type_bow),
        (this_or_next|eq, ":type", itp_type_crossbow),
        ##diplomacy start+ add extra types
        #(this_or_next|eq, ":type", itp_type_pistol),
        #(this_or_next|eq, ":type", itp_type_musket),
        ##diplomacy end+
        (eq, ":type", itp_type_polearm),
        (item_get_swing_damage, ":swing_damage", ":item"),
        (item_get_thrust_damage, ":thrust_damage", ":item"),
        (assign, reg1, ":swing_damage"), #sb : debug
        (assign, reg2, ":thrust_damage"), #sb : debug
        # (item_get_slot, ":swing_damage", ":item", dplmc_slot_item_swing_damage),
        # (item_get_slot, ":thrust_damage", ":item", dplmc_slot_item_thrust_damage),
        (val_mod, ":swing_damage", 256), # get actual damage value
        (val_mod, ":thrust_damage", 256),
        (assign, ":i_score", ":swing_damage"),
        (val_max, ":i_score", ":thrust_damage"),

        ##SB : get additional parameters
        (item_get_speed_rating, ":item_speed", ":item"),
        (item_get_weapon_length, ":item_length", ":item"),
        #shootspeed?

        (try_begin),
          # (eq, ":imod", imod_plain),
          # (assign, ":imod_effect", 0),
        # (else_try),
          (eq, ":imod", imod_cracked),
          (assign, ":imod_effect", -5),
        (else_try),
          (eq, ":imod", imod_rusty),
          (assign, ":imod_effect", -3),
        (else_try),
          (eq, ":imod", imod_bent),
          (assign, ":imod_effect", -3),
          (val_sub, ":item_speed", 3),
        (else_try),
          (eq, ":imod", imod_chipped),
          (assign, ":imod_effect", -1),
        (else_try), #SB : add fine
          (eq, ":imod", imod_fine),
          (assign, ":imod_effect", 1),
        (else_try),
          (eq, ":imod", imod_balanced),
          (assign, ":imod_effect", 3),
          (val_add, ":item_speed", 3),
        (else_try),
          (eq, ":imod", imod_tempered),
          (assign, ":imod_effect", 4),
        (else_try),
          (eq, ":imod", imod_masterwork),
          (assign, ":imod_effect", 5),
          (val_add, ":item_speed", 1),
        (else_try),
          (eq, ":imod", imod_heavy),
          (assign, ":imod_effect", 2),
          (val_sub, ":item_speed", 2),
        (else_try),
          (eq, ":imod", imod_strong),
          (assign, ":imod_effect", 3),
          (val_sub, ":item_speed", 3),
        (try_end),

        (val_add, ":i_score", ":imod_effect"),
        (try_begin), #try to pre-filter civilian weapons that are improvised from being looted (clubs, scythes, etc that should be passed over)
          (call_script, "script_cf_melee_weapon_is_civilian", ":item"),
          (val_div, ":i_score", 3),
        (try_end),
        (try_begin), #item_get_missile_speed is technically an important rating for ranged weapons, but we'll pretend NPCs can't math
          (this_or_next|is_between, ":type", itp_type_bow, itp_type_thrown),
          (is_between, ":type", itp_type_pistol, itp_type_bullets),
          (val_mul, ":i_score", ":item_speed"),
        (else_try), #assume base of 100 speed, 100 length
          (this_or_next|eq, ":type", itp_type_one_handed_wpn),
          (eq, ":type", itp_type_two_handed_wpn),
          (val_mul, ":item_length", ":item_speed"),
          (val_mul, ":i_score", ":item_length"),
        (else_try), #length priority over speed
          (eq, ":type", itp_type_polearm),
          (try_begin), #unless they're slashing
            (gt, ":thrust_damage", ":swing_damage"),
            (item_has_property, ":item", itp_couchable),
            # (item_has_property, ":item", itp_cant_use_on_horseback),
            (ge, ":item_length", dplmc_pike_length_cutoff),
            (val_sub, ":item_length", 50), #offset
            #no penalty for war spear range
            (val_max, ":item_length", 100),
            (val_mul, ":item_length", 4),
            #item speed rounded off when we couch
            (val_add, ":item_speed", 25),
            (val_div, ":item_speed", 10),
            # (val_mul, ":item_speed", 2),
          (try_end),
          (val_mul, ":item_length", ":item_speed"),
          (val_mul, ":i_score", ":item_length"),
        (try_end),
      (else_try),
        # ammo score = (thrust_damage + imod_effect)*2
        # a_large_bag will make score added by 1 to discriminate the same ammo with the plain modifier
        (this_or_next|eq, ":type", itp_type_arrows),
        (this_or_next|eq, ":type", itp_type_bolts),
        (eq, ":type", itp_type_thrown),
        (item_get_thrust_damage, ":thrust_damage", ":item"),
        (val_mod, ":thrust_damage", 256), # get actual damage value
        (store_add, ":i_score", ":thrust_damage", 3), # SB : make sure imods do not reduce damage to 0

        #imodbits_missile   = imodbit_bent | imodbit_large_bag
        #imodbits_thrown   = imodbit_bent | imodbit_heavy| imodbit_balanced| imodbit_large_bag
        (try_begin),
          (eq, ":imod", imod_plain),
          (val_mul, ":i_score", 2),
        (else_try),
          (eq, ":imod", imod_large_bag),
          (val_mul, ":i_score", 2),
          (val_add, ":i_score", 1),
        (else_try),
          (eq, ":imod", imod_bent),
          (val_sub, ":i_score", 3),
          (val_mul, ":i_score", 2),
        (else_try),
          (eq, ":imod", imod_heavy),
          (val_add, ":i_score", 2),
          (val_mul, ":i_score", 2),
        (else_try),
          (eq, ":imod", imod_balanced),
          (val_add, ":i_score", 3),
          (val_mul, ":i_score", 2),
        (try_end),
      (try_end),

      (assign, reg0, ":i_score"),
    ]),
  #### Autoloot improved by rubik end

###################
# Used in conversations

("dplmc_print_wpn_upgrades_to_s0", [
	(store_script_param_1, ":troop"),

	(str_store_string, s0, "str_empty_string"),
	(troop_get_slot, ":upg", ":troop", dplmc_slot_upgrade_wpn_0),
	(troop_get_inventory_slot, ":item", ":troop", 0),
	(try_begin),
		(ge, ":item", 0),
		(str_store_item_name, s10, ":item"),
	(else_try),
		(str_store_string, s10, "str_dplmc_none"),
	(try_end),
	(val_add, ":upg", "str_dplmc_hero_wpn_slot_none"),
	(str_store_string, s1, ":upg"),
	(str_store_string, s0, "@{s0}^{s1}"),
	(troop_get_slot, ":upg", ":troop", dplmc_slot_upgrade_wpn_1),
	(troop_get_inventory_slot, ":item", ":troop", 1),
	(try_begin),
		(ge, ":item", 0),
		(str_store_item_name, s10, ":item"),
	(else_try),
		(str_store_string, s10, "str_dplmc_none"),
	(try_end),
	(val_add, ":upg", "str_dplmc_hero_wpn_slot_none"),
	(str_store_string, s1, ":upg"),
	(str_store_string, s0, "@{s0}^{s1}"),
	(troop_get_slot, ":upg", ":troop", dplmc_slot_upgrade_wpn_2),
	(troop_get_inventory_slot, ":item", ":troop", 2),
	(try_begin),
		(ge, ":item", 0),
		(str_store_item_name, s10, ":item"),
	(else_try),
		(str_store_string, s10, "str_dplmc_none"),
	(try_end),
	(val_add, ":upg", "str_dplmc_hero_wpn_slot_none"),
	(str_store_string, s1, ":upg"),
	(str_store_string, s0, "@{s0}^{s1}"),
	(troop_get_slot, ":upg", ":troop", dplmc_slot_upgrade_wpn_3),
	(troop_get_inventory_slot, ":item", ":troop", 3),
	(try_begin),
		(ge, ":item", 0),
		(str_store_item_name, s10, ":item"),
	(else_try),
		(str_store_string, s10, "str_dplmc_none"),
	(try_end),
	(val_add, ":upg", "str_dplmc_hero_wpn_slot_none"),
	(str_store_string, s1, ":upg"),
	(str_store_string, s0, "@{s0}^{s1}"),
]),

################################
# Copy this troop's upgrade options to everyone

# ("dplmc_copy_upgrade_to_all_heroes", [
	# (store_script_param_1, ":troop"),

	# (troop_get_slot,":upg_armor", ":troop",dplmc_slot_upgrade_armor),
	# (troop_get_slot,":upg_horse",":troop",dplmc_slot_upgrade_horse),
	# (troop_get_slot,":upg_wpn0",":troop",dplmc_slot_upgrade_wpn_0),
	# (troop_get_slot,":upg_wpn1",":troop",dplmc_slot_upgrade_wpn_1),
	# (troop_get_slot,":upg_wpn2",":troop",dplmc_slot_upgrade_wpn_2),
	# (troop_get_slot,":upg_wpn3",":troop",dplmc_slot_upgrade_wpn_3),

	# (try_for_range, ":hero", companions_begin, companions_end),
		# (troop_set_slot,":hero",dplmc_slot_upgrade_armor,":upg_armor"),
		# (troop_set_slot,":hero",dplmc_slot_upgrade_horse,":upg_horse"),
		# (troop_set_slot,":hero",dplmc_slot_upgrade_wpn_0,":upg_wpn0"),
		# (troop_set_slot,":hero",dplmc_slot_upgrade_wpn_1,":upg_wpn1"),
		# (troop_set_slot,":hero",dplmc_slot_upgrade_wpn_2,":upg_wpn2"),
		# (troop_set_slot,":hero",dplmc_slot_upgrade_wpn_3,":upg_wpn3"),
	# (try_end),
# ]),

####################################
# Let each hero loot from the pool

("dplmc_auto_loot_all", [
    (store_script_param_1, ":pool_troop"),
    (store_script_param_2, ":sreg"),
    # for all the NPCs, in order of party listing

    (party_get_num_companion_stacks, ":num_stacks","p_main_party"),
    (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":this_hero","p_main_party",":i_stack"),
        (is_between, ":this_hero", companions_begin, companions_end),
        #SB : show strings for first iteration
        (call_script, "script_dplmc_auto_loot_troop", ":this_hero", ":pool_troop", ":sreg"),
        (val_add, ":sreg", 1),
    (try_end),

    #SB : get starting index once again
    (store_script_param_2, ":sreg"),
    # pick up any discards and format string
    (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":this_hero","p_main_party",":i_stack"),
        (is_between, ":this_hero", companions_begin, companions_end),
        (try_begin), #if first iteration picked up nothing
          (str_is_empty, ":sreg"),
          (call_script, "script_dplmc_auto_loot_troop", ":this_hero", ":pool_troop", ":sreg"),
        (else_try), #do not overwrite string from first iteration
          (call_script, "script_dplmc_auto_loot_troop", ":this_hero", ":pool_troop", -1),
        (try_end),
        (try_begin), #skip the first one
          (gt, ":sreg", dplmc_loot_string),
          (neg|str_is_empty, ":sreg"), # in case second hasn't picked up changes either
          (str_store_string_reg, s1, ":sreg"),
          (str_store_string_reg, s0, dplmc_loot_string),
          (str_store_string, dplmc_loot_string, "str_dplmc_s0_newline_s1"),
        (try_end),
        (val_add, ":sreg", 1), #go to next string register
    (try_end),

    #Done. Now sort the remainder
    (troop_sort_inventory, ":pool_troop"),

]),


####################################
# let this troop take its pick from the loot pool

("dplmc_auto_loot_troop", [
	# (try_begin),
		(store_script_param, ":troop", 1),
		(store_script_param, ":pool", 2),
		(store_script_param, ":sreg", 3), #SB : new param for storing changes

		(troop_get_slot,":upg_armor", ":troop",dplmc_slot_upgrade_armor),
		(troop_get_slot,":upg_horses",":troop",dplmc_slot_upgrade_horse),

		# dump whatever rubbish is in the main inventory
		(troop_get_inventory_capacity, ":inv_cap", ":troop"),
		(try_for_range, ":i_slot", dplmc_ek_alt_items_end, ":inv_cap"), #SB raise from 10, skip over civilian stuff
			(troop_get_inventory_slot, ":item", ":troop", ":i_slot"),
			(ge, ":item", 0),
			(troop_get_inventory_slot_modifier, ":imod", ":troop", ":i_slot"),
			(troop_add_item, ":pool", ":item", ":imod"), #put it back in the pool
			(troop_set_inventory_slot, ":troop", ":i_slot", -1), # delete it
		(try_end),

        #clear slot
        # (try_for_range, ":slot_no", dplmc_slot_upgrade_wpn_0, dplmc_slot_upgrade_wpn_3 + 1),
          # (troop_slot_eq, ":troop", ":slot_no", 0), #0 is keep
          # (troop_set_slot, "trp_heroes_end", ":slot_no", 999999),
        # (else_try), #otherwise we reset to default
          # (troop_set_slot, "trp_heroes_end", ":slot_no", -1),
        # (try_end),

        #SB : loop, calculate current item's score
        # (assign, ":slot_no", dplmc_slot_upgrade_wpn_0 - 1),
        (try_for_range, ":item_slot", ek_item_0, ek_head),
          #SB : clear the pool troop's ek_slots
          (troop_set_inventory_slot, ":pool", ":item_slot", -1), #delete it
          (store_add, ":slot_no", dplmc_slot_upgrade_wpn_0, ":item_slot"), #pre-increment
          (troop_get_slot, ":item_preference", ":troop", ":slot_no"),
          (gt, ":item_preference", 0), #0 is keep
          (troop_get_inventory_slot, ":item", ":troop", ":item_slot"),
          (ge, ":item", 0), #initial item check
          (troop_get_inventory_slot_modifier, ":imod", ":troop", ":item_slot"),

          (try_begin),
            (store_mod, ":item_type", ":item_preference", meta_itp_mask),
            (item_get_type, ":itp", ":item"),
            (neq, ":itp", ":item_type"),
            (troop_set_inventory_slot, ":troop", ":item_slot", -1), #delete it
            (troop_add_item, ":pool", ":item", ":imod"), # chuck it in the pool
            (assign, ":item", -1), #so we fail this loop
          (try_end),
          (ge, ":item", 0),
          #SB : cache the original equipment to see changes
          (troop_set_inventory_slot, ":pool", ":item_slot", ":item"),
          (troop_set_inventory_slot_modifier, ":pool", ":item_slot", ":imod"),

          (call_script, "script_dplmc_get_item_score_with_imod", ":item", ":imod"),
          (assign, ":cur_value", reg0),
          #check to see whether damage is preferred
          (try_begin),
            (call_script, "script_cf_item_type_has_advanced_autoloot", ":item_type"),
            (store_div, ":dmg_type", ":item_preference", meta_dmg_mask),
            (neq, ":dmg_type", 0),
            (item_get_swing_damage, ":swing_damage", ":item"),
            (item_get_thrust_damage, ":thrust_damage", ":item"),
            (try_begin),
              (ge, ":swing_damage", ":thrust_damage"),
              (item_get_swing_damage_type, ":item_dmg_type", ":item"),
            (else_try),
              (lt, ":swing_damage", ":thrust_damage"),
              (item_get_thrust_damage_type, ":item_dmg_type", ":item"),
            (try_end),
            #check if it matches preference
            (val_add, ":item_dmg_type", 1),
            (eq, ":dmg_type", ":item_dmg_type"),
            (val_mul, ":cur_value", 4),
          (try_end),
          (troop_set_slot, "trp_heroes_end", ":slot_no", ":cur_value"),
        (else_try),
          (eq, ":item_preference", 0), #0 is keep
          (troop_set_slot, "trp_heroes_end", ":slot_no", 999999),
        (else_try), #whether no item or discarded
          (lt, ":item", 0),
          (troop_set_slot, "trp_heroes_end", ":slot_no", 0),
        (try_end),

        # (try_for_range, ":slot_no", dplmc_slot_upgrade_wpn_0, dplmc_slot_upgrade_wpn_3 + 1),
          # (troop_get_slot, reg0, ":troop", ":slot_no"),
          # (troop_get_slot, reg1, "trp_heroes_end", ":slot_no"),
          # (store_sub, reg2, ":slot_no", dplmc_slot_upgrade_wpn_0),
          # (troop_get_inventory_slot, ":item", ":troop", reg2),
          # (try_begin),
            # (eq, ":item", -1),
            # (str_store_string, s1, "str_dplmc_none"),
          # (else_try),
            # (str_store_item_name, s1, ":item"),
          # (try_end),

          # (display_message, "@upgrading slot {reg2} with {reg0}, cur score for {s1}: {reg1}"),
        # (try_end),

		(try_for_range, ":i_slot", ek_head, ek_food),
			(troop_get_inventory_slot, ":item", ":troop", ":i_slot"),
            (troop_set_inventory_slot, ":pool", ":i_slot", -1), #delete it
			(ge, ":item", 0),
            (troop_set_inventory_slot, ":pool", ":i_slot", ":item"), #store it
			(troop_get_inventory_slot_modifier, ":imod", ":troop", ":i_slot"),
            (troop_set_inventory_slot_modifier, ":pool", ":i_slot", ":imod"), #store it
			(try_begin),
				(neq, ":upg_armor", 0), # we're upgrading armors
				(is_between, ":i_slot", ek_head, ek_horse), # it's an armor slot
				(troop_set_inventory_slot, ":troop", ":i_slot", -1), #delete it
				(troop_add_item, ":pool", ":item", ":imod"), # chuck it in the pool
			(else_try),
				(neq, ":upg_horses", 0), # we're upgrading horses
				(eq, ":i_slot", ek_horse), # it's a horse slot
				(troop_set_inventory_slot, ":troop", ":i_slot", -1), #delete it
				(troop_add_item, ":pool", ":item", ":imod"), # chuck it in the pool
			(try_end),
		(try_end),

		# clear best matches
		(assign, ":best_helmet_slot", -1),
		(assign, ":best_helmet_val", 0),
		(assign, ":best_body_slot", -1),
		(assign, ":best_body_val", 0),
		(assign, ":best_boots_slot", -1),
		(assign, ":best_boots_val", 0),
		(assign, ":best_gloves_slot", -1),
		(assign, ":best_gloves_val", 0),
		(assign, ":best_horse_slot", -1),
		(assign, ":best_horse_val", 0),

		# Now search through the pool for the best items
		(troop_get_inventory_capacity, ":inv_cap", ":pool"),
		(try_for_range, ":i_slot", ek_food + 1, ":inv_cap"), #SB: skip cached items
			(troop_get_inventory_slot, ":item", ":pool", ":i_slot"),
			(ge, ":item", 0),
			(troop_get_inventory_slot_modifier, ":imod", ":pool", ":i_slot"),
			(call_script, "script_dplmc_troop_can_use_item", ":troop", ":item", ":imod"),
			(eq, reg0, 1), # can use
			#(call_script, "script_get_item_value_with_imod", ":item", ":imod"),  # use the following instead

			#### Autoloot improved by rubik begin
			# get item_score instead of price
			(call_script, "script_dplmc_get_item_score_with_imod", ":item", ":imod"),
			#### Autoloot improved by rubik end
			(assign, ":score", reg0),
			(item_get_type, ":item_type", ":item"),

			(try_begin),
				(eq, ":item_type", itp_type_horse), #it's a horse
				(eq, ":upg_horses", 1), # we're upgrading horses
				(gt, ":score", ":best_horse_val"),
				(assign, ":best_horse_slot", ":i_slot"),
				(assign, ":best_horse_val", ":score"),
			(else_try), #SB : move armor checks here
				(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1), # we're checking armor
				(eq, ":upg_armor", 1), # we're upgrading armor
				(try_begin),
					(eq, ":item_type", itp_type_head_armor),
					(gt, ":score", ":best_helmet_val"),
					(assign, ":best_helmet_slot", ":i_slot"),
					(assign, ":best_helmet_val", ":score"),
				(else_try),
					(eq, ":item_type", itp_type_body_armor),
					(gt, ":score", ":best_body_val"),
					(assign, ":best_body_slot", ":i_slot"),
					(assign, ":best_body_val", ":score"),
				(else_try),
					(eq, ":item_type", itp_type_foot_armor),
					(gt, ":score", ":best_boots_val"),
					(assign, ":best_boots_slot", ":i_slot"),
					(assign, ":best_boots_val", ":score"),
				(else_try),
					(eq, ":item_type", itp_type_hand_armor),
					(gt, ":score", ":best_gloves_val"),
					(assign, ":best_gloves_slot", ":i_slot"),
					(assign, ":best_gloves_val", ":score"),
				(try_end),
            (else_try), #SB : move weapon checks back here
              (assign, ":limit", dplmc_slot_upgrade_wpn_3 + 1),
              (try_begin), #check for denying use on horseback
                  (this_or_next|gt, ":best_horse_val", 0),
                  (eq, ":upg_horses", 1), # we're upgrading horses
                  (this_or_next|item_has_property, ":item", itp_cant_use_on_horseback),
                  (this_or_next|item_has_property, ":item", itp_cant_reload_on_horseback),
                  (item_has_property, ":item", itp_cant_reload_while_moving_mounted),
                  (assign, ":limit", 0),
              (try_end),
              (try_for_range, ":slot_no", dplmc_slot_upgrade_wpn_0, ":limit"),
                (troop_get_slot, ":item_preference", ":troop", ":slot_no"),
                (neq, ":item_preference", 0), #not keep current
                (store_div, ":damage_type", ":item_preference", meta_dmg_mask),
                (val_mod, ":item_preference", meta_dmg_mask), #get the itp + meta
                (call_script, "script_item_get_type_aux", ":item"),
                (this_or_next|eq, ":item_preference", reg0), #either same meta-type
                (eq, ":item_preference", ":item_type"), #or matching base itp

                #check to see whether damage is preferred
                (try_begin),
                  (neq, ":damage_type", 0),
                  (item_get_swing_damage, ":swing_damage", ":item"),
                  (item_get_thrust_damage, ":thrust_damage", ":item"),
                  (try_begin),
                    (ge, ":swing_damage", ":thrust_damage"),
                    (item_get_swing_damage_type, ":item_dmg_type", ":item"),
                  (else_try),
                    (lt, ":swing_damage", ":thrust_damage"),
                    (item_get_thrust_damage_type, ":item_dmg_type", ":item"),
                  (try_end),
                  #check if it matches preference
                  (val_add, ":item_dmg_type", 1),
                  (eq, ":damage_type", ":item_dmg_type"),
                  (val_mul, ":score", 4),
                (try_end),
                #if current score is not ge, replace item and score
                (neg|troop_slot_ge, "trp_heroes_end", ":slot_no", ":score"),
                (troop_set_slot, "trp_heroes_end", ":slot_no", ":score"),
                (assign, ":limit", -1), #loop break
                (store_sub, ":item_slot", ":slot_no", dplmc_slot_upgrade_wpn_0), #ek item slots
                (troop_get_inventory_slot, ":item_no", ":troop", ":item_slot"),
                (try_begin),
                  (eq, ":item_no", -1),
                  (troop_set_inventory_slot, ":pool", ":i_slot", -1),
                (else_try), #replace into pool
                  (troop_get_inventory_slot_modifier, ":imod_no", ":troop", ":item_slot"),
                  (troop_set_inventory_slot, ":pool", ":i_slot", ":item_no"),
                  (troop_set_inventory_slot_modifier, ":pool", ":i_slot", ":imod_no"),
                (try_end),
                (troop_set_inventory_slot, ":troop", ":item_slot", ":item"),
                (troop_set_inventory_slot_modifier, ":troop", ":item_slot", ":imod"),
                # (try_begin),
                  # (str_store_item_name, s1, ":item"),
                  # (try_begin),
                    # (eq, ":item_no", -1),
                    # (str_store_string, s2, "str_dplmc_none"),
                  # (else_try),
                    # (str_store_item_name, s2, ":item_no"),
                  # (try_end),
                  # (assign, reg1, ":score"),
                  # (display_message, "@{s1} better than {s2}, score of {reg1}"),
                # (try_end),
              (try_end),
            (try_end),
        (try_end),

		# Now we know which ones are the best. Give them to the troop.
		(try_begin),
			(assign, ":best_slot", ":best_helmet_slot"),
			(ge, ":best_slot", 0),
			(troop_get_inventory_slot, ":item", ":pool", ":best_slot"),
			(ge, ":item", 0),
			(troop_get_inventory_slot_modifier, ":imod", ":pool", ":best_slot"),
			(troop_set_inventory_slot, ":troop", ek_head, ":item"),
			(troop_set_inventory_slot_modifier, ":troop", ek_head, ":imod"),
			(troop_set_inventory_slot, ":pool", ":best_slot", -1),
		(try_end),

		(try_begin),
			(assign, ":best_slot", ":best_body_slot"),
			(ge, ":best_slot", 0),
			(troop_get_inventory_slot, ":item", ":pool", ":best_slot"),
			(ge, ":item", 0),
			(troop_get_inventory_slot_modifier, ":imod", ":pool", ":best_slot"),
			(troop_set_inventory_slot, ":troop", ek_body, ":item"),
			(troop_set_inventory_slot_modifier, ":troop", ek_body, ":imod"),
			(troop_set_inventory_slot, ":pool", ":best_slot", -1),
		(try_end),

		(try_begin),
			(assign, ":best_slot", ":best_boots_slot"),
			(ge, ":best_slot", 0),
			(troop_get_inventory_slot, ":item", ":pool", ":best_slot"),
			(ge, ":item", 0),
			(troop_get_inventory_slot_modifier, ":imod", ":pool", ":best_slot"),
			(troop_set_inventory_slot, ":troop", ek_foot, ":item"),
			(troop_set_inventory_slot_modifier, ":troop", ek_foot, ":imod"),
			(troop_set_inventory_slot, ":pool", ":best_slot", -1),
		(try_end),

		(try_begin),
			(assign, ":best_slot", ":best_gloves_slot"),
			(ge, ":best_slot", 0),
			(troop_get_inventory_slot, ":item", ":pool", ":best_slot"),
			(ge, ":item", 0),
			(troop_get_inventory_slot_modifier, ":imod", ":pool", ":best_slot"),
			(troop_set_inventory_slot, ":troop", ek_gloves, ":item"),
			(troop_set_inventory_slot_modifier, ":troop", ek_gloves, ":imod"),
			(troop_set_inventory_slot, ":pool", ":best_slot", -1),
		(try_end),

		(try_begin),
			(assign, ":best_slot", ":best_horse_slot"),
			(ge, ":best_slot", 0),
			(troop_get_inventory_slot, ":item", ":pool", ":best_slot"),
			(ge, ":item", 0),
			(troop_get_inventory_slot_modifier, ":imod", ":pool", ":best_slot"),
			(troop_set_inventory_slot, ":troop", ek_horse, ":item"),
			(troop_set_inventory_slot_modifier, ":troop", ek_horse, ":imod"),
			(troop_set_inventory_slot, ":pool", ":best_slot", -1),
		(try_end),

		# (try_for_range, ":i_slot", ek_item_0, ek_head),
			# (store_add, ":trp_slot", ":i_slot", dplmc_slot_upgrade_wpn_0),
			# (troop_get_slot, ":type", ":troop", ":trp_slot"),
			# (gt, ":type", 0), #we're upgrading for this slot
			# (call_script, "script_dplmc_scan_for_best_item_of_type", ":pool", ":type", ":troop"), #search for the best
			# (assign, ":best_slot", reg0),
			# (neq, ":best_slot", -1), #got something
			# (troop_get_inventory_slot, ":item", ":pool", ":best_slot"), #get it
			# (ge, ":item", 0),
			# (troop_get_inventory_slot_modifier, ":imod", ":pool", ":best_slot"),
			# (troop_set_inventory_slot, ":pool", ":best_slot", -1), #remove from pool
			# (troop_set_inventory_slot, ":troop", ":i_slot", ":item"), #add to slot
			# (troop_set_inventory_slot_modifier, ":troop", ":i_slot", ":imod"),
		# (try_end),

        #SB : string storage
        (try_begin),
          (neq, ":sreg", -1),
          (str_store_troop_name, ":sreg", ":troop"),
          (assign, ":num_changes", 0),
          (assign, ":last_change", 0),
          #three cases : discarded item -1, no change 0, change 1 (upgraded/swapped depending on item flags)
          (try_for_range, ":i_slot", ek_item_0, ek_food),
            (troop_get_inventory_slot, ":old_item", ":pool", ":i_slot"),
            (troop_get_inventory_slot, ":new_item", ":troop", ":i_slot"),
            (try_begin),
              (gt, ":old_item", -1),
              (troop_get_inventory_slot_modifier, ":old_imod", ":pool", ":i_slot"),
              (store_add, ":imod_no", ":old_imod", "str_imod_plain"),
              # (str_store_string, s10, ":imod_no"),
              # (str_store_item_name, s20, ":old_item"),
              # (display_message, "@old:{s10}{s20}"),
            (else_try),
              (assign, ":old_imod", imod_plain),
            (try_end),
            (try_begin),
              (gt, ":new_item", -1),
              (troop_get_inventory_slot_modifier, ":new_imod", ":troop", ":i_slot"),
              (store_add, ":imod_no", ":new_imod", "str_imod_plain"),
              # (str_store_string, s10, ":imod_no"),
              # (str_store_item_name, s20, ":new_item"),
              # (display_message, "@new:{s10}{s20}"),
            (else_try),
              (assign, ":new_imod", imod_plain),
            (try_end),

            # #placeholder swap strings
            # (str_clear, s0), #sreg
            # (str_clear, s1), #new string
            # (str_clear, s10), #imod
            # (str_clear, s20), #item

            (try_begin), #keep current
              (is_between, ":i_slot", ek_item_0, ek_head),
              (store_add, ":upgrade_slot", ":i_slot", dplmc_slot_upgrade_wpn_0),
              (troop_slot_eq, ":troop", ":upgrade_slot", 0),
              (assign, ":item_changed", 0),
            (else_try), #same
              (eq, ":new_item", ":old_item"),
              (eq, ":old_imod", ":new_imod"),
              (assign, ":item_changed", 0),
            (else_try), #discarded
              (eq, ":new_item", -1),
              (gt, ":old_item", -1),
              (assign, ":item_changed", 2),
              (assign, ":item_no", ":old_item"),
              (assign, ":imod_no", ":old_imod"),
            (else_try), #swapped/equipped
              (gt, ":new_item", -1),
              (assign, ":item_changed", 1),
              (assign, ":item_no", ":new_item"),
              (assign, ":imod_no", ":new_imod"),
            (try_end),

            #build string
            (try_begin),
              (gt, ":item_changed", 0),
              (val_add, ":imod_no", "str_imod_plain"),
              (str_store_string, s10, ":imod_no"), #this comes with a space
              (str_store_item_name, s20, ":item_no"),

              (try_begin),
                (neq, ":last_change", 1),
                (eq, ":item_changed", 1),
                (str_store_string, s1, "@equipped {s10}{s20}"),
              (else_try),
                (neq, ":last_change", 2),
                (eq, ":item_changed", 2),
                (str_store_string, s1, "@discarded {s10}{s20}"),
              (else_try), #same as before, no need to qualify
                (str_store_string, s1, "@{s10}{s20}"),
              (try_end),
              (str_store_string_reg, s0, ":sreg"),
              (try_begin), #no comma for first part
                (eq, ":num_changes", 0),
                (str_store_string, ":sreg", "str_s0_s1"),
              (else_try),
                (str_store_string, ":sreg", "str_dplmc_s0_comma_s1"),
              (try_end),
              # (assign, reg1, ":num_changes"),
              # (display_message, "@{reg1} : {s1}"),
              (val_add, ":num_changes", ":item_changed"),
              (assign, ":last_change", ":item_changed"),
            (try_end),
          (try_end),
          (try_begin), #discard if we didn't touch the inventory at all
            (le, ":num_changes", 0), #this is a flag, not a count
            (str_clear, ":sreg"),
          (try_end),
        (try_end),

    # (try_end),
]),

#######################
# Search for the most expensive item of a specified type

##diplomacy start+
#"script_dplmc_scan_for_best_item_of_type"
#
#INPUT:
#   arg1 :troop
#   arg2 :item_type
#   arg3 :troop_using
#
#OUTPUT:
#   reg0 index of best item (-1 if not found)
##diplomacy end+
("dplmc_scan_for_best_item_of_type", [
	(store_script_param, ":troop",1),
	(store_script_param, ":item_type",2),
	(store_script_param, ":troop_using", 3),


    #SB : parse damage type and meta type (if any)
    # (store_div, ":dmg_type", ":item_type", meta_dmg_mask),
    (store_mod, ":meta_type", ":item_type", meta_dmg_mask), #use this instead
    (store_mod, ":item_type", ":meta_type", meta_itp_mask), #base type

    (assign, ":best_slot", -1),
    (assign, ":best_value", -1),
    # iterate through the list of items
    (troop_get_inventory_capacity, ":inv_cap", ":troop"),
    (try_for_range, ":i_slot", 0, ":inv_cap"),
        (troop_get_inventory_slot, ":item", ":troop", ":i_slot"),
        (ge, ":item", 0),
        (troop_get_inventory_slot_modifier, ":imod", ":troop", ":i_slot"),
        #(item_get_type, ":this_item_type", ":item"),  use the following instead

        # #### Autoloot improved by rubik begin
        # (try_begin),
            # # (item_slot_eq, ":item", dplmc_slot_two_handed_one_handed, 1),
            # (item_has_property, ":item", itp_type_two_handed_wpn),
            # (neg|item_has_property, ":item", itp_two_handed),
            # (assign, ":this_item_type", 11), # type 11 = two-handed/one-handed
        # (else_try),
            # (item_get_type, ":this_item_type", ":item"),
        # (try_end),
        # #### Autoloot improved by rubik end
        (call_script, "script_item_get_type_aux", ":item"), #SB : compare metatype
        (eq, ":meta_type", reg0), # it's one of the kind we're looking for (meta-type holds itp if none exists)
        (call_script, "script_dplmc_troop_can_use_item", ":troop_using", ":item", ":imod"),
        (eq, reg0, 1), # can use
        #(call_script, "script_get_item_value_with_imod", ":item", ":imod"),  # use the following instead

        #### Autoloot improved by rubik begin
        # get item_score instead of price
        (call_script, "script_dplmc_get_item_score_with_imod", ":item", ":imod"),
        #### Autoloot improved by rubik end
        (assign, ":cur_value", reg0),
        #SB : adjust value here for damage preference
        # (try_begin),
          # (call_script, "script_cf_item_type_has_advanced_autoloot", ":item_type"),
          # (item_get_swing_damage, ":swing_damage", ":item"),
          # (item_get_thrust_damage, ":thrust_damage", ":item"),
          # (try_begin),
            # (ge, ":swing_damage", ":thrust_damage"),
            # (item_get_swing_damage_type, ":item_dmg_type", ":item"),
          # (else_try),
            # (lt, ":swing_damage", ":thrust_damage"),
            # (item_get_thrust_damage_type, ":item_dmg_type", ":item"),
          # (try_end),
          # #check if it matches preference
          # (eq, ":dmg_type", ":item_dmg_type"),
          # (val_mul, ":cur_value", 3),
        # (try_end),
        (gt, ":cur_value", ":best_value"), # best one we've seen yet
        (assign, ":best_slot", ":i_slot"),
        (assign, ":best_value", ":cur_value"),
    (try_end),



    # return the slot of the best one
    (assign, reg0, ":best_slot"),
]),

##diplomacy start+
#"script_dplmc_count_better_items_of_same_type"
#
#INPUT:
#   arg1 :inventory_troop
#   arg2 :item
#   arg2 :item_imod
#   arg3 :troop_using
#
#OUTPUT:
#   reg0 number of items of same type
("dplmc_count_better_items_of_same_type", [
	(store_script_param, ":inventory_troop",1),
	(store_script_param, ":base_item",2),
	(store_script_param, ":base_imod",3),
	(store_script_param, ":troop_using", 4),

	(assign, ":number_better_of_type", 0),
	#(assign, ":total_items_of_type", 0),

	# (item_get_type, ":main_item_type", ":base_item"),
	# (try_begin),
		# (item_has_property, ":item", itp_type_two_handed_wpn),
		# (neg|item_has_property, ":item", itp_two_handed),
		# (assign, ":main_item_type", 11), # type 11 = two-handed/one-handed
	# (try_end),
    #SB : metatype
    (call_script, "script_item_get_type_aux", ":base_item"),
    (assign, ":main_item_type", reg0),

	(call_script, "script_dplmc_get_item_score_with_imod", ":base_item", ":base_imod"),
	(assign, ":primary_score", reg0),

	(call_script, "script_dplmc_troop_can_use_item", ":troop_using", ":base_item", ":base_imod"),
	(assign, ":can_use", 1),
	(try_begin),
		(neq, reg0, 1),
		(assign, ":primary_score", -1000),
		(assign, ":can_use", 0),
	(try_end),
	(assign, ":exact_matches_found", 0),

	(troop_get_inventory_capacity, ":inv_cap", ":inventory_troop"),
	(try_for_range, ":i_slot", 0, ":inv_cap"),
		(troop_get_inventory_slot, ":item", ":inventory_troop", ":i_slot"),
		(ge, ":item", 0),
        # SB : metatype
        (call_script, "script_item_get_type_aux", ":item"),
		(eq, ":main_item_type", reg0),
		#(val_add, ":total_items_of_type", 1),
		(troop_get_inventory_slot_modifier, ":imod", ":inventory_troop", ":i_slot"),
		(call_script, "script_dplmc_troop_can_use_item", ":troop_using", ":item", ":imod"),
		(this_or_next|eq, ":can_use", 0),
			(ge, reg0, 1),
		(try_begin),
			(eq, ":item", ":base_item"),
			(eq, ":imod", ":base_imod"),
			(val_add, ":exact_matches_found", 1),
		(try_end),
		(this_or_next|neq, ":item", ":base_item"),
		(this_or_next|neq, ":imod", ":base_imod"),
			(ge, ":exact_matches_found", 2),
		(call_script, "script_dplmc_get_item_score_with_imod", ":item", ":imod"),
		(ge, reg0, ":primary_score"),#deliberately ge instead of gt because of what I want this for
		(val_add, ":number_better_of_type", 1),
	(try_end),

	(assign, reg0, ":number_better_of_type"),
	#(assign, reg1, ":total_items_of_type"),
]),
##diplomacy end+

("dplmc_copy_upgrade_to_all_heroes",
  [
    (store_script_param_1, ":troop"),
    (store_script_param_2, ":type"),

    (try_begin),
      (eq, ":type", dplmc_wpn_setting_1),
      (troop_get_slot,":upg_wpn0", ":troop",dplmc_slot_upgrade_wpn_0),
      (troop_get_slot,":upg_wpn1", ":troop",dplmc_slot_upgrade_wpn_1),
      (troop_get_slot,":upg_wpn2", ":troop",dplmc_slot_upgrade_wpn_2),
      (troop_get_slot,":upg_wpn3", ":troop",dplmc_slot_upgrade_wpn_3),
      (try_for_range, ":hero", companions_begin, companions_end),
        (troop_set_slot,":hero",dplmc_slot_upgrade_wpn_0,":upg_wpn0"),
        (troop_set_slot,":hero",dplmc_slot_upgrade_wpn_1,":upg_wpn1"),
        (troop_set_slot,":hero",dplmc_slot_upgrade_wpn_2,":upg_wpn2"),
        (troop_set_slot,":hero",dplmc_slot_upgrade_wpn_3,":upg_wpn3"),
      (try_end),
    (else_try),
      (eq, ":type", dplmc_armor_setting),
      (troop_get_slot,":upg_armor", ":troop",dplmc_slot_upgrade_armor),
      (try_for_range, ":hero", companions_begin, companions_end),
        (troop_set_slot,":hero",dplmc_slot_upgrade_armor,":upg_armor"),
      (try_end),
    (else_try),
      (eq, ":type", dplmc_horse_setting),
      (troop_get_slot,":upg_horse", ":troop",dplmc_slot_upgrade_horse),
      (try_for_range, ":hero", companions_begin, companions_end),
        (troop_set_slot,":hero",dplmc_slot_upgrade_horse,":upg_horse"),
      (try_end),
    (try_end),
  ]),

  ("dplmc_get_current_item_for_autoloot",
  [
    (store_script_param_1, ":slot_no"),

    #(try_begin),
      (assign, ":dest_slot", ":slot_no"),
      (troop_get_inventory_slot, ":item", "$temp", ":dest_slot"),
    #(else_try),
    #  (store_sub, ":dest_slot", "$temp", companions_begin),
    #  (val_mul, ":dest_slot", 4),
    #  (val_add, ":dest_slot", 10),
    #  (val_add, ":dest_slot", ":slot_no"),
    #  (troop_get_inventory_slot, ":item", "trp_merchants_end", ":dest_slot"),
    #(try_end),
    (try_begin),
      (ge, ":item", 0),
      (str_store_item_name, s10, ":item"),
    (else_try),
      (str_store_string, s10, "str_dplmc_none"),
    (try_end),
  ]),

  ("dplmc_get_troop_max_hp",
   [
    (store_script_param_1, ":troop"),

    (store_skill_level, ":skill", skl_ironflesh, ":troop"),
    (store_attribute_level, ":attrib", ":troop", ca_strength),
    (val_mul, ":skill", 2),
    (val_add, ":skill", ":attrib"),
    (val_add, ":skill", 35),
    (assign, reg0, ":skill"),
  ]),
  #cc end

  ("dplmc_describe_prosperity_to_s4",
    [
      (store_script_param_1, ":center_no"),

      (str_store_party_name, s60,":center_no"),
      (party_get_slot, ":prosperity", ":center_no", slot_town_prosperity),
      (str_store_string, s4, "str_empty_string"),
      (try_begin),
        (is_between, ":center_no", towns_begin, towns_end),
        (try_begin),
          (eq, ":prosperity", 0),
          (str_store_string, s4, "str_town_prosperity_0"),
        (else_try),
          (is_between, ":prosperity", 1, 11),
          (str_store_string, s4, "str_town_prosperity_10"),
        (else_try),
          (is_between, ":prosperity", 11, 21),
          (str_store_string, s4, "str_town_prosperity_20"),
        (else_try),
          (is_between, ":prosperity", 21, 31),
          (str_store_string, s4, "str_town_prosperity_30"),
        (else_try),
          (is_between, ":prosperity", 31, 41),
          (str_store_string, s4, "str_town_prosperity_40"),
        (else_try),
          (is_between, ":prosperity", 41, 51),
          (str_store_string, s4, "str_town_prosperity_50"),
        (else_try),
          (is_between, ":prosperity", 51, 61),
          (str_store_string, s4, "str_town_prosperity_60"),
        (else_try),
          (is_between, ":prosperity", 61, 71),
          (str_store_string, s4, "str_town_prosperity_70"),
        (else_try),
          (is_between, ":prosperity", 71, 81),
          (str_store_string, s4, "str_town_prosperity_80"),
        (else_try),
          (is_between, ":prosperity", 81, 91),
          (str_store_string, s4, "str_town_prosperity_90"),
        (else_try),
          (is_between, ":prosperity", 91, 101),
          (str_store_string, s4, "str_town_prosperity_100"),
        (try_end),
      (else_try),
        (is_between, ":center_no", villages_begin, villages_end),
        (try_begin),
          (eq, ":prosperity", 0),
          (str_store_string, s4, "str_village_prosperity_0"),
        (else_try),
          (is_between, ":prosperity", 1, 11),
          (str_store_string, s4, "str_village_prosperity_10"),
        (else_try),
          (is_between, ":prosperity", 11, 21),
          (str_store_string, s4, "str_village_prosperity_20"),
        (else_try),
          (is_between, ":prosperity", 21, 31),
          (str_store_string, s4, "str_village_prosperity_30"),
        (else_try),
          (is_between, ":prosperity", 31, 41),
          (str_store_string, s4, "str_village_prosperity_40"),
        (else_try),
          (is_between, ":prosperity", 41, 51),
          (str_store_string, s4, "str_village_prosperity_50"),
        (else_try),
          (is_between, ":prosperity", 51, 61),
          (str_store_string, s4, "str_village_prosperity_60"),
        (else_try),
          (is_between, ":prosperity", 61, 71),
          (str_store_string, s4, "str_village_prosperity_70"),
        (else_try),
          (is_between, ":prosperity", 71, 81),
          (str_store_string, s4, "str_village_prosperity_80"),
        (else_try),
          (is_between, ":prosperity", 81, 91),
          (str_store_string, s4, "str_village_prosperity_90"),
        (else_try),
          (is_between, ":prosperity", 91, 101),
          (str_store_string, s4, "str_village_prosperity_100"),
        (try_end),
      (try_end),
        ]),

  ("dplmc_pay_into_treasury",
    [
      (store_script_param_1, ":amount"),
      (troop_add_gold, "trp_household_possessions", ":amount"),
      (assign, reg0, ":amount"),
      (play_sound, "snd_money_received"),
      (display_message, "@{reg0} denars added to treasury."),
  ]),

  ("dplmc_withdraw_from_treasury",
    [
      (store_script_param_1, ":amount"),
      (troop_remove_gold, "trp_household_possessions", ":amount"),
      (assign, reg0, ":amount"),
      (play_sound, "snd_money_paid"),
      (display_message, "@{reg0} denars removed from treasury."),
  ]),

  ("dplmc_describe_tax_rate_to_s50",
    [
      (store_script_param_1, ":tax_rate"),
      (val_div, ":tax_rate", 25),
      (store_add, ":str_id","str_dplmc_tax_normal", ":tax_rate"),
      (str_store_string, s50, ":str_id"),
  ]),


  ("dplmc_player_troops_leave",
   [
    (store_script_param_1, ":percent"),

    (try_begin),#debug
     (eq, "$cheat_mode", 1),
     (assign, reg0, ":percent"),
     (display_message, "@{!}DEBUG : removing player troops: {reg0}%"),
    (try_end),

    (assign, ":deserters", 0),
    (try_for_parties, ":party_no"),
      (assign, ":remove_troops", 0),
      (try_begin),
        (this_or_next|party_slot_eq, ":party_no", slot_party_type, spt_town),
        (party_slot_eq, ":party_no", slot_party_type, spt_castle),
        (party_slot_eq, ":party_no", slot_town_lord, "trp_player"),
        (assign, ":remove_troops", 1),
      (else_try),
         (eq, "p_main_party", ":party_no"),
         (assign, ":remove_troops", 1),
      (try_end),

      (eq, ":remove_troops", 1),
      (party_get_num_companion_stacks, ":num_stacks",":party_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
        (val_mul, ":stack_size", ":percent"),
        (val_div, ":stack_size", 100),
        (party_stack_get_troop_id, ":troop_id", ":party_no", ":i_stack"),
        (party_remove_members, ":party_no", ":troop_id", ":stack_size"),
        (val_add, ":deserters", ":stack_size"),
      (try_end),
    (try_end),
    (assign, reg0, ":deserters"),
   ]
  ),

  ("dplmc_get_item_buy_price_factor",
    [
	##nested diplomacy start+
    #(store_script_param_1, ":item_kind_id"),
    #(store_script_param_2, ":center_no"),
	#Add two parameters
	(store_script_param, ":item_kind_id", 1),
	(store_script_param, ":center_no", 2),
	(store_script_param, ":customer_no", 3),
	(store_script_param, ":merchant_no", 4),
	##nested diplomacy start+
    (assign, ":price_factor", 100),

	##nested diplomacy start+
    #(call_script, "script_get_trade_penalty", ":item_kind_id"),
	(call_script, "script_dplmc_get_trade_penalty", ":item_kind_id", ":center_no", ":customer_no", ":merchant_no"),
	##nested diplomacy end+
    (assign, ":trade_penalty", reg0),

    (try_begin),
	  ##nested diplomacy start+
	  (gt, ":center_no", 0),
  	  (this_or_next|is_between, ":center_no", centers_begin, centers_end),
		(party_is_active, ":center_no"),

	  (this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_town),
	  (this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_village),
	  ##nested diplomacy end+
      (is_between, ":center_no", centers_begin, centers_end),
      (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
      (store_sub, ":item_slot_no", ":item_kind_id", trade_goods_begin),
      (val_add, ":item_slot_no", slot_town_trade_good_prices_begin),
      (party_get_slot, ":price_factor", ":center_no", ":item_slot_no"),

      (try_begin),
		##nested diplomacy start+
		#OLD:
        #(is_between, ":center_no", villages_begin, villages_end),
        #(party_get_slot, ":market_town", ":center_no", slot_village_market_town),
		##NEW:
		(gt, ":center_no", 0),
		(this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_village),
			(is_between, ":center_no", villages_begin, villages_end),
		(party_get_slot, ":market_town", ":center_no", slot_village_market_town),

		(ge, ":market_town", centers_begin),
		(this_or_next|party_slot_eq, ":market_town", slot_party_type, spt_town),
		(this_or_next|party_slot_eq, ":market_town", slot_party_type, spt_village),
			(is_between, ":market_town", centers_begin, centers_end),
		##nested diplomacy end+
        (party_get_slot, ":price_in_market_town", ":market_town", ":item_slot_no"),
        (val_max, ":price_factor", ":price_in_market_town"),
      (try_end),
	  ##nested diplomacy start+
	  #Enforce constraints
	  (val_clamp, ":price_factor", minimum_price_factor, maximum_price_factor + 1),
	  ##nested diplomacy end+

      #For villages, the good will be sold no cheaper than in the market town
      #This represents the absence of a permanent market -- ie, the peasants retain goods to sell on their journeys to town, and are not about to do giveaway deals with passing adventurers

      (val_mul, ":price_factor", 100), #normalize price factor to range 0..100
      (val_div, ":price_factor", average_price_factor),
    (try_end),

    (store_add, ":penalty_factor", 100, ":trade_penalty"),

    (val_mul, ":price_factor", ":penalty_factor"),
    (val_div, ":price_factor", 100),

    (assign, reg0, ":price_factor"),
    (set_trigger_result, reg0),
  ]),

  ("dplmc_party_calculate_strength",
    [
      (store_script_param_1, ":party"), #Party_id
      (store_script_param_2, ":exclude_leader"), #Party_id

      (assign, reg0,0),
      (party_get_num_companion_stacks, ":num_stacks", ":party"),
      (assign, ":first_stack", 0),
      (try_begin),
        (neq, ":exclude_leader", 0),
        (assign, ":first_stack", 1),
      (try_end),

      (assign, ":sum", 0),
      (try_for_range, ":i_stack", ":first_stack", ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party", ":i_stack"),

        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size",":party",":i_stack"),
        (try_end),
        (val_add, ":sum", ":stack_size"),
      (try_end),
      (assign, reg0, ":sum"),

      (try_begin), #debug
        (eq, "$cheat_mode", 1),
        (display_message, "@{!}DEBUG : sum: {reg0}"),
      (try_end),
  ]),

#script_dplmc_start_alliance_between_kingdoms, 20 days alliance, 40 days truce after that
  # Input: arg1 = kingdom_1, arg2 = kingdom_2, arg3 = initializing_war_peace_cond
  # Output: none
  ("dplmc_start_alliance_between_kingdoms", #sets relations between two kingdoms
    [
      (store_script_param, ":kingdom_a", 1),
      (store_script_param, ":kingdom_b", 2),
      (store_script_param, ":initializing_war_peace_cond", 3),
	  ##diplomacy start+
	  #Since "fac_player_supporters_faction" is used as a shorthand for the faction
	  #run by the player, intercept that here instead of the various places this is
	  #called from.
	  (assign, ":save_reg1", reg1),
	  (call_script, "script_dplmc_translate_inactive_player_supporter_faction_2", ":kingdom_a", ":kingdom_b"),
	  (assign, ":kingdom_a", reg0),
	  (assign, ":kingdom_b", reg1),
	  (assign, reg1, ":save_reg1"),
	  ##diplomacy end+

      (store_relation, ":relation", ":kingdom_a", ":kingdom_b"),
      (val_add, ":relation", 15),
      (val_max, ":relation", 40),
      (set_relation, ":kingdom_a", ":kingdom_b", ":relation"),
      (call_script, "script_exchange_prisoners_between_factions", ":kingdom_a", ":kingdom_b"),

      (try_begin),
        (eq, "$players_kingdom", ":kingdom_a"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_b"),
        (val_add, ":relation", 15),
        (val_max, ":relation", 40),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_b", ":relation"),
        #(call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", "fac_player_supporters_faction"), #event cancels certain quests
      (else_try),
        (eq, "$players_kingdom", ":kingdom_b"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_a"),
        (val_add, ":relation", 15),
        (val_max, ":relation", 40),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_a", ":relation"),
        #(call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", "fac_player_supporters_faction"), #event cancels certain quests
      (try_end),

      (try_begin),
        (eq, ":initializing_war_peace_cond", 1),
        (str_store_faction_name_link, s1, ":kingdom_a"),
        (str_store_faction_name_link, s2, ":kingdom_b"),
		##diplomacy start+ #Due to complaints about the wording
        #(display_log_message, "@{s1} and {s2} have concluded an alliance with each other."),
		(display_log_message, "@{s1} and {s2} have entered into an alliance with each other."),
		##diplomacy end+

        (call_script, "script_add_notification_menu", "mnu_dplmc_notification_alliance_declared", ":kingdom_a", ":kingdom_b"), #stability penalty for early peace is in the menu

        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", ":kingdom_b"), #cancels quests
        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", ":kingdom_a"), #cancels quests
        (assign, "$g_recalculate_ais", 1),


      (try_end),

	  (try_begin), #add truce
		(store_add, ":truce_slot", ":kingdom_a", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
	    ##nested diplomacy start+ replace 80 with a named constant
	    #(faction_set_slot, ":kingdom_b", ":truce_slot", 80),
	    (faction_set_slot, ":kingdom_b", ":truce_slot", dplmc_treaty_alliance_days_initial),
	    ##nested diplomacy end+

		(store_add, ":truce_slot", ":kingdom_b", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
	    ##nested diplomacy start+ replace 80 with a named constant
	    #(faction_set_slot, ":kingdom_a", ":truce_slot", 80),
	    (faction_set_slot, ":kingdom_a", ":truce_slot", dplmc_treaty_alliance_days_initial),
	    ##nested diplomacy end+

		(store_add, ":slot_war_damage_inflicted_on_b", ":kingdom_b", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_b", kingdoms_begin),
		(faction_get_slot, ":damage_inflicted_by_a", ":kingdom_a", ":slot_war_damage_inflicted_on_b"),
		(try_begin),
			(lt, ":damage_inflicted_by_a", 100),
			#controversial policy
		(try_end),
		(faction_set_slot, ":kingdom_a", ":slot_war_damage_inflicted_on_b", 0),

		(store_add, ":slot_war_damage_inflicted_on_a", ":kingdom_a", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_a", kingdoms_begin),
		(faction_get_slot, ":damage_inflicted_by_b", ":kingdom_b", ":slot_war_damage_inflicted_on_a"),
		(try_begin),
			(lt, ":damage_inflicted_by_b", 100),
			#controversial policy
		(try_end),
		(faction_set_slot, ":kingdom_b", ":slot_war_damage_inflicted_on_a", 0),

	  (try_end),

    # share wars
    (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
      (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
      (neq, ":kingdom_a", ":faction_no"),
      (neq, ":kingdom_b", ":faction_no"),
      (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction",":kingdom_a", ":faction_no"),
      #result: -1 faction_1 has a casus belli against faction_2. 1, faction_1 has a truce with faction_2, -2, the two factions are at war
      (eq, reg0, -2),
      (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction",":kingdom_b", ":faction_no"),
      (ge, reg0, -1),
      (call_script, "script_diplomacy_start_war_between_kingdoms", ":kingdom_b", ":faction_no", 2),
    (try_end),
    (try_for_range, ":faction_no", kingdoms_begin, kingdoms_end),
      (faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
      (neq, ":kingdom_a", ":faction_no"),
      (neq, ":kingdom_b", ":faction_no"),
      (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction",":kingdom_b", ":faction_no"),
      #result: -1 faction_1 has a casus belli against faction_2. 1, faction_1 has a truce with faction_2, -2, the two factions are at war
      (eq, reg0, -2),
      (call_script, "script_diplomacy_faction_get_diplomatic_status_with_faction",":kingdom_a", ":faction_no"),
      (ge, reg0, -1),
      (call_script, "script_diplomacy_start_war_between_kingdoms", ":kingdom_a", ":faction_no", 2),
    (try_end),
  ]),

#script_dplmc_start_defensive_between_kingdoms, 20 days defensive: 20 days trade aggreement, 20 days non-aggression after that
  # Input: arg1 = kingdom_1, arg2 = kingdom_2, arg3 = initializing_war_peace_cond
  # Output: none
  ("dplmc_start_defensive_between_kingdoms", #sets relations between two kingdoms
    [
      (store_script_param, ":kingdom_a", 1),
      (store_script_param, ":kingdom_b", 2),
      (store_script_param, ":initializing_war_peace_cond", 3),
	  ##diplomacy start+
	  #Since "fac_player_supporters_faction" is used as a shorthand for the faction
	  #run by the player, intercept that here instead of the various places this is
	  #called from.
	  (assign, ":save_reg1", reg1),
	  (call_script, "script_dplmc_translate_inactive_player_supporter_faction_2", ":kingdom_a", ":kingdom_b"),
	  (assign, ":kingdom_a", reg0),
	  (assign, ":kingdom_b", reg1),
	  (assign, reg1, ":save_reg1"),
	  ##diplomacy end+

      (store_relation, ":relation", ":kingdom_a", ":kingdom_b"),
      (val_add, ":relation", 10),
      (val_max, ":relation", 30),
      (set_relation, ":kingdom_a", ":kingdom_b", ":relation"),
      (call_script, "script_exchange_prisoners_between_factions", ":kingdom_a", ":kingdom_b"),

      (try_begin),
        (eq, "$players_kingdom", ":kingdom_a"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_b"),
        (val_add, ":relation", 10),
        (val_max, ":relation", 30),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_b", ":relation"),
        #(call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", "fac_player_supporters_faction"), #event cancels certain quests
      (else_try),
        (eq, "$players_kingdom", ":kingdom_b"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_a"),
        (val_add, ":relation", 10),
        (val_max, ":relation", 30),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_a", ":relation"),
        #(call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", "fac_player_supporters_faction"), #event cancels certain quests
      (try_end),

      (try_begin),
        (eq, ":initializing_war_peace_cond", 1),
        (str_store_faction_name_link, s1, ":kingdom_a"),
        (str_store_faction_name_link, s2, ":kingdom_b"),
        (display_log_message, "@{s1} and {s2} have concluded a defensive pact with each other."),

        (call_script, "script_add_notification_menu", "mnu_dplmc_notification_defensive_declared", ":kingdom_a", ":kingdom_b"), #stability penalty for early peace is in the menu

        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", ":kingdom_b"), #cancels quests
        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", ":kingdom_a"), #cancels quests
        (assign, "$g_recalculate_ais", 1),


      (try_end),

	  (try_begin), #add truce
		(store_add, ":truce_slot", ":kingdom_a", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
	    ##diplomacy start+ replace 60 with named variable
	    #(faction_set_slot, ":kingdom_b", ":truce_slot", 60),
	    (faction_set_slot, ":kingdom_b", ":truce_slot", dplmc_treaty_defense_days_initial),
	    ##diplomacy end+

		(store_add, ":truce_slot", ":kingdom_b", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
	    ##diplomacy start+ replace 60 with named variable
	    #(faction_set_slot, ":kingdom_a", ":truce_slot", 60),
	    (faction_set_slot, ":kingdom_a", ":truce_slot", dplmc_treaty_defense_days_initial),
	    ##diplomacy end+

		(store_add, ":slot_war_damage_inflicted_on_b", ":kingdom_b", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_b", kingdoms_begin),
		(faction_get_slot, ":damage_inflicted_by_a", ":kingdom_a", ":slot_war_damage_inflicted_on_b"),
		(try_begin),
			(lt, ":damage_inflicted_by_a", 100),
			#controversial policy
		(try_end),
		(faction_set_slot, ":kingdom_a", ":slot_war_damage_inflicted_on_b", 0),

		(store_add, ":slot_war_damage_inflicted_on_a", ":kingdom_a", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_a", kingdoms_begin),
		(faction_get_slot, ":damage_inflicted_by_b", ":kingdom_b", ":slot_war_damage_inflicted_on_a"),
		(try_begin),
			(lt, ":damage_inflicted_by_b", 100),
			#controversial policy
		(try_end),
		(faction_set_slot, ":kingdom_b", ":slot_war_damage_inflicted_on_a", 0),

	  (try_end),
  ]),

#script_dplmc_start_trade_between_kingdoms, 20 days trade aggreement, 20 days non-aggression after that
  # Input: arg1 = kingdom_1, arg2 = kingdom_2, arg3 = initializing_war_peace_cond
  # Output: none
  ("dplmc_start_trade_between_kingdoms", #sets relations between two kingdoms
    [
      (store_script_param, ":kingdom_a", 1),
      (store_script_param, ":kingdom_b", 2),
      (store_script_param, ":initializing_war_peace_cond", 3),
	  ##diplomacy start+
	  #Since "fac_player_supporters_faction" is used as a shorthand for the faction
	  #run by the player, intercept that here instead of the various places this is
	  #called from.
	  (assign, ":save_reg1", reg1),
	  (call_script, "script_dplmc_translate_inactive_player_supporter_faction_2", ":kingdom_a", ":kingdom_b"),
	  (assign, ":kingdom_a", reg0),
	  (assign, ":kingdom_b", reg1),
	  (assign, reg1, ":save_reg1"),
	  ##diplomacy end+

      (store_relation, ":relation", ":kingdom_a", ":kingdom_b"),
      (val_add, ":relation", 5),
      (val_max, ":relation", 20),
      (set_relation, ":kingdom_a", ":kingdom_b", ":relation"),
      (call_script, "script_exchange_prisoners_between_factions", ":kingdom_a", ":kingdom_b"),

      (try_begin),
        (eq, "$players_kingdom", ":kingdom_a"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_b"),
        (val_add, ":relation", 5),
        (val_max, ":relation", 20),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_b", ":relation"),
        #(call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", "fac_player_supporters_faction"), #event cancels certain quests
      (else_try),
        (eq, "$players_kingdom", ":kingdom_b"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_a"),
        (val_add, ":relation", 5),
        (val_max, ":relation", 20),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_a", ":relation"),
        #(call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", "fac_player_supporters_faction"), #event cancels certain quests
      (try_end),

      (try_begin),
        (eq, ":initializing_war_peace_cond", 1),
        (str_store_faction_name_link, s1, ":kingdom_a"),
        (str_store_faction_name_link, s2, ":kingdom_b"),
        (display_log_message, "@{s1} and {s2} have concluded a trade agreement with each other."),

        (call_script, "script_add_notification_menu", "mnu_dplmc_notification_trade_declared", ":kingdom_a", ":kingdom_b"), #stability penalty for early peace is in the menu

        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", ":kingdom_b"), #cancels quests
        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", ":kingdom_a"), #cancels quests
        (assign, "$g_recalculate_ais", 1),


      (try_end),

	  (try_begin), #add truce
		(store_add, ":truce_slot", ":kingdom_a", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
	    ##nested diplomacy start+ replace hardcoded number of days with a variable
	    #(faction_set_slot, ":kingdom_b", ":truce_slot", 40),
	    (faction_set_slot, ":kingdom_b", ":truce_slot", dplmc_treaty_trade_days_initial),
	    ##nested diplomacy end+

		(store_add, ":truce_slot", ":kingdom_b", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
	    ##nested diplomacy start+ replace hardcoded number of days with a variable
	    #(faction_set_slot, ":kingdom_a", ":truce_slot", 40),
	    (faction_set_slot, ":kingdom_a", ":truce_slot", dplmc_treaty_trade_days_initial),
	    ##nested diplomacy end+

		(store_add, ":slot_war_damage_inflicted_on_b", ":kingdom_b", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_b", kingdoms_begin),
		(faction_get_slot, ":damage_inflicted_by_a", ":kingdom_a", ":slot_war_damage_inflicted_on_b"),
		(try_begin),
			(lt, ":damage_inflicted_by_a", 100),
			#controversial policy
		(try_end),
		(faction_set_slot, ":kingdom_a", ":slot_war_damage_inflicted_on_b", 0),

		(store_add, ":slot_war_damage_inflicted_on_a", ":kingdom_a", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_a", kingdoms_begin),
		(faction_get_slot, ":damage_inflicted_by_b", ":kingdom_b", ":slot_war_damage_inflicted_on_a"),
		(try_begin),
			(lt, ":damage_inflicted_by_b", 100),
			#controversial policy
		(try_end),
		(faction_set_slot, ":kingdom_b", ":slot_war_damage_inflicted_on_a", 0),

	  (try_end),
  ]),

#script_dplmc_start_nonaggression_between_kingdoms, 20 days non-aggression
  # Input: arg1 = kingdom_1, arg2 = kingdom_2, arg3 = initializing_war_peace_cond
  # Output: none
  ("dplmc_start_nonaggression_between_kingdoms", #sets relations between two kingdoms
    [
      (store_script_param, ":kingdom_a", 1),
      (store_script_param, ":kingdom_b", 2),
      (store_script_param, ":initializing_war_peace_cond", 3),
	  ##diplomacy start+
	  #Since "fac_player_supporters_faction" is used as a shorthand for the faction
	  #run by the player, intercept that here instead of the various places this is
	  #called from.
	  (assign, ":save_reg1", reg1),
	  (call_script, "script_dplmc_translate_inactive_player_supporter_faction_2", ":kingdom_a", ":kingdom_b"),
	  (assign, ":kingdom_a", reg0),
	  (assign, ":kingdom_b", reg1),
	  (assign, reg1, ":save_reg1"),
	  ##diplomacy end+

      (store_relation, ":relation", ":kingdom_a", ":kingdom_b"),
      (val_add, ":relation", 3),
      (val_max, ":relation", 10),
      (set_relation, ":kingdom_a", ":kingdom_b", ":relation"),
      (call_script, "script_exchange_prisoners_between_factions", ":kingdom_a", ":kingdom_b"),

      (try_begin),
        (eq, "$players_kingdom", ":kingdom_a"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_b"),
        (val_add, ":relation", 3),
        (val_max, ":relation", 10),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_b", ":relation"),
        #(call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", "fac_player_supporters_faction"), #event cancels certain quests
      (else_try),
        (eq, "$players_kingdom", ":kingdom_b"),
        (store_relation, ":relation", "fac_player_supporters_faction", ":kingdom_a"),
        (val_add, ":relation", 3),
        (val_max, ":relation", 10),
        (call_script, "script_set_player_relation_with_faction", ":kingdom_a", ":relation"),
        #(call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", "fac_player_supporters_faction"), #event cancels certain quests
      (try_end),

      (try_begin),
        (eq, ":initializing_war_peace_cond", 1),
        (str_store_faction_name_link, s1, ":kingdom_a"),
        (str_store_faction_name_link, s2, ":kingdom_b"),
        (display_log_message, "@{s1} and {s2} have concluded a non aggression pact with each other."),

        (call_script, "script_add_notification_menu", "mnu_dplmc_notification_nonaggression_declared", ":kingdom_a", ":kingdom_b"), #stability penalty for early peace is in the menu

        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_a", ":kingdom_b"), #cancels quests
        (call_script, "script_event_kingdom_make_peace_with_kingdom", ":kingdom_b", ":kingdom_a"), #cancels quests
        (assign, "$g_recalculate_ais", 1),


      (try_end),

	  (try_begin), #add truce
		(store_add, ":truce_slot", ":kingdom_a", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
	    ##nested diplomacy start+ replace hardcoded number with a variable
	    #(faction_set_slot, ":kingdom_b", ":truce_slot", 20),
	    (faction_set_slot, ":kingdom_b", ":truce_slot", dplmc_treaty_truce_days_initial),
	    ##nested diplomacy end+

		(store_add, ":truce_slot", ":kingdom_b", slot_faction_truce_days_with_factions_begin),
		(val_sub, ":truce_slot", kingdoms_begin),
	    ##nested diplomacy start+ replace hardcoded number with a variable
	    #(faction_set_slot, ":kingdom_a", ":truce_slot", 20),
	    (faction_set_slot, ":kingdom_a", ":truce_slot", dplmc_treaty_truce_days_initial),
	    ##nested diplomacy end+

		(store_add, ":slot_war_damage_inflicted_on_b", ":kingdom_b", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_b", kingdoms_begin),
		(faction_get_slot, ":damage_inflicted_by_a", ":kingdom_a", ":slot_war_damage_inflicted_on_b"),
		(try_begin),
			(lt, ":damage_inflicted_by_a", 100),
			#controversial policy
		(try_end),
		(faction_set_slot, ":kingdom_a", ":slot_war_damage_inflicted_on_b", 0),

		(store_add, ":slot_war_damage_inflicted_on_a", ":kingdom_a", slot_faction_war_damage_inflicted_on_factions_begin),
		(val_sub, ":slot_war_damage_inflicted_on_a", kingdoms_begin),
		(faction_get_slot, ":damage_inflicted_by_b", ":kingdom_b", ":slot_war_damage_inflicted_on_a"),
		(try_begin),
			(lt, ":damage_inflicted_by_b", 100),
			#controversial policy
		(try_end),
		(faction_set_slot, ":kingdom_b", ":slot_war_damage_inflicted_on_a", 0),

	  (try_end),
  ]),



# Input: arg1 = faction_no_1, arg2 = faction_no_2
  ("dplmc_get_prisoners_value_between_factions",
   [
       (store_script_param, ":faction_no_1", 1),
       (store_script_param, ":faction_no_2", 2),

       (assign, ":faction_no_1_value", 0),
       (assign, ":faction_no_2_value", 0),

       (try_for_parties, ":party_no"),
         (store_faction_of_party, ":party_faction", ":party_no"),
         (try_begin),
           (eq, ":party_faction", ":faction_no_1"),
           (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
           (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
             (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":party_no", ":troop_iterator"),
             (store_troop_faction, ":cur_faction", ":cur_troop_id"),

             (eq, ":cur_faction", ":faction_no_2"),
             (try_begin),
               (troop_is_hero, ":cur_troop_id"),
               (call_script, "script_calculate_ransom_amount_for_troop", ":cur_troop_id"),
               (val_add, ":faction_no_1_value", reg0),

               (try_begin),#debug
                 (eq, "$cheat_mode", 1),
                 (assign, reg0, ":faction_no_1_value"),
                 (display_message, "@{!}DEBUG : faction_no_1_value: {reg0}"),
               (try_end),

             (try_end),
           (try_end),
         (else_try),
           (eq, ":party_faction", ":faction_no_2"),
           (party_get_num_prisoner_stacks, ":num_stacks", ":party_no"),
           (try_for_range_backwards, ":troop_iterator", 0, ":num_stacks"),
             (party_prisoner_stack_get_troop_id, ":cur_troop_id", ":party_no", ":troop_iterator"),
             (store_troop_faction, ":cur_faction", ":cur_troop_id"),

             (eq, ":cur_faction", ":faction_no_1"),
             (try_begin),
               (troop_is_hero, ":cur_troop_id"),
               (call_script, "script_calculate_ransom_amount_for_troop", ":cur_troop_id"),
               (val_add, ":faction_no_2_value", reg0),

               (try_begin), #debug
                 (eq, "$cheat_mode", 1),
                 (assign, reg0, ":faction_no_2_value"),
                 (display_message, "@{!}DEBUG : faction_no_2_value: {reg0}"),
               (try_end),

             (try_end),
           (try_end),
         (try_end),
       (try_end),
       (store_sub, reg0, ":faction_no_1_value", ":faction_no_2_value"),
    ]),

# Input: arg1 = faction_no_1, arg2 = faction_no_2
  ("dplmc_get_truce_pay_amount",
   [
       (store_script_param, ":faction_no_1", 1),
       (store_script_param, ":faction_no_2", 2),
       (store_script_param, ":check_peace_war_result", 3),
	   ##diplomacy start+
	   #Since "fac_player_supporters_faction" is used as a shorthand for the faction
	   #run by the player, intercept that here instead of the various places this is
	   #called from.
	   (call_script, "script_dplmc_translate_inactive_player_supporter_faction_2", ":faction_no_1", ":faction_no_2"),
	   (assign, ":faction_no_1", reg0),
	   (assign, ":faction_no_2", reg1),
	   ##diplomacy end+

       (try_begin),
         (eq, "$cheat_mode", 1),
         (assign, reg0, ":check_peace_war_result"), #debug
         (display_message, "@{!}DEBUG : peace_war_result: {reg0}"),#debug
       (try_end),

       ##nested diplomacy start+
       #Improve this script; costs were too low befow.
       #faction_no_1 is player faction asking for peace
       #faction_no_2 is NPC faction that already considered peace and considers
       #      it a bad idea, so the price should not be nominal.

       #(Also, a sign error meant that the amount asked was almost always
       #zero.)

       #Because the PC wants peace and the NPC doesn't, we aren't going to
       #bother calculating relative strength or the like.  Instead, we are
       #going to assume the NPC can achieve his strategic objectives if he
       #does not make peace, and set the price accordingly.

       #Add a generic cost for check_peace_war_result
       #These are the same as in Wahiti's original script.
       (assign, ":base_cost",  4000),
       (try_begin),
          #It's dubious that this is ever currently called if the check-peace-war
          #result was >= 0, but include this for completeness.
          (ge, ":check_peace_war_result", 0),
          (assign, ":base_cost", 4000),
       (else_try),
          (ge, ":check_peace_war_result", -1),
          (assign, ":base_cost", 8000),
       (else_try),
          (ge, ":check_peace_war_result", -2),
          (assign, ":base_cost", 12000),
       (else_try),
          #It shouldn't be used with this parameter; this is for the
          #sake of completeness.
          (le, ":check_peace_war_result", -3),
          (store_mul, ":base_cost", -6000, ":check_peace_war_result"),
       (try_end),

       #Get reparations for held centers.  A truce lasts 20 days, so the
       #value "lost" in rents and tarriffs by declaring peace now cannot be
       #is not greater than 3 times the weekly average (that upper bound is
       #if the NPC is in a position to immediately recapture all of them).

       #If the NPC kingdom is currently attacking a specific village or walled
       #center, even if it isn't an ex-possession it effectively becomes one.
       #(Also, assign it or its center as a demanded fief if there wasn't one
       #already.)
       (assign, ":target_fief", -1),
       (try_begin),
          (lt, ":check_peace_war_result", 1),#This should always be true anyway, but still.
          (this_or_next|faction_slot_eq, ":faction_no_2", slot_faction_ai_state, sfai_attacking_center),
          (faction_slot_eq, ":faction_no_2", slot_faction_ai_state, sfai_raiding_village),
          (faction_get_slot, reg0, ":faction_no_2", slot_faction_ai_object),
          (is_between, reg0, centers_begin, centers_end),
          (assign, ":target_fief", reg0),
       (try_end),

       (assign, ":center_cost", 0),
       (assign, ":concession_value", 0),
       #This this old are newer are considered "recently conquered", meaning that
       #faction_no_2 thinks there's a good chance they could reclaim them if the
       #fighting continued.
       (store_current_hours, ":recently_conquered"),
       (try_begin),
          (ge, ":check_peace_war_result", 1),#ordinarily this should not be true
          (val_sub, ":recently_conquered", 24 * 2),#only the last two days
       (else_try),
          (eq, ":check_peace_war_result", 0),
          (val_sub, ":recently_conquered", 24 * 15),#last 15 days
       (else_try),
          (eq, ":check_peace_war_result", -1),
          (val_sub, ":recently_conquered", 24 * 20),#last 20 days
       (else_try),
          (eq, ":check_peace_war_result", -2),
          (val_sub, ":recently_conquered", 24 * 30),#last 30 days
       (else_try),
          (val_sub, ":recently_conquered", 24 * 60),#last 60 days
       (try_end),

       (try_for_range, ":party_no", centers_begin, centers_end),
          (store_faction_of_party, ":party_current_faction", ":party_no"),
          (eq, ":party_current_faction", ":faction_no_1"),

          #party_value is the estimated weekly income of the fief,
          #applied three times and time discounted
          (call_script, "script_dplmc_estimate_center_weekly_income", ":party_no"),
          (store_mul, ":party_value", reg0, 3),

          (try_begin),
             (ge, "$g_concession_demanded", spawn_points_begin),
             (this_or_next|eq, "$g_concession_demanded", ":party_no"),
             (party_slot_eq, ":party_no", slot_village_bound_center, "$g_concession_demanded"),
             (val_add, ":concession_value", ":party_value"),
          (try_end),

          (assign, ":continue", 0),

          (try_begin),
             #A former possession of faction 2 (must have recently changed hands, or
             #faction 2 must be enthusiastic about the war)
             (party_slot_eq, ":party_no", slot_center_original_faction, ":faction_no_2"),
             (party_slot_ge, ":party_no", dplmc_slot_center_last_transfer_time, ":recently_conquered"),
             (assign, ":continue", 1),
          (else_try),
             #A former possession of faction 2 (must have recently changed hands, or
             #faction 2 must be enthusiastic about the war)
             (party_slot_eq, ":party_no", slot_center_ex_faction, ":faction_no_2"),
             (party_slot_ge, ":party_no", dplmc_slot_center_last_transfer_time, ":recently_conquered"),
             (assign, ":continue", 1),
          (else_try),
             #The center is being attacked by faction 2, or is a village whose castle
             #or town is being attacked by faction 2.
             (ge, ":target_fief", centers_begin),
             (this_or_next|eq, ":party_no", ":target_fief"),
             (party_slot_eq, ":party_no", slot_village_bound_center, ":target_fief"),
             (assign, ":continue", 1),
          (else_try),
             #The center is under siege by faction 2.
             (party_get_slot, reg0, ":party_no", slot_center_is_besieged_by),
             (gt, reg0, 0),
             (party_is_active, reg0),
             (store_faction_of_party, reg0, reg0),
             (eq, reg0, ":faction_no_2"),
             (assign, ":continue", 1),
          (else_try),
             #The center is a village, and the castle or town it is bound to
             #is under siege by faction 2.
             (is_between, ":party_no", villages_begin, villages_end),
             (party_get_slot, reg0, ":party_no", slot_village_bound_center),
             (is_between, reg0, centers_begin, centers_end),
             (party_get_slot, reg0, reg0, slot_center_is_besieged_by),
             (gt, reg0, -1),
             (party_is_active, reg0),
             (store_faction_of_party, reg0, reg0),
             (eq, reg0, ":faction_no_2"),
             (assign, ":continue", 1),
          (try_end),

          (gt, ":continue", 0),

          (val_add, ":center_cost", ":party_value"),
       (try_end),

       #If no held centers were found, assume the campaign objective is to
       #conquer territory rather than recover lost territory, if the
       #NPC is sufficiently enthusiastic about the war.
       (try_begin),
          #Equivalent of a castle and a village
          (eq, ":check_peace_war_result", -1),
          (val_max, ":center_cost", (1500 + 750) * 3),
       (else_try),
          #Equivalent of two castles with two villages
          (le, ":check_peace_war_result", -2),
          (val_max, ":center_cost", (1500 + 750) * 3 * 2),
       (try_end),

	   #If the war started very recently, or a center changed hands very recently,
	   #increase the cost.  The reasoning behind this is to make the AI less prone
	   #to whipsawing.
	   #
	   #The multiplier is 2x for the first 48 hours, then decreases linearly from
       #the two-day mark until it reaches zero at the 8-day mark.
	   #
	   #As an example, here is how a cost of 10,000 would scale over this time:
	   # 1 day  - 20000
	   # 2 days - 20000
	   # 3 days - 18333
	   # 4 days - 16667
	   # 5 days - 15000
	   # 6 days - 13333
	   # 7 days - 11667
	   # 8 days - 10000
	   # 9 days - 10000
	   (store_current_hours, ":cur_hours"),
       (faction_get_slot, ":faction_ai_last_decisive_event", ":faction_no_2", slot_faction_ai_last_decisive_event),
       (store_sub, ":hours_since_last_decisive_event", ":cur_hours", ":faction_ai_last_decisive_event"),
	   (val_max, ":hours_since_last_decisive_event", 0),
	   (try_begin),
	      #First 48 hours, the base & center costs are doubled.
	      (lt, ":hours_since_last_decisive_event", 48 + 1),
		  (val_mul, ":base_cost", 2),
		  (val_mul, ":center_cost", 2),
	   (else_try),
	      #From 2 days to 8 days, the cost multiplier goes from 2 to 1
		  (lt, ":hours_since_last_decisive_event", 24 * 8),
		  (store_sub, reg0, 24 * 2, ":hours_since_last_decisive_event"),#0 to 6 days
		  (store_sub, ":multiplier", 24 * 12, reg0),# 6 to 12 days

		  (val_mul, ":base_cost", ":multiplier"),
		  (val_add, ":base_cost", (24 * 6) // 2),
		  (val_div, ":base_cost", 24 * 6),

		  (val_mul, ":center_cost", ":multiplier"),
		  (val_add, ":center_cost", (24 * 6) // 2),
		  (val_div, ":center_cost", 24 * 6),
	   (try_end),

       #Get (value of ransoms held by faction #1) - (value of ransoms held by faction #2)
       (call_script, "script_dplmc_get_prisoners_value_between_factions", ":faction_no_1", ":faction_no_2"),

       (try_begin),
         (eq, "$cheat_mode", 1),
         (display_message, "@{!}DEBUG : prisoner_value: {reg0}"),#debug
       (try_end),
       (assign, ":prisoner_value", reg0),

       #Write result to reg0
       (store_add, reg0, ":base_cost", ":center_cost"),

	   #Scale for the player's wealth, to partially mitigate the problem
	   #of the cost becoming meaningless as the player's wealth increases.
	   #(Scale less than 1-to-1, so it is possible to become richer in real
	   #terms.)  This is also aimed at reducing the necessity of replacing
	   #the values in mods that alter gold scarcity.
	   (store_troop_gold, ":player_gold", "trp_household_possessions"),
	   (store_troop_gold, reg1, "trp_player"),
	   (val_add, ":player_gold", reg1),
	   (try_begin),
		  #Arbitrarily pick 100,000 as the target wealth, since that's when
		  #you get the Steam "gold farmer" achievement.
	      (gt, ":player_gold", 100000),
		  (store_div, reg1, ":player_gold", 1000),
		  (val_mul, reg1, reg0),
		  (val_div, reg1, 100),

		  (val_add, reg0, reg1),
		  (val_div, reg0, 2),

		  #Apply the same scaling to the concession value
		  (store_div, reg1, ":player_gold", 1000),
		  (val_mul, reg1, ":concession_value"),
		  (val_div, reg1, 100),

		  (val_add, ":concession_value", reg1),
		  (val_div, ":concession_value", 2),
	   (try_end),

       #Take into account campaign difficulty
	   (assign, ":min_cost", reg0),
       (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
       (try_begin),
           (eq, ":reduce_campaign_ai", 0), #hard (1.5x)
           (val_mul, reg0, 3),
           (val_div, reg0, 2),
		   (val_mul, ":min_cost", 87),#set min_cost to 87% of the original base_cost + center_cost
		   (val_div, ":min_cost", 100),
       (else_try),
           (eq, ":reduce_campaign_ai", 1), #moderate (1.0x)
		   (val_mul, ":min_cost", 3),
		   (val_div, ":min_cost", 4),#set min_cost to 75% (base cost + center cost)
       (else_try),
            (eq, ":reduce_campaign_ai", 2), #easy (0.75x)
            (val_mul, reg0, 3),
			(val_div, reg0, 4),
			(val_mul, ":min_cost", 9),
			(val_div, ":min_cost", 16),#set min_cost to (75% squared) of (base cost + center cost)
       (try_end),

       (val_sub, reg0, ":prisoner_value"),

       #Because the NPC kingdom doesn't want peace, it will not agree to peace
       #for free, as that would be a contradiction.
       (val_max, reg0, ":min_cost"),

       (try_begin),
         (eq, "$cheat_mode", 1),
         (display_message, "@{!}DEBUG : peace_war_result after prisoners: {reg0}"),#debug
       (try_end),

       #The value of the concession (if any) was already calculated above
       (assign, reg1, -1),
       (try_begin),
          (gt, "$g_concession_demanded", 0),
       	  (gt, ":concession_value", 0),
          (store_sub, reg1, reg0, ":concession_value"),
          (val_max, reg1, 0),
          #Only accept cash alone in lieu of a fief if you don't partcularly
          #want war, or if the AI is on "easy".
          (try_begin),
             (neq, ":reduce_campaign_ai", 2),#hard or medium
             (lt, ":check_peace_war_result", 0),
             (assign, reg0, -1),
          (try_end),
       (try_end),

     (try_begin), #debug
       (eq, "$cheat_mode", 1),
	     (display_message, "@{!}DEBUG : truce_pay_amount0: {reg0}"),
	     (display_message, "@{!}DEBUG : truce_pay_amount1: {reg1}"),
     (try_end),
     ##nested diplomacy end+
    ]),

  ("dplmc_player_center_surrender",
  [
    (store_script_param, ":center_no", 1),

    #protect player for 24 hours
    (store_current_hours,":protected_until"),
    (val_add, ":protected_until", 48),
    (party_get_slot, ":besieger", ":center_no", slot_center_is_besieged_by),
    (store_faction_of_party, ":besieger_faction",":besieger"),
    ##nested diplomacy start+
    #In this version this variable currently isn't used for anything
    #(party_stack_get_troop_id, ":enemy_party_leader", ":besieger", 0),
    ##nested diplomacy end+

    (party_set_slot,":besieger",slot_party_ignore_player_until,":protected_until"),
    (party_ignore_player, ":besieger", 48),
	##nested diplomacy start+
	#Add support for promoted kingdom ladies
    #(try_for_range, ":lord", active_npcs_begin, active_npcs_end),
	(try_for_range, ":lord", heroes_begin, heroes_end),
	  (this_or_next|is_between, ":lord", active_npcs_begin, active_npcs_end),
	  (troop_slot_eq, ":lord", slot_troop_occupation, slto_kingdom_hero),
	##nested diplomacy end+
      (store_faction_of_troop, ":lord_faction", ":lord"),
      (eq, ":lord_faction", ":besieger_faction"),
      (troop_get_slot, ":led_party", ":lord", slot_troop_leaded_party),
      (party_is_active, ":led_party"),

      (party_slot_eq, ":led_party", slot_party_ai_state, spai_accompanying_army),
      (party_slot_eq, ":led_party", slot_party_ai_object, ":besieger"),

      (party_is_active, ":besieger"),
      (store_distance_to_party_from_party, ":distance_to_marshal", ":led_party", ":besieger"),
      (lt, ":distance_to_marshal", 20),

      (party_set_slot,":led_party",slot_party_ignore_player_until,":protected_until"),
      (party_ignore_player, ":led_party", 48),
    (try_end),

    (party_set_faction,"$current_town","fac_neutral"), #temporarily erase faction so that it is not the closest town
    (party_get_num_attached_parties, ":num_attached_parties_to_castle",":center_no"),
    (try_for_range_backwards, ":iap", 0, ":num_attached_parties_to_castle"),
      (party_get_attached_party_with_rank, ":attached_party", ":center_no", ":iap"),
      (party_detach, ":attached_party"),
      (party_get_slot, ":attached_party_type", ":attached_party", slot_party_type),
      (eq, ":attached_party_type", spt_kingdom_hero_party),
      (neq, ":attached_party_type", "p_main_party"),
      (store_faction_of_party, ":attached_party_faction", ":attached_party"),
      (call_script, "script_get_closest_walled_center_of_faction", ":attached_party", ":attached_party_faction"),
      (try_begin),
        (gt, reg0, 0),
        (call_script, "script_party_set_ai_state", ":attached_party", spai_holding_center, reg0),
      (else_try),
        (call_script, "script_party_set_ai_state", ":attached_party", spai_patrolling_around_center, ":center_no"),
      (try_end),
    (try_end),
    (call_script, "script_party_remove_all_companions", ":center_no"),
    (change_screen_return),
    (party_collect_attachments_to_party, ":center_no", "p_collective_enemy"), #recalculate so that
    (call_script, "script_party_copy", "p_encountered_party_backup", "p_collective_enemy"), #leaving troops will not be considered as captured

	##nested diplomacy start+
	#Anyone who lost a fief due to your surrender will be irritated
	(try_for_range, ":village_no", centers_begin, centers_end),
       (party_slot_eq, ":village_no", slot_village_bound_center, ":center_no"),
	   (party_get_slot, ":village_lord", ":village_no", slot_town_lord),
	   (neq, ":village_lord", "trp_player"),
	   (is_between, ":village_lord", heroes_begin, heroes_end),
	   (call_script, "script_change_player_relation_with_troop", ":village_lord", -1),
    (try_end),
	##nested diplomacy end+
    ##diplomacy
    (call_script, "script_give_center_to_faction", "$current_town", ":besieger_faction"),
    (call_script, "script_order_best_besieger_party_to_guard_center", ":center_no", ":besieger_faction"),

    #relation and controversy
    ##nested diplomacy start+, There should be no relation bonus with the enemy lord
    #(call_script, "script_change_player_relation_with_troop", ":enemy_party_leader", 2),
    ##nested diplomacy end+
    (try_begin),
      (gt, "$players_kingdom", 0),
      (neq, "$players_kingdom", "fac_player_supporters_faction"),
      (neq, "$players_kingdom", "fac_player_faction"),
      (faction_get_slot, ":faction_leader", "$players_kingdom", slot_faction_leader),
  	  ##diplomacy start+
	  ##OLD:
      #(neq, ":faction_leader", "trp_player"),
	  ##NEW:
	  #Also guard against faction leader being some invalid negative number
	  (gt, ":faction_leader", "trp_player"),
	  ##diplomacy end+
      (call_script, "script_change_player_relation_with_troop", ":faction_leader", -2),
    (try_end),

  	(troop_get_slot, ":controversy", "trp_player", slot_troop_controversy),
  	(val_add, ":controversy", 4),
  	(val_min, ":controversy", 100),
  	(troop_set_slot, "trp_player", slot_troop_controversy, ":controversy"),
    ##nested diplmacy start+ add garrison to fief
    #The average # of troops added by script_cf_reinforce_party is 11.5.
    (assign, ":garrison_strength", 3),#easy: 34.5 for a castle
    (try_begin),
       (party_slot_eq, ":center_no", slot_party_type, spt_town),
       (assign, ":garrison_strength", 9),#easy: 103.5 for a town
    (try_end),
    #Take into account campaign difficulty.
    (game_get_reduce_campaign_ai, ":reduce_campaign_ai"),
    (try_begin),
       (eq, ":reduce_campaign_ai", 0), #hard 166% + 3 waves
       (val_mul, ":garrison_strength", 5),
       (val_div, ":garrison_strength", 3),
       (val_add, ":garrison_strength", 3),
    (else_try),
       (eq, ":reduce_campaign_ai", 1), #moderate 166%
       (val_mul, ":garrison_strength", 5),
       (val_div, ":garrison_strength", 3),
    #(else_try),
    #   (eq, ":reduce_campaign_ai", 2), #easy 100%
    #   (store_mul, ":garrison_strength", 1),
    (try_end),

    (try_for_range, ":unused", 0, ":garrison_strength"),
       (call_script, "script_cf_reinforce_party", ":center_no"),
    (try_end),
    (try_for_range, ":unused", 0, 7),# ADD some XP initially
       (store_mul, ":xp_range_min", 150, ":garrison_strength"),
       (store_mul, ":xp_range_max", 200, ":garrison_strength"),
       (store_random_in_range, ":xp", ":xp_range_min", ":xp_range_max"),
       (party_upgrade_with_xp, ":center_no", ":xp", 0),
    (try_end),
    ##nested diplomacy end+
  ]),


  ("dplmc_send_messenger_to_troop",
  [
    (store_script_param, ":target_troop", 1),
    (store_script_param, ":message", 2),
    (store_script_param, ":orders_object", 3),

    #SB : correcting destination for lords waiting to respawn
    (troop_get_slot, ":target_party", ":target_troop", slot_troop_leaded_party),
    (try_begin),
      (le, ":target_party", 0),
      (call_script, "script_lord_get_home_center", ":target_troop"),
      (assign, ":target_party", reg0),
    (try_end),

    (set_spawn_radius, 1),
    (spawn_around_party, "$current_town", "pt_messenger_party"),
    (assign,":spawned_party",reg0),
    #SB : factionalized messenger
    (store_faction_of_party, ":faction_no", ":target_party"),
    (try_begin),
      (eq, ":faction_no", "fac_player_supporters_faction"),
      (is_between, "$g_player_culture", npc_kingdoms_begin, kingdoms_end),
      (assign, ":faction_no", "$g_player_culture"),
    (try_end),
    (try_begin),
      (is_between, ":faction_no", npc_kingdoms_begin, kingdoms_end),
      (faction_get_slot, ":messenger_troop", ":faction_no", slot_faction_messenger_troop),
    (else_try),
      (assign, ":messenger_troop", "trp_dplmc_messenger"),
    (try_end),
    (party_add_members, ":spawned_party", ":messenger_troop", 1),


    (try_begin),
      (eq, ":message", spai_accompanying_army),
      (assign, ":orders_object", "p_main_party"),
    (try_end),

    # (party_add_members, ":spawned_party", "trp_dplmc_messenger", 1),
    (store_faction_of_troop, ":player_faction", "trp_player"),
    (party_set_faction, ":spawned_party", ":player_faction"),
    (party_set_slot, ":spawned_party", slot_party_type, spt_messenger),
    (party_set_slot, ":spawned_party", dplmc_slot_party_mission_diplomacy, ":message"),
    (party_set_slot, ":spawned_party", slot_party_home_center, "$current_town"),

    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_object, ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_orders_object, ":orders_object"),
    #SB : cache the actual troop while going towards known center
    (party_set_slot, ":spawned_party", dplmc_slot_party_origin, ":target_troop"),

    (try_begin), #debug
      (eq, "$cheat_mode", 1),
      (str_store_party_name, s13, ":target_party"),
      (display_message, "@{!}DEBUG - Send message to {s13}"),
    (try_end),
  ]
  ),

  ("dplmc_send_messenger_to_party",
  [
    (store_script_param, ":target_party", 1),
    (store_script_param, ":message", 2),
    (store_script_param, ":orders_object", 3),

    (set_spawn_radius, 1),
    (spawn_around_party, "$current_town", "pt_messenger_party"),
    (assign, ":spawned_party", reg0),

    #SB : factionalized messenger
    (store_faction_of_party, ":faction_no", ":target_party"),
    (try_begin),
      (eq, ":faction_no", "fac_player_supporters_faction"),
      (is_between, "$g_player_culture", npc_kingdoms_begin, kingdoms_end),
      (assign, ":faction_no", "$g_player_culture"),
    (try_end),

    (try_begin),
      (is_between, ":faction_no", npc_kingdoms_begin, kingdoms_end),
      (faction_get_slot, ":messenger_troop", ":faction_no", slot_faction_messenger_troop),
    (else_try),
      (assign, ":messenger_troop", "trp_dplmc_messenger"),
    (try_end),
    (party_add_members, ":spawned_party", ":messenger_troop", 1),
    (party_set_faction, ":spawned_party", "fac_player_faction"),
    (party_set_slot, ":spawned_party", slot_party_type, spt_messenger),
    (party_set_slot, ":spawned_party", dplmc_slot_party_mission_diplomacy, ":message"),
    (party_set_slot, ":spawned_party", slot_party_home_center, "$current_town"),

    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_object, ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_orders_object, ":orders_object"),

    (try_begin), #debug
      (eq, "$cheat_mode", 1),
      (str_store_party_name, s13, ":target_party"),
      (display_message, "@{!}DEBUG - Send message to {s13}"),
    (try_end),
  ]
  ),

  ("dplmc_send_gift",
    [
    (store_script_param, ":target_troop", 1),
    (store_script_param, ":gift", 2),
    (store_script_param, ":amount", 3),

    (try_begin),
      (troop_slot_eq, ":target_troop", slot_troop_occupation, slto_kingdom_hero),
      (troop_get_slot, ":target_party", ":target_troop", slot_troop_leaded_party),
    (else_try),
      (troop_slot_eq, ":target_troop", slot_troop_occupation, slto_kingdom_lady),
      (troop_get_slot, ":target_party", ":target_troop", slot_troop_cur_center),
    (try_end),


    (try_begin), #debug
      (eq, "$cheat_mode", 1),
      (str_store_item_name, s12, ":gift"),
      (str_store_party_name, s13, ":target_party"),
      (display_message, "@{!}DEBUG - Bring {s12} to {s13}"),
    (try_end),

    (try_begin),
       #Guard against this being called without an explicit amount
       (lt, ":amount", 1),
       (display_message, "@{!} ERROR: Bad gift amount {reg0}.  (Tell the mod writer he needs to update his code.)  Using a safe default."),
       (assign, ":amount", 1),
       (troop_slot_eq, ":target_troop", slot_troop_occupation, slto_kingdom_hero),
       (assign, ":amount", 150),
    (try_end),
    (assign, ":original_amount", ":amount"),#Save this here because amount gets modified below!

    (call_script, "script_dplmc_withdraw_from_treasury", 50),
    (troop_get_inventory_capacity, ":capacity", "trp_household_possessions"),

  	  (try_for_range, ":inventory_slot", 0, ":capacity"),
  	    (gt, ":amount", 0),
  		  (troop_get_inventory_slot, ":item", "trp_household_possessions", ":inventory_slot"),
  		  (eq, ":item", ":gift"),
  		  (troop_inventory_slot_get_item_amount, ":tmp_amount", "trp_household_possessions", ":inventory_slot"),
  		  (try_begin),
  		    (le, ":tmp_amount", ":amount"),
  		    (troop_inventory_slot_set_item_amount, "trp_household_possessions", ":inventory_slot", 0),
  		    (val_sub, ":amount", ":tmp_amount"),
  		  (else_try),
  		    (val_sub, ":tmp_amount", ":amount"),
  		    (troop_inventory_slot_set_item_amount, "trp_household_possessions", ":inventory_slot", ":tmp_amount"),
  		    (assign, ":amount", 0),
  		  (try_end),
  	  (try_end),

    (set_spawn_radius, 1),
    (spawn_around_party, "$current_town", "pt_dplmc_gift_caravan"),
    (assign,":spawned_party",reg0),
    (party_set_slot, ":spawned_party", slot_party_type, dplmc_spt_gift_caravan),
    (party_set_slot, ":spawned_party", dplmc_slot_party_mission_diplomacy, ":gift"),
    (party_set_slot, ":spawned_party",  slot_party_orders_object,  ":target_troop"),

    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_object, ":target_party"),
    (party_stack_get_troop_id, ":caravan_master", ":spawned_party", 0),
    (troop_set_slot, ":caravan_master", slot_troop_leaded_party, ":spawned_party"),
    (party_set_slot, ":spawned_party", dplmc_slot_party_mission_parameter_1, ":original_amount"),
    ]),

  ("dplmc_send_gift_to_center",
    [
    (store_script_param, ":target_party", 1),
    (store_script_param, ":gift", 2),
    (store_script_param, ":amount", 3),

    (try_begin), #debug
      (eq, "$cheat_mode", 1),
      (str_store_item_name, s12, ":gift"),
      (str_store_party_name, s13, ":target_party"),
      (display_message, "@{!}DEBUG - Bring {s12} to {s13}"),
    (try_end),

    (try_begin),
       #Guard against this being called without an explicit amount
       (lt, ":amount", 1),
       (display_message, "@{!} ERROR: Bad gift amount {reg0}.  (Tell the mod writer he needs to update his code.)  Using a safe default."),
       (assign, ":amount", 300),
    (try_end),
    (assign, ":original_amount", ":amount"),#Save this here because amount gets modified below!

    (call_script, "script_dplmc_withdraw_from_treasury", 50),
    (troop_get_inventory_capacity, ":capacity", "trp_household_possessions"),
	  (try_for_range, ":inventory_slot", 0, ":capacity"),
	    (gt, ":amount", 0),
		  (troop_get_inventory_slot, ":item", "trp_household_possessions", ":inventory_slot"),
		  (eq, ":item", ":gift"),
		  (troop_inventory_slot_get_item_amount, ":tmp_amount", "trp_household_possessions", ":inventory_slot"),
		  (try_begin),
		    (le, ":tmp_amount", ":amount"),
		    (troop_inventory_slot_set_item_amount, "trp_household_possessions", ":inventory_slot", 0),
		    (val_sub, ":amount", ":tmp_amount"),
		  (else_try),
		    (val_sub, ":tmp_amount", ":amount"),
		    (troop_inventory_slot_set_item_amount, "trp_household_possessions", ":inventory_slot", ":tmp_amount"),
		    (assign, ":amount", 0),
		  (try_end),
	  (try_end),

    (set_spawn_radius, 1),
    (spawn_around_party, "$current_town", "pt_dplmc_gift_caravan"),
    (assign,":spawned_party",reg0),
    (party_set_slot, ":spawned_party", slot_party_type, dplmc_spt_gift_caravan),
    (party_set_slot, ":spawned_party", dplmc_slot_party_mission_diplomacy, ":gift"),
    (party_set_slot, ":spawned_party",  slot_party_orders_object, 0),

    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_object, ":target_party"),
    (party_stack_get_troop_id, ":caravan_master", ":spawned_party", 0),
    (troop_set_slot, ":caravan_master", slot_troop_leaded_party, ":spawned_party"),
    (troop_set_slot, ":caravan_master", slot_troop_leaded_party, ":spawned_party"),
    (party_set_slot, ":spawned_party", dplmc_slot_party_mission_parameter_1, ":original_amount"),
    ]),

  ("dplmc_troop_political_notes_to_s47",
      [
    (store_script_param, ":troop_no", 1),
    ##diplomacy start+
	(assign, ":save_reg1", reg1),#save to revert
    (assign, ":save_reg4", reg4),#save to revert

    (try_begin),
       (eq, 0, 1),#Always disable this right now
       (is_between, "$g_talk_troop", heroes_begin, heroes_end),#i.e. not your chancellor
       (assign, ":troop_speaker", "$g_talk_troop"),
	   (call_script, "script_troop_get_player_relation", ":troop_speaker"),
	   (assign, ":speaker_player_relation", reg0),
    (else_try),
       (assign, ":troop_speaker", -1),
	   (assign, ":speaker_player_relation", 100),
    (try_end),
    ##diplomacy end+

    (try_begin),
      (str_clear, s47),

      (store_faction_of_troop, ":troop_faction", ":troop_no"),

      (faction_get_slot, ":faction_leader", ":troop_faction", slot_faction_leader),

      (str_clear, s40),
      (assign, ":logged_a_rivalry", 0),
      ##nested diplomacy start+
      (str_clear, s41),
      #lord can be married or related to player
      #(try_for_range, ":kingdom_hero", active_npcs_begin, active_npcs_end),
      (try_for_range, ":kingdom_hero", active_npcs_including_player_begin, active_npcs_end),
        #Also, don't include rivalries with retired (or dead) characters
        (neg|troop_slot_ge, ":troop_no", slot_troop_occupation, slto_retirement),
      ##nested diplomacy end+
        (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":kingdom_hero"),
        (lt, reg0, -10),

        (str_store_troop_name_link, s39, ":kingdom_hero"),
		  ##nested diplomacy start+ use second person
        (try_begin),
           (eq, ":kingdom_hero", "trp_player"),
           (str_store_string, s39, "str_you"),
        (try_end),
		  ##nested diplomacy end+
        (try_begin),
          (eq, ":logged_a_rivalry", 0),
          ##nested diplomacy start+
          (call_script, "script_dplmc_store_troop_is_female_reg", ":troop_no", 4),#use reg4 for gender-correct pronoun
          ##nested diplomacy end+
          (str_store_string, s40, "str_dplmc_s39_rival"),
          (assign, ":logged_a_rivalry", 1),
        (else_try),
          (str_store_string, s41, "str_s40"),
          (str_store_string, s40, "str_dplmc_s41_s39_rival"),
        (try_end),

      (try_end),

      (str_clear, s46),
      ##nested diplomacy start+
      #(troop_get_type, reg4, ":troop_no"),#use for gender-correct pronoun
		(call_script, "script_dplmc_store_troop_is_female_reg", ":troop_no", 4),
      (str_store_troop_name, s46,":troop_no"),
	  (assign, ":details_available", 0),
	  (try_begin),
		#Enable details for lords you have met
		(neg|troop_slot_eq, ":troop_no", slot_troop_met, 0),
		(assign, ":details_available", 1),
          (else_try),
                #Enable details when using an "omniscient" or non-specific speaker
                (neg|is_between, ":troop_speaker", heroes_begin, heroes_end),
                (assign, ":details_available", 1),
          (else_try),
                #Enable details for NPCs that aren't standard heroes, because the following checks don't apply
                (neg|is_between, ":troop_no", heroes_begin, heroes_end),
                (assign, ":details_available", 1),
          (else_try),
                #Enable details for lords the speaker has met
                (is_between, ":troop_speaker", heroes_begin, heroes_end),
                (is_between, ":troop_no", heroes_begin, heroes_end),
                (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":troop_speaker"),
                (neq, reg0, 0),#between NPCs, relation 0 means "have not met"
                (assign, ":details_available", 1),
          (else_try),
                #Enable details for v. notable lords (based on renown)
                (troop_slot_ge, ":troop_no", slot_troop_renown, 500),
                (assign, ":details_available", 1),
          (else_try),
                #Enable details for v. notable lords (based on fiefs)
                (assign, reg0, 0),
                (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
                   (this_or_next|party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
                   (this_or_next|party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":troop_no"),
                     (troop_slot_eq, ":troop_no", slot_troop_home, ":center_no"),
                   (val_add, reg0, 2),
                   (party_slot_eq, ":center_no", slot_party_type, spt_town),
                   (val_add, reg0, 2),
                (try_end),
                (ge, reg0, 4),#one town, or 2+ castles
                (assign, ":details_available", 1),
          (try_end),
      #xxx TODO: Make a full implementation of the above that takes into account the time of the last spy report.
      (try_begin),
		(eq, ":details_available", 0),
		(troop_get_slot, reg11, ":troop_no", slot_lord_reputation_type),
        (str_store_string, s46, "str_dplmc_reputation_unknown"),
	  (else_try),
	  ##nested diplomacy end+
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_martial),
        (str_store_string, s46, "str_dplmc_reputation_martial"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
        (str_store_string, s46, "str_dplmc_reputation_debauched"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_selfrighteous),
        (str_store_string, s46, "str_dplmc_reputation_pitiless"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),
        (str_store_string, s46, "str_dplmc_reputation_calculating"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_quarrelsome),
        (str_store_string, s46, "str_dplmc_reputation_quarrelsome"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),
        (str_store_string, s46, "str_dplmc_reputation_goodnatured"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
        (str_store_string, s46, "str_dplmc_reputation_upstanding"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_conventional),
        (str_store_string, s46, "str_dplmc_reputation_conventional"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_adventurous),
        (str_store_string, s46, "str_dplmc_reputation_adventurous"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_otherworldly),
        (str_store_string, s46, "str_dplmc_reputation_romantic"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_moralist),
        (str_store_string, s46, "str_dplmc_reputation_moralist"),
      (else_try),
        (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_ambitious),
        (str_store_string, s46, "str_dplmc_reputation_ambitious"),
      (else_try),
        (troop_get_slot, reg11, ":troop_no", slot_lord_reputation_type),
        (str_store_string, s46, "str_dplmc_reputation_unknown"),
      (try_end),

      ##diplomacy start+
      (str_clear, s39),#remove annoying bug
      (str_clear, s45),#remove annoying bug

      #Special-case spouse into showing up if it doesn't get added below
      (try_begin),
         (troop_get_slot, ":spouse", ":troop_no", slot_troop_spouse),
         (ge, ":spouse", 0),

         #Because blank memory is initially zero, enforce this
         (this_or_next|is_between, ":troop_no", heroes_begin, heroes_end),
            (neq, ":spouse", "trp_player"),
         #Initialize s45
         (str_store_troop_name, s39, ":spouse"),
         (try_begin),
           (eq, ":spouse", "trp_player"),
           (str_store_string, s39, "str_you"),##<-- dplmc+ note, this was s59 before, probably an accidental bug
         (else_try), #SB : speaker
           (eq, ":spouse", ":troop_speaker"),
           (str_store_string, s39, "str_me"),
         (try_end),
         (str_store_string, s45, "str_dplmc_s40_married_s39"),
      (try_end),
      ##diplomacy end+

      (try_for_range, ":love_interest_slot", slot_troop_love_interest_1, slot_troop_love_interests_end),
        (troop_get_slot, ":love_interest", ":troop_no", ":love_interest_slot"),
        ##nested diplomacy start+ ; some lords could romance opposite-gender lords
        #(is_between, ":love_interest", kingdom_ladies_begin, kingdom_ladies_end),
        (is_between, ":love_interest", active_npcs_begin, kingdom_ladies_end),
        #Also prevent a bug for companions / claimants who are lords
        (neq, ":love_interest", "trp_knight_1_1_wife"),#<- should not appear in the game
        #Also prevent bad messages for married/betrothed lords
        (this_or_next|troop_slot_eq, ":troop_no", slot_troop_spouse, ":love_interest"),
           (troop_slot_eq, ":troop_no", slot_troop_spouse, -1),
        (this_or_next|troop_slot_eq, ":troop_no", slot_troop_betrothed, ":love_interest"),
           (troop_slot_eq, ":troop_no", slot_troop_betrothed, -1),
        ##nested diplomacy end+
        (str_store_troop_name, s39, ":love_interest"),
        ##nested diplomacy start+ Use second person properly
        (try_begin),
           (eq, ":love_interest", "trp_player"),
           (str_store_string, s39, "str_you"),
         (else_try), #SB : speaker
           (eq, ":love_interest", ":troop_speaker"),
           (str_store_string, s39, "str_me"),
        (try_end),
        ##nested diplomacy start+
        (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":love_interest"),
        ##nested diplomacy start+
        (call_script, "script_dplmc_store_troop_is_female_reg", ":troop_no", 4),#use reg4 for gender-correct pronoun
        ##nested diplomacy end+
        (str_store_string, s45, "str_dplmc_s40_love_interest_s39"),
        (try_begin),
        	(troop_slot_eq, ":troop_no", slot_troop_spouse, ":love_interest"),
        	(str_store_string, s45, "str_dplmc_s40_married_s39"),
        (else_try),
        	(troop_slot_eq, ":troop_no", slot_troop_betrothed, ":love_interest"),
        	(str_store_string, s45, "str_dplmc_s40_betrothed_s39"),
        (try_end),
      (try_end),

    (str_clear, s44),
    (try_begin),
      (neq, ":troop_no", ":faction_leader"),
      ##nested diplomacy start+
      (gt, ":details_available", 0),
	  #Ensure leader is valid
	  (assign, reg0, 0),#continue if 0
	  (try_begin),
	     (neq, ":troop_no", "trp_player"),
		 (neq, ":faction_leader", "trp_player"),
		 (this_or_next|neg|is_between, ":troop_no", heroes_begin, heroes_end),
			(neg|is_between, ":faction_leader", heroes_begin, heroes_end),
		 (assign, reg0, 1),
	  (try_end),
	  (eq, reg0, 0),

	  (try_begin),
	     (gt, ":troop_speaker", 0),
		 (call_script, "script_dplmc_troop_get_family_relation_to_troop", ":troop_no", ":troop_speaker"),
		 #(val_min, reg0, 20),
		 #(neq, ":faction_leader", "trp_player"),
		 #(val_div, reg0, 2),
	  (try_end),
	  (this_or_next|lt, reg0, 1),
		(ge, ":speaker_player_relation", 1),
      ##nested diplomacy end+
      (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_leader"),

      (assign, ":relation", reg0),
	  ##diplomacy start+ Don't mention anything for kingdom ladies at the beginning; it doesn't add information.
	  (this_or_next|lt, reg0, 0),
	  (this_or_next|gt, reg0, 1),#Remember that relation 1 is neutral (it just means "met") between NPCs
	  (this_or_next|neg|is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
	  (this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
	  (this_or_next|troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_granted_fief),
	     (troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_lord_rejoined),
	  ##diplomacy end+
      (store_add, ":normalized_relation", ":relation", 100),
      (val_add, ":normalized_relation", 5),
      (store_div, ":str_offset", ":normalized_relation", 10),
      (val_clamp, ":str_offset", 0, 20),
      ##nested diplomacy start+
      #(troop_get_type, reg4, ":troop_no"),#use for gender-correct pronoun
      (call_script, "script_dplmc_store_troop_is_female_reg", ":troop_no", 4),
      #TODO: Come back and add this (take into account spying)
      #(neq, ":details_available", 0),#don't show unless more details are available
      ##nested diplomacy end+
      (store_add, ":str_id", "str_dplmc_relation_mnus_100_ns",  ":str_offset"),
      (try_begin),
        (eq, ":faction_leader", "trp_player"),
        ##nested diplomacy start+ "str_you" exists, so we might as well use it
        #(str_store_string, s59, "@you"),
        (str_store_string, s59, "str_you"),
        ##diplomacy end+
      (else_try),
        (str_store_troop_name, s59, ":faction_leader"),
      (try_end),
      (str_store_string, s59, ":str_id"),
      (str_store_string, s44, "@{!}^{s59}"),
    (try_end),

    (str_clear, s48),

    (try_begin),
      (eq, "$cheat_mode", 1),
      (store_current_hours, ":hours"),
      (gt, ":hours", 0),
      (call_script, "script_calculate_troop_political_factors_for_liege", ":troop_no", ":faction_leader"),
      (str_store_string, s48, "str_sense_of_security_military_reg1_court_position_reg3_"),
    (try_end),

    (str_store_string, s47, "str_s46s45s44s48"),

  (try_end),
     ##diplomacy start+
     (assign, reg1, ":save_reg1"),#revert register
     (assign, reg4, ":save_reg4"),#revert register to avoid clobbering
     ##diplomacy end+
    ]),

  ("dplmc_send_patrol",
  [
    (store_script_param, ":start_party", 1),
    (store_script_param, ":target_party", 2),
    (store_script_param, ":size", 3), #0 small, 1 medium, 2, big, 3 elite
    (store_script_param, ":template_faction", 4),
    (store_script_param, ":order_troop", 5),

    (set_spawn_radius, 1),
    (spawn_around_party, ":start_party", "pt_patrol_party"),
    (assign,":spawned_party",reg0),
    (party_set_faction, ":spawned_party", ":template_faction"),
    (party_set_slot, ":spawned_party", slot_party_type, spt_patrol),
    (party_set_slot, ":spawned_party", slot_party_home_center, ":start_party"),
    (party_set_slot, ":spawned_party", dplmc_slot_party_mission_diplomacy, ":order_troop"),
    (str_store_party_name, s5, ":target_party"),
    (party_set_name, ":spawned_party", "str_s5_patrol"),

    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_object, ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_state, spai_patrolling_around_center),

    (try_begin),
      (neg|is_between, ":template_faction", npc_kingdoms_begin, npc_kingdoms_end),

      (party_get_slot, ":template_faction", ":start_party", slot_center_original_faction),
      (try_begin),
        (is_between, "$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
        (assign, ":template_faction", "$g_player_culture"),
      (else_try),
        (party_get_slot, ":town_lord", ":start_party", slot_town_lord),
        (gt, ":town_lord", 0),
        (troop_get_slot, ":template_faction", ":town_lord", slot_troop_original_faction),
      (try_end),

      (try_begin),
        (eq, ":size", 0),
        (call_script, "script_dplmc_withdraw_from_treasury", 1000),
      (else_try),
        (this_or_next|eq, ":size", 1),
        (eq, ":size", 3),
        (call_script, "script_dplmc_withdraw_from_treasury", 2000),
      (else_try),
        (eq, ":size", 2),
        (call_script, "script_dplmc_withdraw_from_treasury", 3000),
      (try_end),
    (try_end),

    (faction_get_slot, ":party_template_a", ":template_faction", slot_faction_reinforcements_a),
    (faction_get_slot, ":party_template_b", ":template_faction", slot_faction_reinforcements_b),
    (faction_get_slot, ":party_template_c", ":template_faction", slot_faction_reinforcements_c),

    (try_begin),
      (eq, ":size", 3),
      (party_add_template, ":spawned_party", ":party_template_c"),
      (party_add_template, ":spawned_party", ":party_template_c"),
    (else_try),
      (val_add, ":size", 1),
      (val_mul, ":size", 2),
      (try_for_range, ":cur_i", 0, ":size"),
        (store_random_in_range, ":random", 0, 3),
        (try_begin),
          (eq, ":random", 0),
          (party_add_template, ":spawned_party", ":party_template_a"),
        (else_try),
          (eq, ":random", 1),
          (party_add_template, ":spawned_party", ":party_template_b"),
        (else_try),
          (party_add_template, ":spawned_party", ":party_template_c"),
        (try_end),

        (try_begin), #debug
          (eq, "$cheat_mode", 1),
          (assign, reg0, ":cur_i"),
          (str_store_faction_name, s7, ":template_faction"),
          (display_message, "@{!}DEBUG - Added {reg0}.template of faction {s7} to patrol."),
        (try_end),
      (try_end),
    (try_end),


    (try_begin), #debug
      (eq, "$cheat_mode", 1),
      (str_store_party_name, s13, ":target_party"),
      (str_store_faction_name, s14, ":template_faction"),
      (str_store_party_name, s15, ":start_party"),
      (display_message, "@{!}DEBUG - Send {s14} patrol from {s15} to {s13}"),
    (try_end),
  ]),

  ("dplmc_send_patrol_party",
  [
    (store_script_param, ":start_party", 1),
    (store_script_param, ":target_party", 2),
    (store_script_param, ":party_no", 3),
    (store_script_param, ":template_faction", 4),

    (set_spawn_radius, 1),
    (spawn_around_party, ":start_party", "pt_patrol_party"),
    (assign,":spawned_party",reg0),
    (party_set_faction, ":spawned_party", ":template_faction"),
    (party_set_slot, ":spawned_party", slot_party_type, spt_patrol),
    (party_set_slot, ":spawned_party", slot_party_home_center, ":start_party"),
    (str_store_party_name, s5, ":target_party"),
    (party_set_name, ":spawned_party", "str_s5_patrol"),

    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_object, ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_state, spai_patrolling_around_center),

    (call_script, "script_party_add_party", ":spawned_party", ":party_no"),
  ]),

  ("dplmc_move_troops_party",
  [
    (store_script_param, ":start_party", 1),
    (store_script_param, ":target_party", 2),
    (store_script_param, ":party_no", 3),
    (store_script_param, ":template_faction", 4),

    (set_spawn_radius, 1),
    (spawn_around_party, ":start_party", "pt_patrol_party"),
    (assign,":spawned_party",reg0),
    (party_set_faction, ":spawned_party", ":template_faction"),
    (party_set_slot, ":spawned_party", slot_party_type, spt_patrol),
    (party_set_slot, ":spawned_party", slot_party_home_center, ":start_party"),
    (str_store_party_name, s5, ":target_party"),
    #SB : fixed string
    (party_set_name, ":spawned_party", "str_s5_transfer"),

    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_party),
    (party_set_ai_object, ":spawned_party", ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_object, ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_ai_state, spai_retreating_to_center),
    (party_set_aggressiveness, ":spawned_party", 0),
    (party_set_courage, ":spawned_party", 3),
    (party_set_ai_initiative, ":spawned_party", 100),

    (call_script, "script_party_add_party", ":spawned_party", ":party_no"),
  ]),

  ("dplmc_send_scout_party",
  [
    (store_script_param, ":start_party", 1),
    (store_script_param, ":target_party", 2),
    (store_script_param, ":faction", 3),

    (set_spawn_radius, 1),
    (spawn_around_party, ":start_party", "pt_scout_party"),
    (assign,":spawned_party",reg0),
    (party_set_faction, ":spawned_party", ":faction"),
    (party_set_slot, ":spawned_party", slot_party_type, spt_scout),
    (party_set_slot, ":spawned_party", slot_party_home_center, ":start_party"),
    (str_store_party_name, s5, ":target_party"),
    (party_set_name, ":spawned_party", "str_s5_scout"),

    (party_add_members, ":spawned_party", "trp_dplmc_scout", 1),

    (party_get_position, pos1, ":target_party"),
    (map_get_random_position_around_position, pos2, pos1, 1),
    (party_set_ai_behavior, ":spawned_party", ai_bhvr_travel_to_point),
    (party_set_ai_target_position, ":spawned_party", pos2),
    (party_set_slot, ":spawned_party", slot_party_ai_object, ":target_party"),
    (party_set_slot, ":spawned_party", slot_party_orders_object, ":target_party"),
    (party_set_aggressiveness, ":spawned_party", 0),
    (party_set_courage, ":spawned_party", 3),
    (party_set_ai_initiative, ":spawned_party", 100),
  ]),

  ("dplmc_init_domestic_policy",
  [
    (try_for_range, ":kingdom", npc_kingdoms_begin, npc_kingdoms_end),
      (try_begin),
        (store_random_in_range, ":random", -3, 4),
        (faction_set_slot, ":kingdom", dplmc_slot_faction_centralization, ":random"),
        (store_random_in_range, ":random", -3, 4),
        (faction_set_slot, ":kingdom", dplmc_slot_faction_aristocracy, ":random"),
        (store_random_in_range, ":random", -3, 4),
        (faction_set_slot, ":kingdom", dplmc_slot_faction_quality, ":random"),
        (store_random_in_range, ":random", -3, 4),
        (faction_set_slot, ":kingdom", dplmc_slot_faction_serfdom, ":random"),
      (try_end),
    (try_end),
  ]),

  #SB : add this to allow randomization of a single faction (see prsnt_dplmc_policy_management)
  ("dplmc_randomize_faction_domestic_policy",
    [
    (store_script_param, ":kingdom", 1),
    (try_for_range, ":slot", dplmc_slot_faction_centralization, dplmc_slot_faction_mercantilism + 1),
      (store_random_in_range, ":random", -3, 4),
      (faction_set_slot, ":kingdom", ":slot", ":random"),
    (try_end),
    ]),

  ("dplmc_is_affiliated_family_member",
  [
      (store_script_param, ":troop_id", 1),

      (assign, ":is_affiliated_family_member", 0),
	  ##nested diplomacy start+
	  (assign, ":save_reg1", reg1),#<- Save reg1 which gets overwritten by script_dplmc_troop_get_family_relation_to_troop
	  ##nested diplomacy end+
      (try_begin),
        (is_between, "$g_player_affiliated_troop", lords_begin, kingdom_ladies_end),
        (try_begin),
		  ##nested diplomacy start+ add use of dplmc_slot_troop_affiliated
		  (this_or_next|troop_slot_eq, ":troop_id", dplmc_slot_troop_affiliated, 3),
		  ##diplomacy end+
          (eq, "$g_player_affiliated_troop", ":troop_id"),
          (assign, ":is_affiliated_family_member", 1),
        (else_try),
          (is_between, ":troop_id", lords_begin, kingdom_ladies_end),
		  ##nested diplomacy start+
          #(call_script, "script_troop_get_family_relation_to_troop", ":troop_id", "$g_player_affiliated_troop"),
		  (call_script, "script_dplmc_troop_get_family_relation_to_troop", ":troop_id", "$g_player_affiliated_troop"),
		  ##nested diplomacy end+
          (gt, reg0, 0),
          (call_script, "script_troop_get_relation_with_troop", "$g_player_affiliated_troop", ":troop_id"),
          (ge, reg0, -10),
		  (assign, ":is_affiliated_family_member", 1),
        (try_end),
      (try_end),
	  ##nested diplomacy start+
	  (assign, reg1, ":save_reg1"),#revert register
	  ##nested diplomacy end+
      (assign, reg0, ":is_affiliated_family_member"),
  ]),

  ("dplmc_affiliate_end",
  [
    (store_script_param, ":cause", 1),

    (assign, "$g_player_affiliated_troop", 0),

    (try_begin),
      (eq, ":cause", 1),
      (assign, ":max_penalty", -16),
      (assign, ":term", 20),
      (assign, ":honor_val", 10),
    (else_try),
      (assign, ":max_penalty", -12),
      (assign, ":honor_val", 5),
      (assign, ":term", 15),
    (try_end),

    (try_for_range, ":family_member", lords_begin, kingdom_ladies_end),
      (call_script, "script_dplmc_is_affiliated_family_member", ":family_member"),
      (gt, reg0, 0),

      (store_skill_level, ":value", "skl_persuasion", "trp_player"),
      (store_random_in_range, ":value", 0, ":value"),
      ##nested diplomacy start+   Fix mistake.
      ##
      ##OLD:
      #(val_add, ":value", ":max_penalty", ":value"),
      #
      #NEW:
      #I'm pretty sure this is what was intended.
      (val_add, ":value", ":max_penalty"),
      ##nested diplomacy end+
      (val_min, ":value", 0),
      (call_script, "script_change_player_relation_with_troop", ":family_member", ":value"),
    (try_end),

    (try_begin),
      (gt, "$player_honor", ":honor_val"),
      (val_add, ":term", ":honor_val"),
    (else_try),
      (val_add, ":term", "$player_honor"),
    (try_end),

    (store_current_hours, ":cur_hours"),
    (store_sub, ":affiliated_hours", ":cur_hours", "$g_player_affiliated_time"),
    (store_div, ":affiliated_days", ":affiliated_hours", 24),
    (val_sub, ":term", ":affiliated_days"),
    (val_max, ":term", 0),
    (val_min, ":term", 40),


    (troop_get_slot, ":controversy", "trp_player", slot_troop_controversy),
    (val_add, ":controversy", ":term"),
    (val_min, ":controversy", 100),
    (troop_set_slot, "trp_player", slot_troop_controversy, ":controversy"),

  ]),

  ("dplmc_appoint_chamberlain",
  [
    (troop_set_auto_equip, "trp_dplmc_chamberlain", 0),
    (troop_set_inventory_slot, "trp_dplmc_chamberlain", ek_body, "itm_tabard"),
    (troop_set_inventory_slot, "trp_dplmc_chamberlain", ek_foot, "itm_leather_boots"),
    (assign, "$g_player_chamberlain", "trp_dplmc_chamberlain"),
    #SB : grab all gold from chest troops (seneschals)
    (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
      (party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
      (store_sub, ":chest_troop", ":center_no", towns_begin),
      (val_add, ":chest_troop", "trp_town_1_seneschal"),
      (store_troop_gold, ":cur_gold", ":chest_troop"),
      (troop_remove_gold, ":chest_troop", ":cur_gold"),
      (troop_add_gold, "trp_household_possessions", ":cur_gold"), #no script call
    (try_end),
  ]),

  ("dplmc_appoint_chancellor",
  [
    (troop_set_auto_equip, "trp_dplmc_chancellor", 0),
    (troop_set_inventory_slot, "trp_dplmc_chancellor", ek_body, "itm_nobleman_outfit"),
    (troop_set_inventory_slot, "trp_dplmc_chancellor", ek_foot, "itm_leather_boots"),
    (assign, "$g_player_chancellor", "trp_dplmc_chancellor"),
  ]),

  ("dplmc_appoint_constable",
  [
    (troop_set_auto_equip, "trp_dplmc_constable", 0),
    (troop_set_inventory_slot, "trp_dplmc_constable", ek_body, "itm_dplmc_coat_of_plates_red_constable"),
    (troop_set_inventory_slot, "trp_dplmc_constable", ek_foot, "itm_leather_boots"),
    (assign, "$g_player_constable", "trp_dplmc_constable"),
  ]),

##diplomacy end

##diplomacy start+
#Importing a script used in Custom Commander.  The inventory copying is used
#as a clever way to make "unmodifiable" views of others' equipment (both the
#PC and NPC have their inventory copied before viewing, and after the window
#closes the copies are written back over the originals).
  ("dplmc_copy_inventory",
    [
      (store_script_param_1, ":source"),
      (store_script_param_2, ":target"),

      (troop_clear_inventory, ":target"),
      (troop_get_inventory_capacity, ":inv_cap", ":source"),
      (try_for_range, ":i_slot", 0, ":inv_cap"),
        (troop_get_inventory_slot, ":item", ":source", ":i_slot"),
        (troop_set_inventory_slot, ":target", ":i_slot", ":item"),
        (troop_get_inventory_slot_modifier, ":imod", ":source", ":i_slot"),
        (troop_set_inventory_slot_modifier, ":target", ":i_slot", ":imod"),
        (troop_inventory_slot_get_item_amount, ":amount", ":source", ":i_slot"),
        (gt, ":amount", 0),
        (troop_inventory_slot_set_item_amount, ":target", ":i_slot", ":amount"),
      (try_end),
    ]),


#Decide whether an NPC wants to exchange a fief or not.
#
# param#1 is NPC being asked
# param#2 is that NPC's fief being asked for
# param#3 is the one asking (usually the player)
# param#4 is the fief being offered in exchange
#
# Result is returned in reg0.  Negative means "no", zero means "yes",
# positive means "yes but you have to pay me this amount".
# If the result is negative, the response string is stored in s14.
  ("dplmc_evaluate_fief_exchange",
    [
      (store_script_param, ":target_npc", 1),
      (store_script_param, ":target_fief", 2),
      (store_script_param, ":asker", 3),
      (store_script_param, ":offered_fief", 4),

      (assign, ":result", -1),
      (assign, reg0, ":result"),
      (str_store_string, s14, "str_ERROR_string"),

      (try_begin),
          #Both NPCs are valid, and are not same character.  One can be the player.
          (neq, ":target_npc", ":asker"),
          (is_between, ":target_npc", heroes_begin, heroes_end),
          (this_or_next|is_between, ":asker", heroes_begin, heroes_end),
             (eq,":asker","trp_player"),
          #Both fiefs are valid and owned by the lords in the arguments
          (is_between, ":target_fief", centers_begin, centers_end),
          (party_slot_eq, ":target_fief", slot_town_lord, ":target_npc"),
          (is_between, ":offered_fief", centers_begin, centers_end),
          (party_slot_eq, ":offered_fief", slot_town_lord, ":asker"),
          #The lords are in the same faction
          (store_troop_faction, ":target_faction", ":target_npc"),
          (store_troop_faction, ":asker_faction", ":asker"),
          (try_begin),
             #Special handling needed for player faction
             (eq, ":asker", "trp_player"),
             (neg|eq, ":target_faction", ":asker_faction"),
             (assign, ":asker_faction", "$players_kingdom"),
          (try_end),
          (this_or_next|eq, ":target_faction", ":asker_faction"),
             (this_or_next|faction_slot_eq,":target_faction",slot_faction_leader,":asker"),
             (faction_slot_eq,":asker_faction",slot_faction_leader,":target_npc"),
          #Get prosperity for use in later tests
          (party_get_slot, ":target_prosperity", ":target_fief", slot_town_prosperity),
          (party_get_slot, ":offered_prosperity", ":offered_fief", slot_town_prosperity),
          (store_div, ":min_prosperity", ":target_prosperity", 10),
          (val_mul, ":min_prosperity", 10),
          #...take into account relation
          (call_script, "script_troop_get_relation_with_troop", ":target_npc", ":asker"),
          (store_div, ":relation_div_10", reg0, 10),
          (val_sub, ":min_prosperity", ":relation_div_10"),
          #...take into account persuasion
          (store_skill_level, ":asker_persuasion", "skl_persuasion", ":asker"),
          (val_sub, ":min_prosperity", ":asker_persuasion"),
          #...take into account personal (not party) trade skill
          (store_skill_level, ":asker_trade", "skl_trade", ":asker"),
          (val_sub, ":min_prosperity", ":asker_trade"),
          #...don't let it rise above original's prosperity.
          (val_min, ":min_prosperity", ":target_prosperity"),
          #target_type 1 = village, 2 = castle, 3 = town
		  (assign, ":target_type", 0),
          (try_begin),
            (party_slot_eq, ":target_fief", slot_party_type, spt_town),
            (assign, ":target_type", 3),
          (else_try),
            (party_slot_eq, ":target_fief", slot_party_type, spt_castle),
            (assign, ":target_type", 2),
          (else_try),
  		    (party_slot_eq, ":target_fief", slot_party_type, spt_village),
            (assign, ":target_type", 1),
          (try_end),
		  (ge, ":target_type", 1),#break with error if the type was bad
          #offered_type: 1 = village, 2 = castle, 3 = town
		  (assign, ":offered_type", 0),
          (try_begin),
            (party_slot_eq, ":offered_fief", slot_party_type, spt_town),
            (assign, ":offered_type", 3),
          (else_try),
            (party_slot_eq, ":offered_fief", slot_party_type, spt_castle),
            (assign, ":offered_type", 2),
          (else_try),
			(party_slot_eq, ":offered_fief", slot_party_type, spt_village),
            (assign, ":offered_type", 1),
          (try_end),
		  (ge, ":offered_type", 1),#break with error if the type was bad
          #Now execute comparison logic:
          (try_begin),
            #refuse to trade town for a castle or village
            (lt, ":offered_type", ":target_type"),
            (eq, ":target_type", 3),
            (str_store_string, s14, "str_dplmc_fief_exchange_refuse_town"),
          (else_try),
            #refuse to trade any better type for a worse type
            (lt, ":offered_type", ":target_type"),
            (str_store_string, s14, "str_dplmc_fief_exchange_refuse_castle"),
          (else_try),
            #refuse to trade for something under siege or being raided
            (this_or_next|party_slot_eq, ":offered_fief", slot_village_state, svs_under_siege),
            (party_slot_eq, ":offered_fief", slot_village_state, svs_being_raided),
            (str_store_party_name, s14, ":offered_fief"),
            (str_store_string, s14, "str_dplmc_fief_exchange_refuse_s14_attack"),
          (else_try),
            #accept a trade if the offered type is better
            (lt, ":target_type", ":offered_type"),
            (str_store_string, s14, "str_dplmc_fief_exchange_accept"),
            (assign, ":result", 0),
		  (else_try),
			#refuse to trade away home center (unless trading up for a better type)
			#Target fief is home of NPC...
			(this_or_next|party_slot_eq, ":target_fief", dplmc_slot_center_original_lord, ":target_npc"),
			   (troop_slot_eq, ":target_npc", slot_troop_home, ":target_fief"),
			(neg|party_slot_eq, ":offered_fief", dplmc_slot_center_original_lord, ":target_npc"),
			#...and offered fief is not.
			(neg|troop_slot_eq, ":target_npc", slot_troop_home, ":offered_fief"),
			(this_or_next|neg|is_between, ":target_npc", companions_begin, companions_end),
				(neg|troop_slot_eq, ":target_npc", slot_troop_town_with_contacts, ":offered_fief"),
			(str_store_party_name, s14, ":target_fief"), #Line added by zerilius
			(str_store_string, s14, "str_dplmc_fief_exchange_refuse_home"),
          (else_try),
            #refuse trade if prosperity is too low
            (lt, ":offered_prosperity", ":min_prosperity"),
            (str_store_string, s14, "str_dplmc_fief_exchange_refuse_rich"),
          (else_try),
            #accept trade for 0 or more denars
            (store_sub, ":result", ":target_prosperity", ":offered_prosperity"),
            (val_mul, ":result", ":target_type"),
            (val_mul, ":result", 36),#Should probably be 60 instead
            #(val_div, ":result", 100),
            (val_add, ":result", 2000),
            (val_max, ":result", 0),
            (try_begin),
               (ge, ":result", 1),
               (assign, reg3, ":result"),
               (str_store_string, s14, "str_dplmc_fief_exchange_accept_reg3_denars"),
            (else_try),
               (str_store_string, s14, "str_dplmc_fief_exchange_accept"),
            (try_end),
          (try_end),
      (try_end),
      (assign, reg0, ":result"),
    ]),

  # script_dplmc_time_sorted_heroes_for_center_aux
  # For internal use only
  # param 1: center no
  # param 2: party_no_to_collect_heroes
  # param 3: minimum time since last met (inclusive), or negative for no restriction
  # param 4: maximum time since last met (exclusive), or negative for no restriction
  ("dplmc_time_sorted_heroes_for_center_aux",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (store_script_param, ":min_time", 3),
      (store_script_param, ":max_time", 4),

      (store_current_hours, ":current_hours"),

      (party_get_num_companion_stacks, ":num_stacks",":center_no"),
      (try_for_range, ":i_stack", 0, ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":center_no",":i_stack"),
        (troop_is_hero, ":stack_troop"),
        #get time since last talk
        (troop_get_slot, ":troop_last_talk_time", ":stack_troop", slot_troop_last_talk_time),
        (store_sub, ":time_since_last_talk", ":current_hours", ":troop_last_talk_time"),
        #add if time meets constraints
        (this_or_next|ge, ":time_since_last_talk", ":min_time"),
           (lt, ":min_time", 0),
        (this_or_next|lt, ":time_since_last_talk", ":max_time"),
           (lt, ":max_time", 0),
        (party_add_members, ":party_no_to_collect_heroes", ":stack_troop", 1),
      (try_end),
      (party_get_num_attached_parties, ":num_attached_parties", ":center_no"),
      (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
        (party_get_attached_party_with_rank, ":attached_party", ":center_no", ":attached_party_rank"),
        (call_script, "script_dplmc_time_sorted_heroes_for_center_aux", ":attached_party", ":party_no_to_collect_heroes",":min_time",":max_time"),
      (try_end),
  ]),

  # script_dplmc_time_sorted_heroes_for_center
  # Input: arg1 = center_no, arg2 = party_no_to_collect_heroes
  # Output: none, adds heroes to the party_no_to_collect_heroes party
  # The catch is that it returns heroes who haven't been met in a day
  # or more before others, for greater use in feasts.
  ("dplmc_time_sorted_heroes_for_center",
    [
      (store_script_param_1, ":center_no"),
      (store_script_param_2, ":party_no_to_collect_heroes"),
      (party_clear, ":party_no_to_collect_heroes"),

      #SB: include these heroes in sorting
      (try_begin),
        (eq, "$g_player_court", ":center_no"),
        (store_faction_of_party, ":center_faction", ":center_no"),
        (faction_slot_eq, ":center_faction", slot_faction_leader, "trp_player"),
        ##diplomacy start+
        #It's not exactly clear if this would work for kingdom ladies.  If they
        #can go from slto_kingdom_lady to slto_inactive, this could take them
        #from there to slto_kingdom_hero unintentionally.
        #
        #Because of this, don't enable this for now.  Elsewhere (where defections
        #occur) add alternate behavior for promoted kingdom ladies.
        #
        #TODO: Later, make sure that kingdom ladies are never inactive normally,
        #so this loop can be expanded to work with them.
        ##diplomacy end+
        (try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
          (store_faction_of_troop, ":active_npc_faction", ":active_npc"),
          (eq, ":active_npc_faction", "fac_player_supporters_faction"),
          (troop_slot_eq, ":active_npc", slot_troop_occupation, slto_inactive),
          (neg|troop_slot_ge, ":active_npc", slot_troop_prisoner_of_party, 0), #if he/she is not prisoner in any center.
          (neg|troop_slot_ge, ":active_npc", slot_troop_prisoner_of_party, 0), #if he/she does not have a party
          (neq, ":active_npc", "$g_player_minister"),
          (party_add_members, ":party_no_to_collect_heroes", ":active_npc"),
          # (set_visitor, ":cur_pos", ":active_npc"),
          # (val_add,":cur_pos", 1),
        (try_end),
      (try_end),

     #Non-attached pretenders (make sure they're not thrown under the bus)
     (try_for_range, ":pretender", pretenders_begin, pretenders_end),
        (neq, ":pretender", "$supported_pretender"),
        (troop_slot_eq, ":pretender", slot_troop_cur_center, ":center_no"),
        (party_add_members, ":party_no_to_collect_heroes", ":pretender", 1),
     (try_end),

     #Heroes you haven't spoken to in 24+ hours
     (call_script, "script_dplmc_time_sorted_heroes_for_center_aux",
         ":center_no", ":party_no_to_collect_heroes", 24, -1),

     #Heroes you haven't spoken to in 12 to 24 hours
     (call_script, "script_dplmc_time_sorted_heroes_for_center_aux",
         ":center_no", ":party_no_to_collect_heroes", 12, 24),

     #Everyone else
     (call_script, "script_dplmc_time_sorted_heroes_for_center_aux",
         ":center_no", ":party_no_to_collect_heroes", -1, 12),
  ]),

  # script_script_dplmc_faction_leader_splits_gold
  # INPUT: arg1 = troop_id, arg2 = new faction_no
  # OUTPUT: none
  ("dplmc_faction_leader_splits_gold",
    [
	(store_script_param_1, ":faction_no"),
    (store_script_param_2, ":king_gold"),
	(assign, ":push_reg0", reg0),#revert register value at end of script
	(assign, ":push_reg1", reg1),#revert register value at end of script

	(faction_get_slot, ":faction_liege", ":faction_no", slot_faction_leader),
	(faction_get_slot, reg0, ":faction_no", dplmc_slot_faction_centralization),
	(val_clamp, reg0, -3, 4),
	(val_mul, reg0, -5),
	(try_begin),
		(troop_slot_ge, ":faction_liege", slot_troop_wealth, 20000),
		(val_add, reg0, 20),#20% if the king is at or above his starting gold
	(else_try),
		(val_add, reg0, 50),#50% otherwise
	(try_end),
	(val_add, reg0, 50),
	(store_mul, ":lord_gold", ":king_gold", reg0),#king splits other half among lords
	(val_div, ":lord_gold", 100),
	(val_sub, ":king_gold", ":lord_gold"),
	(try_begin),
		#If there's enough gold to give a meaningful amount to everyone, do so.
		#(This accomplishes two things.  It makes the distribution more even, and
		#it prevents this script from taking an unreasonably long time for very
		#large amounts of gold.)
		#
		#"Meaningful" is at least 300, because that's the minimum amount of gold a
		#lord will to to a fief to collect (it is also the AI recruitment cost on
		#hard).
		(assign, ":num_lords", 0),#<-- number of lords in faction, not including faction leader
		(try_for_range, ":lord_no", heroes_begin, heroes_end),
			(store_troop_faction, ":lord_faction_no", ":lord_no"),
			(eq, ":faction_no", ":lord_faction_no"),
			(troop_set_slot, ":lord_no", slot_troop_temp_slot, 0),
			(neg|faction_slot_eq, ":faction_no", slot_faction_leader, ":lord_no"),
			(troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
			(neg|troop_slot_ge, ":lord_no", slot_troop_prisoner_of_party, 0),
			(troop_get_slot, ":lord_party", ":lord_no", slot_troop_leaded_party),
			(ge, ":lord_party", 0),
			(val_add, ":num_lords", 1),
		(try_end),
		(try_begin),
			#handle player
			(eq, "$players_kingdom", ":faction_no"),
			(neq, "trp_player", ":faction_liege"),
			(neg|troop_slot_ge, "trp_player", slot_troop_prisoner_of_party, 0),
			(val_add, ":num_lords", 1),
		(try_end),
		(gt, ":num_lords", 0),#<-- can fail
		(store_div, ":gold_to_each", ":lord_gold", ":num_lords"),
		(ge, ":gold_to_each", 300),
		(val_div, ":gold_to_each", 150),#regularize (standard reinforcement costs for easy/medium/hard are 600/450/300, which are multiples of 150)
		(val_mul, ":gold_to_each", 150),

		#(try_begin),
		#	(ge, "$cheat_mode", 1),
		#	(assign, reg0, ":num_lords"),
		#	(assign, reg1, ":gold_to_each"),
		#	(str_store_faction_name, s5, ":faction_no"),
		#	(display_message, "@ {reg0} vassals of the {s5} receive {reg1} denars each (dplmc_faction_leader_splits_gold)"),
		#(try_end),

		(try_for_range, ":lord_no", heroes_begin, heroes_end),
			(ge, ":lord_gold", ":gold_to_each"),
			#verify lord is vassal of kingdom
			(store_troop_faction, ":lord_faction_no", ":lord_no"),
			(eq, ":faction_no", ":lord_faction_no"),
			(neg|faction_slot_eq, ":faction_no", slot_faction_leader, ":lord_no"),
			(troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
			(neg|troop_slot_ge, ":lord_no", slot_troop_prisoner_of_party, 0),
			(troop_get_slot, ":lord_party", ":lord_no", slot_troop_leaded_party),
			(ge, ":lord_party", 0),
			#give gold to lord
			(val_sub, ":lord_gold", ":gold_to_each"),
			#(troop_get_slot, reg0, ":lord_no", slot_troop_temp_slot),
			#(val_add, reg0, ":gold_to_each"),
			#(troop_set_slot, ":lord_no", slot_troop_temp_slot, reg0),
			##(call_script, "script_troop_add_gold", ":lord_no", ":gold_to_each"),
			(call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", ":gold_to_each", ":lord_no"),
		(try_end),
		(try_begin),
			(ge, ":lord_gold", ":gold_to_each"),
			#give gold to player if player is vassal of kingdom
			(eq, "$players_kingdom", ":faction_no"),
			(neq, "trp_player", ":faction_liege"),
			(neg|troop_slot_ge, "trp_player", slot_troop_prisoner_of_party, 0),
			(val_sub, ":lord_gold", ":gold_to_each"),
			(troop_get_slot, reg0, "trp_player", slot_troop_temp_slot),
			(val_add, reg0, ":gold_to_each"),
			(troop_set_slot, "trp_player", slot_troop_temp_slot, reg0),
			##(call_script, "script_troop_add_gold", ":lord_no", ":gold_to_each"),
		(try_end),
	(try_end),
	#Now, distribute the remaining gold.  Assign gold in increments of 300,
	#because that's the minimum amount of gold a lord will go to a fief for
	#(also the AI recruitment cost on hard).
	(store_div, ":count", ":lord_gold", 300),
	(val_max, ":count", 1),
	(try_for_range, ":unused", 0, ":count"),
		(ge, ":lord_gold", 300),
		(call_script, "script_cf_get_random_lord_except_king_with_faction", ":faction_no"),
		(is_between, reg0, heroes_begin, heroes_end),
		(assign, ":troop_no", reg0),
		(val_sub, ":lord_gold", 300),
		(troop_get_slot, reg0, ":troop_no", slot_troop_temp_slot),
		(val_add, reg0, 300),
		(troop_set_slot, ":troop_no", slot_troop_temp_slot, reg0),
		#(call_script, "script_troop_add_gold", ":troop_no", 300),
	(try_end),

	#Now the distribution is set.  Give each one his allotment.
	(try_for_range, ":lord_no", heroes_begin, heroes_end),
		(ge, ":lord_gold", ":gold_to_each"),
		#verify lord is vassal of kingdom
		(store_troop_faction, ":lord_faction_no", ":lord_no"),
		(eq, ":faction_no", ":lord_faction_no"),
		(neg|faction_slot_eq, ":faction_no", slot_faction_leader, ":lord_no"),
		(troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
		(neg|troop_slot_ge, ":lord_no", slot_troop_prisoner_of_party, 0),
		(troop_get_slot, ":lord_party", ":lord_no", slot_troop_leaded_party),
		(ge, ":lord_party", 0),
		#get promised gold
		(troop_get_slot, reg0, ":lord_no", slot_troop_temp_slot),
		(neq, reg0, 0),
		#(try_begin),
		#	(ge, "$cheat_mode", 1),
		#	(str_store_troop_name, s4, ":lord_no"),
		#	(str_store_faction_name, s5, ":faction_no"),
		#	(str_store_troop_name, s6, ":faction_liege"),
		#	(display_message, "@{!}{s4} of the {s5} receives {reg0} denars (dplmc_faction_leader_splits_gold)"),
		#(try_end),
		(call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", reg0, ":lord_no"),
		(troop_set_slot, ":lord_no", slot_troop_temp_slot, 0),
	(try_end),

	(val_add, ":king_gold", ":lord_gold"),#Give remaining gold to king
	(try_begin),
		(ge, "$cheat_mode", 1),
		(str_store_troop_name, s4, ":troop_no"),
		(str_store_faction_name, s5, ":faction_no"),
		(str_store_troop_name, s6, ":faction_liege"),
		(display_message, "@{!}{s6} of the {s5} retains the remaining {reg0} denars (dplmc_faction_leader_splits_gold)"),
	(try_end),

	#(call_script, "script_troop_add_gold", ":faction_liege", ":king_gold"),
	(call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", ":king_gold", ":faction_liege"),
	(assign, reg0, ":push_reg0"),#revert register value
	(assign, reg1, ":push_reg1"),#revert register value
	]),


  #script_dplmc_lord_return_from_exile
  # INPUT: arg1 = troop_id, arg2 = new faction_no
  # OUTPUT: none
  ("dplmc_lord_return_from_exile",
    [
      (store_script_param_1, ":troop_no"),
      (store_script_param_2, ":faction_no"),
      #Check validity
	  (try_begin),
		  (is_between, ":troop_no", heroes_begin, heroes_end),
		  (is_between, ":faction_no", kingdoms_begin, kingdoms_end),
		  (neq, ":troop_no", "trp_player"),
		  (faction_get_slot, ":faction_liege", ":faction_no", slot_faction_leader),
		  #The lord definitely should not already belong to a kingdom
		  (store_troop_faction, ":old_faction", ":troop_no"),
		  (neg|is_between, ":old_faction", kingdoms_begin, kingdoms_end),
		  (try_begin),
			#Handle separately for adding to the player's faction
			#The player may decide to accept or reject the return
			(this_or_next|eq, ":faction_liege", "trp_player"),
			(eq, ":faction_no", "fac_player_supporters_faction"),
			#(eq, 1, 0),#<-- temporarily disable
			#Lord comes to petition the player instead of automatically returning
			(call_script, "script_change_troop_faction", ":troop_no", ":faction_no"),
			(troop_set_slot, ":troop_no", slot_troop_occupation, slto_inactive),
			#Show event (no log without actual faction change)
			(str_store_troop_name_link, s4, ":troop_no"),
			(str_store_faction_name_link, s5, ":faction_no"),
			(faction_get_color, ":color", ":faction_no"), #SB : store colour for logs
			(str_store_troop_name_link, s6, ":faction_liege"),
			(display_message, "@{s4} has returned from exile, seeking refuge with {s6} of {s5}.", ":color"),
		    #Remove party
			(troop_get_slot, ":led_party", ":troop_no", slot_troop_leaded_party),
			(try_begin),
				(party_is_active, ":led_party"),
				(neq, ":led_party", "p_main_party"),
				(remove_party, ":led_party"),
				(troop_set_slot, ":troop_no", slot_troop_leaded_party, -1),
			(try_end),
			#
		  (else_try),
			 #NPC king auto-accepts
			 #Normalize relation between NPC and king
			 (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":faction_liege"),
			 (store_sub, ":relation_change", 0, reg0),#enough to increase to 0 if negative
			 (val_max, ":relation_change", 5),
			 (call_script, "script_troop_change_relation_with_troop", ":troop_no", ":faction_liege", ":relation_change"),
			 #Perform reverse of relation change for exile
			 (try_for_range, ":active_npc", active_npcs_begin, active_npcs_end), #all lords in own faction, and relatives regardless of faction
				(assign, ":relation_change", 0),#no change for non-relatives in other factions
				(try_begin),
					(store_faction_of_troop, ":active_npc_faction", ":active_npc"),
					(eq, ":faction_no", ":active_npc_faction"),
					#Auto-exiling someone at -75 relation to his liege gives a -1 base
					#relation penalty from other lords, so the gain is 1 by default.
					(assign, ":relation_change", 1),
				(try_end),
				##(call_script, "script_troop_get_family_relation_to_troop", ":troop_no", ":active_npc"),
				(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":troop_no", ":active_npc"),
				(assign, ":family_relation", reg0),
				(try_begin),
					(gt, ":family_relation", 1),
					(store_div, ":family_modifier", reg0, 3),
					(val_add, ":relation_change", ":family_modifier"),
				(try_end),

				(neq, ":relation_change", 0),

				(call_script, "script_troop_change_relation_with_troop", ":faction_liege", ":active_npc", ":relation_change"),
				(try_begin),
					(eq, "$cheat_mode", 1),
					(str_store_troop_name, s17, ":active_npc"),
					(str_store_troop_name, s18, ":faction_liege"),
					(assign, reg3, ":relation_change"),
					(display_message, "str_trial_influences_s17s_relation_with_s18_by_reg3"),
				(try_end),
			 (try_end),#end try for range :active_npc

			#Now actually change the faction
			(call_script, "script_change_troop_faction", ":troop_no", ":faction_no"),
			(try_begin), #new-begin
				(neq, ":faction_no", "fac_player_supporters_faction"),
				(this_or_next|troop_slot_eq, ":troop_no", slot_troop_occupation, slto_inactive),
					(troop_slot_eq, ":troop_no", slot_troop_occupation, slto_retirement),
					(troop_slot_eq, ":troop_no", slot_troop_occupation, dplmc_slto_exile), #SB : revoke exile
				(troop_set_slot, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
		    (try_end), #new-end

			#Log event
			(str_store_troop_name_link, s4, ":troop_no"),
			(str_store_faction_name_link, s5, ":faction_no"),
			(str_store_troop_name_link, s6, ":faction_liege"),
			(faction_get_color, ":color", ":faction_no"), #SB : store colour for logs
			(display_log_message, "@{s4} has been granted a pardon by {s6} of {s5} and has returned from exile.", ":color"),

            #SB : spawn full army
            (troop_set_slot, ":troop_no", slot_troop_spawned_before, 0),
			(troop_get_slot, ":led_party", ":troop_no", slot_troop_leaded_party),
			(try_begin),
				(party_is_active, ":led_party"),
				(neq, ":led_party", "p_main_party"),
				(remove_party, ":led_party"),
				(troop_set_slot, ":troop_no", slot_troop_leaded_party, -1),
			(try_end),
		  (try_end),#end NPC king auto-accepts
      (else_try),
	    #Failure.  Perform string register assignment first to avoid differences
		#between debug and non-debug behavior.
		(str_store_troop_name, s5, ":troop_no"),
		(str_store_faction_name, s7, ":faction_no"),
		#(ge, "$cheat_mode", 1),#<-- always show this
		(display_message, "@{!}DEBUG : failure in dplmc_lord_return_from_exile((s5}, {s7})"),
	  (try_end),
    ]),

    #script_dplmc_get_troop_morality_value
    # INPUT: arg1 = troop_id, arg2 = morality type
    # OUTPUT: reg0 has morality value, or 0 if inapplicable
    ("dplmc_get_troop_morality_value",
	[
		(store_script_param, ":troop_id", 1),
		(store_script_param, ":morality_type", 2),

		(assign, reg0, 0),
		(try_begin),
			(neg|is_between, ":troop_id", companions_begin, companions_end),#<-- result is 0 for non-companions
		(else_try),
			(troop_slot_eq, ":troop_id", slot_troop_morality_type, ":morality_type"),
			(troop_get_slot, reg0, ":troop_id", slot_troop_morality_value),
		(else_try),
			(troop_slot_eq, ":troop_id", slot_troop_2ary_morality_type, ":morality_type"),
			(troop_get_slot, reg0, ":troop_id", slot_troop_2ary_morality_value),
		(try_end),

	]),

    #script_dplmc_print_subordinate_says_sir_madame_to_s0
    #
    #In a number of circumstances a subordinate (a soldier in the player's employ) will refer
    #to him as "sir" or "madame".  This is intended as a sign of respect, but becomes
    #unintentionally disrespectful if the player would ordinarily merit a higher title.
    #
    #This function does not take into account the personal characteristics of the speaker in
    #any way.  That logic should occur elsewhere.
    #
    #input: none
    #output: reg0 gets a number corresponding to the title used
    ("dplmc_print_subordinate_says_sir_madame_to_s0",
        [
        (assign, ":highest_honor", 1),#{sir/madame}
        #1: str_dplmc_sirmadame
        #2: str_dplmc_my_lordlady
        #3: str_dplmc_your_highness
        (try_begin),
            #disable extra honors when the player is not recognized
            (gt, "$sneaked_into_town", disguise_none),
            (assign, ":highest_honor", 1),
        (else_try),
            #initialize variables for following steps
            (troop_get_slot, ":player_renown", "trp_player", slot_troop_renown),
            (troop_get_slot, ":player_spouse", "trp_player", slot_troop_spouse),
            #check if the player is the spouse of one of a widely recognized monarch,
            #or if the player is the ruler of one of the starting kingdoms (this can't happen but check anyway)
            (ge, ":player_spouse", 1),
            (try_for_range, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
                (this_or_next|faction_slot_eq, ":faction_no", slot_faction_leader, "trp_player"),
                (faction_slot_eq, ":faction_no", slot_faction_leader, ":player_spouse"),
                (val_max, ":highest_honor", 3),
            (try_end),
            (this_or_next|is_between, ":player_spouse", kings_begin, kings_end),
            (this_or_next|is_between, ":player_spouse", pretenders_begin, pretenders_end),
                (ge, ":highest_honor", 3),
            (val_max, ":highest_honor", 3),
            #Do not continue, since you've already used the highest available honor.
        (else_try),
            #the player is head of his own faction
            (ge, "$players_kingdom", 0),
            #faction leader is player, or faction leader is spouse and spouse is valid
            (this_or_next|faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
                (faction_slot_eq, "$players_kingdom", slot_faction_leader, ":player_spouse"),
            (this_or_next|faction_slot_eq, "$players_kingdom", slot_faction_leader, "trp_player"),
                (ge, ":player_spouse", 1),

            (faction_slot_eq, "$players_kingdom", slot_faction_state, sfs_active),
            (try_begin),
                #If you have sufficient right-to-rule and renown, your subjects
                #will call you "highness".
                (ge, "$player_right_to_rule", 10),
                (store_sub, reg0, 75 + 75, "$player_right_to_rule"),
                (val_mul, reg0, 1200 // 75),#minimum required renown (as an aside, 1200 is evenly divisibly by 75)
                #examples: at right to rule 50, renown must be at least 1600
                #          at right to rule 99, renown must be at least 816
                #          at right to rule 10, renown must be at least 2240
                (ge, ":player_renown", reg0),
                (val_max, ":highest_honor", 3),
            (else_try),
                #"Highness" is also used if the player's kingdom holds meaningful territory.
                (try_begin),
                    #Recalculate the cached value if it's suspicious
                    (faction_slot_eq, "$players_kingdom", slot_faction_num_castles, 0),
                    (faction_slot_eq, "$players_kingdom", slot_faction_num_towns, 0),
                    (call_script, "script_faction_recalculate_strength", "$players_kingdom"),
                (else_try),
                    #Recalculate the cached value if it's obviously wrong
                    (this_or_next|neg|faction_slot_ge, "$players_kingdom", slot_faction_num_castles, 0),
                    (neg|faction_slot_ge, "$players_kingdom", slot_faction_num_towns, 0),
                    (call_script, "script_faction_recalculate_strength", "$players_kingdom"),
                (try_end),
                #Territory points: castles = 2, towns = 3 (ignore villages)
                (faction_get_slot, ":territory_points", "$players_kingdom", slot_faction_num_towns),
                (val_mul, ":territory_points", 3),
                (faction_get_slot, reg0, "$players_kingdom", slot_faction_num_castles),
                (val_add, ":territory_points", reg0),
                (val_add, ":territory_points", reg0),
                #If the player owns even a single center, that's worth at least "my lord" from his followers
                (ge, ":territory_points", 1),
                (val_max, ":highest_honor", 2),
                #By default there are around 48 castles and 22 towns on the map, for a total of 70
                #centers, and 162 "points" if weighting castles = 2 and towns = 3.
                (store_sub, ":global_points", towns_end, towns_begin),
                (val_mul, ":global_points", 3),
                (store_sub, reg0, castles_end, castles_begin),
                (val_add, ":global_points", reg0),
                (val_add, ":global_points", reg0),
                #By default there are 6 NPC kingdoms, averaging 8 castles and 3.66... towns or
                #27 points each (although the initial distribution of territory is not even).
                (store_sub, ":number_kingdoms", npc_kingdoms_end, npc_kingdoms_begin),
                (val_max,  ":number_kingdoms", 1),
                #Territory must be at least 3/4 the total points divided by number of initial kingdoms.
                #Right to rule applied as a percentage bonus, scaled so that you gain recognition with
                #75% right to rule and a 50% size kingdom.

                #What I want is: ( (RtR * 2/3) + 100 ) * territory * kingdoms >= globe * 3/4
                #This is equivalent to: (RtR * 2 + 300) * territory * kingdoms * 4 >= globe * 9
                #The re-ordering is because of rounding.
                (store_mul, ":target_points", ":global_points", 9),
                (store_mul, reg0, "$player_right_to_rule", 2),
                (val_add, reg0, 300),
                (val_mul, reg0, ":territory_points"),
                (val_mul, reg0, ":number_kingdoms"),
                (val_mul, reg0, 4),
                (ge, reg0, ":target_points"),
                (val_max, ":highest_honor", 3),
            (try_end),
            #stop evaluation if you reached highest honor
            (ge, ":highest_honor", 3),
        (else_try),
            #the player is a vassal of one of the initial kingdoms
            (is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
            (val_max, ":highest_honor", 1),
            (eq, "$player_has_homage", 1),#<- can fail
            (val_max, ":highest_honor", 2),
        (try_end),

        (try_begin),
           (ge, ":highest_honor", 3),
           (str_store_string, s0, "str_dplmc_your_highness"),
        (else_try),
           (eq, ":highest_honor", 2),
           (str_store_string, s0, "str_dplmc_my_lordlady"),
        (else_try),
           (str_store_string, s0, "str_dplmc_sirmadam"),
        (try_end),

          ##Special cases
        (try_begin),
          (eq, "$sneaked_into_town", disguise_none),
          (is_between, "$g_talk_troop", companions_begin, companions_end),
          (ge, ":highest_honor", 1),
          (neg|troop_slot_eq, "$g_talk_troop", slot_troop_met, 0),
          (this_or_next|neg|troop_slot_eq, "$g_talk_troop", slot_troop_occupation, slto_inactive),
          (neg|troop_slot_eq, "$g_talk_troop", slot_troop_playerparty_history, 0),
          (neg|troop_slot_eq, "$g_talk_troop", slot_troop_playerparty_history, dplmc_pp_history_nonplayer_entry),
          (troop_get_slot, ":honorific", "$g_talk_troop", slot_troop_honorific),
          (ge, ":honorific", "str_npc1_honorific"),
          (str_store_string, s0, ":honorific"),
        (else_try),
          (eq, ":highest_honor", 1),
          (is_between, "$g_talk_troop", heroes_begin, heroes_end),
          (str_store_string, s0, "str_dplmc_sirmadame"),
        (try_end),

        (assign, reg0, ":highest_honor"),
    ]),


	#"script_dplmc_print_commoner_at_arg1_says_sir_madame_to_s0"
	#
	#In a number of circumstances a commoner, who might or might not be a subject of
	#the player, will refer to him as "sir" or "madame."  This script determines whether
	#a different title would be warranted.
	#
	#input: party_no (usually a village or town)
	#output: reg0 gets a number corresponding to the title used
	("dplmc_print_commoner_at_arg1_says_sir_madame_to_s0", [
		(store_script_param_1, ":party_no"),

		(assign, ":title_level", 1),
		(str_store_string, s0, "str_dplmc_sirmadam"),
		(store_faction_of_party, ":party_faction"),

		(try_begin),
			(eq, "$sneaked_into_town", disguise_none),#disable extra honors when the player is not recognized
			(ge, ":party_no", 0),

			#This is used in various conditions below, so I am calling it once
			#for simplicity.
			(assign, ":save_g_talk_troop", "$g_talk_troop"),
			(assign, ":save_g_encountered_party", "$g_encountered_party"),
            (try_begin),
              (neq, ":party_no", "$g_encountered_party"),
              (assign, "$g_encountered_party", -1),
              (assign, "$g_talk_troop", -1),
            (try_end),
			(call_script, "script_dplmc_print_subordinate_says_sir_madame_to_s0"),
			(assign, ":title_level", reg0),
			(assign, "$g_encountered_party", ":save_g_encountered_party"),
			(assign, "$g_talk_troop", ":save_g_talk_troop"),

			(try_begin),
				#The player is a full member of the faction: use full honors
				(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", ":party_faction"),
				(ge, reg0, DPLMC_FACTION_STANDING_DEPENDENT),
				#(nothing more needs to be done)
			(else_try),
				#the faction has recognized him formally: use full honors
				(this_or_next|eq, ":party_no", "p_main_party"),
				(this_or_next|eq, ":party_faction", "fac_player_supporters_faction"),
				   (faction_slot_ge, ":party_faction", slot_faction_recognized_player, 1),
				#(nothing more needs to be done)
			(else_try),
				#The player is the lord of the town: keep result from script_dplmc_print_subordinate_says_sir_madame_to_s0
				(is_between, ":party_no", centers_begin, centers_end),
				(party_slot_eq, ":party_no", slot_town_lord, "trp_player"),
				#(nothing more needs to be done)
			(else_try),
				#Subjects of neutral kingdoms will use titles up to "my lord".
				(store_relation, ":relation", "fac_player_supporters_faction", ":party_faction"),
				(ge, ":relation", 0),
				(try_begin),
					(ge, ":title_level", 3),
					(assign, ":title_level", 2),
					(str_store_string, s0, "str_dplmc_my_lordlady"),
				(try_end),
			(else_try),
				#Subjects of kingdoms at war (that do not recognize the player) and all cases not
				#yet mentioned will reduce the "level" of the title awarded to the player by 1, to
				#a minimum of 1.
				(try_begin),
					(ge, ":title_level", 3),
					(assign, ":title_level", 2),
					(str_store_string, s0, "str_dplmc_my_lordlady"),
				(else_try),
					(eq, ":title_level", 2),
					(assign, ":title_level", 1),
				   (str_store_string, s0, "str_dplmc_sirmadam"),
				(try_end),
			(try_end),
		(try_end),

		##Special cases
		(try_begin),
			(neq, ":party_no", "$g_encountered_party"),
		(else_try),
			(eq, "$sneaked_into_town", disguise_none),
			(ge, ":title_level", 1),
			(is_between, "$g_talk_troop", companions_begin, companions_end),
			(neg|troop_slot_eq, "$g_talk_troop", slot_troop_met, 0),
			(this_or_next|neg|troop_slot_eq, "$g_talk_troop", slot_troop_occupation, slto_inactive),
				(neg|troop_slot_eq, "$g_talk_troop", slot_troop_playerparty_history, 0),
			(neg|troop_slot_eq, "$g_talk_troop", slot_troop_playerparty_history, dplmc_pp_history_nonplayer_entry),
			(troop_get_slot, ":honorific", "$g_talk_troop", slot_troop_honorific),
			(ge, ":honorific", "str_npc1_honorific"),
			(str_store_string, s0, ":honorific"),
		(else_try),
			(eq, ":title_level", 1),
			(is_between, "$g_talk_troop", heroes_begin, heroes_end),
			(assign, ":title_level", "str_dplmc_sirmadame"),
		(try_end),

		(assign, reg0, ":title_level"),

		##Switch to cultural equivalents
      #(try_begin),
		#   (eq, ":party_no", "$g_encountered_party"),
		#   (is_between, "$g_talk_troop", heroes_begin, heroes_end),
	   #   (troop_get_slot, ":culture_faction", "$g_talk_troop", slot_troop_original_faction),
		#   (is_between, ":culture_faction", npc_kingdoms_begin, npc_kingdoms_end),
		#(else_try),
		#   (eq, ":party_no", "$g_encountered_party"),
		#   (ge, "$g_talk_troop", soldiers_begin),
		#   (store_faction_of_troop, ":culture_faction", "$g_talk_troop"),
		#	(is_between, ":culture_faction", npc_kingdoms_begin, npc_kingdoms_end),
		#(else_try),
      #   (is_between, ":party_no", centers_begin, centers_end),
      #   (party_get_slot, ":culture_faction", ":party_no", slot_center_original_faction),
  		#	(is_between, ":culture_faction", npc_kingdoms_begin, npc_kingdoms_end),
		#(else_try),
		#   (assign, ":culture_faction", ":party_faction"),
		#(try_end),
		#(try_begin),
		#   (is_between, "$g_talk_troop", companions_begin, companions_end),#do not switch
		#(else_try),
		#  (eq, ":title_level", 1),
		#	(eq, ":culture_faction", "fac_kingdom_6"),
		#	(str_store_string, s0, "@{!}{sahib/sahiba}"),
		#(try_end),
	]),

  ##script_cf_dplmc_troop_is_female
  #
  #This exists to make it easy to modify this to work with mods that redefine the troop types.
  #See script_dplmc_store_troop_is_female
  #
  #INPUT: arg1: troop_no
  #OUTPUT: none
  ("cf_dplmc_troop_is_female",
  [
	(store_script_param_1, ":troop_no"),
	(assign, ":is_female", 0),
	(ge, ":troop_no", 0),#Undefined behavior when the arguments are invalid.
	(try_begin),
	   (eq, ":troop_no", active_npcs_including_player_begin),
	   (assign, ":troop_no", "trp_player"),
	(try_end),
  	(troop_get_type, ":is_female", ":troop_no"),
	(val_mod, ":is_female", 2), # Makes even number skins "0" odd number "1" - tf_female is eqal to 1
	(eq, ":is_female", tf_female),
  ]),

  ##script_dplmc_store_troop_is_female
  #
  #This exists to make it easy to modify this to work with mods that redefine the troop types.
  #
  #If you change this, remember to also change script_cf_dplmc_troop_is_female and
  #script_dplmc_store_is_female_troop_1_troop_2
  #
  #INPUT: arg1: troop_no
  #
  #OUTPUT:
  #       reg0: 1 is yes, 0 is no
  ("dplmc_store_troop_is_female",
  [
    (store_script_param_1, ":troop_no"),
	(ge, ":troop_no", 0),
    (try_begin),
       (eq, ":troop_no", active_npcs_including_player_begin),
       (assign, ":troop_no", "trp_player"),
    (try_end),
    (troop_get_type, ":is_female", ":troop_no"),
	(val_mod, ":is_female", 2), # Makes even number skins "0" odd number "1" - tf_female is eqal to 1
	(assign, reg0, ":is_female"),
  ]),

  ("dplmc_store_troop_is_female_reg",
  [
    (store_script_param_1, ":troop_no"),
    (store_script_param_2, ":reg_no"),
    (ge, ":troop_no", 0),
    (troop_get_type, ":is_female", ":troop_no"),
	(val_mod, ":is_female", 2), # Makes even number skins "0" odd number "1" - tf_female is eqal to 1
        ##Can asign to registers 0,1,2,3, 65, or 4
    (try_begin),
      (eq, ":reg_no", 4),
      (assign, reg4, ":is_female"),
    (else_try),
      (eq, ":reg_no", 3),
      (assign, reg3, ":is_female"),
    (else_try),
      (eq, ":reg_no", 2),
      (assign, reg2, ":is_female"),
    (else_try),
      (eq, ":reg_no", 1),
      (assign, reg1, ":is_female"),
    (else_try),
      (eq, ":reg_no", 0),
      (assign, reg0, ":is_female"),
    (else_try),
      (eq, ":reg_no", 65),
      (assign, reg65, ":is_female"),
    (else_try),
      ##default to reg4
      (assign, reg4, ":reg_no"),
      (display_message, "@{!} ERROR: called script dplmc-store-troop-is-female-reg with bad argument {reg4}"),
      (assign, reg4, ":is_female"),
    (try_end),
  ]),

  ##script_dplmc_store_is_female_troop_1_troop_2
  #
  #This exists to make it easy to modify this to work with mods that redefine the troop types.
  #See script_dplmc_store_troop_is_female
  #
  #INPUT:
  #      arg1: troop_1
  #      arg2: troop_2
  #OUTPUT:
  #       reg0: 0 for not female, 1 for female
  #       reg1: 0 for not female, 1 for female
  ("dplmc_store_is_female_troop_1_troop_2",
  [
	(store_script_param_1, ":troop_1"),
	(store_script_param_2, ":troop_2"),
    (ge, ":troop_1", 0),
    (ge, ":troop_1", 0),
    (troop_get_type, ":is_female_1", ":troop_1"),
    (troop_get_type, ":is_female_2", ":troop_2"),
	(val_mod, ":is_female_1", 2), # Makes even number skins "0" odd number "1" - tf_female is eqal to 1
	(val_mod, ":is_female_2", 2), # Makes even number skins "0" odd number "1" - tf_female is eqal to 1
	(assign, reg0, ":is_female_1"),
	(assign, reg1, ":is_female_2"),
  ]),

  #script_cf_dplmc_evaluate_pretender_proposal
  # INPUT: arg1 = troop_id for pretender
  # OUTPUT: reg0 = answer
  #
  # Writes reason to s14
  # May clobber s0, s1
  #
  ("cf_dplmc_evaluate_pretender_proposal",
    [
      (store_script_param_1, ":pretender"),
	  (assign, ":answer", -1),
	  (assign, ":save_reg1", reg1),
	  (assign, ":save_reg65", reg65),
	  (call_script, "script_dplmc_store_troop_is_female", ":pretender"),
	  (assign, reg65, reg0),

	  (str_store_string, s14, "str_ERROR_string"),

	  (is_between, ":pretender", pretenders_begin, pretenders_end),
	  (troop_slot_eq, ":pretender", slot_troop_occupation, slto_kingdom_hero),

	  (store_troop_faction, ":pretender_faction", ":pretender"),
	  (is_between, ":pretender_faction", npc_kingdoms_begin, npc_kingdoms_end),
	  (troop_slot_eq, ":pretender", slot_troop_original_faction, ":pretender_faction"),
	  (faction_slot_eq, ":pretender_faction", slot_faction_leader, ":pretender"),
	  (faction_slot_eq, ":pretender_faction", slot_faction_state, sfs_active),

	  (troop_slot_eq, ":pretender", slot_troop_spouse, -1),
	  (troop_slot_eq, ":pretender", slot_troop_betrothed, -1),

	  (troop_get_slot, ":pretender_renown", ":pretender", slot_troop_renown),
	  (val_max, ":pretender_renown", 1),

	  #There, we've covered the preliminaries: this should be a standard post-rebellion
	  #setup.  Now verify that the player is in a correct state.

	  (eq, "$players_kingdom", ":pretender_faction"),
	  (eq, "$player_has_homage", 1),
	  (troop_slot_eq, "trp_player", slot_troop_spouse, -1),
	  (troop_slot_eq, "trp_player", slot_troop_betrothed, -1),

	  (troop_get_slot, ":player_renown", "trp_player", slot_troop_renown),
	  (call_script, "script_troop_get_player_relation", ":pretender"),
	  (assign, ":player_relation", reg0),

	  #Find competitors
	  (assign, ":b", -1),
	  (assign, ":b_relation", -101),
	  (assign, ":c", -1),
	  (assign, ":c_renown", -1),

	  (store_add, ":faction_renown", ":pretender_renown", ":player_renown"),
	  (assign, ":faction_lords", 2),#the player and the pretender

	  (troop_set_slot, ":pretender", slot_troop_temp_slot, 0),#clear
	  (troop_set_slot, "trp_player", slot_troop_temp_slot, 0),#clear

      (try_for_range_backwards, ":competitor", heroes_begin, heroes_end),
        (troop_slot_eq, ":competitor", slot_troop_occupation, slto_kingdom_hero),
        (store_faction_of_troop, ":competitor_faction", ":competitor"),
        (eq, ":competitor_faction", ":pretender_faction"),
        (try_begin),
          (is_between, ":competitor", kings_begin, kings_end), #SB : exclude former monarchs
          (troop_slot_eq, ":competitor", slot_troop_original_faction, ":pretender_faction"),
          (troop_set_slot, ":competitor", slot_troop_temp_slot, -99999),#low value
          (assign, ":competitor_renown", 0), #do not factor in
        (else_try),
          (troop_set_slot, ":competitor", slot_troop_temp_slot, 0),#clear
          (troop_get_slot, ":competitor_renown", ":competitor", slot_troop_renown),
        (try_end),

        (neq, ":competitor", active_npcs_including_player_begin),
        (neq, ":competitor", ":pretender"),

        (call_script, "script_troop_get_relation_with_troop", ":competitor", ":pretender"),
        (assign, ":competitor_relation", reg0),

        (val_add, ":faction_renown", ":competitor_renown"),
        (val_add, ":faction_lords", 1),

        (try_begin),
           (ge, ":competitor_relation", ":b_relation"),
           (neg|troop_slot_eq, ":competitor", slot_troop_spouse, "trp_player"),
           (neg|troop_slot_eq, "trp_player", slot_troop_spouse, ":competitor"),
           (assign, ":b", ":competitor"),
           (assign, ":b_relation", ":competitor_relation"),
        (try_end),
        (try_begin),
           (ge, ":competitor_renown", ":c_renown"),
           (assign, ":c", ":competitor"),
           (assign, ":c_renown", ":competitor_renown"),
        (try_end),
      (try_end),

      (assign, ":pretender_towns", 0),
      (assign, ":pretender_castles", 0),
      (assign, ":pretender_villages", 0),

      (assign, ":player_towns", 0),
      (assign, ":player_castles", 0),
      (assign, ":player_villages", 0),

      (assign, ":faction_towns", 0),
      (assign, ":faction_castles", 0),
      (assign, ":faction_villages", 0),

      (assign, ":original_towns", 0),
      (assign, ":original_castles", 0),
      (assign, ":original_villages", 0),

   	  #(store_sub, ":global_towns", towns_end, towns_begin),
	  #(store_sub, ":global_castles", castles_end, castles_begin),
	  #(store_sub, ":global_villages", villages_end, villages_begin),

	  (assign, ":highest_score", -1),
	  (assign, ":highest_score_lord", -1),

	  (try_for_range, ":center_no", towns_begin, towns_end),
		(store_faction_of_party, ":center_faction", ":center_no"),
		(try_begin),
			(party_slot_eq, ":center_no", slot_town_lord, ":pretender"),
			(val_add, ":pretender_towns", 1),
			(val_add, ":faction_towns", 1),
		(else_try),
			(party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
			(val_add, ":player_towns", 1),
			(val_add, ":faction_towns", 1),
		(else_try),
			(this_or_next|eq, ":center_faction", ":pretender_faction"),
				(eq, ":center_faction", "fac_player_supporters_faction"),
			(val_add, ":faction_towns", 1),
			(party_get_slot, ":town_lord", ":center_no", slot_town_lord),
			(this_or_next|eq, ":town_lord", "trp_player"),
				(is_between, ":town_lord", heroes_begin, heroes_end),
			(troop_get_slot, ":local_temp", ":town_lord", slot_troop_temp_slot),
			(val_add, ":local_temp", 3),
			(troop_set_slot, ":town_lord", slot_troop_temp_slot, ":local_temp"),
			(ge, ":local_temp", ":highest_score"),
			(assign, ":highest_score", ":local_temp"),
			(assign, ":highest_score_lord", ":town_lord"),
		(try_end),
		(try_begin),
			(party_slot_eq, ":center_no", slot_center_original_faction, ":pretender_faction"),
			(val_add, ":original_towns", 1),
		(try_end),
	  (try_end),

	  (try_for_range, ":center_no", castles_begin, castles_end),
		(store_faction_of_party, ":center_faction", ":center_no"),
		(try_begin),
			(party_slot_eq, ":center_no", slot_town_lord, ":pretender"),
			(val_add, ":pretender_castles", 1),
			(val_add, ":faction_castles", 1),
		(else_try),
			(party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
			(val_add, ":player_castles", 1),
			(val_add, ":faction_castles", 1),
		(else_try),
			(this_or_next|eq, ":center_faction", ":pretender_faction"),
				(eq, ":center_faction", "fac_player_supporters_faction"),
			(val_add, ":faction_castles", 1),
			(party_get_slot, ":town_lord", ":center_no", slot_town_lord),
			(this_or_next|eq, ":town_lord", "trp_player"),
				(is_between, ":town_lord", heroes_begin, heroes_end),
			(troop_get_slot, ":local_temp", ":town_lord", slot_troop_temp_slot),
			(val_add, ":local_temp", 2),
			(troop_set_slot, ":town_lord", slot_troop_temp_slot, ":local_temp"),
			(ge, ":local_temp", ":highest_score"),
			(assign, ":highest_score", ":local_temp"),
			(assign, ":highest_score_lord", ":town_lord"),
		(try_end),
		(try_begin),
			(party_slot_eq, ":center_no", slot_center_original_faction, ":pretender_faction"),
			(val_add, ":original_castles", 1),
		(try_end),
	  (try_end),

	  (try_for_range, ":center_no", villages_begin, villages_end),
		(store_faction_of_party, ":center_faction", ":center_no"),
		(try_begin),
			(party_slot_eq, ":center_no", slot_town_lord, ":pretender"),
			(val_add, ":pretender_villages", 1),
			(val_add, ":faction_villages", 1),
		(else_try),
			(party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
			(val_add, ":player_villages", 1),
			(val_add, ":faction_villages", 1),
		(else_try),
			(this_or_next|eq, ":center_faction", ":pretender_faction"),
				(eq, ":center_faction", "fac_player_supporters_faction"),
			(val_add, ":faction_villages", 1),
			(party_get_slot, ":town_lord", ":center_no", slot_town_lord),
			(this_or_next|eq, ":town_lord", "trp_player"),
				(is_between, ":town_lord", heroes_begin, heroes_end),
			(troop_get_slot, ":local_temp", ":town_lord", slot_troop_temp_slot),
			(val_add, ":local_temp", 1),
			(troop_set_slot, ":town_lord", slot_troop_temp_slot, ":local_temp"),
			(ge, ":local_temp", ":highest_score"),
			(assign, ":highest_score", ":local_temp"),
			(assign, ":highest_score_lord", ":town_lord"),
		(try_end),
		(try_begin),
			(party_slot_eq, ":center_no", slot_center_original_faction, ":pretender_faction"),
			(val_add, ":original_villages", 1),
		(try_end),
	  (try_end),

	  #Update stats
	  (faction_set_slot, ":pretender_faction", slot_faction_num_castles, ":faction_castles"),
	  (faction_set_slot, ":pretender_faction", slot_faction_num_towns, ":faction_towns"),

	  #Point totals used below
	  #Faction Score A: (4 * towns) + (2 * castles) + villages
	  (store_mul, ":faction_score_a", ":faction_towns", 4),
	  (val_add, ":faction_score_a", ":faction_castles"),
	  (val_add, ":faction_score_a", ":faction_castles"),
	  (val_add, ":faction_score_a", ":faction_villages"),

	  #Faction Score B: (3 * towns) + (2 * castles) + villages
	  (store_sub, ":faction_score_b", ":faction_score_a", ":faction_towns"),

	  #Original Score A: (4 * towns) + (2 * castles) + villages
	  (store_mul, ":original_score_a", ":original_towns", 4),
	  (val_add, ":original_score_a", ":original_castles"),
	  (val_add, ":original_score_a", ":original_castles"),
	  (val_add, ":original_score_a", ":original_villages"),

	  #Original Score B: (3 * towns) + (2 * castles) + villages
	  (store_sub, ":original_score_b", ":faction_score_b", ":faction_towns"),

	  #The first fail-condition encountered will be the explanation used,
	  #so make sure the most pressing ones go first.
	  (try_begin),
	      #relation low: using the same cutoff normally used for becoming a vassal
		  (lt, ":player_relation", 0),
		  (assign, ":answer", -1),
		  (str_store_string, s14, "@Given the way things stand between us at the moment, {playername}, I would not consider it prudent to enter into such an arrangement."),
	  (else_try),
         #check player right to rule
		 (store_add, ":player_score", "$player_right_to_rule", ":player_relation"),
		 (this_or_next|lt, "$player_right_to_rule", 20),#the level required for your spouse to join a rebellion
			(lt, ":player_score", 100),
		 (assign, ":answer", -1),
		 (str_store_string, s14, "@{playername}, I am grateful to you, but in the eyes of the people you do not have sufficient legitimacy as a potential co-ruler.  Marrying you would undermine my own claim to the throne."),
	  (else_try),
         #check player renown
		 (store_mul, ":min_score", ":pretender_renown", 2),
		 (val_div, ":min_score", 3),#2/3 pretender renown, 750 by default
		 (val_clamp, ":min_score", 500, 1200),#500 is the minimum to begin the claimant quest; 1200 is the initial value for original lords #SB fixed comment

		 (lt, ":player_renown", ":min_score"),
		 (assign, ":answer", -1),
		 (try_begin),
			(ge, "$cheat_mode", 1),
			(assign, reg0, ":player_renown"),
			(assign, reg1, ":min_score"),
			(display_message, "@{!}DEBUG - player renown {reg0}, required renown {reg1}"),
		  (try_end),
		 (str_store_string, s14, "@{playername}, I know that if it were not for you I would not sit on this throne, but your name is little renowned in Calradia.  Marrying you would be perceived as an uneven match and would call into question my own claim to the throne."),
	  (else_try),
		  #check player has sufficient fiefs
		  (store_mul, ":player_score", ":player_towns", 3),
		  (val_add, ":player_score", ":player_castles"),
		  (val_add, ":player_score", ":player_castles"),
		  (val_add, ":player_score", ":player_villages"),# player_score = (3 * towns) + (2 * castles) + villages

		  (assign, ":min_score", 6),#A town, a castle, and a village; two towns; three castles; six villages; etc...

		  (try_begin),
			#Ensure the minimum is not unreasonable on small maps.
			(lt, ":original_score_b", 18),
			(lt, ":faction_score_b", 18),
			(assign, reg0, ":original_score_b"),
			(val_max, reg0, ":faction_score_b"),
			(store_div, ":min_score", reg0, 3),
		  (try_end),

		  (troop_get_slot, ":two_thirds_pretender_score", ":pretender", slot_troop_temp_slot),
		  (val_mul, ":two_thirds_pretender_score", 2),
		  (val_add, ":two_thirds_pretender_score", 1),
		  (val_div, ":two_thirds_pretender_score", 3),
		  (val_max, ":min_score", ":two_thirds_pretender_score"),

		  (lt, ":player_score", ":min_score"),
		  (assign, ":answer", -1),
		  (try_begin),
			(ge, "$cheat_mode", 1),
			(assign, reg0, ":player_score"),
			(assign, reg1, ":min_score"),
			(display_message, "@{!}DEBUG - player score {reg0} out of a required {reg1}"),
		  (try_end),
		  (str_store_string, s14, "@{playername}, I am grateful for your assistance in regaining my rightful throne, but you do not have sufficient personal holdings to be a suitable match for me.  It would be an uneven partnership."),
     (else_try),
	      #does the player have as much renown as competitors?
		  (lt, ":player_renown", ":c_renown"),
	      (assign, ":answer", -1),
		  (str_store_troop_name, s14, ":c"),
		  (try_begin),
			(ge, "$cheat_mode", 1),
			(assign, reg0, ":player_renown"),
			(assign, reg1, ":c_renown"),
			(display_message, "@{!}DEBUG - player score {reg0}, competitor score {reg1}"),
		  (try_end),
		  (str_store_string_reg, s0, s15),#clobber s0, save s15
		  (call_script, "script_troop_describes_troop_to_s15", ":pretender", ":c"),
		  (str_store_string, s14, "@{playername}, I am grateful to you, but if I were to accept at this time I would risk offending powerful lords such as {s15}, who may consider themselves to have honor equal to or greater than your own."),
		  (str_store_string_reg, s15, s0),#revert s15
	 (else_try),
	      #is the player outfieffed by a competitor?
          (gt, ":highest_score_lord", "trp_player"),
          (neq, ":highest_score_lord", ":pretender"),

		  (store_mul, ":player_score", ":player_towns", 3),
		  (val_add, ":player_score", ":player_castles"),
		  (val_add, ":player_score", ":player_castles"),
		  (val_add, ":player_score", ":player_villages"),# player_score = (3 * towns) + (2 * castles) + villages
             (lt, ":player_score", ":highest_score"),

		  (store_mul, reg0, ":highest_score", 3),#allow small differences
		  (val_add, reg0, 2),
		  (val_div, reg0, 4),
		  (gt, reg0, ":player_score"),

	     (assign, ":answer", -1),
		  (str_store_troop_name, s14, ":highest_score_lord"),
		  (try_begin),
			(ge, "$cheat_mode", 1),
			(assign, reg0, ":player_score"),
			(assign, reg1, ":highest_score"),
			(display_message, "@{!}DEBUG - player score {reg0}, competitor score {reg1}"),
		  (try_end),
		  (str_store_string_reg, s0, s15),#clobber s0, save s15
		  (call_script, "script_troop_describes_troop_to_s15", ":pretender", ":highest_score_lord"),
		  (str_store_string, s14, "@{playername}, I am grateful to you, but if I were to accept at this time I would risk offending great lords such as {s15}, who may consider themselves to have honor equal to or greater than your own."),
		  (str_store_string_reg, s15, s0),#revert s15
      (else_try),
		  #does the player have as much relation as competitors?
		  (lt, ":player_relation", ":b_relation"),
		  (ge, ":b_relation", 5),
		  (assign, ":answer", -1),
		 (try_begin),
			(ge, "$cheat_mode", 1),
			(assign, reg0, ":player_relation"),
			(assign, reg1, ":b_relation"),
			(display_message, "@{!}DEBUG - player relation {reg0}, rival relation {reg1}"),
		  (try_end),
		  (str_store_string_reg, s0, s15),#clobber s0, save s15
		  (call_script, "script_troop_describes_troop_to_s15", ":pretender", ":b"),
		  (str_store_string, s14, "@{playername}, while I am grateful to you, I must confess I am fond of {s15}."),
		  (str_store_string_reg, s15, s0),#revert s15
	  (else_try),
		  #check: sufficient lords?
		  (assign, ":needed_lords", 1),
		  (try_for_range, ":troop_no", lords_begin, lords_end),
			(troop_slot_eq, ":troop_no", slot_troop_original_faction, ":pretender_faction"),
			(val_add, ":needed_lords", 1),
		  (try_end),
		  #Must be at least 75% of original size
		  (val_mul, ":needed_lords", 3),
		  (val_div, ":needed_lords", 4),

		  (lt, ":faction_lords", ":needed_lords"),
		  (assign, ":answer", -1),
		  (try_begin),
			(ge, "$cheat_mode", 1),
			(assign, reg0, ":faction_lords"),
			(assign, reg1, ":needed_lords"),
			(display_message, "@{!}DEBUG - lords in faction {reg0}, required lords {reg1}"),
		  (try_end),

		  (str_store_string, s14, "@Our realm has too few vassals.  In the current precarious state of the affairs I must use the lure of a potential political alliance to attract new vassals, and cannot yet be seen to commit to any single {reg65?suitor:candidate}."),
	  (else_try),
		  #check: pretender has enough fiefs?
		  #Must not be exceeded in fiefs by anyone in the faction.
		  (store_mul, ":pretender_score", ":pretender_towns", 3),
		  (val_add, ":pretender_score", ":pretender_castles"),
		  (val_add, ":pretender_score", ":pretender_castles"),
		  (val_add, ":pretender_score", ":pretender_villages"),
		  (troop_set_slot, ":pretender", slot_troop_temp_slot, ":pretender_score"),

		  (store_mul, reg0, ":highest_score", 3),#allow small differences
		  (val_add, reg0, 2),
		  (val_div, reg0, 4),

		  (gt, reg0, ":pretender_score"),

		  (assign, ":answer", -1),
		  (try_begin),
			(ge, "$cheat_mode", 1),
			(assign, reg1, reg0),
			(assign, reg0, ":pretender_score"),
			(display_message, "@{!}DEBUG - liege has {reg0} center points, needs at least {reg1}"),
		  (try_end),
		  (str_store_string_reg, s0, s15),#clobber s0, save s15
		  (call_script, "script_troop_describes_troop_to_s15", ":pretender", ":highest_score_lord"),
		  (str_store_string, s14, "@Because I have insufficient personal holdings compared to {s15}, if I entered into such an arrangement I would risk appearing to be a puppet, throwing the stability of the realm into jeopardy."),
		  (str_store_string_reg, s15, s0),#revert s15
	 (else_try),
		  #Check if pretender has enough fiefs, part 2.
		  #Must not have fewer fief points than the number of faction points divided by the
		  #number of lords (so this condition can't be bypassed by just failing to assign
		  #centers to anyone during the rebellion)
		  (store_mul, ":points_per_lord", ":faction_towns", 3),
		  (val_add, ":points_per_lord", ":faction_castles"),
		  (val_add, ":points_per_lord", ":faction_castles"),
		  (val_add, ":points_per_lord", ":faction_villages"),
		  (val_div, ":points_per_lord", ":faction_lords"),#includes pretender so cannot be zero

		  (gt, ":points_per_lord", ":pretender_score"),

		  (assign, ":answer", -1),
		  (try_begin),
			(ge, "$cheat_mode", 1),
			(assign, reg0, ":pretender_score"),
			(assign, reg1, ":points_per_lord"),
			(display_message, "@{!}DEBUG - liege has {reg0} center points, needs at least {reg1}"),
		  (try_end),
		  (str_store_faction_name, s14, ":pretender_faction"),
		  (str_store_string, s14, "@Because my personal holdings are insufficiently large compared to other lords of the {s14}, if I entered into such an arrangement I would risk appearing to be a puppet, throwing the stability of the realm into jeopardy."),
	  (else_try),
		  #check if player is widely hated in faction
		  (assign, ":total_negative", 0),
		  (assign, ":total_enemies", 0),
		  (assign, ":total_positive", 0),
		  (assign, ":total_friends", 0),
		  (try_for_range, ":troop_no", heroes_begin, heroes_end),
		     (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
			 (store_troop_faction, reg0, ":troop_no"),
			 (eq, reg0, ":pretender_faction"),
			 (call_script, "script_troop_get_player_relation", ":troop_no"),
			 (try_begin),
				(lt, reg0, 0),
				(val_add, ":total_negative", 1),
				(lt, reg0, -19),
				(val_add, ":total_enemies", 1),
			 (else_try),
				(gt, reg0, 0),
				(val_add, ":total_positive", 1),
				(gt, reg0, 19),
				(val_add, ":total_friends", 1),
			 (try_end),
		  (try_end),
		  #Must not have a "disapproval rating" of over 33%
		  (val_mul, ":total_enemies", 2),
		  (val_mul, ":total_negative", 2),
		  (this_or_next|gt, ":total_enemies", ":total_friends"),
		     (gt, ":total_negative", ":total_positive"),

		  (assign, ":answer", -1),
		  (str_store_faction_name, s14, ":pretender_faction"),
		  (str_store_string, s14, "@I am grateful to you, {playername}, but you have too many enemies among the lords of the {s14} for your proposal to be politically viable.  If I were to accept, there might be a revolt."),
	  (else_try),
		  #controversy must be less than 25, and less than half the relation with the liege
		  (troop_get_slot, ":controversy_2", "trp_player", slot_troop_controversy),
		  (ge, ":controversy_2", 1),
		  (val_mul, ":controversy_2", 2),
		  (this_or_next|ge, ":controversy_2", 50),
		     (ge, ":controversy_2", ":player_relation"),
		  (assign, ":answer", -1),
		  (str_store_faction_name, s14, ":pretender_faction"),
		  (str_store_string, s14, "@You have engendered too much controversy recently, {playername} .  If I were to accept at this time, there might be a revolt among the lords of the {s14}.  Let us speak of this later when the furor has died down."),
	  (else_try),
		  #check is marshall
		  (neg|faction_slot_eq, ":pretender_faction", slot_faction_marshall, "trp_player"),
		  (assign, ":answer", -2),#<-- negative two, not -1
		  (str_store_faction_name, s14, ":pretender_faction"),
		  (str_store_string, s14, "@If you desire to lead the {s14} alongside me, gather support among my vassals to become marshall, and demonstrate to them your abilities as a war leader."),
	  (else_try),
		  #player is marshall: is the territory sufficient?

		  #The faction must have at least 80% of its former territory under scoring system A or scoring system B.
		  (store_mul, ":four_fifths_original_score_a", ":original_score_a", 4),
		  (val_div, ":four_fifths_original_score_a", 5),

		  (store_mul, ":four_fifths_original_score_b", ":original_score_b", 4),
		  (val_div, ":four_fifths_original_score_b", 5),

		  (lt, ":faction_score_a", ":four_fifths_original_score_a"),
		  (lt, ":faction_score_b", ":four_fifths_original_score_b"),
		  (assign, ":answer", -3),

		  (call_script, "script_dplmc_print_centers_in_numbers_to_s0", ":original_towns", ":original_castles", ":original_villages"),
		  (str_store_string_reg, s1, s0),
		  (call_script, "script_dplmc_print_centers_in_numbers_to_s0", ":faction_towns", ":faction_castles", ":faction_villages"),

		  (str_store_faction_name, s14, ":pretender_faction"),
		  (str_store_string, s14, "@Our realm has lost too much territory.  We once held {s1} but now only hold {s0}.  In the current precarious state of affairs I must retain the possibility of a political alliance to use as a bargaining chip with the other sovereigns, so I yet be seen to commit to any single {reg65?suitor:candidate}.  Restore the {s14} to its former glory, and I will gladly have you rule beside me as my {husband/wife}."),
	  (else_try),
		 #player is marshall: are any native centers lost?

		 (str_clear, s0),
		 (str_clear, s1),
		 (assign, ":num_lost_towns_and_castles", 0),

		 (try_for_range, ":center_no", centers_begin, centers_end),
			(party_slot_eq, ":center_no", slot_center_original_faction, ":pretender_faction"),
			(store_faction_of_party, ":center_faction", ":center_no"),
			(neq, ":center_faction", ":pretender_faction"),
			(neq, ":center_faction", "fac_player_supporters_faction"),
			(try_begin),
				(eq, ":num_lost_towns_and_castles", 0),
				(str_store_party_name, s0, ":center_no"),
			(else_try),
				(eq, ":num_lost_towns_and_castles", 1),
				(str_store_party_name, s1, ":center_no"),
			(else_try),
				(str_store_string, s0, "str_dplmc_s0_comma_s1"),
				(str_store_party_name, s1, ":center_no"),
			(try_end),
			(val_add, ":num_lost_towns_and_castles", 1),
		 (try_end),
		 #post-loop cleanup
		 (try_begin),
			(ge, ":num_lost_towns_and_castles", 2),
			(str_store_string, s0, "str_dplmc_s0_and_s1"),
		 (try_end),
		 #native towns lost
		 (ge, ":num_lost_towns_and_castles", 1),
		 (store_sub, reg0, ":num_lost_towns_and_castles", 1),
		 (str_store_faction_name, s14, ":pretender_faction"),
		 (str_store_string, s14, "@{s0} {reg0?have:has} been lost to foreign hands.  Restore the {s14} to its rightful boundaries, and I will gladly have you rule beside me as my {husband/wife}."),
		 (assign, ":answer", -3),
	  (else_try),
	  #Timer answer
	     (lt, "$g_player_days_as_marshal", 14),
		  (assign, reg0, "$g_player_days_as_marshal"),
		  (store_sub, reg1, reg0, 1),
		  (str_store_faction_name, s14, ":pretender_faction"),
		  (str_store_string, s14, "@You have only been marshall for {reg0} {reg1?days:day}.  Let us speak of this after you have held the post for at least two weeks."),
		  (assign, ":answer", -4),
	  (else_try),
		#In the future we may need a proper quest of some kind, or at least a timer, but this will do for now.
		(assign, ":answer", 1),
		(str_store_faction_name, s14, ":pretender_faction"),
		(str_store_string, s14, "@If not for you I would not sit on this throne, {playername}.  When we started our long walk, few people had the courage to support me.  And fewer still would be willing to put their lives at risk for my cause.  But you didn't hesitate for a moment in throwing yourself at my enemies. We have gone through a lot together, and with God's help, we prevailed.  I will gladly accept you as both my {husband/wife} and co-ruler of the {s14}."),
	  (try_end),

	  (assign, reg65, ":save_reg65"),
	  (assign, reg1, ":save_reg1"),
	  (assign, reg0, ":answer"),
  ]),

  #script_dplmc_center_point_calc
  # INPUT: arg1 = faction_id
  #        arg2 = troop_1
  #        arg2 = troop_2
  #        arg3 = town_point_value (see explanation below)
  #
  # OUTPUT:
  #        reg0 = total renown / total faction points (or 0 if no centers held)
  #        reg1 = troop_1 total (not divided)
  #        reg2 = troop_2 total (not divided)
  #        reg3 = faction average lord renown (or 0 if no lords)
  #
  #In various places the game tallies center points differently.  The values of
  #villages/castles/fiefs, respectively, in some places are 1/2/2, in other
  #places are 1/2/3, and in others are 1/3/4.
  #Specifying the town point value determines which scheme will be used to
  #determine ceter points:
  #        arg3 = 2 gives 1/2/2
  #        arg3 = 3 gives 1/2/3
  #        arg3 = 4 gives 1/2/4
  #
  #If the specified town_point_value is not 2,3, or 4, the script is allowed to
  #clamp the value or substitute a default.
  ("dplmc_center_point_calc",
    [
		(store_script_param, ":faction_id", 1),
		(store_script_param, ":troop_1", 2),
		(store_script_param, ":troop_2", 3),
		(store_script_param, ":town_point_value", 4),

		(val_clamp, ":town_point_value", 2, 5),

		#The outputs
		(assign, ":faction_score", 0),
		(assign, ":troop_1_score", 0),
		(assign, ":troop_2_score", 0),
		#(assign, ":average_renown", 0),

		#Intermediate values we use for computing outputs
		(assign, ":total_renown", 0),
		(assign, ":num_lords", 0),

		#Handle the player first
		#(assign, ":player_in_faction", 0),
		(assign, ":faction_alias", ":faction_id"),
		(try_begin),
			(this_or_next|eq, ":faction_id", "$players_kingdom"),
				(eq, ":faction_id", "fac_player_supporters_faction"),
			(val_add, ":num_lords", 1),
			(troop_get_slot, ":total_renown", "trp_player", slot_troop_renown),
			#(assign, ":player_in_faction", 1),
			(assign, ":faction_alias", "fac_player_supporters_faction"),
			(eq, ":faction_id", "fac_player_supporters_faction"),
			(assign, ":faction_alias", "$players_kingdom"),
		(try_end),

		#Get lords in faction
		(try_for_range, ":troop_no", heroes_begin, heroes_end),
			(troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
			(neq, ":troop_no", "trp_kingdom_heroes_including_player_begin"),
			(store_troop_faction, ":faction_no", ":troop_no"),
			(this_or_next|eq, ":faction_no", ":faction_id"),
				(eq, ":faction_no", ":faction_alias"),

			(val_add, ":num_lords", 1),
			(troop_get_slot, ":renown", ":troop_no", slot_troop_renown),
			(val_max, ":renown", 0),
			(val_add, ":total_renown", ":renown"),
		(try_end),

		#Get stats for centers
		(try_for_parties, ":center_no"),
			(assign, ":points", 0),
			(try_begin),
				#Towns are 2, 3, or 4 points
				(this_or_next|is_between, ":center_no", towns_begin, towns_end),
				(party_slot_eq, ":center_no", slot_party_type, spt_town),
				(assign, ":points", ":town_point_value"),
			(else_try),
				#Castles are always 2 points
				(this_or_next|is_between, ":center_no", castles_begin, castles_end),
				(party_slot_eq, ":center_no", slot_party_type, spt_castle),
				(assign, ":points", 2),#castles are always 2
			(else_try),
				#Villages are always 1 point
				(this_or_next|is_between, ":center_no", villages_begin, villages_end),
				(party_slot_eq, ":center_no", slot_party_type, spt_village),
			(try_end),

			#Don't process parties that aren't centers.
			(ge, ":points", 1),

			#NB: We don't know for sure that troop_1 and troop_2 aren't the
			#same value, and we don't even necessarily know that they're part
			#of the specified faction.
			(try_begin),
				(party_slot_eq, ":center_no", slot_town_lord, ":troop_1"),
				(val_add, ":troop_1_score", ":points"),
			(try_end),

			(try_begin),
				(party_slot_eq, ":center_no", slot_town_lord, ":troop_2"),
				(val_add, ":troop_2_score", ":points"),
			(try_end),

			(store_faction_of_party, ":faction_no", ":center_no"),
			(this_or_next|eq, ":faction_no", ":faction_id"),
				(eq, ":faction_no", ":faction_alias"),
			(val_add, ":faction_score", ":points"),
		(try_end),

		# OUTPUT:
		#        reg0 = faction renown / faction points (or 0 if faction has no centers)
		#        reg1 = troop_1 total (not divided)
		#        reg2 = troop_2 total (not divided)
		#        reg3 = faction average lord renown (or 0 if no lords)
		(assign, reg0, 0),
		(try_begin),
			(neq, ":faction_score", 0),
			(store_div, reg0, ":total_renown", ":faction_score"),
		(try_end),
		(assign, reg1, ":troop_1_score"),
		(assign, reg2, ":troop_2_score"),
		(assign, reg3, 0),
		(try_begin),
			(neq, ":num_lords", 0),
			(store_div, reg0, ":total_renown", ":num_lords"),
		(try_end),
	]),


  #script_dplmc_good_produced_at_center_or_its_villages
  # For towns, also includes the villages that attach to it
  #
  # INPUT: arg1 = good_no
  #        arg2 = center_no
  # OUTPUT:
  #        reg0 = 0 if no, 1 if yes
  ("dplmc_good_produced_at_center_or_its_villages",
  [
	(store_script_param, ":good_no", 1),
	(store_script_param, ":center_no", 2),

	(assign, ":has_good", 0),
	(assign, ":save_reg1", reg1),
	(assign, ":save_reg2", reg2),
	(store_current_hours, ":cur_hours"),
	(store_sub, ":recent_time", ":cur_hours", 3 * 24),


	(try_begin),
		(is_between, ":good_no", trade_goods_begin, trade_goods_end),
		(ge, ":center_no", 1),
		(this_or_next|is_between, ":center_no", centers_begin, centers_end),
			(party_is_active, ":center_no"),
		(this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_town),
		(this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_castle),
		(this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_village),
			(is_between, ":center_no", centers_begin, centers_end),
		(call_script, "script_center_get_production", ":center_no", ":good_no"),
		(try_begin),
			#Positive production
			(ge, reg0, 1),
			(assign, ":has_good", 1),
		(else_try),
			#Is a town or a castle, and one of its villages has positive prodution
			(this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_town),
				(party_slot_eq, ":center_no", slot_party_type, spt_castle),
			(try_for_range, ":cur_village", villages_begin, villages_end),
				(eq, ":has_good", 0),
				#is bound to center
				(this_or_next|party_slot_eq, ":cur_village", slot_village_market_town, ":center_no"),
					(party_slot_eq, ":cur_village", slot_village_bound_center, ":center_no"),#for castles
               (assign, reg0, 0),
               (try_begin),
                  #If a trading party from the village reached the town recently, its goods are
				  #available.
                  (party_slot_ge, ":cur_village", dplmc_slot_village_trade_last_arrived_to_market, ":recent_time"),
                  (assign, reg0, 1),
               (else_try),
                  #If the village is not looted and this center is not under siege, the
				  #goods from the village could be acquired if they were needed.
					   (neg|party_slot_eq, ":cur_village", slot_village_state, svs_looted),
					   (neg|party_slot_eq, ":cur_village", slot_village_state, svs_deserted),
                  (neg|party_slot_eq, ":center_no", slot_village_state, svs_under_siege),
                  (assign, reg0, 1),
               (try_end),
               (eq, reg0, 1),
				#If an eligible village has positive production, set "has_good" to true.
				(call_script, "script_center_get_production", ":cur_village", ":good_no"),
				(ge, reg0, 1),
				(assign, ":has_good", 1),
			(try_end),
		(try_end),
	(try_end),

	(assign, reg0, ":has_good"),
	(assign, reg1, ":save_reg1"),
	(assign, reg2, ":save_reg2"),
  ]),

  #script_dplmc_assess_ability_to_purchase_good_from_center
  # INPUT: arg1 = good_no
  #        arg2 = center_no
  # OUTPUT:
  #        reg0 = actual price (may be theoretical if unavailable)
  #        reg1 = 1 if available, 0 if unavailable
  ("dplmc_assess_ability_to_purchase_good_from_center",
    [
		(store_script_param, ":good_no", 1),
		(store_script_param, ":center_no", 2),

		#This is still quite experimental.  This is a work in progress
                #rather than a finished formula.
		(assign, ":price_factor", average_price_factor),
		(assign, ":has_good", 0),

		(try_begin),
			(is_between, ":center_no", centers_begin, centers_end),
			(this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_village),
				(party_slot_eq, ":center_no", slot_party_type, spt_town),

			(is_between, ":good_no", trade_goods_begin, trade_goods_end),

			(store_sub, ":item_slot_no", ":good_no", trade_goods_begin),
			(val_add, ":item_slot_no", slot_town_trade_good_prices_begin),
			(party_get_slot, ":price_factor", ":center_no", ":item_slot_no"),

			(call_script, "script_dplmc_good_produced_at_center_or_its_villages", ":good_no", ":center_no"),
			(assign, ":has_good", reg0),
			#abort if good is found
			(lt, ":has_good", 1),

			(store_faction_of_party, ":center_faction", ":center_no"),
			(faction_get_slot, ":mercantilism", ":center_faction", dplmc_slot_faction_mercantilism),
			(val_clamp, ":mercantilism", -3, 4),

			#For towns, check trade centers.
			(this_or_next|party_slot_eq, ":center_no", slot_party_type, spt_town),
				(is_between, ":center_no", towns_begin, towns_end),

			(store_current_hours, ":cur_hours"),
			(assign, ":best_foreign_price", maximum_price_factor),
         (assign, ":worst_price_seen", ":price_factor"),

			(try_for_range, ":trade_town_index", slot_town_trade_routes_begin, slot_town_trade_routes_end),
				(party_get_slot, ":trade_town", ":center_no", ":trade_town_index"),
            (is_between, ":trade_town", centers_begin, centers_end),

				(party_get_slot, ":price_factor_2", ":trade_town", ":item_slot_no"),
				(val_max, ":worst_price_seen", ":price_factor_2"),

            (party_slot_eq, ":trade_town", slot_party_type, spt_town),
				(call_script, "script_dplmc_good_produced_at_center_or_its_villages", ":good_no", ":trade_town"),
				#The town has or produces the item
				(ge, reg0, 1),

				#Get the number of hours since the last caravan arrival, and set the penalty accordingly.
				(assign, ":hours_since", 0),
				#The slot storing the arrival time.  This may be uninitialized for old saved games used
				#with this mod.
				(store_sub, ":arrival_slot", ":trade_town_index", slot_town_trade_routes_begin),
				(val_add, ":arrival_slot", dplmc_slot_town_trade_route_last_arrivals_begin),
				(try_begin),
					#This condition can only occur if the number of trade route slots was increased
					#but the number of trade arrival time slots was not.  Check just in case, to avoid
					#strange errors.
					(neg|is_between, ":arrival_slot", dplmc_slot_town_trade_route_last_arrivals_begin, dplmc_slot_town_trade_route_last_arrivals_end),
					#Set "hours-since" to one week.
					(assign, ":hours_since", 7 * 24),
				(else_try),
					#If the slot is uninitialized, give it a random plausible value.
					(party_slot_eq, ":center_no", ":arrival_slot", 0),#Uninitialzed memory!
					(store_random_in_range, ":hours_since", 1, (24 * 7 * 5) + 1),#random time in last five weeks
					(party_get_slot, ":prosperity_factor", ":center_no", slot_town_prosperity),
					(val_clamp, ":prosperity_factor", 0, 101),
					(val_add, ":prosperity_factor", 75),
					(val_mul, ":hours_since", 125),
					(val_div, ":hours_since", ":prosperity_factor"),#last arrival some time in the last five weeks, plus or minus up to 40% based on prosperity
					(store_sub, ":last_arrival", ":cur_hours", ":hours_since"),
					(party_set_slot, ":center_no", ":arrival_slot", ":last_arrival"),
				(else_try),
					(party_get_slot, ":last_arrival", ":center_no", ":arrival_slot"),
					(store_sub, ":hours_since", ":cur_hours", ":last_arrival"),
					(val_max, ":hours_since", 0),
				(try_end),


				#Base penalty is 5%.  It stays at a flat 5% for the first week, then begins rising
				#at a rate of 5% per week afterwards (incremented continuously).
				#Clamp the maximum penalty at 50%.
				(store_mul, ":penalty", ":hours_since", 5),
				(val_add, ":penalty", (24 * 7) // 2),
				(val_div, ":penalty", 24 * 7),
				(val_max, ":penalty", 5),#required for the first week
				(val_min, ":penalty", 50),#don't increase above 50%

				#Apply mercantilism
				(store_faction_of_party, ":other_faction", ":trade_town"),
				(try_begin),
					#Decrease penalty for mercantilism, increase for free trade
					(eq, ":other_faction", ":center_faction"),
					(val_sub, ":penalty", ":mercantilism"),
				(else_try),
					#Increase penalty for mercantilism, decrease for free trade
					(val_add, ":penalty", ":mercantilism"),
				(try_end),

				(try_begin),
					(ge, ":price_factor_2", average_price_factor),
					(val_mul, ":price_factor_2", ":penalty"),
					(val_add, ":price_factor_2", 50),
					(val_div, ":price_factor_2", 100),
				(else_try),
					(store_add, reg0, 100, ":penalty"),
					(val_mul, reg0, average_price_factor),
					(val_add, reg0, 50),
					(val_div, reg0, 100),
					(val_add, ":price_factor_2", reg0),
				(try_end),
				#Make use of the source
				(assign, ":has_good", 1),
				(val_min, ":best_foreign_price", ":price_factor_2"),
			(try_end),
			(try_begin),
			   (ge, ":has_good", 1),
				(val_max, ":price_factor", ":best_foreign_price"),
			(else_try),
  		      #Make it so that lack of supply will not make the price lower
			   (lt, ":has_good", 1),
			   (val_max, ":price_factor", ":worst_price_seen"),
			(try_end),
		(try_end),

		(try_begin),
			(lt, ":has_good", 1),
			(val_max, ":price_factor", average_price_factor),#don't give bargains if there is no supply
			(val_mul, ":price_factor", 8),#sixty percent penalty
			(val_div, ":price_factor", 5),
		(try_end),

		#Apply constraints at the last step
		(val_clamp, ":price_factor", minimum_price_factor, maximum_price_factor),

		(assign, reg0, ":price_factor"),
		(assign, reg1, ":has_good"),
	]),

	# script_dplmc_get_faction_truce_length_with_faction
	# INPUT
	#   arg1:  faction_1
	#   arg2:  faction_2
	# OUTPUT
	#   reg0:  The length in days of faction_1's truce with faction_2, if any.
	#          If no truce exists, the appropriate value to return is zero.
    ("dplmc_get_faction_truce_length_with_faction",
	   [
	    (store_script_param, ":faction_1", 1),
		(store_script_param, ":faction_2", 2),

		(assign, ":truce_length", 0),

		(try_begin),
			(is_between, ":faction_1", kingdoms_begin, kingdoms_end),
			(is_between, ":faction_2", kingdoms_begin, kingdoms_end),
			(neq, ":faction_1", ":faction_2"),
			(store_add, ":truce_slot", ":faction_2", slot_faction_truce_days_with_factions_begin),
			(val_sub, ":truce_slot", kingdoms_begin),
			(faction_get_slot, ":truce_length", ":faction_1", ":truce_slot"),
        (try_end),
	    (assign, reg0, ":truce_length"),
	   ]),

  #script_dplmc_get_terrain_code_for_battle
  #
  # Gets the terrain code for a battle between two parties, which
  # is usually a value like rt_desert, but can instead be two
  # special values: -1 for
  #
  # INPUT: arg1 = attacker_party
  #        arg2 = defender_party
  # OUTPUT: reg0 = terrain code (-1 for invalid, -2 for siege)
  ("dplmc_get_terrain_code_for_battle",
   [
      (store_script_param, ":attacker_party", 1),
      (store_script_param, ":defender_party", 2),

      (assign, reg0, dplmc_terrain_code_unknown), #Terrain code, defined in header_terrain_types.py

	  (try_begin),
		#Check for village missions
         (this_or_next|eq, ":attacker_party", "p_main_party"),
			(eq, ":defender_party", "p_main_party"),
		 (ge, "$g_encounter_is_in_village", 1),
		 (assign, reg0, dplmc_terrain_code_village),#defined in header_terrain_types.py
      (else_try),
		#If the attacker party is a town, a castle, a village, a bandit lair, or a ship,
		#set the terrain code to "none" since we don't have any specific ideas for modifying
		#the unit-type performance in scenarios of that type (whatever they are).
         (ge, ":attacker_party", 0),
         (this_or_next|party_slot_eq, ":attacker_party", slot_party_type, spt_town),#no modifier for being attacked by garrisoned troops
         (this_or_next|party_slot_eq, ":attacker_party", slot_party_type, spt_castle),
         (this_or_next|party_slot_eq, ":attacker_party", slot_party_type, spt_village),
         (this_or_next|party_slot_eq, ":attacker_party", slot_party_type, spt_bandit_lair),
			(party_slot_eq, ":attacker_party", slot_party_type, spt_ship),#no modifier for being attacked by a ship
         (assign, reg0, dplmc_terrain_code_unknown),#no terrain options, defined in header_terrain_types.py
	  (else_try),
		#If the attacker party is *attached* to a town/castle/village, a bandit lair, or a ship,
		#set the terrain code to "none" since we don't have any specific ideas for modifying
		#the unit-type performance in scenarios of that type (whatever they are).
	     (ge, ":attacker_party", 0),
	     (party_get_attached_to, ":attachment", ":attacker_party"),
		 (ge, ":attachment", 0),
		 (party_is_active, ":attachment"),
		 (this_or_next|party_slot_eq, ":attachment", slot_party_type, spt_town),#no modifier for being attacked by garrisoned troops
         (this_or_next|party_slot_eq, ":attachment", slot_party_type, spt_castle),
         (this_or_next|party_slot_eq, ":attachment", slot_party_type, spt_village),
         (this_or_next|party_slot_eq, ":attachment", slot_party_type, spt_bandit_lair),
			(party_slot_eq, ":attachment", slot_party_type, spt_ship),#no modifier for being attacked by a ship
         (assign, reg0, dplmc_terrain_code_unknown),#no terrain modifiers
      (else_try),
		#If the attacker party isn't a weird type, the terrain is entirely based on the
		#defender (unless the defender is invalid).
         (ge, ":defender_party", 0),
         (try_begin),
			#If the defender is a walled center, use siege mode.
            (this_or_next|party_slot_eq, ":defender_party", slot_party_type, spt_town),
            (party_slot_eq, ":defender_party", slot_party_type, spt_castle),
            (assign, reg0, dplmc_terrain_code_siege),#siege mode, defined in header_terrain_types.py
		 (else_try),
			#If the defender is a village
			(party_slot_eq, ":defender_party", slot_party_type, spt_village),
			(assign, reg0, dplmc_terrain_code_village),
         (else_try),
			#If the defender is a bandit lair or a ship, use no terrain modifier.
            (this_or_next|party_slot_eq, ":defender_party", slot_party_type, spt_bandit_lair),
				(party_slot_eq, ":defender_party", slot_party_type, spt_ship),
            (assign, reg0, dplmc_terrain_code_unknown),#no terrain modifiers
 		 (else_try),
			#If the defender is attached, do the same checks but for the attachment.
		    (party_get_attached_to, ":attachment", ":defender_party"),
			(ge, ":attachment", 0),
			(party_is_active, ":attachment"),
			(assign, ":attachment_value", -100),
			(try_begin),
				#Walled centers use siege modifiers
			   (this_or_next|party_slot_eq, ":attachment", slot_party_type, spt_town),
			      (party_slot_eq, ":attachment", slot_party_type, spt_castle),
			   (assign, ":attachment_value", dplmc_terrain_code_siege),
			(else_try),
				#Villages
			   (party_slot_eq, ":attachment", slot_party_type, spt_village),
			   (assign, ":attachment_value", dplmc_terrain_code_village),
			(else_try),
				#bandit-lairs and ships have no modifiers currently
			   (this_or_next|party_slot_eq, ":attachment", slot_party_type, spt_bandit_lair),
				(party_slot_eq, ":attachment", slot_party_type, spt_ship),
			   (assign, ":attachment_value", dplmc_terrain_code_unknown),#no terrain modifiers
			(try_end),
			#If neither of the above apply, fall through to the next condition.
			(neq, ":attachment_value", -100),
			(assign, reg0, ":attachment_value"),
         (else_try),
			#Use the terrain under the defender.
			#In the future I might want to change this so there's a tactics contest
			#between the attacker and defender to choose the more favorable ground
			#from their immediate surroundings.  I would also have to change the actual
			#terrain-type code.
            (party_get_current_terrain, reg0, ":defender_party"),
		 (try_end),
      (else_try),
		 #If we get here, it means the defender was invalid, so use the terrain under
		 #the attacker.
         (ge, ":attacker_party", 0),
         (party_get_current_terrain, reg0, ":attacker_party"),#terrain under attacker
      (try_end),
   ]),

  #script_dplmc_party_calculate_strength_in_terrain
  # INPUT: arg1 = party_id
  #        arg2 = terrain (from header_terrain_types.py)
  #        arg3 = exclude leader (0 for do-not-exclude, 1 for exclude)
  #        arg4 = cache policy (1 is use terrain, 2 is use non-terrain, 0 is do not use)
  # OUTPUT: reg0 = strength with terrain
  #         reg1 = strength ignoring terrain
  ("dplmc_party_calculate_strength_in_terrain",
    [
      (store_script_param, ":party", 1), #Party_id
      (store_script_param, ":terrain_type", 2),#a value from header_terrain_types.py
      (store_script_param, ":exclude_leader", 3),#(0 for do-not-exclude, 1 for exclude)
      (store_script_param, ":cache_policy", 4),#1 is use terrain, 2 is use non-terrain, 0 is do not use)

      (assign, ":total_strength_terrain", 0),
      (assign, ":total_strength_no_terrain", 0),

      (party_get_num_companion_stacks, ":num_stacks", ":party"),
      (assign, ":first_stack", 0),
      (try_begin),
        (neq, ":exclude_leader", 0),
        (assign, ":first_stack", 1),
      (try_end),
	  #Bonus for heroes on top of the rest
	  (assign, ":hero_percent", 110),
	  ##Moved setting the multipliers out of the loop...
	  (assign, ":guaranteed_horse_percent", 100),
	  (assign, ":guaranteed_ranged_percent", 100),
	  (assign, ":guaranteed_neither_percent", 100),
	  #First, test for some special codes:
	  (try_begin),
	     (eq, ":terrain_type", dplmc_terrain_code_none),#Apply no modifiers
		 (assign, ":hero_percent", 100),
	  (else_try),
	  	(eq, ":terrain_type", dplmc_terrain_code_village),#A dismounted fight at a village (apply hero modifier, nothing else)
      (else_try),
        (eq, ":terrain_type", dplmc_terrain_code_siege),#A siege battle, not including sorties.
        (assign, ":guaranteed_ranged_percent", 120),
	  #The rest are ordinary rt_* codes.
	  #I changed the balance of these to make the variations less extreme (e.g. 150% mounted strength on rt_steppe).
	  #I believe that the version from ArcherOS is trying to create certain map results, rather than solely
	  #make autocalc strength more accurate in terms of "what would happen if they fought the player".
	  (else_try),
        (eq, ":terrain_type", rt_steppe),
		#The 150% increase in the steppe strikes me as excessive.
		#Since the NPC cost increase for mounted troops is 20%, and the PC cost is 65%,
		#it isn't entirely implausible.
	    #(assign, ":guaranteed_horse_percent", 150),
		#Archer uses 150%, Custom Commander uses a flat 125%.
		(assign, ":guaranteed_horse_percent", 120),
	  (else_try),
		#I am unaware of any game mechanic in live battles that gives any disadvantage
		#to horses on snow or sand as opposed to a plain.
		(this_or_next|eq, ":terrain_type", rt_snow),
		(this_or_next|eq, ":terrain_type", rt_desert),
			(eq, ":terrain_type", rt_plain),
		(assign, ":guaranteed_horse_percent", 120),
     (else_try),
		#I suspect that the 120% mounted bonus for steppe forests is inaccurate,
		#but I haven't checked it out yet.
	    (eq, ":terrain_type", rt_steppe_forest),
        (assign, ":guaranteed_horse_percent", 120),
     (else_try),
        (this_or_next|eq, ":terrain_type", rt_forest),
        (this_or_next|eq, ":terrain_type", rt_mountain_forest),
		     (eq, ":terrain_type", rt_snow_forest),
        #(assign, ":guaranteed_neither_percent", 120),
		(assign, ":guaranteed_neither_percent", 110),
	 (try_end),

      (try_for_range, ":i_stack", ":first_stack", ":num_stacks"),
        (party_stack_get_troop_id, ":stack_troop",":party", ":i_stack"),
        (store_character_level, ":stack_strength", ":stack_troop"),
        (val_add, ":stack_strength", 4), #new was 12 (patch 1.125)
        (val_mul, ":stack_strength", ":stack_strength"),
        (val_mul, ":stack_strength", 2), #new (patch 1.125)
        #move the next two lines to after terrain advantage
        #(val_div, ":stack_strength", 100),
        #(val_max, ":stack_strength", 1), #new (patch 1.125)
        (assign, ":terrain_free_strength", ":stack_strength"),
        ##use Arch3r's terrain advantage code (bug-fix changes 2011-04-13; other changes 2011-04-25)
        (try_begin),
           ##AotE terrain advantages
           (assign, ":hero_horse", 0),#added for heroes (any positive number = has a horse)
           (try_begin),
		      (this_or_next|eq, "trp_player", ":stack_troop"),
				(troop_is_hero, ":stack_troop"),
		      (gt, ":guaranteed_horse_percent", ":hero_percent"),#don't bother if we wouldn't use the result
              (neg|troop_is_guarantee_horse, ":stack_troop"),#don't bother if we already know the troop has a horse
			  (store_skill_level, reg0, "skl_riding", ":stack_troop"),
			  (ge, reg0, 2),#don't bother if the troop has no/minimal riding skill
			  #Just checking ek_horse may not work for non-companions, so check the inventory
			  (troop_get_inventory_capacity, ":inv_cap", ":stack_troop"),
			  (ge, ":inv_cap", 1),
			  (val_min, ":inv_cap", dplmc_ek_alt_items_begin + 8),#Don't check too much of the inventory
			  (try_for_range, ":inv_slot", 0, ":inv_cap"),
				(troop_inventory_slot_get_item_amount, reg1, ":stack_troop", ":inv_slot"),
				(ge, reg1, 1),#quantity must be greater than zero
				(troop_get_inventory_slot, reg0, ":stack_troop", ":inv_slot"),
				(ge, reg0, 1),#must be a valid item
				(item_get_type, reg1, reg0),#check if the item is a horse
				(eq, reg1, itp_type_horse),
				(assign, ":inv_cap", ":inv_slot"),#break loop
			  (try_end),
			  #If no horse found, set to zero
              (neg|is_between, ":hero_horse", horses_begin, horses_end),
              (assign, ":hero_horse", 0),
           (try_end),
		   (assign, ":stack_strength_multiplier", 100),#<-- percent multiplier
           (try_begin),#Mounted troops
			  (this_or_next|ge, ":hero_horse", 1),
              (troop_is_guarantee_horse, ":stack_troop"),
              (assign, ":stack_strength_multiplier", ":guaranteed_horse_percent"),
		   (else_try),#Ranged troops
              (troop_is_guarantee_ranged, ":stack_troop"),
              (assign, ":stack_strength_multiplier", ":guaranteed_ranged_percent"),
           (else_try),#Infantry
              (assign, ":stack_strength_multiplier", ":guaranteed_neither_percent"),
           (try_end),

		   #Use hero/player modifiers if a better one didn't apply
		   (try_begin),
		      (this_or_next|eq, ":stack_troop", "trp_player"),
			     (troop_is_hero, ":stack_troop"),
			  (val_max, ":stack_strength_multiplier", ":hero_percent"),#hero bonus
		   (try_end),

		   (val_mul, ":stack_strength", ":stack_strength_multiplier"),
		   (val_add, ":stack_strength", 50),#add this before division for correct rounding
           (val_div, ":stack_strength", 100),
           ##AotE terrain advantages
        (try_end),
        #moved the next two lines here from above
        (val_div, ":stack_strength", 100),#<- moved here from above
        (val_max, ":stack_strength", 1), #new (patch 1.125) #<- moved here from above
        (val_div, ":terrain_free_strength", 100),
        (val_max, ":terrain_free_strength", 1),
        (try_begin),
          (neg|troop_is_hero, ":stack_troop"),
          (party_stack_get_size, ":stack_size",":party",":i_stack"),
          (party_stack_get_num_wounded, ":num_wounded",":party",":i_stack"),
          (val_sub, ":stack_size", ":num_wounded"),
          (val_mul, ":stack_strength", ":stack_size"),
          (val_mul, ":terrain_free_strength", ":stack_size"),
        (else_try),
          (troop_is_wounded, ":stack_troop"), #hero & wounded
          (assign, ":stack_strength", 0),
          (assign, ":terrain_free_strength", 0),
        (try_end),
        (val_add, ":total_strength_terrain", ":stack_strength"),
        (val_add, ":total_strength_no_terrain", ":terrain_free_strength"),
      (try_end),
	  #Load results into registers and cache if appropriate
	  (assign, reg0, ":total_strength_terrain"),
	  (assign, reg1, ":total_strength_no_terrain"),
      (try_begin),
         (eq, ":cache_policy", 1),
         (party_set_slot, ":party", slot_party_cached_strength, reg0),
      (else_try),
         (eq, ":cache_policy", 2),
         (party_set_slot, ":party", slot_party_cached_strength, reg1),
      (try_end),
  ]),


  #script_dplmc_player_can_give_troops_to_troop  (Warning, clobbers {s11}!)
  #
  # INPUT: arg1 = troop_id
  # OUTPUT: reg0 = 1 or more is yes, 0 or less is no
  #
  # This script does not take into account things like whether the troop
  # is a prisoner of a party, so it can be used for checking whether troops
  # can be added to a garrison.
  #
  # The general logic is that you can give troops to a member of your
  # own faction if any of the following are true:
  #   - You are the faction leader or marshall
  #   - You are the spouse of the faction leader, and the faction
  #     leader is not on bad terms with you
  #   - The troop is an affiliated family member
  #   - The troop is your spouse, and is either pliable or not on bad terms
  #   - The troop is a former companion with whom you are on good terms
  #   - The troop is related to you by marriage and you are on good terms
  #
  # For allied factions, the conditions are similar to the above.
  # However, being the marshall or leader of your own faction does not
  # guarantee cooperation from lords who dislike you.
  #
  # For non-allied other factions, the check for faction leader or
  # marshall are not relevant, and the faction must not be at war
  # with the player's faction.
  ("dplmc_player_can_give_troops_to_troop",
  [
	(store_script_param, ":troop_id", 1), #Party_id
	(assign, ":can_give_troops", 0),
	(assign, ":save_reg1", reg1),

	(try_begin),
		(this_or_next|eq, ":troop_id", "trp_kingdom_heroes_including_player_begin"),
		(eq, ":troop_id", "trp_player"),
		(assign, ":can_give_troops", 1),
	(else_try),
		(lt, ":troop_id", 1),
		(assign, ":can_give_troops", 0),
	(else_try),
		(store_faction_of_troop, ":troop_faction", ":troop_id"),

		(call_script, "script_troop_get_player_relation", ":troop_id"),
		(assign, ":troop_relation", reg0),
		(troop_get_slot, ":troop_reputation", ":troop_id", slot_lord_reputation_type),

		(try_begin),
			#Troop is member of player supporters faction
			(eq, ":troop_faction", "fac_player_supporters_faction"),
			##Always yes in Native, but if centralization is negative allow non-compliance
			(faction_get_slot, reg0, ":troop_faction", dplmc_slot_faction_centralization),
			(try_begin),
				(ge, reg0, 0),
				(assign, reg0, -200),
			(else_try),
				(val_mul, reg0, -10),
				(val_add, reg0, -35),#Centralization -1 has -25, -2 has -15, and -3 has -5
			(try_end),
			(gt, ":troop_relation", reg0),
			(assign, ":can_give_troops", 1),
		(else_try),
			#Troop is a member of the same faction as the player
			(eq, ":troop_faction", "$players_kingdom"),
			(faction_get_slot, ":troop_faction_leader", ":troop_faction", slot_faction_leader),
			(try_begin),
				#Leader or marshall
				(this_or_next|eq, ":troop_faction_leader", "trp_player"),
					(faction_slot_eq, ":troop_faction", slot_faction_marshall, "trp_player"),
				#If centralization is negative allow non-compliance
				(faction_get_slot, reg0, ":troop_faction", dplmc_slot_faction_centralization),
				(try_begin),
					(ge, reg0, 0),
					(assign, reg0, -200),
				(else_try),
					(val_mul, reg0, -10),
					(val_add, reg0, -35),#Centralization -1 has -25, -2 has -15, and -3 has -5
				(try_end),
				(gt, ":troop_relation", reg0),
				(assign, ":can_give_troops", 1),
			(else_try),
				#Spouse of leader
				(gt, ":troop_faction_leader", 1),
				(neg|troop_slot_eq, "trp_player", slot_troop_spouse, -1),
				(this_or_next|troop_slot_eq, ":troop_faction_leader", slot_troop_spouse, "trp_player"),
					(troop_slot_eq, "trp_player", slot_troop_spouse, ":troop_faction_leader"),
				(call_script, "script_troop_get_player_relation", ":troop_faction_leader"),
				(ge, reg0, 0),
				#If centralization is negative allow non-compliance
				(faction_get_slot, reg0, ":troop_faction", dplmc_slot_faction_centralization),
				(try_begin),
					(ge, reg0, 0),
					(assign, reg0, -200),
				(else_try),
					(val_mul, reg0, -10),
					(val_add, reg0, -35),#Centralization -1 has -25, -2 has -15, and -3 has -5
				(try_end),
				(gt, ":troop_relation", reg0),
				(assign, ":can_give_troops", 1),
			(else_try),
				#Spouse of troop
				(neg|troop_slot_eq, "trp_player", slot_troop_spouse, -1),
				(this_or_next|troop_slot_eq, ":troop_id", slot_troop_spouse, "trp_player"),
					(troop_slot_eq, "trp_player", slot_troop_spouse, ":troop_id"),
				(this_or_next|ge, ":troop_relation", 0),
				(this_or_next|eq, ":troop_reputation", lrep_conventional),
				(this_or_next|eq, ":troop_reputation", lrep_moralist),
					(eq, ":troop_reputation", lrep_otherworldly),
				(assign, ":can_give_troops", 1),
			(else_try),
				#Affiliated family member
				(call_script, "script_dplmc_is_affiliated_family_member", ":troop_id"),
				(ge, reg0, 1),
				(assign, ":can_give_troops", 1),
			(else_try),
				#Close companion previously under arms
				(this_or_next|is_between, ":troop_id", companions_begin, companions_end),
					(is_between, ":troop_id", pretenders_begin, pretenders_end),
				(neg|troop_slot_eq, ":troop_id", slot_troop_playerparty_history, dplmc_pp_history_nonplayer_entry),
				(ge, ":troop_relation", 20),
				(assign, ":can_give_troops", 1),
			(else_try),
				#In-law (or hypothetically a blood relative) who is close with the player
				(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":troop_id", "trp_player"),
				(ge, reg0, 2),#<-- deliberately set the cutoff to 2, not 1
				(ge, ":troop_relation", 14),
				(this_or_next|ge, reg0, 10),
					(ge, ":troop_relation", 20),
				(assign, ":can_give_troops", 1),
			(try_end),
		(else_try),
			#Troop is member of a faction allied with the player's
			(call_script, "script_dplmc_get_faction_truce_length_with_faction", "$players_kingdom", ":troop_faction"),
			(gt, reg0, dplmc_treaty_defense_days_expire),
			(faction_get_slot, ":player_faction_leader", "$players_kingdom", slot_faction_leader),
			(try_begin),
				#Leader or marshall
				(this_or_next|eq, ":player_faction_leader", "trp_player"),
					(faction_slot_eq, "$players_kingdom", slot_faction_marshall, "trp_player"),
				(ge, ":troop_relation", 0),#only for allied factions, not for the player's own faction
				(assign, ":can_give_troops", 1),
			(else_try),
				#Spouse of leader
				(gt, ":player_faction_leader", 1),
				(neg|troop_slot_eq, "trp_player", slot_troop_spouse, -1),
				(this_or_next|troop_slot_eq, ":player_faction_leader", slot_troop_spouse, "trp_player"),
					(troop_slot_eq, "trp_player", slot_troop_spouse, ":player_faction_leader"),
				(ge, ":troop_relation", 0),#only for allied factions, not for the player's own faction
				(call_script, "script_troop_get_player_relation", ":player_faction_leader"),
				(ge, reg0, 0),
				(assign, ":can_give_troops", 1),
			(else_try),
				#Spouse of troop
				(neg|troop_slot_eq, "trp_player", slot_troop_spouse, -1),
				(this_or_next|troop_slot_eq, ":troop_id", slot_troop_spouse, "trp_player"),
					(troop_slot_eq, "trp_player", slot_troop_spouse, ":troop_id"),
				(this_or_next|ge, ":troop_relation", 0),
				(this_or_next|eq, ":troop_reputation", lrep_conventional),
				(this_or_next|eq, ":troop_reputation", lrep_moralist),
					(eq, ":troop_reputation", lrep_otherworldly),
				(assign, ":can_give_troops", 1),
			(else_try),
				#Affiliated family member
				(call_script, "script_dplmc_is_affiliated_family_member", ":troop_id"),
				(ge, reg0, 1),
				(assign, ":can_give_troops", 1),
			(else_try),
				#Close companion previously under arms
				(this_or_next|is_between, ":troop_id", companions_begin, companions_end),
					(is_between, ":troop_id", pretenders_begin, pretenders_end),
				(neg|troop_slot_eq, ":troop_id", slot_troop_playerparty_history, dplmc_pp_history_nonplayer_entry),
				(ge, ":troop_relation", 20),
				(assign, ":can_give_troops", 1),
			(else_try),
				#In-law (or hypothetically a blood relative) who is close with the player
				(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":troop_id", "trp_player"),
				(ge, reg0, 2),#<-- deliberately set the cutoff to 2, not 1
				(ge, ":troop_relation", 14),
				(this_or_next|ge, reg0, 10),
					(ge, ":troop_relation", 20),
				(assign, ":can_give_troops", 1),
			(try_end),
		(else_try),
			#Troop is a member of a faction that isn't hostile to the player's
			(store_relation, reg0, ":troop_faction", "fac_player_faction"),
			(ge, reg0, 0),
			(store_relation, reg0, ":troop_faction", "$players_kingdom"),
			(ge, reg0, 0),
			(try_begin),
				#Spouse of troop
				(neg|troop_slot_eq, "trp_player", slot_troop_spouse, -1),
				(this_or_next|troop_slot_eq, ":troop_id", slot_troop_spouse, "trp_player"),
					(troop_slot_eq, "trp_player", slot_troop_spouse, ":troop_id"),
				(this_or_next|ge, ":troop_relation", 0),
				(this_or_next|eq, ":troop_reputation", lrep_conventional),
				(this_or_next|eq, ":troop_reputation", lrep_moralist),
					(eq, ":troop_reputation", lrep_otherworldly),
				(assign, ":can_give_troops", 1),
			(else_try),
				#Affiliated family member
				(call_script, "script_dplmc_is_affiliated_family_member", ":troop_id"),
				(ge, reg0, 1),
				(assign, ":can_give_troops", 1),
			(else_try),
				#Close companion previously under arms
				(this_or_next|is_between, ":troop_id", companions_begin, companions_end),
					(is_between, ":troop_id", pretenders_begin, pretenders_end),
				(neg|troop_slot_eq, ":troop_id", slot_troop_playerparty_history, dplmc_pp_history_nonplayer_entry),
				(ge, ":troop_relation", 20),
				(assign, ":can_give_troops", 1),
			(else_try),
				#In-law (or hypothetically a blood relative) who is close with the player
				(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":troop_id", "trp_player"),
				(ge, reg0, 2),#<-- deliberately set the cutoff to 2, not 1
				(ge, ":troop_relation", 14),
				(this_or_next|ge, reg0, 10),
					(ge, ":troop_relation", 20),
				(assign, ":can_give_troops", 1),
			(try_end),
		(try_end),
	(try_end),

	(assign, reg1, ":save_reg1"),
	(assign, reg0, ":can_give_troops"),
  ]),

  #script_dplmc_print_centers_in_numbers_to_s0
  #
  #similar to script_print_troop_owned_centers_in_numbers_to_s0
  #
  #INPUT:
  #  arg1: owned_towns
  #  arg2: owned_castles
  #  arg3: owned_villages
  #
  #OUTPUT:
  #  reg0: owned_towns + owned_castles + owned_villages
  #    s0: a string describing the numbers of centers
    ("dplmc_print_centers_in_numbers_to_s0",
   [
     (store_script_param_1, ":owned_towns"),
	 (store_script_param_2, ":owned_castles"),
	 (store_script_param, ":owned_villages", 3),
     (str_store_string, s0, "@nothing"),

     (assign, ":num_types", 0),
     (try_begin),
       (gt, ":owned_villages", 0),
       (assign, reg0, ":owned_villages"),
       (store_sub, reg1, reg0, 1),
       (str_store_string, s0, "@{reg0} village{reg1?s:}"),
       (val_add, ":num_types", 1),
     (try_end),

     (try_begin),
       (gt, ":owned_castles", 0),
       (assign, reg0, ":owned_castles"),
       (store_sub, reg1, reg0, 1),
       (try_begin),
         (eq, ":num_types", 0),
         (str_store_string, s0, "@{reg0} castle{reg1?s:}"),
       (else_try),
         (str_store_string, s0, "@{reg0} castle{reg1?s:} and {s0}"),
       (try_end),
       (val_add, ":num_types", 1),
     (try_end),

     (try_begin),
       (gt, ":owned_towns", 0),
       (assign, reg0, ":owned_towns"),
       (store_sub, reg1, reg0, 1),
       (try_begin),
         (eq, ":num_types", 0),
         (str_store_string, s0, "@{reg0} town{reg1?s:}"),
       (else_try),
         (eq, ":num_types", 1),
         (str_store_string, s0, "@{reg0} town{reg1?s:} and {s0}"),
       (else_try),
         (str_store_string, s0, "@{reg0} town{reg1?s:}, {s0}"),
       (try_end),
     (try_end),

     (store_add, reg0, ":owned_villages", ":owned_castles"),
     (val_add, reg0, ":owned_towns"),
     ]),

  #"script_dplmc_distribute_gold_to_lord_and_holdings"
  #
  #Related to script_dplmc_remove_gold_from_lord_and_holdings, divides the gold
  #between the lord and his fortresses in a semi-intelligent way.
  #
  #INPUT:
  #   arg1: the amount of gold
  #   arg2: the lord's ID
  ("dplmc_distribute_gold_to_lord_and_holdings",
   [
	(store_script_param_1, ":gold_left"),
	(store_script_param_2, ":lord_no"),

	(try_begin),
		(lt, ":lord_no", 0),#Invalid ID
	(else_try),
		#If the number is negative, handle this using script_dplmc_remove_gold_from_lord_and_holdings
		(lt, ":gold_left", 0),
		(val_mul, ":gold_left", -1),
		(call_script, "script_dplmc_remove_gold_from_lord_and_holdings", ":gold_left", ":lord_no"),
		(assign, ":gold_left", 0),
	(else_try),
		(neq, ":lord_no", "trp_player"),
		(neg|troop_is_hero, ":lord_no"),#Not hero or player
        (troop_add_gold, ":lord_no", ":gold_left"),
        (assign, ":gold_left", 0),
	(else_try),
		#The player doesn't use center wealth to pay garrison wages, so just
		#give it directly.
		(eq, ":lord_no", "trp_player"),
		(troop_add_gold, "trp_player", ":gold_left"),
		(assign, ":gold_left", 0),
	(else_try),
		(neg|troop_is_hero, ":lord_no"),#If the lord isn't the player, and isn't a hero, do nothing
	(else_try),
		(troop_get_slot, ":target_gold", ":lord_no", slot_troop_wealth),
		(val_max, ":target_gold", 0),
		#If the lord is low on gold, first he takes enough gold so he isn't low on funds,
		#or all of the gold, whichever is less.
		(store_sub, ":gold_to_give", 6000, ":target_gold"),#6000 is the standard starting gold for lords (kings start with more, but don't increase this for them, since I'm using this number as a "low on gold" threshold)
		(val_max, ":gold_to_give", 0),
		(val_min, ":gold_to_give", ":gold_left"),

		(val_add, ":target_gold", ":gold_to_give"),
		(troop_set_slot, ":lord_no", slot_troop_wealth, ":target_gold"),
		(val_sub, ":gold_left", ":gold_to_give"),
		#If gold remains, the lord gives some to any castles or towns he owns that have
		#low wealth.  Note that iterating in this order means that towns get checked
		#before castles do.
		(gt, ":gold_left", 0),
		(try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
			(party_slot_eq, ":center_no", slot_town_lord, ":lord_no"),
			(party_get_slot, ":target_gold", ":center_no", slot_town_wealth),
			#Don't give gold to centers with garrisons more than 50% above the ideal size
			(store_party_size_wo_prisoners, ":garrison_size", ":center_no"),
			(call_script, "script_party_get_ideal_size", ":center_no"),#This script has been modified to support this use
			(val_mul, reg0, 3),
			(val_div, reg0, 2),
			(ge, reg0, ":garrison_size"),

			(try_begin),
				(party_slot_eq, ":center_no", slot_party_type, spt_town),
				(store_sub, ":gold_to_give", 4000, ":target_gold"),#4000 is the standard starting gold for towns
			(else_try),
				(store_sub, ":gold_to_give", 2000, ":target_gold"),#2000 is the standard starting gold for castles
			(try_end),

			(val_max, ":gold_to_give", 0),
			(val_min, ":gold_to_give", ":gold_left"),
			(gt, ":gold_to_give", 0),
			(val_add, ":target_gold", ":gold_to_give"),
			(party_set_slot, ":center_no", slot_town_wealth, ":target_gold"),
			(val_sub, ":gold_left", ":gold_to_give"),
		(try_end),
		#If gold is left -- the lord isn't low on gold, and none of his walled centers are --
		#he pockets the remainder.
		(gt, ":gold_left", 0),
		(troop_get_slot, ":target_gold", ":lord_no", slot_troop_wealth),
		(val_add, ":target_gold", ":gold_left"),
		(val_max, ":target_gold", 0),
		(troop_set_slot, ":lord_no", slot_troop_wealth, ":target_gold"),
		(assign, ":gold_left", 0),
	(try_end),
	]),


  #"script_dplmc_remove_gold_from_lord_and_holdings"
  #
  #
  #INPUT:
  #   arg1: the amount of money to remove (greater than zero)
  #   arg2: the ID of the lord spending the money
  #
  #OUTPUT:
  #   None
    ("dplmc_remove_gold_from_lord_and_holdings",
   [
    (store_script_param_1, ":gold_cost"),
	(store_script_param_2, ":lord_no"),

	(try_begin),
		(lt, ":lord_no", 0),#Invalid ID
	(else_try),
		(neq, ":lord_no", "trp_player"),
		(neg|troop_is_hero, ":lord_no"),#Not player or hero
	(else_try),
		#If the number is negative, give gold instead of taking it.
		#Handle this using script_dplmc_distribute_gold_to_lord_and_holdings
		(lt, ":gold_cost", 0),
		(val_mul, ":gold_cost", -1),
		(call_script, "script_dplmc_distribute_gold_to_lord_and_holdings", ":gold_cost", ":lord_no"),
		(assign, ":gold_cost", 0),
	(else_try),
		#For the player, first subtract the gold from his treasury (if any).
		(eq, ":lord_no", "trp_player"),
	    (store_troop_gold, ":treasury", "trp_household_possessions"),
		(try_begin),
		(ge, ":treasury", 1),
		(val_min, ":treasury", ":gold_cost"),
		(call_script, "script_dplmc_withdraw_from_treasury", ":treasury"),
		(val_sub, ":gold_cost", ":treasury"),
		(try_end),
		(store_troop_gold, ":treasury", "trp_player"),
		(try_begin),
			(ge, ":treasury", 1),
			(val_min, ":treasury", ":gold_cost"),
			(troop_remove_gold, "trp_player", ":treasury"),
			(val_sub, ":gold_cost", ":treasury"),
		(try_end),
		#Fall through to the next section if the treasury didn't cover it.
		(lt, ":gold_cost", 1),
	(else_try),
		#Remove the gold directly from the lord's wealth slot
		(ge, ":gold_cost", 1),
		(ge, ":lord_no", 1),#not the player
		(troop_get_slot, ":treasure", ":lord_no", slot_troop_wealth),
		(ge, ":treasure", 1),
		(try_begin),
			(ge, ":treasure", ":gold_cost"),
			(val_sub, ":treasure", ":gold_cost"),
			(assign, ":gold_cost", 0),
		(else_try),
			(val_sub, ":gold_cost", ":treasure"),
			(assign, ":treasure", 0),
		(try_end),
		(troop_set_slot, ":lord_no", slot_troop_wealth, ":treasure"),
		#Fall through to the next section if his personal wealth didn't cover it.
		(lt, ":gold_cost", 1),
	(else_try),
		#Remove remaining gold from uncollected taxes.
		#We iterate backwards in order to remove from villages before castles and towns.
		(ge, ":gold_cost", 1),
		(try_for_range_backwards, ":center_no", centers_begin, centers_end),
			(ge, ":gold_cost", 1),
			(party_slot_eq, ":center_no", slot_town_lord, ":lord_no"),
			(party_get_slot, ":treasure", ":center_no", slot_center_accumulated_rents),
			(try_begin),
               	(gt, ":treasure", 0),
				(ge, ":treasure", ":gold_cost"),
				(val_sub, ":treasure", ":gold_cost"),
				(assign, ":gold_cost", 0),
			(else_try),
               	(gt, ":treasure", 0),
				(val_sub, ":gold_cost", ":treasure"),
				(assign, ":treasure", 0),
			(try_end),
				(party_set_slot, ":center_no", slot_center_accumulated_rents, ":treasure"),

			(ge, ":gold_cost", 1),
			(party_get_slot, ":treasure", ":center_no", slot_center_accumulated_tariffs),
			(try_begin),
               	(gt, ":treasure", 0),
				(ge, ":treasure", ":gold_cost"),
				(val_sub, ":treasure", ":gold_cost"),
				(assign, ":gold_cost", 0),
			(else_try),
               	(gt, ":treasure", 0),
				(val_sub, ":gold_cost", ":treasure"),
				(assign, ":treasure", 0),
			(try_end),
			(party_set_slot, ":center_no", slot_center_accumulated_tariffs, ":treasure"),
		(try_end),
		#Fall through to the next section if the uncollected taxes didn't cover it.
		(lt, ":gold_cost", 1),
	(else_try),
		#Remove remaining gold from center wealth.  We iterate backwards to remove from
		#castles before towns.
		(ge, ":gold_cost", 1),
		(try_for_range_backwards, ":center_no", centers_begin, centers_end),
			(ge, ":gold_cost", 1),
			(party_slot_eq, ":center_no", slot_town_lord, ":lord_no"),
			(party_get_slot, ":treasure", ":center_no", slot_town_wealth),
		(ge, ":treasure", 1),
		(try_begin),
			(ge, ":treasure", ":gold_cost"),
			(val_sub, ":treasure", ":gold_cost"),
			(assign, ":gold_cost", 0),
		(else_try),
			(val_sub, ":gold_cost", ":treasure"),
			(assign, ":treasure", 0),
		(try_end),
			(party_set_slot, ":center_no", slot_town_wealth, ":treasure"),
		(try_end),
		(lt, ":gold_cost", 1),
	(else_try),
	    #Try to remove the gold from the hero himself
		(store_troop_gold, ":treasure", ":lord_no"),
		(gt, ":treasure", 0),
		(try_begin),
			(ge, ":treasure", ":gold_cost"),
			(troop_remove_gold, ":lord_no", ":gold_cost"),
			(assign, ":gold_cost", 0),
		(else_try),
			(troop_remove_gold, ":treasure"),
			(val_sub, ":gold_cost", ":treasure"),
		(try_end),
	(try_end),

   ]),

  # "script_dplmc_prepare_hero_center_points_ignoring_center"
  #
  # Input: arg1 = target_center
   ("dplmc_prepare_hero_center_points_ignoring_center",[
	  (store_script_param, ":target_center", 1),

	  (troop_set_slot, "trp_player", slot_troop_temp_slot, 0),
	  (troop_set_slot, "trp_player", dplmc_slot_troop_temp_slot, 0),

	  (try_for_range, ":troop_no", heroes_begin, heroes_end),
		(troop_set_slot, ":troop_no", slot_troop_temp_slot, 0),
		(troop_set_slot, ":troop_no", dplmc_slot_troop_temp_slot, 0),
	  (try_end),

	  (try_for_range, ":center_no", centers_begin, centers_end),
	    #Skip "target center"
		(neq, ":center_no", ":target_center"),

		#Lord is player or a hero
		(party_get_slot, ":troop_no", ":center_no", slot_town_lord),
		(this_or_next|eq, ":troop_no", "trp_player"),
			(is_between, ":troop_no", heroes_begin, heroes_end),

		#Update lord point total
		(assign, ":center_points", 1),
		(try_begin),
			(party_slot_eq, ":center_no", slot_party_type, spt_town),
			(assign, ":center_points", 3),
		(else_try),
			(party_slot_eq, ":center_no", slot_party_type, spt_castle),
			(assign, ":center_points", 2),
		(try_end),

		(troop_get_slot, ":slot_value", ":troop_no", slot_troop_temp_slot),
		(val_add, ":slot_value", ":center_points"),
		(troop_set_slot, ":troop_no", slot_troop_temp_slot, ":slot_value"),

		#Update distance from closest owned center to target
		(is_between, ":target_center", centers_begin, centers_end),
		(troop_get_slot, ":slot_value", ":troop_no", dplmc_slot_troop_temp_slot),
		(store_distance_to_party_from_party, ":cur_distance", ":target_center", ":center_no"),
		(val_max, ":cur_distance", 1),
		(try_begin),
			(eq, ":slot_value", 0),
			(assign, ":slot_value", ":cur_distance"),
		(try_end),
		(val_min, ":slot_value", ":cur_distance"),
		(troop_set_slot, ":troop_no", dplmc_slot_troop_temp_slot, ":slot_value"),
	  (try_end),
	  ##Update cached totals
	  (try_for_range, ":troop_no", heroes_begin, heroes_end),
		(troop_get_slot, reg0, ":troop_no", slot_troop_temp_slot),
		(val_add, reg0, 1),
		(troop_set_slot, ":troop_no", dplmc_slot_troop_center_points_plus_one, reg0),
          (try_end),
          (troop_get_slot, reg0, "trp_player", slot_troop_temp_slot),
          (val_add, reg0, 1),
          (troop_set_slot, "trp_player", dplmc_slot_troop_center_points_plus_one, reg0),
          #Since the target center was omitted from the point totals, handle it here
	  (try_begin),
		(is_between, ":target_center", centers_begin, centers_end),
		(party_get_slot, ":troop_no", ":target_center", slot_town_lord),
		#Only perform this update for a troop whose center point value was updated above
		(this_or_next|is_between, ":troop_no", heroes_begin, heroes_end),
		(eq, ":troop_no", "trp_player"),
		(troop_get_slot, reg0, ":troop_no", dplmc_slot_troop_center_points_plus_one),
		(val_add, reg0, 1),#1 point for villages
		(try_begin),
		   (is_between, ":target_center", walled_centers_begin, walled_centers_end),
		   (val_add, reg0, 1),#2 points for castles
		   (is_between, ":target_center", towns_begin, towns_end),
		   (val_add, reg0, 1),#3 points for towns
		(try_end),
		(troop_set_slot, ":troop_no", dplmc_slot_troop_center_points_plus_one, reg0),
	  (try_end),
   ]),


  # script_dplmc_calculate_troop_score_for_center_aux
  #  Similar to script_calculate_troop_score_for_center
  #
  # slot_troop_temp_slot must already be loaded with center points;
  # dplmc_slot_troop_temp_slot must already be loaded with distance.
  #
  # Input: arg1 = evaluator
  #        arg2 = troop_no
  #        arg3 = center_no
  # Output: reg0 = score
  #         reg1 = explanation string
  ("dplmc_calculate_troop_score_for_center_aux",
   [(store_script_param, ":troop_1", 1),
    (store_script_param, ":troop_2", 2),
	 (store_script_param, ":center_no", 3),

	 (assign, ":explanation", "str_political_explanation_most_deserving_in_faction"),
	 (assign, ":explanation_priority", -1),

   (try_begin),
      (lt, ":troop_1", 0),
      (assign, ":relation", 0),
      (assign, ":reputation", lrep_none),
   (else_try),
      (eq, ":troop_1", ":troop_2"),
      (assign, ":relation", 50),
	   (troop_get_slot, ":reputation", ":troop_1", slot_lord_reputation_type),
   (else_try),
      (call_script, "script_troop_get_relation_with_troop", ":troop_1", ":troop_2"),
      (assign, ":relation", reg0),
      (troop_get_slot, ":reputation", ":troop_1", slot_lord_reputation_type),
   (try_end),
   (val_clamp, ":relation", -100, 101),

   (troop_get_slot, reg0, ":troop_2", slot_troop_renown),
   (val_max, reg0, 0),
   (store_add, ":score", 500, reg0),
	(troop_get_slot, ":num_center_points", ":troop_2", slot_troop_temp_slot),
	(val_max, ":num_center_points", 0),
	(val_add, ":num_center_points", 1),

	#Subtract distance from closest other fief owned, except when
	#considering the lord's original holdings.
	(try_begin),
	  (troop_slot_ge, ":troop_2", slot_troop_temp_slot, 1),
	  (neg|troop_slot_eq, ":troop_2", slot_troop_home, ":center_no"),
	  (neg|party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":troop_2"),

	  (troop_get_slot, reg0, ":troop_2", dplmc_slot_troop_temp_slot),
	  (gt, reg0, 1),
	  (val_min, reg0, 250),#upper cap on distance effect (bear in mind that this is subtracted from 500 + troop renown)
	  (val_sub, ":score", reg0),
	(try_end),

   #(store_random_in_range, ":random", 50, 100),
   #(val_mul, ":score", ":random"),
	(val_mul, ":score", 75),
   (val_div, ":score", ":num_center_points"),

	(assign, ":fiefless_bonus_used", 0),
	(try_begin),
	   #Bonus for lords with no other fiefs when a village is being considered.
      (lt, ":num_center_points", 2),
	  (party_slot_eq, ":center_no", slot_party_type, spt_village),
      (neq, ":reputation", lrep_debauched),
      (neq, ":reputation", lrep_selfrighteous),
      (neq, ":reputation", lrep_quarrelsome),
		(val_mul, ":score", 2),
		(try_begin),
		  (lt, ":explanation_priority", 100),
		  (assign, ":explanation_priority", 100),
		  (assign, ":explanation", "str_political_explanation_lord_lacks_center"),
		(try_end),
	 (assign, ":fiefless_bonus_used", 1),#because it has already been applied
	(try_end),

	(assign, ":troop_2_slot_alias", ":troop_2"),
	(try_begin),
		(eq, ":troop_2", "trp_player"),
		(assign, ":troop_2_slot_alias", "trp_kingdom_heroes_including_player_begin"),
	(try_end),

   (try_begin),
	#Bonus for conquerer
		(neq, ":reputation",  lrep_debauched),
		(this_or_next|neq, ":reputation", lrep_selfrighteous),
		   (eq, ":troop_1", ":troop_2"),
		(neq, ":reputation", lrep_cunning),
	  (neg|party_slot_eq, ":center_no", slot_party_type, spt_village),
      (party_slot_eq, ":center_no", slot_center_last_taken_by_troop, ":troop_2_slot_alias"),
	  (try_begin),
		 (lt, ":num_center_points", 2),
		 (eq, ":fiefless_bonus_used", 0),
		 (assign, reg1, 50),#50% increase
	  (else_try),
	     (this_or_next|troop_slot_eq, ":troop_2", slot_troop_home, ":center_no"),
		 (this_or_next|party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":troop_2_slot_alias"),
		 (this_or_next|party_slot_eq, ":center_no", dplmc_slot_center_ex_lord, ":troop_2_slot_alias"),
			(eq, ":reputation", lrep_martial),
		 (assign, reg1, 50),#50% increase
	  (else_try),
		 (assign, reg1, 25),#25% increase
	  (try_end),
	  (store_add, reg0, 100, reg1),
	  (val_mul, ":score", reg0),
	  (val_div, ":score", 100),
		(try_begin),
		  (ge, reg1, ":explanation_priority"),
		  (assign, ":explanation_priority", reg1),
		  (assign, ":explanation", "str_political_explanation_lord_took_center"),
 		(try_end),
	(else_try),
	#Bonus for original owner
		(gt, ":troop_2", 0),
		(party_slot_eq, ":center_no", dplmc_slot_center_original_lord, ":troop_2_slot_alias"),
		(try_begin),
			(lt, ":num_center_points", 2),
			(eq, ":fiefless_bonus_used", 0),
			(assign, reg1, 50),#50% increase
		(else_try),
			(this_or_next|eq, ":troop_2", ":troop_1"),
			(this_or_next|troop_slot_eq, ":troop_2", slot_troop_home, ":center_no"),
				(party_slot_eq, ":center_no", dplmc_slot_center_ex_lord, ":troop_2_slot_alias"),
			(assign, reg1, 50),#50% increase
		(else_try),
			(assign, reg1, 25),#25% increase
		(try_end),
		(store_add, reg0, 100, reg1),
		(val_mul, ":score", reg0),
		(val_div, ":score", 100),
		(try_begin),
		  (ge, reg1, ":explanation_priority"),
		  (assign, ":explanation_priority", reg1),
        (assign, ":explanation", "str_dplmc_political_explanation_original_lord"),
 		(try_end),
	(else_try),
	#Bonus for previous owner, lord
		(gt, ":troop_2", 0),
		(party_slot_eq, ":center_no", dplmc_slot_center_ex_lord, ":troop_2_slot_alias"),
		(try_begin),
			(lt, ":num_center_points", 2),
			(eq, ":fiefless_bonus_used", 0),
			(assign, reg1, 50),#50% increase
		(else_try),
		(troop_slot_eq, ":troop_2", slot_troop_home, ":center_no"),
			(assign, reg1, 50),
		(else_try),
			(assign, reg1, 25),#25% increase
		(try_end),
		(store_add, reg0, 100, reg1),
		(val_mul, ":score", reg0),
		(val_div, ":score", 100),
		(try_begin),
		  (ge, reg1, ":explanation_priority"),
		  (assign, ":explanation_priority", reg1),
        (assign, ":explanation", "str_dplmc_political_explanation_original_lord"),
 		(try_end),
	(else_try),
	#Bonus for lord claiming the center as home
		(troop_slot_eq, ":troop_2", slot_troop_home, ":center_no"),
		(val_mul, ":score", 5),
		(val_div, ":score", 4),
		(try_begin),
		  (ge, 25, ":explanation_priority"),
		  (assign, ":explanation_priority", 25),
        (assign, ":explanation", "str_dplmc_political_explanation_original_lord"),
 		(try_end),
	(else_try),
	#Aesthetic penalty (doesn't apply when there was a bonus)
	#To try to make the late game less mixed, have a preference towards
	#assigning lords to their own faction types.
		(troop_get_slot, reg0, ":troop_2", slot_troop_original_faction),
		(party_get_slot, reg1, ":center_no", slot_center_original_faction),
		(neq, reg0, reg1),
	#These extra checks are to avoid penalizing the player or promoted companions
	#unintentionally.
		(is_between, reg0, npc_kingdoms_begin, npc_kingdoms_end),
		(is_between, reg1, npc_kingdoms_begin, npc_kingdoms_end),
		#Take 95% of score
		(val_mul, ":score", 19),
		(val_add, ":score", 10),
		(val_div, ":score", 20),
   (try_end),

	#add 2 x relation (minus controversy) to score
   (troop_get_slot, ":controversy", ":troop_2", slot_troop_controversy),
   (val_clamp, ":controversy", 0, 101),
	(store_mul, ":relation_mod", ":relation", 2),
	(val_sub, ":relation_mod", ":controversy"),
	#this modifier will not raise the score by more than 50%
	(store_add, reg0, ":score", 1),
	(val_div, reg0, 2),
	(val_max, reg0, 1),
	(val_min, ":relation_mod", reg0),

	(store_mul, reg0, ":score", 100),#rego has pre-relationship modified score
	(val_add, ":score", ":relation_mod"),
	(val_div, reg0, ":score"),
	(store_sub, reg1, ":score", 100),#reg1 has percentage change (i.e. 1.5 times becomes 50% change) from relation/controversy

	(try_begin),
		(ge, reg1, 0),
		(ge, reg1, ":explanation_priority"),
		  (ge, ":relation", 15),
		(assign, ":explanation_priority", reg1),
		  (assign, ":explanation", "str_political_explanation_most_deserving_friend"),
	(try_end),

   (assign, reg0, ":score"),
	(assign, reg1, ":explanation"),
   ]),


  #Adapted "auto-sell" from rubik's Custom Commander
  #auto sell credit rubik (CC) begin:
  #
  # script_dplmc_auto_sell
  # INPUTS:
  #    arg1 :customer (the one selling the stuff)
  #    arg2 :merchant (the one buying the stuff)
  #    arg3 :auto_sell_price_limit (only sell stuff less expensive than this)
  #    arg4 :valid_items_begin (use this to only sell a limited range of things)
  #    arg5 :valid_items_end   (use this to only sell a limited range of things)
  #    arg6 :actually_sell_items (set to 0 for a "dry run"; set to 2 to print a descriptive message)
  #
  # OUTPUTS:
  #    reg0 amount of gold gained by customer (not actually gained if this was a dry run)
  #    reg1 number of items sold by customer (not actually sold if this was a dry run)
  ("dplmc_auto_sell", [
	#This script has various changes from the CC version.
	#In particular, all parameters other than "customer" and "merchant",
	#and reporting the number of items & gold change.
	(store_script_param, ":customer", 1),
	(store_script_param, ":merchant", 2),
	#dplmc+ start added parameters
	(store_script_param, ":auto_sell_price_limit", 3),
	(store_script_param, ":valid_items_begin", 4),
	(store_script_param, ":valid_items_end", 5),
	(store_script_param, ":actually_sell_items", 6),
	#dplmc+ end added parameters

	#dplmc+ added section begin
	(assign, ":save_reg2", reg2),
	(assign, ":save_reg3", reg3),
	(assign, ":save_reg65", reg65),
	(assign, ":save_talk_troop", "$g_talk_troop"),
	#The talk troop is used for price information, but it's possible for this to be called
	#from other contexts (like a menu).
	(assign, "$g_talk_troop", ":merchant"),

	(assign, ":gold_gained", 0),
	(assign, ":items_sold", 0),
	#(assign, ":most_expensive_sold_item", -1),
	#(assign, ":most_expensive_sold_imod", -1),
	#(assign, ":most_expensive_sold_price", -1),
	#dplmc+ added section end

    (store_free_inventory_capacity, ":space", ":merchant"),
    (troop_get_inventory_capacity, ":inv_cap", ":customer"),
	(set_show_messages, 0),#<-dplmc+ added
	(store_troop_gold, ":m_gold", ":merchant"),#dplmc+: to support "dry runs", move this out of the loop
    (try_for_range_backwards, ":i_slot", dplmc_ek_alt_items_end, ":inv_cap"),#we're reserving several "safe" slots in the beginning of the inventory
      (troop_get_inventory_slot, ":item", ":customer", ":i_slot"),
      (troop_get_inventory_slot_modifier, ":imod", ":customer", ":i_slot"),
      (gt, ":item", -1),
      (item_get_type, ":type", ":item"),
      (item_slot_eq, ":type", dplmc_slot_item_type_not_for_sell, 0),
	  #dplmc+ begin added constraints
	  (is_between, ":item", ":valid_items_begin", ":valid_items_end"),
	  (neg|is_between, ":type", books_begin, books_end),
	  (this_or_next|neg|is_between, ":type", food_begin, food_end),
	     (eq, ":imod", imod_rotten),
	  (neg|is_between, ":type", trade_goods_begin, trade_goods_end),
	  (neq, ":imod", imod_lordly),#dplmc+: never sell "lordly" items
	  #dplmc+ end added constraints

      (call_script, "script_dplmc_get_item_value_with_imod", ":item", ":imod"),
      (assign, ":score", reg0),
      (val_div, ":score", 100),
      (call_script, "script_game_get_item_sell_price_factor", ":item"),
      (assign, ":sell_price_factor", reg0),
      (val_mul, ":score", ":sell_price_factor"),
      (val_div, ":score", 100),
      (val_max, ":score",1),

	  #dplmc+ start changed section
	  (le, ":score", ":auto_sell_price_limit"),
	  (le, ":score", ":m_gold"),
	  (gt, ":space", 0),

	  #For equipment, in general don't sell the item unless you have a better one,
	  #or the item is useless to you.  (The idea is to stop from accidentally
	  #selling the player's own equipment.)
	  (item_get_type, ":this_item_type", ":item"),

	  #Normally, we would do the following:

	  #(try_begin),
	  #   (item_slot_eq, ":item", dplmc_slot_two_handed_one_handed, 1),
	  #	 (assign, ":this_item_type", 11), # type 11 = two-handed/one-handed
	  #(try_end),

	  #However, we are delaying that step until later, because type 11 is the
	  #same as itp_type_goods.


	  #Don't sell items if there's a reasonable chance that they might
	  #be the player's alternate personal equipment.  It goes without saying
	  #that items the player can't use aren't counted.
	  #
	  #(Items the player has equipped will not even be considered for sale,
	  #but it is common for players to have a variety of items they use in
	  #different circumstances, which might not all be equipped.)
	  #
	  #For melee weapons: don't sell the best weapon or the second-best of a type
	  #   (it might be a backup, or there might be a variety of weapons of
	  #   the same type in situational use)
	  #For shields: don't sell the best or second-best shield
	  #For thrown weapons: don't sell the best three thrown weapons
	  #For ammunition: don't sell the best three of the ammunition kind (arrows,
	  #   bolts) unless you lack a weapon that uses the ammunition.
	  #For armor: don't sell the best armor of a kind.
	  #For horses: don't sell the best or second-best horse
	  #For bows and crossbows: don't sell the best item of a kind (all bows are
	  #   very similar, so there's little chance someone would carry an alternate)
	  #For muskets and pistols: don't sell the best or second-best weapon of
	  #   a kind.

	  (assign, ":can_sell", 1),

	  (try_begin),
		 #Ammunition type: arrows (if you have a bow you can use, don't sell the best 3 arrow packs you have)
	     (eq, ":this_item_type", itp_type_arrows),
		 (call_script, "script_dplmc_scan_for_best_item_of_type", ":customer", itp_type_bow, ":customer"),
		 (try_begin),
			(ge, reg0, 0),
			(call_script, "script_dplmc_count_better_items_of_same_type", ":customer", ":item", ":imod", ":customer"),
			(lt, reg0, 3),#must not be best (0), second-best (1), or third-best (2)
			(assign, ":can_sell", 0),
		 (try_end),
	  (else_try),
		#Ammunition type: bolts (if you have a crossbow you can use, don't sell the best 3 bolt packs you have)
	     (eq, ":this_item_type", itp_type_bolts),
		 (call_script, "script_dplmc_scan_for_best_item_of_type", ":customer", itp_type_crossbow, ":customer"),
		 (try_begin),
			(ge, reg0, 0),
			(call_script, "script_dplmc_count_better_items_of_same_type", ":customer", ":item", ":imod", ":customer"),
			(lt, reg0, 3),#must not be best (0), second-best (1), or third-best (2)
			(assign, ":can_sell", 0),
		 (try_end),
	  (else_try),
		#Ammunition type: bullets (if you have a pistol or musket you can use, don't sell the best 3 bullet packs you have)
	     (eq, ":this_item_type", itp_type_bullets),
		 #Do muskets and pistols both use bullets?  I'll assume so.
		 (call_script, "script_dplmc_scan_for_best_item_of_type", ":customer", itp_type_musket, ":customer"),
		 (assign, reg1, reg0),
		 (call_script, "script_dplmc_scan_for_best_item_of_type", ":customer", itp_type_pistol, ":customer"),
		 (try_begin),
			(this_or_next|ge, reg0, 0),
				(ge, reg1, 0),
			(call_script, "script_dplmc_count_better_items_of_same_type", ":customer", ":item", ":imod", ":customer"),
			(lt, reg0, 3),
			(assign, ":can_sell", 0),
		 (try_end),
	  (else_try),
		#Catch: all non-usable equipment
		(is_between, ":this_item_type", itp_type_horse, itp_type_musket + 1),
		(neq, ":this_item_type", itp_type_goods),
		(call_script, "script_dplmc_troop_can_use_item", ":customer", ":item", ":imod"),
		(eq, reg0, 0),#Past here, we don't have to check for usability
	  (else_try),
		#Thrown weapons: don't sell best 3 you can use
		(eq, ":this_item_type", itp_type_thrown),
		(call_script, "script_dplmc_count_better_items_of_same_type", ":customer", ":item", ":imod", ":customer"),
		(store_sub, ":can_sell", reg0, 2),#must not be best (0) or second-best (1) or third-best (2)
	  (else_try),
		#Types where both the best and the second-best aren't sold
		#Horses, shields, melee weapons, and firearms
		(this_or_next|is_between, ":this_item_type", itp_type_horse, itp_type_polearm + 1),
		(this_or_next|eq, ":this_item_type", itp_type_shield),
		(this_or_next|eq, ":this_item_type", itp_type_pistol),
			(eq, ":this_item_type", itp_type_musket),
		(call_script, "script_dplmc_count_better_items_of_same_type", ":customer", ":item", ":imod", ":customer"),
		(store_sub, ":can_sell", reg0, 1),#must not be best (0) or second best (1)
 	  (else_try),
		#Types where the best isn't sold (armor, not including shields)
		(is_between, ":this_item_type", itp_type_head_armor, itp_type_hand_armor + 1),
		(call_script, "script_dplmc_count_better_items_of_same_type", ":customer", ":item", ":imod", ":customer"),
		(assign, ":can_sell", reg0),#must not be best (0)
	  (try_end),

	  #(try_begin),
	  #   (lt, ":can_sell", 1),
	  #	 (gt, "$cheat_mode", 0),
	  #	 (call_script, "script_dplmc_count_better_items_of_same_type", ":customer", ":item", ":imod", ":customer"),
 	  #	 (assign, reg1, ":i_slot"),
	  #	 (str_store_item_name, s0, ":item"),
	  #	 (display_message, "@{!} DEBUG - Will not sell item {s0} at slot {reg1}.  Better items of same kind: {reg0}"),
	  #(try_end),

	  (ge, ":can_sell", 1),

	  #(try_begin),
	  #	(ge, ":score", ":most_expensive_sold_price"),
	  #	(assign, ":most_expensive_sold_item", ":item"),
	  #	(assign, ":most_expensive_sold_imod", ":imod"),
	  #	(assign, ":most_expensive_sold_price", ":score"),
	  #(try_end),

	  #Log the transaction even if in dry run mode
	  (val_sub, ":m_gold", ":score"),
	  (val_add, ":gold_gained", ":score"),
	  (val_add, ":items_sold", 1),
	  (val_sub, ":space", 1),

	  #If not a dry run, apply the transaction
	  (neq, ":actually_sell_items", 0),
	  (troop_add_item, ":merchant", ":item", ":imod"),
	  (troop_set_inventory_slot, ":customer", ":i_slot", -1),
	  (troop_remove_gold, ":merchant", ":score"),
	  (troop_add_gold, ":customer", ":score"),
      #dplmc+ end changed section
    (try_end),

	(set_show_messages, 1),#<- dplmc+ added

	#dplmc+ added section begin
	#Print a message if appropriate
	(try_begin),
		(is_between, ":actually_sell_items", 2, 4),#2 or 3
		(this_or_next|ge, ":items_sold", 1),
			(eq, ":actually_sell_items", 3),
		(assign, reg0, ":gold_gained"),
		(assign, reg1, ":items_sold"),
		(store_sub, reg3, reg1, 1),
		(str_store_troop_name, s0, ":merchant"),
		(try_begin),
			(this_or_next|is_between, ":merchant", quick_battle_troops_begin, quick_battle_troops_end),
			(this_or_next|is_between, ":merchant", heroes_begin, heroes_end),
			(this_or_next|is_between, ":merchant", dplmc_employees_begin, dplmc_employees_end),
			(is_between, ":merchant", walkers_end, tournament_champions_end),
			(display_message, "@You sold {reg1} {reg3?items:item} to {s0} and gained {reg0} {reg3?denars:denar}."),
		(else_try),
			(display_message, "@You sold {reg1} {reg3?items:item} to the {s0} and gained {reg0} {reg3?denars:denar}."),
		(try_end),
	(try_end),

	#Revert variables
	(assign, reg2, ":save_reg2"),
	(assign, reg3, ":save_reg3"),
	(assign, reg65, ":save_reg65"),
	(assign, "$g_talk_troop", ":save_talk_troop"),

	#Return diagnostics
	(assign, reg0, ":gold_gained"),
	(assign, reg1, ":items_sold"),
	#dplmc+ added section end
  ]),
  #auto sell credit rubik (CC) end

  ##For use with autosell
  #Input: center_no
  #Output: none
  ("dplmc_player_auto_sell_at_center", [
     (store_script_param, ":center_no", 1),
	 (assign, ":save_reg0", reg0),
	 (assign, ":save_reg1", reg1),
	 (try_begin),
	    ##For Towns:
		(is_between, ":center_no", towns_begin, towns_end),
		(try_begin),
			#1. Selling weapons, shields, and ranged weapons to the weaponsmith
		    (party_get_slot, ":merchant_troop", ":center_no", slot_town_weaponsmith),
			(ge, ":merchant_troop", 1),
			(call_script, "script_dplmc_auto_sell", "trp_player", ":merchant_troop", "$g_dplmc_auto_sell_price_limit", weapons_begin, ranged_weapons_end, 2),
		(try_end),
		(try_begin),
			#2. Selling armor to the armorer
			(party_get_slot, ":merchant_troop", ":center_no", slot_town_armorer),
			(ge, ":merchant_troop", 1),
			(call_script, "script_dplmc_auto_sell", "trp_player", ":merchant_troop", "$g_dplmc_auto_sell_price_limit", armors_begin, armors_end, 2),
 		(try_end),
		(try_begin),
			#3. Selling horses to the horse merchant
			(party_get_slot, ":merchant_troop", ":center_no", slot_town_horse_merchant),
			(ge, ":merchant_troop", 1),
			(call_script, "script_dplmc_auto_sell", "trp_player", ":merchant_troop", "$g_dplmc_auto_sell_price_limit", horses_begin, horses_end, 2),
		(try_end),
		(try_begin),
			#4. Selling whatever may remain to the general merchant
			(party_get_slot, ":merchant_troop", ":center_no", slot_town_merchant),
			(ge, ":merchant_troop", 1),
			(call_script, "script_dplmc_auto_sell", "trp_player", ":merchant_troop", "$g_dplmc_auto_sell_price_limit", all_items_begin, all_items_end, 2),
		(try_end),
	 (else_try),
		##For Villages:
		(is_between, ":center_no", villages_begin, villages_end),
		(party_get_slot, ":merchant_troop", ":center_no", slot_town_elder),
		(ge, ":merchant_troop", 1),
		(call_script, "script_dplmc_auto_sell", "trp_player", ":merchant_troop", "$g_dplmc_auto_sell_price_limit", all_items_begin, all_items_end, 2),
	 (else_try),
	    ##Error
		(assign, reg0, ":center_no"),
		(display_message, "@{!} ERROR FOR AUTOSELL for town ID {reg0}: Bad town or merchant was missing"),
	 (try_end),
	 (assign, reg0, ":save_reg0"),
	 (assign, reg1, ":save_reg1"),
  ]),

##Adapted Auto-Buy-Food from rubik's Custom Commander
#Changed to parameterize merchant and customer, but did not finish expanding
#the script to work with non-player arguments.  (There is currently no need,
#but I can imagine using it for NPCs sent on item-purchasing missions, or if
#NPC parties had to buy food.)
#
##OLD: Overwrites: reg1, reg2, reg3, reg4
##NEW: Overwrite reg0
#
#INPUT:
#      arg1 :customer
#      arg2 :merchant_troop
  ("dplmc_auto_buy_food", [
    (store_script_param, ":customer", 1),
    (store_script_param, ":merchant_troop", 2),
    ##added section begin, preserve registers
    (assign, ":save_reg1", reg1),
    (assign, ":save_reg2", reg2),
    (assign, ":save_reg3", reg3),
    (assign, ":save_reg4", reg4),
    ##added section end

    (assign, ":customer_in_player_party", 0),#Always assumed true... re-write if you need to use for others

    (store_troop_gold, ":begin_gold", ":customer"),
    (store_free_inventory_capacity, ":begin_space", ":customer"),
    (troop_get_inventory_capacity, ":inv_cap", ":merchant_troop"),
    (set_show_messages, 0),
    (try_for_range, ":i_slot", 10, ":inv_cap"),
      (troop_get_inventory_slot, ":item", ":merchant_troop", ":i_slot"),
      (gt, ":item", -1),
      (is_between, ":item", food_begin, food_end),
      (troop_inventory_slot_get_item_amount, ":amount", ":merchant_troop", ":i_slot"),
      ##dplmc+: The next line required making a change to header_operations.py
      (troop_inventory_slot_get_item_max_amount, ":max_amount", ":merchant_troop", ":i_slot"),
      (eq, ":amount", ":max_amount"),

      (item_get_slot, ":food_portion", ":item", dplmc_slot_item_food_portion),
      (val_max, ":food_portion", 0),#dplmc+ added
      (store_item_kind_count, ":food_count", ":item", ":customer"),
      (lt, ":food_count", ":food_portion"),
      (store_free_inventory_capacity, ":free_inv_cap", ":customer"),
      (gt, ":free_inv_cap", 0),

      (call_script, "script_game_get_item_buy_price_factor", ":item"),
      (assign, ":buy_price_factor", reg0),
      (store_item_value,":score",":item"),
      (val_mul, ":score", ":buy_price_factor"),
      (val_div, ":score", 100),
      (val_max, ":score",1),
      (store_troop_gold, ":customer_gold", ":customer"),
      (ge, ":customer_gold", ":score"),

      (troop_add_item, ":customer", ":item"),
      (troop_set_inventory_slot, ":merchant_troop", ":i_slot", -1),
      (troop_remove_gold, ":customer", ":score"),
      (troop_add_gold, ":merchant_troop", ":score"),
    (try_end),
    (set_show_messages, 1),
    (store_troop_gold, ":end_gold", ":customer"),
    (store_free_inventory_capacity, ":end_space", ":customer"),
    (try_begin),
      (neq, ":end_gold", ":begin_gold"),
      (store_sub, reg1, ":begin_gold", ":end_gold"),
      (store_sub, reg2, ":begin_space", ":end_space"),
      (store_sub, reg3, reg1, 1),
      (store_sub, reg4, reg2, 1),
      (eq, ":customer_in_player_party", 1),#<- added
      (display_message, "@You have bought {reg2} {reg4?kinds:kind} of food and lost {reg1} {reg3?denars:denar}."),
    (try_end),

    # sell rotten food
    (store_troop_gold, ":begin_gold", ":customer"),
    (store_free_inventory_capacity, ":begin_space", ":customer"),
    (troop_get_inventory_capacity, ":inv_cap", ":customer"),
    (set_show_messages, 0),
    (try_for_range, ":i_slot", 10, ":inv_cap"),
      (troop_get_inventory_slot, ":item", ":customer", ":i_slot"),
      (gt, ":item", -1),
      (is_between, ":item", food_begin, food_end),
      (troop_get_inventory_slot_modifier, ":imod", ":customer", ":i_slot"),
      (eq, ":imod", imod_rotten),
      (store_free_inventory_capacity, ":free_inv_cap", ":merchant_troop"),
      (gt, ":free_inv_cap", 0),

      (call_script, "script_dplmc_get_item_value_with_imod", ":item", ":imod"),
      (assign, ":score", reg0),
      (val_div, ":score", 100),
      (call_script, "script_game_get_item_sell_price_factor", ":item"),
      (assign, ":sell_price_factor", reg0),
      (val_mul, ":score", ":sell_price_factor"),
      (troop_inventory_slot_get_item_amount, ":amount", ":customer", ":i_slot"),
      (troop_inventory_slot_get_item_max_amount, ":max_amount", ":customer", ":i_slot"),
      (val_mul, ":score", ":amount"),
      (val_div, ":score", ":max_amount"),
      (val_div, ":score", 100),
      (val_max, ":score",1),
      (store_troop_gold, ":merchant_gold", ":merchant_troop"),
      (ge, ":merchant_gold", ":score"),

      #(troop_add_item, ":merchant_troop", ":item", ":imod"),
      (troop_set_inventory_slot, ":customer", ":i_slot", -1),
      (troop_remove_gold, ":merchant_troop", ":score"),
      (troop_add_gold, ":customer", ":score"),
    (try_end),
    (set_show_messages, 1),
    (store_troop_gold, ":end_gold", ":customer"),
    (store_free_inventory_capacity, ":end_space", ":customer"),
    (try_begin),
      (neq, ":end_gold", ":begin_gold"),
      (store_sub, reg1, ":end_gold", ":begin_gold"),
      (store_sub, reg2, ":end_space", ":begin_space"),
      (store_sub, reg3, reg1, 1),
      (store_sub, reg4, reg2, 1),
      (eq, ":customer_in_player_party", 1), #<- added
      (display_message, "@You sold {reg2} {reg4?kinds:kind} of rotten food and gained {reg1} {reg3?denars:denar}."),
    (try_end),
    ##added section begin, preserve registers
    (assign, reg1, ":save_reg1"),
    (assign, reg2, ":save_reg2"),
    (assign, reg3, ":save_reg3"),
    (assign, reg4, ":save_reg4"),
    ##added section end
  ]),
##Auto-Buy-Food from rubik's Custom Commander end

  # script_dplmc_get_trade_penalty
  #
  #This is similar to the old script_get_trade_penalty,
  #except it uses parameters instead of relying on global variables.
  #
  # Input:
  # param1: item_kind_id
  # param2: market center
  # param3: customer troop (-1 for a non-troop-specific answer, -2 to notify the script that this is being used to evaluate a gift)
  # param4: merchant troop (-1 for a non-troop-specific answer)
  # Output: reg0

  ("dplmc_get_trade_penalty",
    [
	  #Additions begin:
      (store_script_param, ":item_kind_id", 1),
      (store_script_param, ":market_center", 2),
      (store_script_param, ":customer_troop", 3),
      (store_script_param, ":merchant_troop", 4),
      #End Additions
      (assign, ":penalty",0),

	  ##Change this to support alternative customers
      ##(party_get_skill_level, ":trade_skill", "p_main_party", skl_trade),
	  (try_begin),
		 #Player: use skill of player party
	     (eq, ":customer_troop", "trp_player"),
		 (party_get_skill_level, ":trade_skill", "p_main_party", skl_trade),
	  (else_try),
		 #Hero leading a party: use skill of led party
	     (gt, ":customer_troop", -1),
	     (troop_is_hero, ":customer_troop"),
		 (troop_get_slot, ":customer_party", ":customer_troop", slot_troop_leaded_party),
		 (gt, ":customer_party", 0),
		 (party_is_active, ":customer_party"),
		 (party_get_skill_level, ":trade_skill", ":customer_party", skl_trade),
	  (else_try),
		 #Troop: use troop skill
		 (gt, ":customer_troop", -1),
		 (store_skill_level, ":trade_skill", ":customer_troop"),
	  (else_try),
		 (assign, ":trade_skill", 0),
	  (try_end),
	  ##End Change
      (try_begin),
        (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
        (assign, ":penalty",15), #reduced slightly
        (store_mul, ":skill_bonus", ":trade_skill", 1),
        (val_sub, ":penalty", ":skill_bonus"),
      (else_try),
        (assign, ":penalty",100),
        (store_mul, ":skill_bonus", ":trade_skill", 5),
        (val_sub, ":penalty", ":skill_bonus"),
      (try_end),

      (assign, ":penalty_multiplier", average_price_factor),#<-- replaced 1000 with average_price_factor
##       # Apply penalty if player is hostile to merchants faction
##      (store_relation, ":merchants_reln", "fac_merchants", "fac_player_supporters_faction"),
##      (try_begin),
##        (lt, ":merchants_reln", 0),
##        (store_sub, ":merchants_reln_dif", 10, ":merchants_reln"),
##        (store_mul, ":merchants_relation_penalty", ":merchants_reln_dif", 20),
##        (val_add, ":penalty_multiplier", ":merchants_relation_penalty"),
##      (try_end),

       # Apply penalty if player is on bad terms with the town
      (try_begin),
		(eq, ":customer_troop", "trp_player"),#added
        (is_between, ":market_center", centers_begin, centers_end),#changed $g_encountered_party to :market_center
        (party_get_slot, ":center_relation", ":market_center", slot_center_player_relation),#changed $g_encountered_party to :market_center
        (store_mul, ":center_relation_penalty", ":center_relation", -3),
        (val_add, ":penalty_multiplier", ":center_relation_penalty"),
        (try_begin),
          (lt, ":center_relation", 0),
          (store_sub, ":center_penalty_multiplier", 100, ":center_relation"),
          (val_mul, ":penalty_multiplier", ":center_penalty_multiplier"),
          (val_div, ":penalty_multiplier", 100),
        (try_end),
      (try_end),

       # Apply penalty if player is on bad terms with the merchant (not currently used)
	   ##Begin Change
      #(call_script, "script_troop_get_player_relation", "$g_talk_troop"),
      #(assign, ":troop_reln", reg0),
	  (try_begin),
		 (this_or_next|eq, ":merchant_troop", "trp_player"),
			(eq, ":customer_troop", "trp_player"),
		 (gt, ":merchant_troop", -1),
		 (gt, ":customer_troop", -1),
		 (call_script, "script_troop_get_player_relation", ":merchant_troop"),
		 (assign, ":troop_reln", reg0),
	  (else_try),
	    (is_between, ":merchant_troop", heroes_begin, heroes_end),
		 (is_between, ":customer_troop", heroes_begin, heroes_end),
		 (call_script, "script_troop_get_relation_with_troop", ":merchant_troop", ":customer_troop"),
		 (assign, ":troop_reln", reg0),
	  (else_try),
	     (assign, ":troop_reln", 0),
	  (try_end),
	  ##End Change
      #(troop_get_slot, ":troop_reln", "$g_talk_troop", slot_troop_player_relation),
      (try_begin),
        (lt, ":troop_reln", 0),
        (store_sub, ":troop_reln_dif", 0, ":troop_reln"),
        (store_mul, ":troop_relation_penalty", ":troop_reln_dif", 20),
        (val_add, ":penalty_multiplier", ":troop_relation_penalty"),
      (try_end),


	  (try_begin),
		##Begin Change
		#(is_between, "$g_encountered_party", villages_begin, villages_end),
		(is_between, ":market_center", centers_begin, centers_end),
		(party_slot_eq, ":market_center", slot_party_type, spt_village),
		##End Change
	    (val_mul, ":penalty", 2),
	  (try_end),

	  (try_begin),
        (is_between, ":market_center", centers_begin, centers_end),#changed $g_encountered_party to :market_center
	    #Double trade penalty if no local production or consumption
	    (is_between, ":item_kind_id", trade_goods_begin, trade_goods_end),
		##Begin Change
		#(OPTIONAL CHANGE: Do not apply this to food)
		(this_or_next|eq, ":customer_troop", -2),
        (this_or_next|lt, "$g_dplmc_gold_changes", DPLMC_GOLD_CHANGES_LOW),
		   (neg|is_between, ":item_kind_id", food_begin, food_end),

		(assign, ":save_reg1", reg1),
		(assign, ":save_reg2", reg2),
		##End Change
	    (call_script, "script_center_get_production", ":market_center", ":item_kind_id"),#changed $g_encountered_party to :market_center
	    (eq, reg0, 0),
	    (call_script, "script_center_get_consumption", ":market_center", ":item_kind_id"),#changed $g_encountered_party to :market_center
	    (eq, reg0, 0),
	    (val_mul, ":penalty", 2),
		##Begin Change
		(assign, reg1, ":save_reg1"),
		(assign, reg2, ":save_reg2"),
		##End Change
	  (try_end),

      (val_mul, ":penalty",  ":penalty_multiplier"),
	  ##Begin Change
	  (val_add, ":penalty", average_price_factor // 2),#round in the correct direction (we don't need to worry about penalty < 0)
      (val_div, ":penalty", average_price_factor),#replace the hardcoded constant 1000 with average_price_factor
	  ##End Change
      (val_max, ":penalty", 1),
      (assign, reg0, ":penalty"),
  ]),


##"script_dplmc_print_cultural_word_to_sreg"
##INPUTS:
#  arg1  - speaker troop
#  arg2  - which word/phrase to retrieve (arbitrary code)
#  arg3  - string register
#OUTPUTS:
#  writes result to string register
   ("dplmc_print_cultural_word_to_sreg", [
     (store_script_param, ":speaker", 1),
     (store_script_param, ":context", 2),
     (store_script_param, ":string_register", 3),

     #Right now this is entirely faction-based, but you could give different
     #results for individual lords.
	 #(Note: Now certain parts of it do vary for heroes, to mimic the behavior in Native
	 #feast dialogs for the word for wine.)

     (assign, ":speaker_faction", -1),
     (try_begin),
		#Player faction
		(this_or_next|eq, ":speaker", "trp_player"),
			(eq, ":speaker", "trp_kingdom_heroes_including_player_begin"),
		(assign, ":speaker_faction", "fac_player_supporters_faction"),#<- This will potentially get translated later
	 (else_try),
		#Hero original faction
        (is_between, ":speaker", heroes_begin, heroes_end),
        (troop_get_slot, ":speaker_faction", ":speaker", slot_troop_original_faction),
	 (else_try),
		#Hero original faction
		(gt, ":speaker", -1),
		(troop_is_hero, ":speaker"),
		(troop_slot_ge, ":speaker", slot_troop_original_faction, npc_kingdoms_begin),
		(neg|troop_slot_ge, ":speaker", slot_troop_original_faction, npc_kingdoms_end),
		(troop_get_slot, ":speaker_faction", ":speaker", slot_troop_original_faction),
     (else_try),
		#Troop current faction
        (gt, ":speaker", -1),
        (store_troop_faction, ":speaker_faction", ":speaker"),
     (try_end),

	 (try_begin),
      (lt, ":speaker", 1),
     (else_try),
	   ##Only continue if the current faction isn't associated with a distinctive culture
	   (lt, ":speaker_faction", dplmc_non_generic_factions_begin),
	   ##This will work unless the order of the first factions gets changed
	 (else_try),
	   #Translate raiders into the equivalent kingdoms
	   (is_between, ":speaker", bandits_begin, bandits_end),
         (try_begin),
			(eq, ":speaker", "trp_mountain_bandit"),#Mountain bandits
			(assign, ":speaker_faction", "fac_kingdom_5"),#Rhodoks
		 (else_try),
			(eq, ":speaker", "trp_forest_bandit"),#Forest bandits
			(assign, ":speaker_faction", "fac_kingdom_1"),#Swadian
		 (else_try),
			(eq, ":speaker", "trp_sea_raider"),#Sea raiders
			(assign, ":speaker_faction", "fac_kingdom_4"),#Nords
		 (else_try),
			(eq, ":speaker", "trp_steppe_bandit"),#Steppe bandits
			(assign, ":speaker_faction", "fac_kingdom_3"),#Khergits
		 (else_try),
			(eq, ":speaker", "trp_taiga_bandit"),#Taiga bandits
			(assign, ":speaker_faction", "fac_kingdom_2"),#Vaegir
		 (else_try),
			(eq, ":speaker", "trp_desert_bandit"),#Desert bandits
			(assign, ":speaker_faction", "fac_kingdom_6"),#Sarranid
		 (try_end),
		 (ge, ":speaker_faction", dplmc_non_generic_factions_begin),
    (else_try),
		#For companions without default initial cultures, infer one from their home.
		#(Actually, don't limit this to companions, since there's a chance that others
		#could have a valid home slot.)
		#(is_between, ":speaker", companions_begin, companions_end),
		#(is_between, ":speaker", heroes_begin, heroes_end),
		(troop_is_hero, ":speaker"),
		(troop_get_slot, ":home_center", ":speaker", slot_troop_home),
		(is_between, ":home_center", centers_begin, centers_end),
		(party_get_slot, ":speaker_faction", ":home_center", slot_center_original_faction),
	 (else_try),
		#For villagers, merchants, etc.
		(eq, ":speaker", "$g_talk_troop"),
		(neg|is_between, ":speaker", heroes_begin, heroes_end),#Not a character that might have an explicitly-set faction
		(neg|is_between, ":speaker", training_ground_trainers_begin, tavern_minstrels_end),#Not a trainer, ransom broker, traveler, bookseller, or minstrel
		(ge, "$g_encountered_party", 0),
		(try_begin),
			#For towns / castles / villages, use the original faction
			(is_between, "$g_encountered_party", centers_begin, centers_end),
			(party_get_slot, ":speaker_faction", "$g_encountered_party", slot_center_original_faction),
		(else_try),
			#Use faction of encountered party
			(party_is_active, "$g_encountered_party"),
			(store_faction_of_party, ":speaker_faction", "$g_encountered_party"),
			#For generic factions, use the closest center
			(lt, ":speaker_faction", dplmc_non_generic_factions_begin),
			(assign, ":speaker_faction", reg0),#save register
			(call_script, "script_get_closest_center", "$g_encountered_party"),
			(assign, ":home_center", reg0),
			(assign, reg0, ":speaker_faction"),#revert register
			(party_get_slot, ":speaker_faction", ":home_center", slot_center_original_faction),
		(try_end),
	 (try_end),

    #Translate for player's kingdom
	 (try_begin),
		(ge, "$players_kingdom", dplmc_non_generic_factions_begin),
		(this_or_next|eq, ":speaker_faction", "fac_player_faction"),
		(this_or_next|eq, ":speaker_faction", "fac_player_supporters_faction"),
		(eq, ":speaker_faction", "$players_kingdom"),
		(assign, ":speaker_faction", "$players_kingdom"),
		(neg|is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
		(this_or_next|is_between, "$g_player_culture", cultures_begin, cultures_end),
		(is_between,"$g_player_culture", npc_kingdoms_begin, npc_kingdoms_end),
		(assign, ":speaker_faction", "$g_player_culture"),
	 (try_end),

     #Store variant
     (try_begin),
        #Iconic cultural weapon that can be used metonymously for force of arms.
		#Native equivalent is "sword".
		#Non-Warband example: "He who lives by the {sword}, dies by the {sword}."
		#Example usage: "My {sword} is at the disposal of my liege."
		(eq, ":context", DPLMC_CULTURAL_TERM_WEAPON),
        (try_begin),
           (this_or_next|eq, ":speaker_faction", "fac_kingdom_4"),#Nords
           (eq, ":speaker_faction", "fac_kingdom_2"),#Vaegirs
           (str_store_string, ":string_register", "@axe"),
        (else_try),
           (eq, ":speaker_faction", "fac_kingdom_5"),#Rhodoks
           (str_store_string, ":string_register", "@spear"),
        (else_try),
           (eq, ":speaker_faction", "fac_kingdom_3"),#Khergits
           (str_store_string, ":string_register", "@bow"),
        (else_try),
			#Default: Swadia, Sarranid, others
           (str_store_string, ":string_register", "@sword"),
        (try_end),
    (else_try),
        #Plural version of iconic cultural weapon that can be used metonymously for force of arms.
		#Native equivalent is "swords".
		(eq, ":context", DPLMC_CULTURAL_TERM_WEAPON_PLURAL),
        (try_begin),
           (this_or_next|eq, ":speaker_faction", "fac_kingdom_4"),#Nords
           (eq, ":speaker_faction", "fac_kingdom_2"),#Vaegirs
           (str_store_string, ":string_register", "@axes"),
        (else_try),
           (eq, ":speaker_faction", "fac_kingdom_5"),#Rhodoks
           (str_store_string, ":string_register", "@spears"),
        (else_try),
           (eq, ":speaker_faction", "fac_kingdom_3"),#Khergits
           (str_store_string, ":string_register", "@bows"),
        (else_try),
			#Default: Swadia, Sarranid, others
           (str_store_string, ":string_register", "@swords"),
        (try_end),
	 (else_try),
		#Cultural phrase that means "fight" (first person singular)
		#Native equivalent is "swing my sword."
		#Example usage: "I want to be able to {swing my sword} with a good conscience."
        (eq, ":context", DPLMC_CULTURAL_TERM_USE_MY_WEAPON),
        (try_begin),
           (eq, ":speaker_faction", "fac_kingdom_4"),#Nords
           (eq, ":speaker_faction", "fac_kingdom_2"),#Vaegirs
           (str_store_string, ":string_register", "@swing my axe"),
        (else_try),
           (eq, ":speaker_faction", "fac_kingdom_5"),#Rhodoks
           (str_store_string, ":string_register", "@lift my spear"),
        (else_try),
           (eq, ":speaker_faction", "fac_kingdom_3"),#Khergits
           (str_store_string, ":string_register", "@loose my arrows"),
        (else_try),
			#Default: Swadia, Sarranid, others
           (str_store_string, ":string_register", "@swing my sword"),
        (try_end),
	(else_try),
		#equivalent to lowercase "king" or "queen"
		(this_or_next|eq, ":context", DPLMC_CULTURAL_TERM_KING_FEMALE),
		(eq, ":context", DPLMC_CULTURAL_TERM_KING),
		(try_begin),
		   (eq, ":speaker_faction", "fac_kingdom_3"),#Khergit
		   (str_store_string, ":string_register", "str_khan"),
		(else_try),
		   (eq, ":speaker_faction", "fac_kingdom_6"),#Sarranid
		   (str_store_string, ":string_register", "@sultan"),
		(else_try),
		   #Default: Swadia, Rhodok, Nord, Vaegir, others
		   (str_store_string, ":string_register", "str_king"),
		   (eq, ":context", DPLMC_CULTURAL_TERM_KING_FEMALE),
		   (str_store_string, ":string_register", "str_queen"),
		(try_end),
	(else_try),
		#equivalent to lowercase "kings"
		(eq, ":context", DPLMC_CULTURAL_TERM_KING_PLURAL),
		(try_begin),
		   (eq, ":speaker_faction", "fac_kingdom_3"),#Khergit
		   (str_store_string, ":string_register", "@khans"),
		(else_try),
		   (eq, ":speaker_faction", "fac_kingdom_6"),#Sarranid
		   (str_store_string, ":string_register", "@sultans"),
		(else_try),
 		   #Default: Swadia, Rhodok, Nord, Vaegir, others
		   (str_store_string, ":string_register", "@kings"),
		(try_end),
	(else_try),
		#equivalent to lowercase "lord"
		(eq, ":context", DPLMC_CULTURAL_TERM_LORD),
		(str_store_string, ":string_register", "@lord"),
	(else_try),
		#equivalent to lowercase "lords"
		(eq, ":context", DPLMC_CULTURAL_TERM_LORD_PLURAL),
		(str_store_string, ":string_register", "@lords"),
	(else_try),
		#As in, "I shall tell my {swineherd} about your sweet promises" or "Any {swineherd} can claim to be king".
		(eq, ":context", DPLMC_CULTURAL_TERM_SWINEHERD),
		(assign, ":mode", ":speaker"),
		(try_begin),
		   (gt, ":speaker", 0),
		   (neg|troop_is_hero, ":speaker"),
		   (store_current_hours, ":mode"),
		   (val_add, ":mode", "$g_encountered_party"),
		(try_end),
		(val_max, ":mode", 0),#Default to mode 0 for negative speakers
		(val_mod, ":mode", 2),
		(try_begin),
           (eq, ":speaker_faction", "fac_kingdom_2"),#Vaegirs
		   (try_begin),
		      (eq, ":mode", 0),
              (str_store_string, ":string_register", "@goatherd"),
		   (else_try),
		       (str_store_string, ":string_register", "@swineherd"),
		   (try_end),
        (else_try),
		   (eq, ":speaker_faction", "fac_kingdom_3"),#Khergits
		   (try_begin),
		      (eq, ":mode", 0),
              (str_store_string, ":string_register", "@stable {boy/girl}"),
        (else_try),
		      (str_store_string, ":string_register", "@shepherd {boy/girl}"),
		   (try_end),
		(else_try),
		   (eq, ":speaker_faction", "fac_kingdom_6"),#Sarranids
		   (try_begin),
		      (eq, ":mode", 0),
		      (str_store_string, ":string_register", "@goatherd"),
		   (else_try),
		      (str_store_string, ":string_register", "@shepherd {boy/girl}"),
		   (try_end),
        (else_try),
           #Swadia, Rhodok, Nord, others
           (str_store_string, ":string_register", "@swineherd"),
        (try_end),
	(else_try),
		#As in, "I'd like to buy every man who comes in here tonight a jar of your best wine."
		(this_or_next|eq, ":context", DPLMC_CULTURAL_TERM_TAVERNWINE),
		#Follow the pattern used in Native for lords in feasts
		#(c.f. "str_flagon_of_mead", "str_skin_of_kumis", "str_mug_of_kvass", "str_cup_of_wine")

		(try_begin),
			#For lords, use "mode" so it works the same as in feast dialogs
			(is_between, ":speaker", heroes_begin, heroes_end),
			(this_or_next|neg|is_between, ":speaker", companions_begin, companions_end),
				(neg|troop_slot_eq, ":speaker", slot_troop_original_faction, ":speaker_faction"),
			(store_mod, ":mode", ":speaker", 2),
		(else_try),
			#Otherwise set mode to 0, to always use the cultural alternative
			(assign, ":mode", 0),
		(try_end),

		(try_begin),
			(eq, ":speaker_faction", "fac_kingdom_2"),
			(eq, ":mode", 0),#From feast: 50% chance of falling through to "wine"
			(str_store_string, ":string_register", "@kvass"),#Vaegirs: kvass
		(else_try),
			(eq, ":speaker_faction", "fac_kingdom_3"),
			(eq, ":mode", 0),#From feast: 50% chance of falling through to "wine"
			(str_store_string, ":string_register", "@kumis"),#Khergits: kumis
		(else_try),
			(eq, ":speaker_faction", "fac_kingdom_4"),
			(str_store_string, ":string_register", "@mead"),#Nords: mead
		(else_try),
			(str_store_string, ":string_register", "@wine"),#Default: wine
		(try_end),
    (else_try),
	#Error string
        (assign, ":save_reg0", reg0),
		(assign, reg0, ":context"),
		(display_message, "@{!}ERROR - dplmc_print_cultural_word_to_sreg called for bad context {reg0}"),
		(str_store_string, ":string_register", "str_ERROR_string"),
		(assign, reg0, ":save_reg0"),
    (try_end),

   ]),


  #script_dplmc_print_player_spouse_says_my_husband_wife_to_s0
  #
  #INPUT:
  #  arg1: troop_no
  #  arg2: whether the first letter must be capitalized
  #
  #OUTPUT:
  #    s0: a string that can be substituted for "my {husband/wife}" or "my love"
  ("dplmc_print_player_spouse_says_my_husband_wife_to_s0",
   [
     (store_script_param_1, ":troop_no"),
     (store_script_param_2, ":capitalized"),

 	 (assign, ":save_reg0", reg0),
	 (assign, ":save_reg6", reg6),
	 (assign, ":save_reg7", reg7),
	 #(assign, reg6, ":capitalized"),
	 (assign, reg7, 0),

    #Base switch is 50 (i.e. where the "brave champion" greeting starts)
    (try_begin),
      (lt, ":troop_no", 1),#bad value
      (assign, reg0, 0),
      (assign, reg6, lrep_none),
    (else_try),
	   (call_script, "script_troop_get_player_relation", ":troop_no"),#write relation to reg0
      (troop_get_slot, reg6, ":troop_no", slot_lord_reputation_type),#write relation to reg6
      (eq, reg6, lrep_conventional),#...jumps to next branch (keeping reg0 and reg6) if this isn't true
		(val_add, reg0, 25),#from 25+
	 (else_try),
      (eq, reg6, lrep_otherworldly),
		(val_add, reg0, 30),#from 20+
	 (else_try),
      (eq, reg6, lrep_moralist),
      (store_sub, reg7, "$player_honor", 10),
      (val_clamp, reg7, -40, 31),
      (val_add, reg0, reg7),
      (assign, reg7, 0),
    (else_try),
      (eq, reg6, lrep_ambitious),
      (assign, reg7, -10),
      (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
         (this_or_next|party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
            (party_slot_eq, ":center_no", slot_town_lord, ":troop_no"),
         (val_add, reg7, 10),
         (party_slot_eq, ":center_no", slot_party_type, spt_town),
         (val_add, reg7,  10),
      (try_end),
      (val_clamp, reg7, -10, 30),
      (val_add, reg0, reg7),
      (assign, reg7, 0),
    (else_try),
      (eq, reg6, lrep_adventurous),
      (val_add, reg7, 20),#from 30+
    (else_try),
      (eq, reg6, lrep_none),
      (is_between, reg6, heroes_begin, heroes_end),
      (val_sub, reg0, 20),#from 70+
    (else_try),
      (eq, reg6, lrep_cunning),
      (val_sub, reg0, 20),#from 70+
    (else_try),
      (this_or_next|eq, reg6, lrep_debauched),
      (this_or_next|eq, reg6, lrep_quarrelsome),
      (this_or_next|eq, reg6, lrep_selfrighteous),
      (val_sub, reg0, 30),#from 80+
	 (try_end),

    (try_begin),
       (ge, reg0, 50),
       (assign, reg7, 1),
    (try_end),

    (try_begin),
       #Embellishment: diminuitive pet-names
       (eq, reg6, lrep_debauched),
       (gt, ":troop_no", 0),
       (store_character_level, ":player_level", "trp_player"),
       (store_character_level, ":troop_level", ":troop_no"),
       (troop_get_slot, ":player_renown", "trp_player", slot_troop_renown),
       (this_or_next|ge, ":troop_level", ":player_level"),
       (this_or_next|troop_slot_ge, ":troop_no", slot_troop_renown, ":player_renown"),
          (lt, reg0, 50),
       (assign, reg6, ":capitalized"),#Whether the first letter needs to be upper case
       (str_store_string, s0, "@{reg6?M:m}y poppet"),
    (else_try),
       #The basic idea.  Further embellishments may come.
       (assign, reg6, ":capitalized"),#Whether the first letter needs to be upper case
       (str_store_string, s0, "str_dplmc_reg6my_reg7spouse"),
    (try_end),

	 #Revert registers
	 (assign, reg0, ":save_reg0"),
	 (assign, reg6, ":save_reg6"),
	 (assign, reg7, ":save_reg7"),
   ]),

  ##"script_dplmc_initialize_autoloot"
  ##
  ##Only needs to be called once, but it's safe to call multiple times
  ##(it uses "$g_autoloot" to store the version)
  ##
  ##Inputs: arg1: 1 to force this to run
  ##Outputs: None
  ("dplmc_initialize_autoloot",
  [
	(store_script_param_1, ":force_to_run"),

	(try_begin),
		#Check if there is anything to do
		(this_or_next|eq, ":force_to_run", 1),
			(neq, "$g_autoloot", 2),
      (try_begin),
		   #Print a message to make it obvious when this is happening more than it should.
		   (ge, "$cheat_mode", 1),
		   (store_current_hours, ":hours"),
		   (gt, ":hours", 0),
		   (display_message, "@{!}Initializing auto-loot.  This message should not appear more than once."),
      (try_end),
		#Initialize
		(try_for_range, ":cur_food", food_begin, food_end),
			(item_set_slot, ":cur_food", dplmc_slot_item_food_portion, 1),
		(try_end),

		# #deprecated due to 1.165 operations
		# (call_script, "script_dplmc_init_item_difficulties"),
		# (call_script, "script_dplmc_init_item_base_score"),

		(assign, "$g_dplmc_auto_sell_price_limit", 50),
		(assign, "$g_dplmc_sell_items_when_leaving", 0),
		(assign, "$g_dplmc_buy_food_when_leaving", 0),

		(item_set_slot, itp_type_book, dplmc_slot_item_type_not_for_sell, 1),
		(item_set_slot, itp_type_goods, dplmc_slot_item_type_not_for_sell, 1),
		(item_set_slot, itp_type_animal, dplmc_slot_item_type_not_for_sell, 1),

		(assign, "$g_autoloot", 2),
	(try_end),
  ]),


##"script_dplmc_get_troop_standing_in_faction"
#
#INPUT: arg1  :troop_no
#       arg2  :faction_no
#
#OUTPUT:
#       reg0  A constant with the value DPLMC_FACTION_STANDING_<something>
#
## Constants defined in module_constants.py
#DPLMC_FACTION_STANDING_LEADER = 60
#DPLMC_FACTION_STANDING_LEADER_SPOUSE = 50
#DPLMC_FACTION_STANDING_MARSHALL = 40
#DPLMC_FACTION_STANDING_LORD = 30
#DPLMC_FACTION_STANDING_DEPENDENT = 20
#DPLMC_FACTION_STANDING_MEMBER = 10#includes mercenaries
#DPLMC_FACTION_STANDING_PETITIONER = 5
#DPLMC_FACTION_STANDING_UNAFFILIATED = 0
##diplomacy end+
 ("dplmc_get_troop_standing_in_faction",
 [
    (store_script_param_1, ":troop_no"),
    (store_script_param_2, ":faction_no"),

    (assign, ":standing", DPLMC_FACTION_STANDING_UNAFFILIATED),
    (assign, ":original_faction_no", ":faction_no"),
    (try_begin),
        #Translate fac_player_faction
        (eq, ":faction_no", "fac_player_faction"),
        (assign, ":faction_no", "fac_player_supporters_faction"),
    (try_end),

    (try_begin),
       (this_or_next|lt, ":troop_no", 0),#Do nothing, bad troop ID
          (lt, ":faction_no", 0),#Do nothing, bad faction
    (else_try),
       #Because of how this script is used, if fac_player_supporters_faction is active,
       # this always reports that the player is its leader (even though that is sometimes
       # untrue, for example in a claimant quest)
       (eq, ":troop_no", "trp_player"),#Short-circuit the remainder if these are true
       (eq, ":faction_no", "fac_player_supporters_faction"),
       (faction_slot_eq, "fac_player_supporters_faction", slot_faction_state, sfs_active),
       # (neg|is_between, "$supported_pretender", pretenders_begin, pretenders_end), #SB : claimant exception
       (assign, ":standing", DPLMC_FACTION_STANDING_LEADER),
    (else_try),
		(try_begin),
			#Translate fac_player_supporters_faction
			(eq, ":faction_no", "fac_player_supporters_faction"),
			(gt, "$players_kingdom", 0),
			(assign, ":faction_no", "$players_kingdom"),
		(try_end),

        (store_faction_of_troop, ":troop_faction", ":troop_no"),
        (try_begin),
           #Translate fac_player_supporters_faction
           (this_or_next|eq, ":troop_no", "trp_player"),
           (this_or_next|eq, ":troop_faction", "fac_player_faction"),
           (eq, ":troop_faction", "fac_player_supporters_faction"),
           (assign, ":troop_faction", "fac_player_supporters_faction"),
           (gt, "$players_kingdom", 0),
           (assign, ":troop_faction", "$players_kingdom"),
        (try_end),
        (eq, ":troop_faction", ":faction_no"),#<- Short-circuit the remainder if this is false
        (assign, ":standing", DPLMC_FACTION_STANDING_MEMBER),

        (faction_get_slot, ":faction_leader", ":faction_no", slot_faction_leader),
        (try_begin),
           #Faction leader
           (eq, ":faction_leader", ":troop_no"),
           (assign, ":standing", DPLMC_FACTION_STANDING_LEADER),
        (else_try),
           #Spouse of faction leader
           (gt, ":faction_leader", -1),
           (this_or_next|troop_slot_eq, ":troop_no", slot_troop_spouse, ":faction_leader"),
              (troop_slot_eq, ":faction_leader", slot_troop_spouse, ":troop_no"),
           #Deal with possible uninitialized slot
           (this_or_next|troop_slot_eq, ":faction_leader", slot_troop_spouse, ":troop_no"),
           (this_or_next|neq, ":faction_leader", 0),
              (is_between, ":troop_no", heroes_begin, heroes_end),
           (assign, ":standing", DPLMC_FACTION_STANDING_LEADER_SPOUSE),
        (else_try),
           #Faction marshall
           (faction_slot_eq, ":faction_no", slot_faction_marshall, ":troop_no"),
           (assign, ":standing", DPLMC_FACTION_STANDING_MARSHALL),
        (else_try),
           #If the troop is the player, if he has homage he is a lord.
           #Otherwise he is a mercenary.
           (eq, ":troop_no", "trp_player"),
           (try_begin),
              (this_or_next|eq, ":faction_no", "fac_player_supporters_faction"),
              (ge, "$player_has_homage", 1),
              (assign, ":standing", DPLMC_FACTION_STANDING_LORD),
           (else_try),
              #If the player is married to a lord/lady in the faction, the
              #homage variable should always be set to 1+, but add a separate
              #check just in case.
              (troop_get_slot, reg0, "trp_player", slot_troop_spouse),
              (is_between, reg0, heroes_begin, heroes_end),
              (store_faction_of_troop, reg0, reg0),
              (this_or_next|eq, reg0, "fac_player_supporters_faction"),
              (eq, reg0, ":faction_no"),
              (assign, ":standing", DPLMC_FACTION_STANDING_LORD),
           (try_end),
        (else_try),
            #None of the following conditions apply for non-heroes
            (this_or_next|lt, ":troop_no", heroes_begin),
                (neg|troop_is_hero, ":troop_no"),
        (else_try),
           #For kingdom heroes, part 1 (check lordship based on occupation)
           (this_or_next|troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_granted_fief),
           (this_or_next|troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_lord_rejoined),
           (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),
           (assign, ":standing", DPLMC_FACTION_STANDING_LORD),
        (else_try),
           #For kingdom ladies
           (this_or_next|is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
              (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_lady),
           (assign, ":standing", DPLMC_FACTION_STANDING_DEPENDENT),
        (else_try),
           #For petitioners
           (eq, ":original_faction_no", "fac_player_supporters_faction"),
           (is_between, ":troop_no", lords_begin, lords_end),
           (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_inactive),
           (neg|troop_slot_ge, ":troop_no", slot_troop_leaded_party, 0),
           (neg|troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0),
           (assign, ":standing", DPLMC_FACTION_STANDING_PETITIONER),
        (else_try),
            #For kingdom heroes, part 2 (all non-companion active NPCs)
            (is_between, ":troop_no", active_npcs_begin, active_npcs_end),
            (neg|is_between, ":troop_no", companions_begin, companions_end),
            (assign, ":standing", DPLMC_FACTION_STANDING_LORD),
        (try_end),
    (try_end),

    (assign, reg0,  ":standing"),
 ]),

 ## "script_dplmc_store_troop_is_eligible_for_affiliate_messages"
 ("dplmc_store_troop_is_eligible_for_affiliate_messages",
 [
	(store_script_param_1, ":troop_no"),
	(assign, ":is_eligible", 0),
	(assign, ":save_reg1", reg1),
	(try_begin),
		(lt, ":troop_no", 1),
	(else_try),
		(neg|troop_is_hero, ":troop_no"),
	(else_try),
		#Initialize :faction_no and :faction_relation
		(store_faction_of_troop, ":faction_no", ":troop_no"),
		(store_relation, ":faction_relation", ":faction_no", "fac_player_supporters_faction"),
		(try_begin),
			(eq, ":faction_no", "$players_kingdom"),
			(val_max, ":faction_relation", 1),
		(try_end),
		#Companion
		(gt, ":faction_relation", -1),
		(is_between, ":troop_no", companions_begin, companions_end),
		(neg|troop_slot_eq, ":troop_no", slot_troop_playerparty_history, dplmc_pp_history_nonplayer_entry),
		(troop_slot_ge, ":troop_no", slot_troop_player_relation, 20),
		(assign, ":is_eligible", 1),
	(else_try),
		#Faction marshall (if the player is the faction leader)
		#Faction leader (if the player is the faction marshall)
		(eq, ":faction_no", "$players_kingdom"),
		(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
		(ge, reg0, DPLMC_FACTION_STANDING_MARSHALL),
		(call_script, "script_dplmc_get_troop_standing_in_faction", ":troop_no", "$players_kingdom"),
		(ge, reg0, DPLMC_FACTION_STANDING_MARSHALL),
		(assign, ":is_eligible", 1),
	(else_try),
		#Spouse / relatives / in-laws
		(gt, ":faction_relation", -1),
		#(is_between, ":troop_no", heroes_begin, heroes_end),## should be safe even for non-heroes
		(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":troop_no", "trp_player"),
		(ge, reg0, 2),
		(troop_get_slot, reg1, ":troop_no", slot_troop_player_relation),
		(val_add, reg0, reg1),
		(ge, reg0, 20),
		(assign, ":is_eligible", 1),
	(else_try),
		#Affiliates
		(call_script, "script_dplmc_is_affiliated_family_member", ":troop_no"),
		(ge, reg0, 1),
		(assign, ":is_eligible", 1),
	(else_try),
		#Cheat mode: add faction leaders to test this out
		(gt, "$cheat_mode", 0),
		(is_between, ":faction_no", kingdoms_begin, kingdoms_end),
		(faction_slot_eq, ":faction_no", slot_faction_leader, ":troop_no"),
		(assign, ":is_eligible", 1),
	(try_end),
	(assign, reg1, ":save_reg1"),
	(assign, reg0, ":is_eligible"),
 ]),

# "script_dplmc_sell_all_prisoners"
#
# Taken from rubik's Custom Commander, and altered to have parameters
# and return feedback.
#
#INPUT:
#Arg 1: actually remove (positive for yes, zero or negative for no)
#Arg 2: if positive, use this as a fixed price instead of calculating dynamically
#OUTPUT:
#reg0: amount of gold gained (or would have been gained if the sale occurred)
#reg1: number of prisoners sold (or would have been sold if the sale occurred)
  ("dplmc_sell_all_prisoners",
   [
    (store_script_param_1, ":actually_remove"),
    (store_script_param_2, ":fixed_price"),

    (assign, ":total_removed", 0),
    (assign, ":total_income", 0),
    (party_get_num_prisoner_stacks, ":num_stacks", "p_main_party"),
    (try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
      (party_prisoner_stack_get_troop_id, ":troop_no", "p_main_party", ":i_stack"),
      #SB : correction to use game script
      (call_script, "script_game_check_prisoner_can_be_sold", ":troop_no"),
      (eq, reg0, 1),
      # (neg|troop_is_hero, ":troop_no"),
      (party_prisoner_stack_get_size, ":stack_size", "p_main_party", ":i_stack"),
      (try_begin),
         (gt, ":fixed_price", 0),
         (assign, ":sell_price", ":fixed_price"),
      (else_try),
         (call_script, "script_game_get_prisoner_price", ":troop_no"),
         (assign, ":sell_price", reg0),
      (try_end),
      (store_mul, ":stack_total_price", ":sell_price", ":stack_size"),
      (val_add, ":total_income", ":stack_total_price"),
      (val_add, ":total_removed", ":stack_size"),
      (gt, ":actually_remove", 0),#Stop short if this is a dry run
      (party_remove_prisoners, "p_main_party", ":troop_no", ":stack_size"),
    (try_end),
    (try_begin),
      (gt, ":actually_remove", 0),#Stop short if this is a dry run
      (troop_add_gold, "trp_player", ":total_income"),
    (try_end),
    (assign, reg0, ":total_income"),
    (assign, reg1, ":total_removed"),
  ]),

#"script_dplmc_translate_inactive_player_supporter_faction_2"
#
#Since "fac_player_supporters_faction" is often used as a parameter when what
#is really meant is "the faction led by the player" (which is never a different
#faction in Native), there are many calls we want to change.  Another solution
#is to approach the problem from the other side, and "correct" the arguments.
#
#If exactly one argument is equal to fac_player_supporters_faction, and fac_player_supporters_faction
#is not sfs_active, and $players_kingdom is an NPC kingdom of which the player is ruler or co-ruler,
#and the other argument is not equal to $players_kingdom, then the argument equal to fac_player_supporters_faction
#will be replaced with $players_kingdom.
#
#INPUT:
# arg1 - faction_1
# arg2 - faction_2
#OUTPUT:
# reg0 - faction_1, possibly replacing fac_player_supporters_faction with $players_kingdom (see above)
# reg1 - faction_2, possibly replacing fac_player_supporters_faction with $players_kingdom (see above)
("dplmc_translate_inactive_player_supporter_faction_2",
[
    (store_script_param_1, ":faction_1"),
    (store_script_param_2, ":faction_2"),

	(try_begin),
		(this_or_next|faction_slot_eq, "fac_player_supporters_faction", slot_faction_state, sfs_active),
		(this_or_next|neg|is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
		(this_or_next|eq, ":faction_1", "$players_kingdom"),
		(this_or_next|eq, ":faction_2", "$players_kingdom"),
			(eq, ":faction_1", ":faction_2"),
      #Do nothing
	(else_try),
		(eq, ":faction_1", "fac_player_supporters_faction"),
		(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
		(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
		(assign, ":faction_1", "$players_kingdom"),
	(else_try),
		(eq, ":faction_2", "fac_player_supporters_faction"),
		(call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", "$players_kingdom"),
		(ge, reg0, DPLMC_FACTION_STANDING_LEADER_SPOUSE),
		(assign, ":faction_2", "$players_kingdom"),
	(try_end),

	(assign, reg0, ":faction_1"),
	(assign, reg1, ":faction_2"),
]),

##"script_cf_dplmc_player_party_meets_autoloot_conditions"
##
#
#INPUT:
#   None
#OUTPUT:
#   reg0   -1 means there are no companions and skill is too low
#           0 means there are companions and skill is too low
#           1 means skill is high enough but there are no companions
#           2 means skill is high enough and there are companions
#
# Will fail if it does not set reg0 to 2.
##
("cf_dplmc_player_party_meets_autoloot_conditions",
[
	  (store_skill_level, ":best_loot_skill", "skl_looting", "trp_player"),
	  (store_skill_level, ":player_inv_skill", "skl_inventory_management", "trp_player"),
	  (assign, ":best_inv_skill", ":player_inv_skill"),
	  (assign, ":num_companions", 0),
      (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
      (try_for_range, ":stack_no", 0, ":num_stacks"),
         (party_stack_get_troop_id,   ":stack_troop", "p_main_party", ":stack_no"),
		 (ge, ":stack_troop", 0),
		 #Check skill
		 (is_between, ":stack_troop", heroes_begin, heroes_end),
		 (store_skill_level, ":hero_skill", "skl_inventory_management", ":stack_troop"),
		 (val_max, ":best_inv_skill", ":hero_skill"),

		 (store_skill_level, ":hero_skill", "skl_looting", ":stack_troop"),
		 (val_max, ":best_loot_skill", ":hero_skill"),
		 #Check is companion
         (is_between, ":stack_troop", companions_begin, companions_end),
         (val_add, ":num_companions", 1),
      (try_end),

	  (try_begin),
	    (lt, ":player_inv_skill", 2),
		(lt, ":best_inv_skill", 3),
		(lt, ":best_loot_skill", 2),
		(assign, reg0, 0),
		(try_begin),
			(lt, ":num_companions", 1),#change 2011-06-07
			(assign, reg0, -1),
		(try_end),
	  (else_try),
		(assign, reg0, 1),
		(gt, ":num_companions", 0),
		(assign, reg0, 2),
	  (try_end),

	  (eq, reg0, 2),
]),


##"script_dplmc_troop_get_family_relation_to_troop"
##
##Like troop_get_family_relation_to_troop, except instead of writing to s11,
##it writes the index of the relation string to reg1, and writes nothing at
##all to reg4.
  ("dplmc_troop_get_family_relation_to_troop",
    [
    (store_script_param_1, ":troop_1"),
    (store_script_param_2, ":troop_2"),

    ##dplmc start+

	(try_begin),
		(eq, ":troop_1", active_npcs_including_player_begin),
		(assign, ":troop_1", "trp_player"),
	(try_end),
	(try_begin),
		(eq, ":troop_2", active_npcs_including_player_begin),
		(assign, ":troop_2", "trp_player"),
	(try_end),

	#use gender script
    #(troop_get_type, ":gender_1", ":troop_1"),
	(call_script, "script_dplmc_store_troop_is_female", ":troop_1"),
	(assign, ":gender_1", reg0),
	(assign, ":relation_string", "str_no_relation"),
	##dplmc end+
	(assign, ":relation_strength", 0),

	##dplmc start+
	#Uninitialized memory is 0, which equals "trp_player", which is the cause
	#of some annoying bugs.  In Native the game doesn't set the various family
	#slots to -1 except for the player and in the heroes_begin to heroes_end
	#range.

	(troop_get_slot, ":spouse_of_1", ":troop_1", slot_troop_spouse),#just do this to get an error if the troop ID is bad
	(troop_get_slot, ":spouse_of_2", ":troop_2", slot_troop_spouse),#just do this to get an error if the troop ID is bad

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":troop_1", ":troop_2", slot_troop_spouse),
	(assign, ":spouse_of_1", reg0),
	(assign, ":spouse_of_2", reg1),

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":spouse_of_1", ":spouse_of_2", slot_troop_father),
	(assign, ":father_of_spouse_of_1", reg0),
	(assign, ":father_of_spouse_of_2", reg1),

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":spouse_of_1", ":spouse_of_2", slot_troop_mother),
	#(assign, ":mother_of_spouse_of_1", reg0),
	(assign, ":mother_of_spouse_of_2", reg1),

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":troop_1", ":troop_2", slot_troop_father),
	(assign, ":father_of_1", reg0),
	(assign, ":father_of_2", reg1),

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":troop_1", ":troop_2", slot_troop_mother),
	(assign, ":mother_of_1", reg0),
	(assign, ":mother_of_2", reg1),

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":father_of_1", ":father_of_2", slot_troop_father),
	(assign, ":paternal_grandfather_of_1", reg0),
	(assign, ":paternal_grandfather_of_2", reg1),

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":father_of_1", ":father_of_2", slot_troop_mother),
	(assign, ":paternal_grandmother_of_1", reg0),
	(assign, ":paternal_grandmother_of_2", reg1),

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":mother_of_1", ":mother_of_2", slot_troop_father),
	(assign, ":maternal_grandfather_of_1", reg0),
	(assign, ":maternal_grandfather_of_2", reg1),

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":mother_of_1", ":mother_of_2", slot_troop_mother),
	(assign, ":maternal_grandmother_of_1", reg0),
	(assign, ":maternal_grandmother_of_2", reg1),

	(call_script, "script_dplmc_helper_get_troop1_troop2_family_slot_aux", ":troop_1", ":troop_2", slot_troop_guardian),
	(assign, ":guardian_of_1", reg0),
	(assign, ":guardian_of_2", reg1),
	##diplomacy end+

	#(str_store_string, s11, "str_no_relation"),

	(try_begin),
	  (eq, ":troop_1", ":troop_2"),
	  #self
	(else_try),
	  ##diplomacy start+
      (this_or_next|eq, ":spouse_of_2", ":troop_1"),#polygamy helper
	  ##diplomacy end+
	  (eq, ":spouse_of_1", ":troop_2"),
	  (assign, ":relation_strength", 20),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_wife"),
	  (else_try),
	    (assign, ":relation_string", "str_husband"),
	  (try_end),
	(else_try),
	  (eq, ":father_of_2", ":troop_1"),
	  (assign, ":relation_strength", 15),
	  (assign, ":relation_string", "str_father"),
	(else_try),
	  (eq, ":mother_of_2", ":troop_1"),
	  (assign, ":relation_strength", 15),
	  (assign, ":relation_string", "str_mother"),
	(else_try),
	  (this_or_next|eq, ":father_of_1", ":troop_2"),
	  (eq, ":mother_of_1", ":troop_2"),
	  (assign, ":relation_strength", 15),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_daughter"),
	  (else_try),
	    (assign, ":relation_string", "str_son"),
	  (try_end),
	##diplomacy start+
	(else_try),
	   #Check for half-siblings: sharing a father
	   (neq, ":father_of_1", -1),
	   (eq, ":father_of_1", ":father_of_2"),
	   (neq, ":mother_of_1", ":mother_of_2"),
	   (assign, ":relation_strength", 10),
	   (try_begin),
	     (eq, ":gender_1", tf_female),
	     (assign, ":relation_string", "str_dplmc_half_sister"),
	   (else_try),
	     (assign, ":relation_string", "str_dplmc_half_brother"),
	   (try_end),
   (else_try),
	   #Check for half-siblings: sharing a mother
	   (neq, ":mother_of_1", -1),
	   (eq, ":mother_of_1", ":mother_of_2"),
	   (neq, ":father_of_1", ":father_of_2"),
	   (assign, ":relation_strength", 10),
	   (try_begin),
	     (eq, ":gender_1", tf_female),
	     (assign, ":relation_string", "str_dplmc_half_sister"),
	   (else_try),
	     (assign, ":relation_string", "str_dplmc_half_brother"),
	   (try_end),
	##diplomacy end+
	(else_try),
	  #(gt, ":father_of_1", -1), #necessary, as some lords do not have the father registered #dplmc+ replaced
	  (neq, ":father_of_1", -1), #dplmc+ added
	  (eq, ":father_of_1", ":father_of_2"),
	  (assign, ":relation_strength", 10),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_sister"),
	  (else_try),
	    (assign, ":relation_string", "str_brother"),
	  (try_end),
	(else_try),
	  (eq, ":guardian_of_2", ":troop_1"),
	  (assign, ":relation_strength", 10),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_sister"),
	  (else_try),
	    (assign, ":relation_string", "str_brother"),
	  (try_end),
	(else_try),
	  (eq, ":guardian_of_1", ":troop_2"),
	  (assign, ":relation_strength", 10),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_sister"),
	  (else_try),
	    (assign, ":relation_string", "str_brother"),
	  (try_end),
	##diplomacy start+
    (else_try),#polygamy, between two people married to the same person
	   (neq, ":spouse_of_1", -1),
	   (eq, ":spouse_of_2", ":spouse_of_1"),
	   (assign, ":relation_strength", 10),
	   (try_begin),
	      (call_script, "script_dplmc_store_troop_is_female", ":troop_2"),
		  (neq, ":gender_1", reg0),
		  (assign, ":relation_string", "str_dplmc_co_spouse"),
	   (else_try),
	      (eq, ":gender_1", tf_female),
	     (assign, ":relation_string", "str_dplmc_sister_wife"),
	   (else_try),
	      (assign, ":relation_string", "str_dplmc_co_husband"),
	   (try_end),
	##diplomacy end+
	(else_try),
	  #(gt, ":paternal_grandfather_of_1", -1),#dplmc+ replaced
	  (neq, ":father_of_2", -1),#dplmc+ added
	  (this_or_next|eq, ":maternal_grandfather_of_1", ":father_of_2"),#dplmc+ added
	  (eq, ":paternal_grandfather_of_1", ":father_of_2"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_niece"),
	  (else_try),
	    (assign, ":relation_string", "str_nephew"),
	  (try_end),
	##diplomacy start+: add niece/nephew through mother
	(else_try),
	  (neq, ":mother_of_2", -1),
  	  (this_or_next|eq, ":maternal_grandmother_of_1", ":mother_of_2"),
	  (eq, ":paternal_grandmother_of_1", ":mother_of_2"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_niece"),
	  (else_try),
	    (assign, ":relation_string", "str_nephew"),
	  (try_end),
	##diplomacy end+
	(else_try), #specifically aunt and uncle by blood -- i assume that in a medieval society with lots of internal family conflicts, they would not include aunts and uncles by marriage
	  #(gt, ":paternal_grandfather_of_2", -1),#dplmc+ replaced
	  (neq, ":father_of_1", -1),#dplmc+ added
	  (this_or_next|eq, ":maternal_grandfather_of_2", ":father_of_1"),#dplmc+ added
	  (eq, ":paternal_grandfather_of_2", ":father_of_1"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_aunt"),
	  (else_try),
	    (assign, ":relation_string", "str_uncle"),
	  (try_end),
	##diplomacy start+
	#blood uncles & blood aunts, continued (via mother)
	(else_try),
	  (neq, ":mother_of_1", -1),
	  (this_or_next|eq, ":maternal_grandmother_of_2", ":mother_of_1"),
	  (eq, ":paternal_grandmother_of_2", ":mother_of_1"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_aunt"),
	  (else_try),
	    (assign, ":relation_string", "str_uncle"),
	  (try_end),
	##diplomacy end+
	(else_try),
	  #(gt, ":paternal_grandfather_of_1", 0),#dplmc+ replaced (why was this one "gt 0" but the previous "gt -1"?)
	  (neq, ":paternal_grandfather_of_1", -1),#dplmc+ added
	  (this_or_next|eq, ":maternal_grandfather_of_2", ":paternal_grandfather_of_1"),#dplmc+ added
	  (eq, ":paternal_grandfather_of_2", ":paternal_grandfather_of_1"),
	  (assign, ":relation_strength", 2),
	  (assign, ":relation_string", "str_cousin"),
	##diplomacy start+
	#Add cousin via paternal grandmother or maternal grandparents
	(else_try),
	  (neq, ":maternal_grandfather_of_1", -1),
	  (this_or_next|eq, ":maternal_grandfather_of_2", ":maternal_grandfather_of_1"),
	  (eq, ":paternal_grandfather_of_2", ":maternal_grandfather_of_1"),
	  (assign, ":relation_strength", 2),
	  (assign, ":relation_string", "str_cousin"),
	(else_try),
	  (neq, ":paternal_grandmother_of_1", -1),
	  (this_or_next|eq, ":maternal_grandmother_of_2", ":paternal_grandmother_of_1"),
	  (eq, ":paternal_grandmother_of_2", ":paternal_grandmother_of_1"),
	  (assign, ":relation_strength", 2),
	  (assign, ":relation_string", "str_cousin"),
	(else_try),
	  (neq, ":maternal_grandmother_of_1", -1),
	  (this_or_next|eq, ":maternal_grandmother_of_2", ":maternal_grandmother_of_1"),
	  (eq, ":paternal_grandmother_of_2", ":maternal_grandmother_of_1"),
	  (assign, ":relation_strength", 2),
	  (assign, ":relation_string", "str_cousin"),
	##diplomacy end+
   	(else_try),
   	  (eq, ":father_of_spouse_of_1", ":troop_2"),
   	  (assign, ":relation_strength", 5),
   	  (try_begin),
   	    (eq, ":gender_1", tf_female),
   	    (assign, ":relation_string", "str_daughterinlaw"),
   	  (else_try),
   	    (assign, ":relation_string", "str_soninlaw"),
   	  (try_end),
	(else_try),
	  (eq, ":father_of_spouse_of_2", ":troop_1"),
	  (assign, ":relation_strength", 5),
	  (assign, ":relation_string", "str_fatherinlaw"),
	(else_try),
	  (eq, ":mother_of_spouse_of_2", ":troop_1"),
	  (neq, ":mother_of_spouse_of_2", "trp_player"), #May be necessary if mother for troops not set to -1
	  (assign, ":relation_strength", 5),
	  (assign, ":relation_string", "str_motherinlaw"),

	(else_try),
	  #(gt, ":father_of_spouse_of_1", -1), #necessary #dplmc+ replaced
	  (neq, ":father_of_spouse_of_1", -1), #dplmc+ added
	  (eq, ":father_of_spouse_of_1", ":father_of_2"),
	  (assign, ":relation_strength", 5),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_sisterinlaw"),
	  (else_try),
	    (assign, ":relation_string", "str_brotherinlaw"),
	  (try_end),
	(else_try),
	  #(gt, ":father_of_spouse_of_2", -1), #necessary #dplmc+ replaced
	  (neq, ":father_of_spouse_of_2", -1), #dplmc+ added
	  (eq, ":father_of_spouse_of_2", ":father_of_1"),
	  (assign, ":relation_strength", 5),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_sisterinlaw"),
	  (else_try),
	    (assign, ":relation_string", "str_brotherinlaw"),
	  (try_end),
	(else_try),
#	  (gt, ":spouse_of_2", -1), #necessary to avoid bug #dplmc+ replaced
	  (neq, ":spouse_of_2", -1), #dplmc+ added
	  (troop_slot_eq, ":spouse_of_2", slot_troop_guardian, ":troop_1"),
	  (assign, ":relation_strength", 5),
	  (try_begin),
	    #(eq, ":gender_1", tf_female),#dplmc+ replaced
	    (eq, ":gender_1", tf_female),#dplmc+ added
	    (assign, ":relation_string", "str_sisterinlaw"),
	  (else_try),
	    (assign, ":relation_string", "str_brotherinlaw"),
	  (try_end),
	(else_try),
	  #(gt, ":spouse_of_1", -1), #necessary to avoid bug #dplmc+ replaced
	  (neq, ":spouse_of_1", -1), #dplmc+ added
	  (troop_slot_eq, ":spouse_of_1", slot_troop_guardian, ":troop_2"),
	  (assign, ":relation_strength", 5),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_sisterinlaw"),
	  (else_try),
	    (assign, ":relation_string", "str_brotherinlaw"),
	  (try_end),
	(else_try),
	  #grandchild
	  (neq, ":troop_2", -1),
	   (this_or_next|eq, ":paternal_grandfather_of_1", ":troop_2"),
	   (this_or_next|eq, ":maternal_grandfather_of_1", ":troop_2"),
	   (this_or_next|eq, ":paternal_grandmother_of_1", ":troop_2"),
		   (eq, ":maternal_grandmother_of_1", ":troop_2"),
	   (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_dplmc_granddaughter"),
	  (else_try),
	    (assign, ":relation_string", "str_dplmc_grandson"),
	  (try_end),
	(else_try),
	   #grandparent
	   (neq, ":troop_1", -1),
	   (this_or_next|eq, ":paternal_grandfather_of_2", ":troop_1"),
	   (this_or_next|eq, ":maternal_grandfather_of_2", ":troop_1"),
	   (this_or_next|eq, ":paternal_grandmother_of_2", ":troop_1"),
		   (eq, ":maternal_grandmother_of_2", ":troop_1"),
	  (assign, ":relation_strength", 4),
	  (try_begin),
	    (eq, ":gender_1", tf_female),
	    (assign, ":relation_string", "str_dplmc_grandmother"),
	  (else_try),
	    (assign, ":relation_string", "str_dplmc_grandfather"),
	  (try_end),
	(try_end),
	##diplomacy start+
	##Add relations for rulers not already encoded
	(try_begin),
		(eq, ":relation_strength", 0),
		(neq, ":troop_1", ":troop_2"),
		(try_begin),
			#Lady Isolla of Suno's father King Esterich was King Harlaus's cousin,
			#making them first cousins once removed.  Assign a weight of "1"
			#to this (for reference, the lowest value normally given in Native is 2).
			(this_or_next|eq, ":troop_1", "trp_kingdom_1_lord"),
			    (eq, ":troop_1", "trp_kingdom_1_pretender"),
			(this_or_next|eq, ":troop_2", "trp_kingdom_1_lord"),
			    (eq, ":troop_2", "trp_kingdom_1_pretender"),
			(assign, ":relation_strength", 1),
			(assign, ":relation_string", "str_cousin"),
		(else_try),
			#Prince Valdym's uncle was Regent Burelek, father of King Yaroglek,
			#making the two of them first cousins.
			(this_or_next|eq, ":troop_1", "trp_kingdom_2_lord"),
			    (eq, ":troop_1", "trp_kingdom_2_pretender"),
			(this_or_next|eq, ":troop_2", "trp_kingdom_2_lord"),
				(eq, ":troop_2", "trp_kingdom_2_pretender"),
			(assign, ":relation_strength", 2),
			(assign, ":relation_string", "str_cousin"),
		(else_try),
			#Sanjar Khan and Dustum Khan were both sons of Janakir Khan
			#(although by different mothers) making them half-brothers.
			(this_or_next|eq, ":troop_1", "trp_kingdom_3_lord"),
			    (eq, ":troop_1", "trp_kingdom_3_pretender"),
			(this_or_next|eq, ":troop_2", "trp_kingdom_3_lord"),
				(eq, ":troop_2", "trp_kingdom_3_pretender"),
			(assign, ":relation_strength", 10),
			(assign, ":relation_string", "str_dplmc_half_brother"),
			#Adjust their parentage to make this work automatically
			(try_begin),
		      	(troop_slot_eq, ":troop_1", slot_troop_father, -1),
				(troop_slot_eq, ":troop_2", slot_troop_father, -1),
				#Set their "father" slot to a number guaranteed not to have spurious collisions
				(store_mul, ":janakir_khan", "trp_kingdom_3_lord", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),#defined in module_constants.py
				(val_add, ":janakir_khan", DPLMC_VIRTUAL_RELATIVE_FATHER_OFFSET),#defined in module_constants.py
				(troop_set_slot, ":troop_1", slot_troop_father, ":janakir_khan"),
				(troop_set_slot, ":troop_2", slot_troop_father, ":janakir_khan"),
				#Differentiate their mothers, so they are half-brothers instead of full-brothers
				(try_begin),
					(troop_slot_eq, ":troop_1", slot_troop_mother, -1),
					(store_mul, reg0, ":troop_1", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
					(val_add, reg0, DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
					(troop_set_slot, ":troop_1", slot_troop_mother, reg0),
				(try_end),
				(try_begin),
					(troop_slot_eq, ":troop_2", slot_troop_mother, -1),
					(store_mul, reg0, ":troop_2", DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
					(val_add, reg0, DPLMC_VIRTUAL_RELATIVE_MULTIPLIER),
					(troop_set_slot, ":troop_2", slot_troop_mother, reg0),
				(try_end),
			(try_end),
		(try_end),
	(try_end),
	##Add uncles and aunts by marriage.
	##In Native, the relation strength for blood uncles/aunts is 4, and for cousins is 2.
	##In light of this I've decided to set the relation strength for aunts/uncles by marriage to 2.
	(try_begin),
		(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
		#Test if troop_1 is married to a sibling of one of troop_2's parents, pt. 1
		(ge, ":spouse_of_1", 0),
		(neg|troop_slot_eq, ":spouse_of_1", slot_troop_father, -1),
		(this_or_next|troop_slot_eq, ":spouse_of_1", slot_troop_father, ":paternal_grandfather_of_2"),
			(troop_slot_eq, ":spouse_of_1", slot_troop_father, ":maternal_grandfather_of_2"),
		(assign, ":relation_strength", 2),
		(try_begin),
			(eq, ":gender_1", tf_female),
			(assign, ":relation_string", "str_aunt"),
		(else_try),
			(assign, ":relation_string", "str_uncle"),
		(try_end),
	(else_try),
		(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
		#Test if troop_1 is married to a sibling of one of troop_2's parents, pt. 2
		(ge, ":spouse_of_1", 0),
		(neg|troop_slot_eq, ":spouse_of_1", slot_troop_mother, -1),
		(this_or_next|troop_slot_eq, ":spouse_of_1", slot_troop_mother, ":paternal_grandmother_of_2"),
			(troop_slot_eq, ":spouse_of_1", slot_troop_mother, ":maternal_grandmother_of_2"),
		(assign, ":relation_strength", 2),
		(try_begin),
			(eq, ":gender_1", tf_female),
			(assign, ":relation_string", "str_aunt"),
		(else_try),
			(assign, ":relation_string", "str_uncle"),
		(try_end),
	(else_try),
		(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
		#Test if troop_2 is married to a sibling of one of troop_1's parents, pt. 1
		(ge, ":spouse_of_2", 0),
		(neg|troop_slot_eq, ":spouse_of_2", slot_troop_father, -1),
		(this_or_next|troop_slot_eq, ":spouse_of_2", slot_troop_father, ":paternal_grandfather_of_1"),
			(troop_slot_eq, ":spouse_of_2", slot_troop_father, ":maternal_grandfather_of_1"),
		(assign, ":relation_strength", 2),
		(try_begin),
			(eq, ":gender_1", tf_female),
			(assign, ":relation_string", "str_niece"),
		(else_try),
			(assign, ":relation_string", "str_nephew"),
		(try_end),
	(else_try),
		(lt, ":relation_strength", 2),#Skip this check if a stronger relation has been found.
		#Test if troop_2 is married to a sibling of one of troop_1's parents, pt. 2
		(ge, ":spouse_of_2", 0),
		(neg|troop_slot_eq, ":spouse_of_2", slot_troop_mother, -1),
		(this_or_next|troop_slot_eq, ":spouse_of_2", slot_troop_mother, ":paternal_grandmother_of_1"),
			(troop_slot_eq, ":spouse_of_2", slot_troop_mother, ":maternal_grandmother_of_1"),
		(assign, ":relation_strength", 2),
		(try_begin),
			(eq, ":gender_1", tf_female),
			(assign, ":relation_string", "str_niece"),
		(else_try),
			(assign, ":relation_string", "str_nephew"),
		(try_end),
	(try_end),

	(try_begin),
		(this_or_next|neg|troop_is_hero, ":troop_1"),
		(neg|troop_is_hero, ":troop_2"),
		(assign, ":relation_string", "str_no_relation"),
		(assign, ":relation_strength", 0),
	(try_end),

	(assign, reg0, ":relation_strength"),
	(assign, reg1, ":relation_string"),
	]),

##"script_cf_dplmc_faction_has_bias_against_gender"
("cf_dplmc_faction_has_bias_against_gender", [
	(store_script_param_1, ":faction_no"),
	(store_script_param_2, ":test_gender"),#Special: 1 is female

    (assign, reg0, 0),
	(lt, "$g_disable_condescending_comments", 2),#If bias is disabled, do not continue
	(is_between, ":test_gender", 0, 2),#valid genders are 0 and 1

	(try_begin),
		(eq, ":faction_no", "fac_player_supporters_faction"),
		(is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
		(assign, ":faction_no", "$players_kingdom"),
	(try_end),

	(try_begin),
		#For a-typical factions, nothing by default.
		(neg|is_between, ":faction_no", npc_kingdoms_begin, npc_kingdoms_end),
	(else_try),
		#If the leader has that gender, no prejudice.
		(faction_get_slot, ":active_npc", ":faction_no", slot_faction_leader),
		(gt, ":active_npc", -1),
		(call_script, "script_dplmc_store_troop_is_female", ":active_npc"),
		(eq, reg0, ":test_gender"),
		(assign, reg0, 0),
	(else_try),
		#Traditional gender prejudice if both are true:
		#1.  The faction has no original members of the specified gender.
		#2.  The faction has original members with non-accepting lord personalities.

		(assign, ":num_closeminded", 0),
		(assign, ":end_cond", active_npcs_end),

		(try_for_range, ":active_npc", active_npcs_begin, ":end_cond"),#Deliberately do not include kingdom ladies
			#Also deliberately exclude companions and pretenders
			#(Pretenders are marginalized at the start of the game, and
			#companions don't necessarily start in positions of power either)
			(this_or_next|is_between, ":active_npc", kings_begin, kings_end),
				(is_between, ":active_npc", lords_begin, lords_end),
			(troop_slot_eq, ":active_npc", slot_troop_original_faction, ":faction_no"),

			(call_script, "script_dplmc_store_troop_is_female", ":active_npc"),
			(try_begin),
				(eq, reg0, ":test_gender"),
				(assign, ":num_closeminded", -1000),
				(assign, ":end_cond", ":active_npc"),
			(else_try),
				(troop_get_slot, reg0, ":active_npc", slot_lord_reputation_type),
				(is_between, reg0, lrep_none + 1, lrep_roguish),#Lord (non-commoner, non-liege, non-lady) personality type
				(neq, reg0, lrep_cunning),
				(neq, reg0, lrep_goodnatured),
				(val_add, ":num_closeminded", 1),
			(try_end),
		(try_end),

		(store_sub, reg0, ":num_closeminded", 1),#Needs at least one
		(val_clamp, reg0, 0, 2),
	(try_end),

	(try_begin),
		(ge, "$cheat_mode", 1),
		(assign, ":end_cond", reg1),#just save reg1 and reg2 (ignore the normal meaning of the variable names)
		(assign, ":active_npc", reg2),
		(assign, reg1, ":faction_no"),
		(assign, reg2, ":test_gender"),
		(display_message, "@{!} Checked if faction {reg1} is prejudiced against {reg2?women:men}: {reg0?true:false}"),
		(assign, reg1, ":end_cond"),#revert reg1 and reg2 (ignore the normal meaning of the variable names)
		(assign, reg2, ":active_npc"),
	(try_end),
	(gt, reg0, 0),
]),

#"script_dplmc_store_troop_personality_caution_level"
#
# INPUT:
#   arg1 :troop_no
# OUTPUT:
#   reg0 -1 for aggressive
#         0 for neither
#         1 for cautious
("dplmc_store_troop_personality_caution_level", [
	#Used a number of places to determine whether a lord is cautious
	#or aggressive.  The standard is something like:
	#
	#For cautious:
	#(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_upstanding),
    #    (this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_debauched),
    #    (this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_goodnatured),
    #    (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_cunning),
	#
	#For aggressive:
	#(this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_martial),
    #    (this_or_next|troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_quarrelsome),
    #    (troop_slot_eq, ":troop_no", slot_lord_reputation_type, lrep_selfrighteous),
	#
	#I've expanded this for companion/lady personalities.
	#The result can be either:
	# -1  =  aggressive
	#  0  =  neutral
	#  1  =  cautious
	(store_script_param_1, ":troop_no"),

	(try_begin),
		(neg|is_between, ":troop_no", heroes_begin, heroes_end),#The player or troops that don't have slot_lord_reputation_type
		(assign, reg0, 0),#neither cautious nor aggressive
	(else_try),
		(call_script, "script_dplmc_get_troop_morality_value", ":troop_no", tmt_aristocratic),
		(lt, reg0, 0),#compliments when the player retreats
		(assign, reg0, 1),#cautious
	(else_try),
		(gt, reg0, 0),#complains when the player retreats
		(assign, reg0, -1),#aggressive
	(else_try),
		(troop_get_slot, ":reputation", ":troop_no", slot_lord_reputation_type),
		(this_or_next|eq, ":reputation", lrep_adventurous),
		(this_or_next|eq, ":reputation", lrep_martial),
		(this_or_next|eq, ":reputation", lrep_quarrelsome),
			(eq, ":reputation", lrep_selfrighteous),
		(assign, reg0, -1),#aggressive
	(else_try),
		(this_or_next|ge, ":reputation", lrep_conventional),
		(this_or_next|eq, ":reputation", lrep_upstanding),
		(this_or_next|eq, ":reputation", lrep_debauched),
		(this_or_next|eq, ":reputation", lrep_goodnatured),
			(eq, ":reputation", lrep_cunning),
		(assign, reg0, 1),#cautious
	(else_try),
		(assign, reg0, 0),#neither cautious nor aggressive
	(try_end),
]),

##"script_dplmc_cap_troop_describes_troop_to_troop_s1"
#
# e.g.
#
#(call_script, "script_dplmc_cap_troop_describes_troop_to_troop_s1", 1, "trp_player", ":third_lord", "$g_talk_troop"),
#
#INPUT:
#        arg1  :capitalization (0 if middle of sentence, 1 if sentence start)
#        arg2  :speaker (the one doing the talking)
#        arg3  :described (the one being named)
#        arg4  :listener (the one being spoken to)
#
#OUTPUT:
#        Writes result to s1, clobbers s0
#
#Similar to "script_troop_describes_troop_to_s15", except
#it takes into account the perspective of the one being
#spoken to, and writes to s1
  ("dplmc_cap_troop_describes_troop_to_troop_s1",
  [
	(store_script_param, ":capitalization", 1),
	(store_script_param, ":speaker", 2),
	(store_script_param, ":described", 3),
	(store_script_param, ":listener", 4),

	(assign, ":save_reg0", reg0),
	(assign, ":save_reg1", reg1),

	(str_store_troop_name, s0, ":described"),

	(assign, reg0, ":capitalization"),
	(try_begin),
		(eq, ":described", ":listener"),
		(neq, ":speaker", ":listener"),
		(str_store_string, s0, "@{reg0?Y:y}ou"),
		(assign, reg0, 1),
	(else_try),
		(eq, ":described", ":speaker"),
		(str_store_string, s0, "@{reg0?M:m}yself"),
		(assign, reg0, 1),
	(else_try),
		(this_or_next|eq, ":described", "trp_player"),#only calculate family relationships for the player and heroes
			(is_between, ":described", heroes_begin, heroes_end),
		(assign, ":speaker_relation", 0),
		(assign, ":speaker_relation_string", 0),
		(try_begin),
			(this_or_next|eq, ":speaker", "trp_player"),#only calculate family relationships for the player and heroes
				(is_between, ":speaker", heroes_begin, heroes_end),
			(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":described", ":speaker"),
			(assign, ":speaker_relation", reg0),
			(assign, ":speaker_relation_string", reg1),
		(try_end),
		(assign, reg0, 0),
		(try_begin),
			(this_or_next|eq, ":described", "trp_player"),#only calculate family relationships for the player and heroes
				(is_between, ":described", heroes_begin, heroes_end),
			(call_script, "script_dplmc_troop_get_family_relation_to_troop", ":described", ":listener"),
		(try_end),
		(this_or_next|ge, ":speaker_relation", 1),
			(ge, reg0, 1),
		(try_begin),
			(eq, ":speaker_relation", reg0),
			(eq, reg1, ":speaker_relation_string"),
			(neq, ":speaker", ":listener"),
			(assign, reg0, ":capitalization"),
			(str_store_string, s1, ":speaker_relation_string"),
			(str_store_string, s1, "@{reg0?O:o}ur {s1} {s0}"),
		(else_try),
			(ge, ":speaker_relation", reg0),
			(assign, reg0, ":capitalization"),
			(str_store_string, s1, ":speaker_relation_string"),
			(str_store_string, s1, "@{reg0?M:m}y {s1} {s0}"),
		(else_try),
			(assign, reg0, ":capitalization"),
			(str_store_string, s1, reg1),
			(str_store_string, s1, "@{reg0?Y:y}our {s1} {s0}"),
		(try_end),
	###Disable "marshall/liege", because that's done elsewhere anyway
	#(else_try),
	#	(store_faction_of_troop, ":speaker_faction", ":speaker"),
	#	(try_begin),
	#		(eq, ":speaker", "trp_player"),
	#		(assign, ":speaker_faction", "$players_kingdom"),
	#	(try_end),
	#
	#	(store_faction_of_troop, ":listener_faction", ":listener"),
	#	(try_begin),
	#		(eq, ":listener", "trp_player"),
	#		(assign, ":listener_faction", "$players_kingdom"),
	#	(try_end),
	#
	#	(faction_slot_eq, ":speaker_faction", slot_faction_leader, ":described"),
	#	(this_or_next|is_between, ":speaker_faction", npc_kingdoms_begin, npc_kingdoms_end),
	#		(faction_slot_eq, ":speaker_faction", slot_faction_state, sfs_active),
	#	(this_or_next|neq, ":described", "trp_player"),
	#		(eq, ":speaker_faction", "$players_kingdom"),
	#	(assign, reg0, ":capitalization"),
	#	(try_begin),
	#		(eq, ":speaker_faction", ":listener_faction"),
	#		(neq, ":speaker", ":listener"),
	#		(str_store_string, s1, "@{reg0?O:o}ur liege {s0}"),
	#	(else_try),
	#		(str_store_string, s1, "@{reg0?M:m}y liege {s0}"),
	#	(try_end),
	#(else_try),
	#	(faction_slot_eq, ":speaker_faction", slot_faction_marshall, ":described"),
	#	(this_or_next|is_between, ":speaker_faction", npc_kingdoms_begin, npc_kingdoms_end),
	#		(faction_slot_eq, ":speaker_faction", slot_faction_state, sfs_active),
	#	(this_or_next|neq, ":described", "trp_player"),
	#		(eq, ":speaker_faction", "$players_kingdom"),
	#	(try_begin),
	#		(eq, ":speaker_faction", ":listener_faction"),
	#		(neq, ":speaker", ":listener"),
	#		(str_store_string, s1, "@{reg0?O:o}ur marshall {s0}"),
	#	(else_try),
	#		(str_store_string, s1, "@{reg0?M:m}y marshall {s0}"),
	#	(try_end),
	#(else_try),
	#	(this_or_next|is_between, ":listener_faction", npc_kingdoms_begin, npc_kingdoms_end),
	#		(faction_slot_eq, ":listener_faction", slot_faction_state, sfs_active),
	#	(faction_slot_eq, ":listener_faction", slot_faction_leader, ":described"),
	#	(this_or_next|neq, ":described", "trp_player"),
	#		(eq, ":listener_faction", "$players_kingdom"),
	#	(assign, reg0, ":capitalization"),
	#	(str_store_string, s1, "@{reg0?Y:y}our liege {s0}"),

	###Disable "friend", because it gets really spammy.  (It looks really stupid to have
	###a list of fifty names, all of them starting with "Your Friend So-and-So".)
	#(else_try),
	#	(call_script, "script_troop_get_relation_with_troop", ":described", ":listener"),
	#	(ge, reg0, 20),
	#	(this_or_next|neq, ":listener", "trp_player"),
	#		(ge, reg0, 50),
	#	(call_script, "script_troop_get_relation_with_troop", ":described", ":speaker"),
	#	(this_or_next|neq, ":listener", "trp_player"),
	#		(neq, ":speaker_trp_player"),
	#	(try_begin),
	#		(ge, reg0, 20),
	#		(this_or_next|neq, ":speaker", "trp_player"),
	#			(ge, reg0, 50),
	#		(assign, reg0, ":capitalization"),
	#		(str_store_string, s1, "@{reg0?O:o}ur friend {s0}"),
	#	(else_try),
	#		(assign, reg0, ":capitalization"),
	#		(str_store_string, s1, "@{reg0?Y:y}our friend {s0}"),
	#	(try_end),
	#(else_try),
	#	(call_script, "script_troop_get_relation_with_troop", ":described", ":speaker"),
	#	(ge, reg0, 20),
	#	(this_or_next|neq, ":speaker", "trp_player"),
	#		(ge, reg0, 50),
	#	(assign, reg0, ":capitalization"),
	#	(str_store_string, s1, "@{reg0?M:m}y friend {s0}"),

	###The "<Jarl Aedin> of <Tihr>" condition works fine, but I'm not particularly impressed.
	###I'm not sure it's an improvement over just using their name, so I'm disabling it for now.
	#(else_try),
	#	#Did not use relation string: name by owned town.
	#	#Do not use names of castles, due to potential absurdities like "Count Harringoth of Harringoth Castle".
	#	#Skip kings and pretenders because of "Lady Isolla of Suno of Suno" and similar things.
	#	(neg|is_between, ":described", kings_begin, kings_end),
	#	(neg|is_between, ":described", pretenders_begin, pretenders_end),
	#	(this_or_next|eq, ":described", "trp_player"),
	#		(is_between, ":described", heroes_begin, heroes_end),
	#
	#	(assign, ":owned_town", -1),
	#	(assign, ":owned_town_score", -1),
	#	(troop_get_slot, ":original_faction", ":described", slot_troop_original_faction),
	#	(try_for_range, ":town_no", towns_begin, towns_end),
	#		(party_get_slot, ":town_lord", ":town_no", slot_town_lord),
	#		(ge, ":town_lord", 0),
	#		(assign, reg0, 0),
	#		(try_begin),
	#			(eq, ":town_lord", ":described"),
	#			(assign, reg0, 10),
	#		(else_try),
	#			(this_or_next|troop_slot_eq, ":town_lord", slot_troop_spouse, ":described"),
	#				(troop_slot_eq, ":described", slot_troop_spouse, ":town_lord"),
	#			(this_or_next|is_between, ":described", kingdom_ladies_begin, kingdom_ladies_end),
	#				(troop_slot_eq, ":described", slot_troop_occupation, slto_kingdom_lady),
	#			(assign, reg0, 1),
	#		(else_try),
	#			(assign, reg0, 0),
	#		(try_end),
	#		(gt, reg0, 0),
	#		(try_begin),
	#			(party_slot_eq, ":town_no", slot_center_original_faction, ":original_faction"),
	#			(val_add, reg0, 1),
	#		(try_end),
	#		(try_begin),
	#			(this_or_next|party_slot_eq, ":town_no", dplmc_slot_center_original_lord, ":described"),
	#				(party_slot_eq, ":town_no", dplmc_slot_center_original_lord, ":town_lord"),
	#			(val_add, reg0, 2),
	#		(try_end),
	#		(try_begin),
	#			(this_or_next|troop_slot_eq, ":town_lord", slot_troop_home, ":town_no"),
	#				(troop_slot_eq, ":town_lord", slot_troop_home, ":town_no"),
	#			(val_add, reg0, 2),
	#		(try_end),
	#		(gt, reg0, ":owned_town_score"),
	#		(assign, ":owned_town_score", reg0),
	#		(assign, ":owned_town", ":town_no"),
	#	(try_end),
	#	(is_between, ":owned_town", towns_begin, towns_end),
	#	(str_store_party_name, s1, ":owned_town"),
	#	(str_store_string, s1, "@{s0} of {s1}"),
	(else_try),
		(str_store_string, s1, "str_s0"),
	(try_end),

	(assign, reg0, ":save_reg0"),
	(assign, reg1, ":save_reg1"),
	(str_store_string_reg, s0, s1),
	]),

##"script_dplmc_helper_get_troop1_troop2_family_slot_aux"
##
## Helper function that does something specific that I want in
## script_dplmc_troop_get_family_relation_to_troop.
##
## Gets the slot value, but for troops that aren't trp_player
## and are not within (heroes_begin, heroes_end), values of "0"
## are transformed to -1.  Also gives a result of -1 (instead of
## an error) for negative troop IDs, which is what I want in
## this situation (otherwise I'd be explicitly checking this and
## setting the result to -1 if it was bad).
##
## Also, values equal to "active_npcs_including_player_begin" are
## transformed to "trp_player" (i.e. 0), to allow storing that
## value.
##
##INPUT:  arg1   :troop_1
##        arg2   :troop_2
##        arg3   :slot_no
##
##OUTPUT: reg0   value of slot for troop_1, or -1
##        reg1   value of slot for troop_2, or -1
("dplmc_helper_get_troop1_troop2_family_slot_aux",
	[
		(store_script_param, ":troop_1", 1),
		(store_script_param, ":troop_2", 2),
		(store_script_param, ":slot_no", 3),

		#(1) Get the value for the first troop into reg0
		(try_begin),
			#Negative numbers are placeholders for invalid family members
			(lt, ":troop_1", 0),
			(assign, reg0, -1),
		(else_try),
			#For active_npcs_including_player_begin, use the family slot from trp_player
			(eq, ":troop_1", active_npcs_including_player_begin),
			(troop_get_slot, reg0, "trp_player", ":slot_no"),
		(else_try),
			#Otherwise get the family member slot
			(troop_get_slot, reg0, ":troop_1", ":slot_no"),
			#However, for non-heroes, the memory might not be initialized,
			#so don't take a value of 0 at face-value.
			(eq, reg0, 0),
			(neg|is_between, ":troop_1", heroes_begin, heroes_end),
			(neq, ":troop_1", "trp_player"),
			(assign, reg0, -1),
		(try_end),

		#Translate from active_npcs_including_player_begin to trp_player
		(try_begin),
			(eq, reg0, active_npcs_including_player_begin),
			(assign, reg0, "trp_player"),
		(try_end),

		#(2) Get the value for the second troop into reg1
		(try_begin),
			#Negative numbers are placeholders for invalid family members
			(lt, ":troop_2", 0),
			(assign, reg1, -1),
		(else_try),
			#For active_npcs_including_player_begin, use the family slot from trp_player
			(eq, ":troop_2", active_npcs_including_player_begin),
			(troop_get_slot, reg1, "trp_player", ":slot_no"),
		(else_try),
			#Otherwise get the family member slot
			(troop_get_slot, reg1, ":troop_2", ":slot_no"),
			#However, for non-heroes, the memory might not be initialized,
			#so don't take a value of 0 at face-value.
			(eq, reg1, 0),
			(neg|is_between, ":troop_2", heroes_begin, heroes_end),
			(neq, ":troop_2", "trp_player"),
			(assign, reg1, -1),
		(try_end),

		#Translate from active_npcs_including_player_begin to trp_player
		(try_begin),
			(eq, reg1, active_npcs_including_player_begin),
			(assign, reg1, "trp_player"),
		(try_end),
	]),

	##"script_dplmc_estimate_center_weekly_income"
	#
	#  INPUT:  arg1   :center_no
	# OUTPUT:  reg0   estimated value of weekly income
	#
	#TODO: Add a better explanation for why this function does not include tarrifs.
	("dplmc_estimate_center_weekly_income", [
		(store_script_param_1, ":center_no"),
		(party_get_slot, ":prosperity", ":center_no", slot_town_prosperity),
		(try_begin),
		  #If there is some sort of aberration, assign to 50 instead of
		  #clamping, on the assumption that the value bears no relation
		  #to the true prosperity at all.
		  (neg|is_between, ":prosperity", 0, 101),
		  (assign, ":prosperity", 50),
		(try_end),
		(store_add, reg0, 20, ":prosperity"),
		(val_mul, reg0, 1200),
		(val_div, reg0, 120),
		(try_begin),
		  (party_slot_eq, ":center_no", slot_party_type, spt_town),
		  #Towns have higher base rent than castles and villages
		  (val_mul, reg0, 2),
		  #Include town garrison allowance
		  (val_mul, ":prosperity", 15),
		  (val_add, ":prosperity", 700),
		  (val_mul, ":prosperity", 3),
		  (val_div, ":prosperity", 2),
		  (val_add, reg0, ":prosperity"),
		(else_try),
		  (party_slot_eq, ":center_no", slot_party_type, spt_castle),
		  #Include castle garrison allowance
		  (val_mul, ":prosperity", 15),
		  (val_add, ":prosperity", 700),
		  (val_add, reg0, ":prosperity"),
		(try_end),
		#At this point, the final result is in reg0.
	]),

  # "script_dplmc_get_closest_center_or_two"
  # Input: arg1 = party_no
  # Output: reg0 = center_no (closest)
  #         reg1 = center_no2 (another close center or -1)
  #
  # If reg1 is non-negative, it should make some sense to say "<party_no> is
  # between <reg0> and <reg1>".
  #
  # The way I do this is:
  #   1.  Find the closest center to the party.
  #   2.  Excluding the center from (1), find the closest center to the
  #       party which is not closer to the center from (1) than it is to
  #       the party.  (There might not be any centers matching this
  #       description.)
  #
  # If the party is much closer to center_1 than center_2, I discard
  # the second center.  (The rationale is that if I'm standing on my
  # doorstep, it is be helpful to say "I am between my house and the
  # grocery store".  It is less misleading to just say "I am near my
  # house.")
  ("dplmc_get_closest_center_or_two",
    [
      (store_script_param_1, ":party_no"),
      (call_script, "script_get_closest_center", ":party_no"),#writes closest center to reg0
      (store_distance_to_party_from_party, ":distance_to_beat", ":party_no", reg0),
      (val_mul, ":distance_to_beat", 2),
      (val_add, ":distance_to_beat", 1),

      (assign, reg1, -1),
      (try_for_range, ":center_no", centers_begin, centers_end),
        (neq, ":center_no", reg0),
        (store_distance_to_party_from_party, ":party_to_center_distance", ":party_no", ":center_no"),
        (lt, ":party_to_center_distance", ":distance_to_beat"),
        (store_distance_to_party_from_party, ":center_to_center_distance", reg0, ":center_no"),
        (gt, ":center_to_center_distance", ":party_to_center_distance"),
        (assign, ":distance_to_beat", ":party_to_center_distance"),
        (assign, reg1, ":center_no"),
      (try_end),
  ]),


# Jrider +
   ###################################################################################
   # REPORT PRESENTATIONS v1.2 scripts
   # Script overlay_container_add_listbox_item
   # use ...
   # return ...
   ("overlay_container_add_listbox_item", [
        (store_script_param, ":line_y", 1),
        (store_script_param, ":npc_id", 2),

        (set_container_overlay, "$g_jrider_character_relation_listbox"),

        # create text overlay for entry
        (create_text_overlay, reg10, s1, tf_left_align),
        (overlay_set_color, reg10, 0xDDDDDD),
        (position_set_x, pos1, 650),
        (position_set_y, pos1, 750),
        (overlay_set_size, reg10, pos1),
        (position_set_x, pos1, 0),
        (position_set_y, pos1, ":line_y"),
        (overlay_set_position, reg10, pos1),

        # create button
        (create_image_button_overlay, reg10, "mesh_white_plane", "mesh_white_plane"),
        (position_set_x, pos1, 0), # 590 real, 0 scrollarea
        (position_set_y, pos1, ":line_y"),
        (overlay_set_position, reg10, pos1),
        (position_set_x, pos1, 16000),
        (position_set_y, pos1, 750),
        (overlay_set_size, reg10, pos1),
        (overlay_set_alpha, reg10, 0),
        (overlay_set_color, reg10, 0xDDDDDD),

        # store relation of button id to character number for use in triggers
        (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", reg10),
        (troop_set_slot, "trp_temp_array_b", ":current_storage_index", "$num_charinfo_candidates"),

        # reset variables if appropriate flags are up
        (try_begin),
            (try_begin),
                (this_or_next|eq, "$g_jrider_pres_called_from_menu", 1),
                (ge, "$g_jrider_reset_selected_on_faction", 1),

                (assign, "$character_info_id", ":npc_id"),
                (assign, "$g_jrider_last_checked_indicator", reg10),
                (assign, "$g_latest_character_relation_entry", "$num_charinfo_candidates"),
            (try_end),
        (try_end),

        # close the container
        (set_container_overlay, -1),
   ]),

   # script get_relation_candidate_list_for_presentation
   # return a list of candidate according to type of list and restrict options
   # Use ...
   ("fill_relation_canditate_list_for_presentation",
    [
        (store_script_param, ":pres_type", 1),
        (store_script_param, ":base_candidates_y", 2),

        # Type of list from global variable: 0 courtship, 1 known lords
        (try_begin),
        ## For courtship:
            (eq, ":pres_type", 0),

            (try_for_range_backwards, ":lady", kingdom_ladies_begin, kingdom_ladies_end),
                (troop_slot_ge, ":lady", slot_troop_met, 1), # met or better
                (troop_slot_eq, ":lady", slot_troop_spouse, -1), # unmarried

                # use faction filter
                (store_troop_faction, ":lady_faction", ":lady"),
                (val_sub, ":lady_faction", kingdoms_begin),
                (this_or_next|eq, "$g_jrider_faction_filter", -1),
                (eq, "$g_jrider_faction_filter", ":lady_faction"),

                (call_script, "script_troop_get_relation_with_troop", "trp_player", ":lady"),
                (gt, reg0, 0),
                (assign, reg3, reg0),

                (str_store_troop_name, s2, ":lady"),

                (store_current_hours, ":hours_since_last_visit"),
                (troop_get_slot, ":last_visit_hour", ":lady", slot_troop_last_talk_time),
                (val_sub, ":hours_since_last_visit", ":last_visit_hour"),
                (store_div, ":days_since_last_visit", ":hours_since_last_visit", 24),
                (assign, reg4, ":days_since_last_visit"),

                #(str_store_string, s1, "str_s1_s2_relation_reg3_last_visit_reg4_days_ago"),
                (str_store_string, s1, "@{s2}: {reg3}, {reg4} days"),

                # create custom listbox entry, set the container first
                (store_mul, ":y_mult", "$num_charinfo_candidates", 16), # adapt y position to entry number, was 18
                (store_add, ":line_y", ":base_candidates_y", ":y_mult"),

                (call_script, "script_overlay_container_add_listbox_item", ":line_y", ":lady"),

                # candidate found, store troop id for later use
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", "$num_charinfo_candidates"),
                (troop_set_slot, "trp_temp_array_c", ":current_storage_index", ":lady"),

                # update entry counter
                (val_add, "$num_charinfo_candidates", 1),
            (try_end),
        ## End courtship relations
        (else_try),
        ## For lord relations
            (eq, ":pres_type", 1),

            # Loop to identify
            (try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
                (troop_set_slot, ":active_npc", slot_troop_temp_slot, 0),
            (try_end),

            (try_for_range, ":unused", active_npcs_begin, active_npcs_end),

                (assign, ":score_to_beat", 101),
                (assign, ":best_relation_remaining_npc", -1),

                (try_for_range, ":active_npc", active_npcs_begin, active_npcs_end),
                        (troop_slot_eq, ":active_npc", slot_troop_temp_slot, 0),
                        (troop_slot_ge, ":active_npc", slot_troop_met, 1),
                        (troop_slot_eq, ":active_npc", slot_troop_occupation, slto_kingdom_hero),

                        (call_script, "script_troop_get_player_relation", ":active_npc"),
                        (assign, ":relation_with_player", reg0),
                        (le, ":relation_with_player", ":score_to_beat"),

                        (assign, ":score_to_beat", ":relation_with_player"),
                        (assign, ":best_relation_remaining_npc", ":active_npc"),
                (try_end),
                (gt, ":best_relation_remaining_npc", -1),

                (str_store_troop_name, s4, ":best_relation_remaining_npc"),
                (assign, reg4, ":score_to_beat"),

                (str_store_string, s1, "@{s4}: {reg4}"),
                (troop_set_slot, ":best_relation_remaining_npc", slot_troop_temp_slot, 1),

                # use faction filter
                (store_troop_faction, ":npc_faction", ":best_relation_remaining_npc"),
                (val_sub, ":npc_faction", kingdoms_begin),
                (this_or_next|eq, "$g_jrider_faction_filter", -1),
                (eq, "$g_jrider_faction_filter", ":npc_faction"),

                # candidate found,
                # create custom listbox entry, set the container first
                (store_mul, ":y_mult", "$num_charinfo_candidates", 16), # adapt y position to entry number, was 18
                (store_add, ":line_y", ":base_candidates_y", ":y_mult"),

                (call_script, "script_overlay_container_add_listbox_item", ":line_y", ":best_relation_remaining_npc"),

                #store troop id for later use (could be merged with the object id)
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", "$num_charinfo_candidates"),
                (troop_set_slot, "trp_temp_array_c", ":current_storage_index", ":best_relation_remaining_npc"),

                # update entry counter
                (val_add, "$num_charinfo_candidates", 1),
            (try_end),
        ## END Lords relations
        (else_try),
        ## Character and Companions
            (eq, ":pres_type", 2),

            # companions
            (try_for_range_backwards, ":companion", companions_begin, companions_end),
                (troop_slot_eq, ":companion", slot_troop_occupation, slto_player_companion),

                (str_store_troop_name, s1, ":companion"),

        (try_begin),
                    (troop_slot_eq, ":companion", slot_troop_current_mission, npc_mission_kingsupport),
                    (str_store_string, s1, "@{s1}(gathering support)"),
                (else_try),
                    (troop_slot_eq, ":companion", slot_troop_current_mission, npc_mission_gather_intel),
                    (str_store_string, s1, "@{s1} (intelligence)" ),
                (else_try),
                    (troop_slot_ge, ":companion", slot_troop_current_mission, npc_mission_peace_request),
                    (neg|troop_slot_eq, ":companion", slot_troop_current_mission, 8),
                    (str_store_string, s1, "@{s1} (ambassy)"),
                (else_try),
                        (eq, ":companion", "$g_player_minister"),
                    (str_store_string, s1, "@{s1} (minister"),
                (else_try),
                    (main_party_has_troop, ":companion"),
                    (str_store_string, s1, "@{s1} (under arms)"),
                (else_try),
                    (troop_slot_eq, ":companion", slot_troop_current_mission, npc_mission_rejoin_when_possible),
                    (str_store_string, s1, "@{s1} (attempting to rejoin)"),
                (else_try),
                    (troop_slot_ge, ":companion", slot_troop_cur_center, 1),
                    (str_store_string, s1, "@{s1} (separated after battle)"),
                (try_end),
                # candidate found,
                # create custom listbox entry, set the container first
                (store_mul, ":y_mult", "$num_charinfo_candidates", 16), # adapt y position to entry number, was 18
                (store_add, ":line_y", ":base_candidates_y", ":y_mult"),

                (call_script, "script_overlay_container_add_listbox_item", ":line_y", ":companion"),

                #store troop id for later use (could be merged with the object id)
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", "$num_charinfo_candidates"),
                (troop_set_slot, "trp_temp_array_c", ":current_storage_index", ":companion"),

                # update entry counter
                (val_add, "$num_charinfo_candidates", 1),
            (try_end),
            # END companions

            # Wife/Betrothed
            # END Wife/Betrothed

            (try_begin),
            # Character
                (str_store_troop_name, s1, "trp_player"),

                # candidate found,
                # create custom listbox entry, set the container first
                (store_mul, ":y_mult", "$num_charinfo_candidates", 16), # adapt y position to entry number, was 18
                (store_add, ":line_y", ":base_candidates_y", ":y_mult"),

                (call_script, "script_overlay_container_add_listbox_item", ":line_y", "trp_player"),

                #store troop id for later use (could be merged with the object id)
                (store_add, ":current_storage_index", "$g_base_character_presentation_storage_index", "$num_charinfo_candidates"),
                (troop_set_slot, "trp_temp_array_c", ":current_storage_index", "trp_player"),

                # update entry counter
                (val_add, "$num_charinfo_candidates", 1),
            (try_end),
            # End Character

        (try_end),
        ## END Character and Companions
    ]),

    # script get_troop_relation_to_player_string
    # return relation to player string in the specified parameters
    #
    ("get_troop_relation_to_player_string",
     [
         (store_script_param, ":target_string", 1),
         (store_script_param, ":troop_no", 2),

         (call_script, "script_troop_get_player_relation", ":troop_no"),
         (assign, ":relation", reg0),
         (str_clear, s61),

         (store_add, ":normalized_relation", ":relation", 100),
         (val_add, ":normalized_relation", 5),
         (store_div, ":str_offset", ":normalized_relation", 10),
         (val_clamp, ":str_offset", 0, 20),
         (store_add, ":str_rel_id", "str_relation_mnus_100_ns",  ":str_offset"),

         ## Make something if troop has relation but not strong enought to warrant a string
         (try_begin),
           (neq, ":str_rel_id", "str_relation_plus_0_ns"),
           (str_store_string, s61, ":str_rel_id"),
         (else_try),
           (neg|eq, reg0, 0),
           (str_is_empty, s61),
           (str_store_string, s61, "@ knows of you."),
         (else_try),
           (eq, reg0, 0),
           (str_is_empty, s61),
           (str_store_string, s61, "@ has no opinion about you."),
         (try_end),

         ## copy result string to target string
         (str_store_string_reg, ":target_string", s61),
     ]),

    # script get_troop_holdings
    # returns number of fief and list name (reg50, s50)
    ("get_troop_holdings",
     [
         (store_script_param, ":troop_no", 1),

         (assign, ":owned_centers", 0),
         (assign, ":num_centers", 0),
         (try_for_range_backwards, ":cur_center", centers_begin, centers_end),
             (party_slot_eq, ":cur_center", slot_town_lord, ":troop_no"),
             (try_begin),
               (eq, ":num_centers", 0),
               (str_store_party_name, s50, ":cur_center"),
               (val_add, ":owned_centers", 1),
             (else_try),
               (eq, ":num_centers", 1),
               (str_store_party_name, s57, ":cur_center"),
               (str_store_string, s50, "@{s57} and {s50}"),
               (val_add, ":owned_centers", 1),
             (else_try),
               (str_store_party_name, s57, ":cur_center"),
               (str_store_string, s50, "@{!}{s57}, {s50}"),
               (val_add, ":owned_centers", 1),
             (try_end),
             (val_add, ":num_centers", 1),
         (try_end),
         (assign, reg50, ":owned_centers"),
     ]),

    # script generate_extended_troop_relation_information_string
    # return information about troop according to type (lord, lady, maiden)
    # Use (hm lots of registers and strings)
    # result stored in s1
    ("generate_extended_troop_relation_information_string",
     [
         (store_script_param, ":troop_no", 1),

         # clear the strings and registers we'll use to prevent external interference
         (str_clear, s1),
         (str_clear, s2),
         (str_clear, s60),
         (str_clear, s42),
         (str_clear, s43),
         (str_clear, s44),
         (str_clear, s45),
         (str_clear, s46),
         (str_clear, s47),
         (str_clear, s48),
         (str_clear, s49),
         (str_clear, s50),
         (assign, reg40,0),
         (assign, reg41,0),
         (assign, reg43,0),
         (assign, reg44,0),
         (assign, reg46,0),
         (assign, reg47,0),
         (assign, reg48,0),
         (assign, reg49,0),
         (assign, reg50,0),
         (assign, reg51,0),

         (try_begin),
             (eq, ":troop_no", "trp_player"),
             (overlay_set_display, "$g_jrider_character_faction_filter", 0),

             # Troop name
             (str_store_troop_name, s1, ":troop_no"),

             # Get renown - slot_troop_renown
             (troop_get_slot, ":renown", ":troop_no", slot_troop_renown),
             (assign, reg40, ":renown"),

             # Controversy - slot_troop_controversy
             (troop_get_slot, ":controversy", ":troop_no", slot_troop_controversy),
             (assign, reg41, ":controversy"),

             # Honor - $player_honor
             (assign, reg42, "$player_honor"),

             # Right to rule - $player_right_to_rule
             (assign, reg43, "$player_right_to_rule"),

             # Current faction
             (store_add, reg45, "$players_kingdom"),
             (try_begin),
                 (is_between, "$players_kingdom", "fac_player_supporters_faction", npc_kingdoms_end),
                 (str_store_faction_name, s45, "$players_kingdom"),
             (else_try),
                 (assign, reg45, 0),
                 (str_store_string, s45, "@Calradia."),
             (try_end),

             # status
             (assign, ":origin_faction", "$players_kingdom"),
             #SB : gender strings
             (try_begin),
                 (is_between, ":origin_faction", npc_kingdoms_begin, npc_kingdoms_end),
                 (str_store_string, s44, "@sworn {man/woman}"),
             (else_try),
                 (eq, ":origin_faction", "fac_player_supporters_faction"),
                 (str_store_string, s44, "@ruler"),
             (else_try),
                 (str_store_string, s44, "@free {man/woman}"),
             (try_end),

             # Current liege and relation
             (faction_get_slot, ":liege", "$players_kingdom", slot_faction_leader),
             (str_store_troop_name, s46, ":liege"),
             (try_begin),
                 (eq, ":liege", ":troop_no"),
                 (assign, reg46, 0),
             (else_try),
                 (assign, reg46, ":liege"),
                 (str_clear, s47),
                 (str_clear, s60),

                 # Relation to liege
                 (call_script, "script_get_troop_relation_to_player_string", s47, ":liege"),
             (end_try),

             # Holdings
             (call_script, "script_get_troop_holdings", ":troop_no"),

             #### Final Storage
             (str_store_string, s1, "@{s1} Renown: {reg40}, Controversy: {reg41}^Honor: {reg42}, Right to rule: {reg43}^\
You are a {s44} of {s45}^{reg45?{reg46?Your liege, {s46},{s47}:You are the ruler of {s45}}:}^^Friends: ^Enemies: ^^Fiefs:^  {reg50?{s50}:no fief}"),
         #######################
         # END Player information
         (else_try),
         #######################
         # Lord information
             (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_kingdom_hero),

             # Troop name
             (str_store_troop_name, s1, ":troop_no"),

             # relation to player
             (str_clear, s2),
             (str_clear, s60),
             (call_script, "script_get_troop_relation_to_player_string", s2, ":troop_no"),

             # Get renown - slot_troop_renown
             (troop_get_slot, ":renown", ":troop_no", slot_troop_renown),
             (assign, reg40, ":renown"),

             # Controversy - slot_troop_controversy
             (troop_get_slot, ":controversy", ":troop_no", slot_troop_controversy),
             (assign, reg41, ":controversy"),

             # Get Reputation type - slot_lord_reputation_type
             (troop_get_slot, ":reputation", ":troop_no", slot_lord_reputation_type),
             (assign, reg42, "str_personality_archetypes"),
             (val_add, reg42, ":reputation"),
             (str_store_string, s42, reg42),

             (assign, reg42, ":reputation"),
             # Intrigue impatience - slot_troop_intrigue_impatience
             (troop_get_slot, ":impatience", ":troop_no", slot_troop_intrigue_impatience),
             (assign, reg43, ":impatience"),

             # Current faction - store_troop_faction
             (store_troop_faction, ":faction", ":troop_no"),
             (troop_get_slot, ":origin_faction", ":troop_no", slot_troop_original_faction),

             # Original faction - slot_troop_original_faction
             (try_begin), #SB : do not display original faction string if same
               (neq, ":faction", ":origin_faction"),
               (val_sub, ":origin_faction", npc_kingdoms_begin),
               (val_add, ":origin_faction", "str_kingdom_1_adjective"),
               (str_store_string, s44, ":origin_faction"),
               (assign, reg44, 1),
             (else_try), #if same, start line with capitalized Noble
               (assign, reg44, 0),
             (try_end), #actually skip this line altogether if ruler
             (str_store_faction_name, s45, ":faction"),

             # Current liege - deduced from current faction
             (faction_get_slot, ":liege", ":faction", slot_faction_leader),
             (try_begin),
               #When a member of a faction without a valid leader
               (lt, ":liege", 0),
               (assign, reg46, ":liege"),
               (str_store_string, s46, "str_noone"),
               (assign, reg47, 0),
             (else_try),
               (str_store_troop_name, s46, ":liege"),
               (try_begin),
                 (eq, ":liege", ":troop_no"),
                 (assign, reg46, 0),
               (else_try),
                 (assign, reg46, ":liege"),
                 # Relation to liege
                 (call_script, "script_troop_get_relation_with_troop", ":troop_no", ":liege"),
                 (assign, reg47, reg0),
               (end_try),
             (try_end),

             # Promised a fief ?
             (troop_get_slot, reg51, ":troop_no", slot_troop_promised_fief),

             # Holdings
             (call_script, "script_get_troop_holdings", ":troop_no"),

              # slot_troop_prisoner_of_party
              (assign, reg48, 0),
              (try_begin),
                (troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0),
                (assign, reg48, 1),
                (troop_get_slot, ":prisoner_party", ":troop_no", slot_troop_prisoner_of_party),
                (store_faction_of_party, ":party_faction", ":prisoner_party"),
                (str_store_faction_name, s48, ":party_faction"),
              (try_end),

              # Days since last meeting
              (store_current_hours, ":hours_since_last_visit"),
              (troop_get_slot, ":last_visit_hour", ":troop_no", slot_troop_last_talk_time),
              (val_sub, ":hours_since_last_visit", ":last_visit_hour"),
              (store_div, reg49, ":hours_since_last_visit", 24),

              #### Final Storage (8 lines)
              (str_store_string, s1, "@{s1}{s2} {reg46?Reputed to be {s42}:}^Renown: {reg40}, Controversy: {reg41} {reg46?Impatience: {reg43}:}^\
{reg46?{reg44?{s44} noble:Noble} of the {s45}^Liege: {s46}, Relation: {reg47}:Ruler of the {s45}}^^{reg48?Currently prisoner of the {s48}:}^\
Days since last meeting: {reg49}^^Fiefs {reg51?(was promised a fief):}:^  {reg50?{s50}:no fief}"),
        ######################
        ## END lord infomation
        (else_try),
        #########################
        # kingdom lady, unmarried
             (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
             (troop_slot_eq, ":troop_no", slot_troop_spouse, -1),

             (str_store_troop_name, s1, ":troop_no"),

             # relation to player
             (str_clear, s2),
             (str_clear, s60),
             (call_script, "script_get_troop_relation_to_player_string", s2, ":troop_no"),

             # Controversy - slot_troop_controversy
             (troop_get_slot, ":controversy", ":troop_no", slot_troop_controversy),
             (assign, reg41, ":controversy"),

             # Reputation type
             (troop_get_slot, ":reputation", ":troop_no", slot_lord_reputation_type),
             (try_begin),
                 (eq, ":reputation", lrep_conventional),
                 (str_store_string, s42, "@conventional"),
             (else_try),
                 (eq, ":reputation", lrep_adventurous),
                 (str_store_string, s42, "@adventurous"),
             (else_try),
                 (eq, ":reputation", lrep_otherworldly),
                 (str_store_string, s42, "@otherwordly"),
             (else_try),
                 (eq, ":reputation", lrep_ambitious),
                 (str_store_string, s42, "@ambitious"),
             (else_try),
                 (eq, ":reputation", lrep_moralist),
                 (str_store_string, s42, "@moralist"),
             (else_try),
                 (assign, reg42, "str_personality_archetypes"),
                 (val_add, reg42, ":reputation"),
                 (str_store_string, s42, reg42),
             (try_end),

             # courtship state - slot_troop_courtship_state
             (troop_get_slot, ":courtship_state", ":troop_no", slot_troop_courtship_state),
             (try_begin),
               (eq, ":courtship_state", 1),
               (str_store_string, s43, "@just met"),
             (else_try),
               (eq, ":courtship_state", 2),
               (str_store_string, s43, "@admirer"),
             (else_try),
               (eq, ":courtship_state", 3),
               (str_store_string, s43, "@promised"),
             (else_try),
               (eq, ":courtship_state", 4),
               (str_store_string, s43, "@breakup"),
             (else_try),
               (str_store_string, s43, "@unknown"),
             (try_end),

             # Current faction - store_troop_faction
             (store_troop_faction, ":faction", ":troop_no"),
             (troop_get_slot, ":origin_faction", ":troop_no", slot_troop_original_faction),

             # Original faction - slot_troop_original_faction
             (try_begin),
               (val_sub, ":origin_faction", npc_kingdoms_begin),
               (val_add, ":origin_faction", "str_kingdom_1_adjective"),
               (str_store_string, s44, ":origin_faction"),
             (end_try),
             (str_store_faction_name, s45, ":faction"),

             # Father/Guardian
             (assign, reg46, 0),
             (try_begin),
                 (troop_slot_ge, ":troop_no", slot_troop_father, 0),
                 (troop_get_slot, ":guardian", ":troop_no", slot_troop_father),
                 (assign, reg46, 1),
             (else_try),
                 (troop_get_slot, ":guardian", ":troop_no", slot_troop_guardian),
             (try_end),
             (str_store_troop_name, s46, ":guardian"),

             # Relation with player
             (str_clear, s47),
             (str_clear, s60),
             (call_script, "script_get_troop_relation_to_player_string", s47, ":guardian"),

             # courtship permission - slot_lord_granted_courtship_permission
             (try_begin),
                 (troop_slot_ge, ":guardian", slot_lord_granted_courtship_permission, 1),
                 (assign, reg45, 1),
             (else_try),
                 (assign, reg45, 0),
             (try_end),

             # betrothed
             (assign, reg48, 0),
             (try_begin),
                 (troop_slot_ge, ":troop_no", slot_troop_betrothed, 0),
                 (troop_get_slot, reg48, ":troop_no", slot_troop_betrothed),
                 (str_store_troop_name, s48, reg48),
                 (assign, reg48, 1),
             (try_end),

             # Days since last meeting
             (store_current_hours, ":hours_since_last_visit"),
             (troop_get_slot, ":last_visit_hour", ":troop_no", slot_troop_last_talk_time),
             (val_sub, ":hours_since_last_visit", ":last_visit_hour"),
             (store_div, reg49, ":hours_since_last_visit", 24),

             # Heard poems
             (assign, reg50, 0),
             (str_clear, s50),

             (try_begin),
                 (troop_slot_eq, ":troop_no", slot_lady_courtship_heroic_recited, 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Heroic {s50}"),
             (try_end),
             (try_begin),
                 (troop_slot_eq, ":troop_no", slot_lady_courtship_allegoric_recited, 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Allegoric {s50}"),
             (try_end),
             (try_begin),
                 (troop_slot_eq, ":troop_no", slot_lady_courtship_comic_recited, 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Comic {s50}"),
             (try_end),
             (try_begin),
                 (troop_slot_eq, ":troop_no", slot_lady_courtship_mystic_recited, 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Mystic {s50}"),
             (try_end),
             (try_begin),
                 (troop_slot_eq, ":troop_no", slot_lady_courtship_tragic_recited, 1),
                 (val_add, reg50, 1),
                 (str_store_string, s50, "@Tragic {s50}"),
             (try_end),

             #### Final Storage (8 lines)
             (str_store_string, s1, "@{s1}{s2} Controversy: {reg41}^Reputation: {s42}, Courtship state: {s43}^\
Belongs to the {s45}^{reg46?Her father, {s46}:Her guardian, {s46}}{s47}^Allowed to visit: {reg45?yes:no} {reg48?Betrothed to {s48}:}^^\
Days since last meeting: {reg49}^^Poems:^  {reg50?{s50}:no poem heard}"),
        #########################
        # END kingdom lady, unmarried
        (else_try),
        #########################
        # companions
            (is_between, ":troop_no", companions_begin, companions_end),
            (overlay_set_display, "$g_jrider_character_faction_filter", 0),

            (str_store_troop_name, s1, ":troop_no"),

            (troop_get_slot, ":reputation", ":troop_no", slot_lord_reputation_type),

            (assign, reg42, "str_personality_archetypes"),
            (val_add, reg42, ":reputation"),
            (str_store_string, s42, reg42),

            # birthplace
            (troop_get_slot, ":home", ":troop_no", slot_troop_home),
            (str_store_party_name, s43, ":home"),

            # contacts town - slot_troop_town_with_contacts
            (troop_get_slot, ":contact_town", ":troop_no", slot_troop_town_with_contacts),
            (str_store_party_name, s44, ":contact_town"),

            # current faction of contact town
            (store_faction_of_party, ":town_faction", ":contact_town"),
            (str_store_faction_name, s45, ":town_faction"),

            # slot_troop_prisoner_of_party
            (assign, reg48, 0),
            (try_begin),
                (troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0),
                (assign, reg48, 1),
                (troop_get_slot, ":prisoner_party", ":troop_no", slot_troop_prisoner_of_party),
                (store_faction_of_party, ":party_faction", ":prisoner_party"),
                (str_store_faction_name, s48, ":party_faction"),
            (try_end),

            # Days since last meeting
            (store_current_hours, ":hours_since_last_visit"),
            (troop_get_slot, ":last_visit_hour", ":troop_no", slot_troop_last_talk_time),
            (val_sub, ":hours_since_last_visit", ":last_visit_hour"),
            (store_div, reg49, ":hours_since_last_visit", 24),

            (try_begin), # Companion gathering support for Right to Rule
                (troop_slot_eq, ":troop_no", slot_troop_current_mission, npc_mission_kingsupport),
                (str_store_string, s50, "@Gathering support"),
            (else_try), # Companion gathering intelligence
                (troop_slot_eq, ":troop_no", slot_troop_current_mission, npc_mission_gather_intel),
                (troop_get_slot, ":contact_town", ":troop_no", slot_troop_town_with_contacts),
                (store_faction_of_party, ":town_faction", ":contact_town"),
                (str_store_faction_name, s66, ":town_faction"),
                (str_store_string, s50, "@Gathering intelligence in the {s66}"),
            (else_try), # Companion on peace mission
                (troop_slot_ge, ":troop_no", slot_troop_current_mission, npc_mission_peace_request),
                (neg|troop_slot_ge, ":troop_no", slot_troop_current_mission, 8),

                (troop_get_slot, ":troop_no", ":troop_no", slot_troop_mission_object),
                (str_store_faction_name, s66, ":faction"),

                (str_store_string, s50, "@Ambassy to {s66}"),
            (else_try), # Companion is serving as minister player has court
                (eq, ":troop_no", "$g_player_minister"),
                (str_store_string, s50, "@Minister"),
            (else_try),
                (str_store_string, s50, "str_dplmc_none"),
        (try_end),

            # days left
            (troop_get_slot, reg50, ":troop_no", slot_troop_days_on_mission),

            #### Final Storage (8 lines)
            (str_store_string, s1, "@{s1}, {s2}^Reputation: {s42}^\
Born at {s43}^Contact in {s44} of the {s45}.^\
^{reg48?Currently prisoner of the {s48}:}^Days since last talked to: {reg49}^^Current mission:^  {s50}{reg50?, back in {reg50} days.:}"),
        #########################
        # END companions
        (try_end),
    ]),

    # Script generate_known_poems_string
    # generate in s1 list of known poems filling with blank lines for unknown ones
    ("generate_known_poems_string",
     [
        # Known poems string
        (assign, ":num_poems", 0),
        (str_store_string, s1, "str_s1__poems_known"),
        (try_begin),
            (gt, "$allegoric_poem_recitations", 0),
            (str_store_string, s1, "str_s1_storming_the_castle_of_love_allegoric"),
            (val_add, ":num_poems", 1),
        (try_end),
        (try_begin),
            (gt, "$tragic_poem_recitations", 0),
            (str_store_string, s1, "str_s1_kais_and_layali_tragic"),
            (val_add, ":num_poems", 1),
        (try_end),
        (try_begin),
            (gt, "$comic_poem_recitations", 0),
            (str_store_string, s1, "str_s1_a_conversation_in_the_garden_comic"),
            (val_add, ":num_poems", 1),
        (try_end),
        (try_begin),
            (gt, "$heroic_poem_recitations", 0),
            (str_store_string, s1, "str_s1_helgered_and_kara_epic"),
            (val_add, ":num_poems", 1),
        (try_end),
        (try_begin),
            (gt, "$mystic_poem_recitations", 0),
            (str_store_string, s1, "str_s1_a_hearts_desire_mystic"),
            (val_add, ":num_poems", 1),
        (try_end),

        # fill blank lines
        (try_for_range, ":num_poems", 5),
            (str_store_string, s1, "@{s1}^"),
        (try_end),
    ]),
   # Jrider -

#"script_dplmc_save_civilian_clothing"
##Save civilian clothing so it will still appear later
#
#INPUT: troop number
#OUTPUT: none
   ("dplmc_save_civilian_clothing", [
     (store_script_param, ":troop_no", 1),
     #SB : this interferes with auto-loot
     (try_begin),
        (gt, ":troop_no", 0),#deliberately exclude player
        (troop_is_hero, ":troop_no"),#only applies to unique characters
        (try_for_range, ":dest_slot", dplmc_ek_alt_items_begin, min(dplmc_ek_alt_items_end, dplmc_ek_alt_items_begin + 4)),
           (store_add, ":source_slot", ":dest_slot", ek_head - dplmc_ek_alt_items_begin),
           (troop_get_inventory_slot, ":item_id", ":troop_no", ":dest_slot"),
           (lt, ":item_id", 1),#do not overwrite an existing item in the destination slot
           (troop_get_inventory_slot, ":item_id", ":troop_no", ":source_slot"),
           (troop_set_inventory_slot, ":troop_no", ":dest_slot", ":item_id"),
        (try_end),
     (try_end),
   ]),
##diplomacy end+

##diplomacy end+

  #Equipment cost fix
   ("player_get_value_of_original_items",
    [
      (store_script_param, ":player_no", 1),
      (store_script_param, ":agent_no", 2),
      (store_script_param, ":troop_id", 3),
      (assign, ":total_equipment_cost", 0),
      (try_for_range, ":i_item_slot", 0, 8),
          (neg|player_item_slot_is_picked_up, ":player_no", ":i_item_slot"),
          (agent_get_item_slot, ":item_id", ":agent_no", ":i_item_slot"), #value between 0-7, order is weapon1, weapon2, weapon3, weapon4, head_armor, body_armor, leg_armor, hand_armor
          #(player_get_item_id, ":item_id", ":player_no", ":i_item_slot"), #only for server
          (neq, ":item_id", -1),
          (call_script, "script_multiplayer_get_item_value_for_troop", ":item_id", ":troop_id"),
          (val_add, ":total_equipment_cost", reg0),

          #Debugging
          #(assign, reg1, ":total_equipment_cost"),
          #(str_store_item_name, s0, ":item_id"),
          #(multiplayer_send_string_to_player, ":player_no", multiplayer_event_show_server_message, "@{s0} for {reg0}g added to total equipment cost, which is now: {reg1}g"),
          ##
      (try_end),
      (try_for_agents, ":cur_horse"),
         #Check all horses in the scene and see if one of them is agent_no's bought horse. Won't be enough to just do (agent_get_horse, ":horse", ":agent_no"),
         #since you get money back for a bought horse, even if you have dismounted it, if the horse is still alive and has no other rider.
         (agent_is_alive, ":cur_horse"),
         (neg|agent_is_human, ":cur_horse"),  #Spawned agent is horse
         (agent_get_slot, ":agent_no_bought_horse", ":agent_no", slot_agent_bought_horse),
         (eq, ":agent_no_bought_horse", ":cur_horse"),
         (assign, ":add_horse_cost_to_equipment_value", 0),
         (try_begin),
             (agent_get_rider, ":rider_agent_id", ":cur_horse"),
             (try_begin),
                 (neq, ":rider_agent_id", -1),
                 (neg|agent_is_non_player, ":rider_agent_id"),
                 (agent_get_slot, ":agent_no_bought_horse", ":rider_agent_id", slot_agent_bought_horse),
                 (eq, ":agent_no_bought_horse", ":cur_horse"), #agent_no is mounted on the same horse he bought
                 (assign, ":add_horse_cost_to_equipment_value", 1),

                 #Debugging
                 #(agent_get_item_id, ":mount_type", ":cur_horse"), #(works only for horses, returns -1 otherwise)
                 #(str_store_item_name, s0, ":mount_type"),
                 #(multiplayer_send_string_to_player, ":player_no", multiplayer_event_show_server_message, "@You are mounted on your bought {s0} and will get money for it"),
                 ##
             (else_try),
                 (eq, ":rider_agent_id", -1), #If cur_horse doesn't have a rider
                 (agent_get_horse, ":agent_no_mount", ":agent_no"),
                 (eq, ":agent_no_mount", -1), #If agent_no is not mounted on another horse
                 (agent_get_slot, ":agent_no_bought_horse", ":agent_no", slot_agent_bought_horse),
                 (eq, ":agent_no_bought_horse", ":cur_horse"),
                 (assign, ":add_horse_cost_to_equipment_value", 1),

                 #Debugging
                 #(agent_get_item_id, ":mount_type", ":cur_horse"), #(works only for horses, returns -1 otherwise)
                 #(str_store_item_name, s0, ":mount_type"),
                 #(multiplayer_send_string_to_player, ":player_no", multiplayer_event_show_server_message, "@Your bought {s0} is alive so you get money for it"),
                 ##
            (try_end),
            (eq, ":add_horse_cost_to_equipment_value", 1),
            (agent_get_item_id, ":cur_mount_type", ":cur_horse"), #Checks which type the horse is
            (call_script, "script_multiplayer_get_item_value_for_troop", ":cur_mount_type", ":troop_id"),
            (val_add, ":total_equipment_cost", reg0),
            (multiplayer_send_string_to_player, ":player_no", multiplayer_event_show_server_message, "@Added money for your old horse"),
         (try_end),
      (try_end),
      (agent_set_slot, ":agent_no", slot_agent_bought_horse, -1),
      (assign, reg0, ":total_equipment_cost"),
     ]),
     ###

     ##script_improve_center
     #helper script for building in centers
    ("improve_center", [
        (store_script_param, ":center_no", 1),
        (store_script_param, ":builder", 2),
        (store_script_param, ":improvement_time", 3),
        (party_set_slot, ":center_no", slot_center_current_improvement, "$g_improvement_type"),
        (store_current_hours, ":cur_hours"),
        (store_mul, ":hours_takes", ":improvement_time", 24),
        (val_add, ":hours_takes", ":cur_hours"),
        (party_set_slot, ":center_no", slot_center_improvement_end_hour, ":hours_takes"),
        (assign, reg6, ":improvement_time"),
        (call_script, "script_get_improvement_details", "$g_improvement_type"),
        (add_party_note_from_sreg, ":center_no", 2, "@A {s0} is being built. It will finish in {reg6} days", 1),
        (try_begin), #should probably raise this depending on project instead of constant reward
          (troop_is_hero, ":builder"),
          (neq, ":builder", "trp_player"),
          (call_script, "script_change_troop_renown", ":builder", dplmc_companion_skill_renown),
        (try_end),
    ]),

     ##script_calculate_improvement_limit
     #calculate threshold for building stuff
     #input: troop_no, center_no (unused)
     #output: reg0
    ("calculate_improvement_limit", [
        (store_script_param_1, ":troop_no"),
        (store_script_param_2, ":center_no"),
        (assign, ":limit", dplmc_improvement_limit),
        (troop_get_slot, ":personality", ":troop_no", slot_lord_reputation_type),
        (try_begin), #bad personality, unlikely to ever build property
            (is_between, ":personality", lrep_selfrighteous, lrep_goodnatured),
            (val_mul, ":limit", ":personality"),
            (val_div, ":limit", 2),
        (else_try), #include companion personality types
            (is_between, ":personality", lrep_goodnatured, lrep_custodian),
            (try_begin), #exception
              (neq, ":personality", lrep_roguish),
              (store_mul, ":level", ":personality", 250),
              (val_sub, ":limit", ":level"),
            (try_end),
        (try_end),
        (assign, reg0, ":limit"),
    ]),

     ##script_calculate_equipment_limit
     #calculate threshold for upgrading equipment imod from merchants
     #input: troop_no, center_no (unused)
     #output: reg0
    ("calculate_equipment_limit", [
        (store_script_param_1, ":troop_no"),
        (store_script_param_2, ":center_no"),
        (assign, ":limit", dplmc_equipment_limit),
        (troop_get_slot, ":personality", ":troop_no", slot_lord_reputation_type),

        (try_begin), #focus on arms
          (is_between, ":personality", lrep_martial, lrep_selfrighteous),
          (val_div, ":limit", 2),
        (else_try), #invest in gear not fief
          (eq, ":personality", lrep_roguish),
          (val_sub, ":limit", 1000),
        (try_end),

        #aristocracy modifier as enthusiasm for shopping
        (store_faction_of_party, ":faction_no", ":center_no"),
        (faction_get_slot, ":aristocracy", ":faction_no", dplmc_slot_faction_aristocracy),
        (val_mul, ":aristocracy", -100), #high plutocracy more shopping, decreasing threshold
        (val_add, ":limit", ":aristocracy"),

        (assign, reg0, ":limit"),
    ]),
    #script_change_troop_intrigue_impatience
    #inputs: troop_no ($g_talk_troop), amount
    #output: slot_troop_intrigue_impatience changed
    ("change_troop_intrigue_impatience", [
        (store_script_param_1, ":troop_no"),
        (store_script_param_2, ":amount"),
        (troop_get_slot, ":impatience", ":troop_no", slot_troop_intrigue_impatience),
        (val_max, ":impatience", ":amount"),
        (troop_set_slot, ":troop_no", slot_troop_intrigue_impatience, ":impatience"),
    ]),
    #script_center_get_bandits
    #inputs: center_no, mode
    #output: bandit_troop in reg0
    # get an appropriate bandit to infest the village
  ("center_get_bandits",[

    (store_script_param_1, ":village_no"),
    (store_script_param_2, ":mode"),
    (assign, ":bandit_troop", "trp_looter"),

    (try_begin), #native mode
      (eq, ":mode", -1),
      (store_random_in_range, ":random_no", 0, 3),
      (try_begin),
        (eq, ":random_no", 0),
        (assign, ":bandit_troop", "trp_bandit"),
      (else_try),
        (eq, ":random_no", 1),
        (assign, ":bandit_troop", "trp_mountain_bandit"),
      (else_try),
        (assign, ":bandit_troop", "trp_forest_bandit"),
      (try_end),
    (else_try), #faction mode
      (eq, ":mode", 0),

      (assign, ":bandit_troop", "trp_looter"),
      # (store_faction_of_party, ":faction", ":village_no"),
      (party_get_slot, ":faction", ":village_no", slot_center_original_faction),
      (store_random_in_range, ":random_no", 0, 10),
      (try_begin), #deserter troops, 10% chance
        (eq, ":random_no", 0),
        (faction_get_slot, ":bandit_troop", ":faction", slot_faction_deserter_troop),
      (else_try),
        (lt, ":random_no", 6),  #regular bandits (looter to brigand), 50%
        (val_div, ":random_no", 2),
        (store_add, ":bandit_troop","trp_looter",":random_no"),
      (else_try), #regional bandits, 40% (should be terrain based though)
        (try_begin),
          (eq, ":faction", "fac_kingdom_6"),
          (assign, ":bandit_troop", "trp_desert_bandit"),
        (else_try),
          (eq, ":faction", "fac_kingdom_5"),
          (assign, ":bandit_troop", "trp_mountain_bandit"),
        (else_try),
          (eq, ":faction", "fac_kingdom_4"),
          (assign, ":bandit_troop", "trp_sea_raider"),
        (else_try),
          (eq, ":faction", "fac_kingdom_3"),
		  (try_begin),
			(lt, ":random_no", 3),
			(assign, ":bandit_troop", "trp_black_khergit_horseman"), # dckplmc - 20% chance of black khergits
		  (else_try),
			(assign, ":bandit_troop", "trp_steppe_bandit"),
		  (try_end),
        (else_try),
          (eq, ":faction", "fac_kingdom_2"),
          (assign, ":bandit_troop", "trp_taiga_bandit"),
        (else_try),
          (eq, ":faction", "fac_kingdom_1"),
          (assign, ":bandit_troop", "trp_forest_bandit"),
        (try_end),
      (try_end),
    (else_try), #terrain mode
      (eq, ":mode", 1),
      #base type first
      (party_get_current_terrain, ":terrain_type", ":village_no"),
      (try_begin),
        (this_or_next|eq, ":terrain_type", rt_steppe),
        (eq, ":terrain_type", rt_steppe_forest),
		(store_random_in_range, ":random_no", 0, 10),
	    (try_begin),
		  (lt, ":random_no", 3),
		  (assign, ":bandit_troop", "trp_black_khergit_horseman"), # dckplmc - 20% chance of black khergits
	    (else_try),
		  (assign, ":bandit_troop", "trp_steppe_bandit"),
	    (try_end),
      # (else_try),
        # (eq, ":terrain_type", rt_plain),
        # (assign, ":bandit_troop", "trp_bandit"),
      (else_try),
        (this_or_next|eq, ":terrain_type", rt_snow),
        (eq, ":terrain_type", rt_snow_forest),
        (assign, ":bandit_troop", "trp_taiga_bandit"),
      (else_try),
        (this_or_next|eq, ":terrain_type", rt_desert),
        (eq, ":terrain_type", rt_desert_forest),
        (assign, ":bandit_troop", "trp_desert_bandit"),
      # (else_try),
        # (eq, ":terrain_type", rt_forest),
        # (assign, ":bandit_troop", "trp_forest_bandit"),
      (try_end),
      (try_begin),
        (eq, ":bandit_troop", "trp_looter"), #still not picked
        #proximity to features (forest, mountain, ocean),
        (party_get_position, pos1, ":village_no"),
        (try_begin), #cf operation to see if it's near water
          (map_get_water_position_around_position, pos2, pos1, 5),
          # after finding water limit range of spawning (so sea raiders don't appear upriver)
          (store_add, ":limit", "p_sea_raider_spawn_point_1", num_sea_raider_spawn_points),
          (try_for_range, ":spawn_point", "p_sea_raider_spawn_point_1", ":limit"),
            (store_distance_to_party_from_party, ":distance", ":village_no", ":spawn_point"),
            (lt, ":distance", 50), # 200% bandit spawning radius
            (assign, ":limit", -1),
          (try_end),
          (eq, ":limit", -1), #within boundaries
          (assign, ":bandit_troop", "trp_sea_raider"),
        (else_try), #sample random points until we find forest/mountain (coast)
          (assign, ":forest_count", 0),
          (assign, ":mountain_count", 0),
          (assign, ":other_count", 0),
          (try_for_range, ":unused", 0, 100),
            (map_get_land_position_around_position, pos2, pos1, 5),
            (party_set_position, "p_temp_party", pos2),
            (party_get_current_terrain, ":terrain_type", "p_temp_party"),
            (try_begin),
              (eq, ":terrain_type", rt_forest),
              (val_add, ":forest_count", 1),
            (else_try),
              (eq, ":terrain_type", rt_mountain),
              (val_add, ":mountain_count", 1),
            (else_try),
              (val_add, ":other_count", 1),
            (try_end),
          (try_end),
          (try_begin), # not enough features
            (gt, ":other_count", 75), #pass through to faction calls
            (call_script, "script_center_get_bandits", ":village_no", 0),
            (assign, ":bandit_troop", reg0),
          (else_try),
            (gt, ":forest_count", ":mountain_count"),
            (gt, ":forest_count", 15),
            (assign, ":bandit_troop", "trp_forest_bandit"),
          (else_try),
            (gt, ":mountain_count", ":forest_count"),
            (gt, ":mountain_count", 15),
            (assign, ":bandit_troop", "trp_mountain_bandit"),
          (try_end),
        (try_end),
      (try_end),
    (try_end),
    (assign, reg0, ":bandit_troop"),
  ]),


  ("create_wpn_slot_overlay", [
      (store_script_param, ":slot", 1),
      (store_script_param, ":pos", 2),
      (init_position, pos1),
      (position_set_x, pos1, 270),
      (position_set_y, pos1, ":pos"),
      (create_combo_button_overlay, ":obj"),
      (overlay_set_position, ":obj", pos1),
      (assign, ":sub_overlay_id", 0),
      (store_add, ":upgrade_slot", ":slot", dplmc_slot_upgrade_wpn_0),

      # #SB : add meta-types
      # (overlay_add_item, ":obj", "str_dplmc_hero_wpn_slot_pikes"),
      # (overlay_add_item, ":obj", "str_dplmc_hero_wpn_slot_lance"),
      # (overlay_add_item, ":obj", "str_dplmc_hero_wpn_slot_morningstar"),
      # (try_for_range_backwards, ":item_type", dplmc_itp_morningstar, dplmc_itp_pike + 1),
        # (troop_slot_eq, "$temp", ":upgrade_slot", ":item_type"),
        # (overlay_set_val, ":obj", ":sub_overlay_id"),
      # (else_try),
        # (val_add, ":sub_overlay_id", 1),
      # (try_end),
      (call_script, "script_dplmc_get_current_item_for_autoloot", ":slot"), #goes to "keep current", s10
      (try_for_range_backwards, ":item_type", 0, itp_type_animal),
        (this_or_next|is_between, ":item_type", itp_type_one_handed_wpn, itp_type_goods),
        (this_or_next|is_between, ":item_type", itp_type_pistol, itp_type_animal),
        (eq, ":item_type", 0),
        (store_add, ":out_string", "str_dplmc_hero_wpn_slot_none", ":item_type"),
        (overlay_add_item, ":obj", ":out_string"),
        (try_begin), #find base type
          (troop_get_slot, ":cur_value", "$temp", ":upgrade_slot"),
          (val_mod, ":cur_value", meta_itp_mask),
          (eq, ":cur_value", ":item_type"),
          (overlay_set_val, ":obj", ":sub_overlay_id"),
        (try_end),
        (val_add, ":sub_overlay_id", 1),
      (try_end),

      #store id in slot
      (troop_set_slot, "trp_stack_selection_ids", ":slot", ":obj"),
      # # only works for original button, not drop-down lists
      # (overlay_set_additional_render_height, ":obj", 99),

      (assign, reg1, ":obj"), #return overlay id
  ]),


  ("update_wpn_slot_itp", [
      (store_script_param, ":slot", 1),
      (store_script_param, ":value", 2),
      (troop_get_slot, ":item_type", "trp_temp_array_c", ":value"),
      (troop_get_slot, ":slot_value", "$temp", ":slot"),
      (try_begin), #if new value supports metamods, inherit
        (call_script, "script_cf_item_type_has_advanced_autoloot", ":item_type"),
        (store_mod, ":original_value", ":slot_value", meta_itp_mask),
        (val_sub, ":slot_value", ":original_value"), #remove original itp
        (val_add, ":slot_value", ":item_type"), #add new
      (else_try), #otherwise replace value
        (assign, ":slot_value", ":item_type"),
      (try_end),
      (troop_set_slot, "$temp", ":slot", ":slot_value"),
      (assign, "$temp_2", ":slot"),
      #restart presentation instead of updating overlay value (because we can't)
      (start_presentation, "prsnt_dplmc_autoloot_upgrade_management"),
  ]),
  #script_item_get_type_aux : auxiliary item classification script, see header_items for values
  #input : item
  #output: reg0, item type or meta-type
  ("item_get_type_aux", [
    (store_script_param, ":item", 1),

    (item_get_type, ":itp", ":item"),
    (try_begin),
      # (item_slot_eq, ":item", dplmc_slot_two_handed_one_handed, 1),
      # (item_has_property, ":item", itp_type_two_handed_wpn),
      (eq, ":itp", itp_type_two_handed_wpn),
      (neg|item_has_property, ":item", itp_two_handed),
      (assign, ":itp", dplmc_itp_morningstar), # type 11 = two-handed/one-handed
    (else_try),
      (eq, ":itp", itp_type_polearm),
      (item_get_swing_damage, ":swing", ":item"),
      (item_get_thrust_damage, ":thrust", ":item"),
      (try_begin),
        (ge, ":swing", ":thrust"),
        (item_get_swing_damage_type, ":damage_type", ":item"),
        (eq, ":damage_type", cut),
        (assign, ":itp", dplmc_itp_halberd),
      (else_try),
        (lt, ":swing", ":thrust"),
        (try_begin), #lances
          (item_has_property, ":item", itp_couchable),
          (assign, ":itp", dplmc_itp_lance),
        (else_try), #can't be both lance and pike
          # (item_has_property, ":item", itp_cant_use_on_horseback), #too restrictive
          (item_get_weapon_length, ":length", ":item"),
          (ge, ":length", dplmc_pike_length_cutoff), #arbitrary value to allow awlpikes to fall in range
          (item_has_capability, ":item", itcf_thrust_polearm), #has two-handed thrust
          (this_or_next|item_has_property, ":item", itp_two_handed),
          (item_has_property, ":item", itp_penalty_with_shield),
          (assign, ":itp", dplmc_itp_pike),
        (try_end),
      (try_end),
    (try_end),
    (assign, reg0, ":itp"),
  ]),

  #check if weapons are wholly inappropriate for actual combat
  ("cf_melee_weapon_is_civilian", [
    (store_script_param, ":item", 1),
    (this_or_next|is_between, ":item", "itm_sickle", "itm_dagger"),
    (this_or_next|is_between, ":item", "itm_scythe", "itm_military_fork"),
    (this_or_next|eq, ":item", "itm_wooden_stick"),
    (eq, ":item", "itm_torch"),
    # (eq, ":item", "itm_stones"),
     #include arena weapons here as well
  ]),

  #check if the item type has advanced auto-loot options available (damage type, meta-type)
  ("cf_item_type_has_advanced_autoloot", [
    (store_script_param, ":item_type", 1),
    (this_or_next|is_between, ":item_type", itp_type_one_handed_wpn, itp_type_shield),
    (eq, ":item_type", itp_type_thrown), #throwing axe vs jaridss vs rocks
    #all other ranged weapons are pierce (for now) excluding arena ones
  ]),

  #script_display_policy_string_to_reg
  #unify string register usage to one temp s0 and one output s20
  #register reg2,3 are used for mode and postfix
  ("display_policy_string_to_reg", [
    (store_script_param, ":faction_no", 1),
    (store_script_param, reg2, 2), #whether it is third person "the" or first person "our"
    (store_script_param, reg3, 3), #spaces or line breaks as the postfix delimiter

    (str_store_faction_name_link, s5, ":faction_no"),
    (assign, ":string", "str_dplmc_neither_centralize_nor_decentralized"),
    (faction_get_slot, ":centralization", ":faction_no", dplmc_slot_faction_centralization),
    (val_add, ":string", ":centralization"),
    (str_store_string, s0, ":string"),
    (str_store_string, s20, "@{s20}{reg2?Our government:The goverment of the {s5}} is {s0}.{reg3?^: }"),

    (assign, ":string", "str_dplmc_neither_aristocratic_nor_plutocratic"),
    (faction_get_slot, ":aristocraty", ":faction_no", dplmc_slot_faction_aristocracy),
    (val_add, ":string", ":aristocraty"),
    (str_store_string, s0, ":string"),
    (str_store_string, s20, "@{s20}The upper class society is {s0}.{reg3?^: }"),

    (assign, ":string", "str_dplmc_mixture_serfs"),
    (faction_get_slot, ":serfdom", ":faction_no", dplmc_slot_faction_serfdom),
    (val_add, ":string", ":serfdom"),
    (str_store_string, s0, ":string"),
    (str_store_string, s20, "@{s20}{reg2?Our:The} people are {s0}.{reg3?^: }"),

    (assign, ":string", "str_dplmc_mediocre_quality"),
    (faction_get_slot, ":quality", ":faction_no", dplmc_slot_faction_quality),
    (val_add, ":string", ":quality"),
    (str_store_string, s0, ":string"),
    (str_store_string, s20, "@{s20}{reg2?Our:The} troops have {s0}.{reg3?^: }"),

    ##nested diplomacy start+ add mercantilism
    (assign, ":string", "str_dplmc_neither_mercantilist_nor_laissez_faire"),
    (faction_get_slot, ":mercantilism", ":faction_no", dplmc_slot_faction_mercantilism),
    (val_add, ":string", ":mercantilism"),
    (str_store_string, s0, ":string"),
    (str_store_string, s20, "@{s20}{reg2?Our:The government's} approach to trade is {s0}.{reg3?^: }"),
  ]),

  #native stuff for startup merchants
  ("get_troop_of_merchant",
  [
        (store_faction_of_party, ":starting_town_faction", "$g_starting_town"),
        (store_sub, ":troop_of_merchant", ":starting_town_faction", npc_kingdoms_begin),
        (val_add, ":troop_of_merchant", startup_merchants_begin),
        (assign, reg0, ":troop_of_merchant"),
  ]),

  #reusable code to check whether npcs in a specific range have been met
  #does not account for alternative towns
  ("cf_no_known_taverngoers",
  [
      (store_script_param_1, ":begin"),
      (store_script_param_2, ":end"),
      # (assign, ":num_towns", tavern_booksellers_end),
      (try_for_range, ":troop_no", ":begin", ":end"),
        # (neg|party_slot_eq, ":town_no", slot_center_tavern_bookseller, 0),
        # (party_get_slot, ":seller", ":town_no", slot_center_tavern_bookseller),#addition - fixed 2011-03-29
        (troop_slot_ge, ":troop_no", slot_troop_met, 1),
        (troop_get_slot, ":town_no", ":troop_no", slot_troop_cur_center),
        (is_between, ":town_no", walled_centers_begin, walled_centers_end),
        (assign, ":end", ":begin"), #loop break
      (try_end),
      (neq, ":begin", ":end"),
  ]),

  #script_list_known_taverngoers
  #input: starting/ending troop range, also party slot if necessary as error check
  #output: location of known tavern npcs to s11
  ("list_known_taverngoers",
  [
      (store_script_param, ":begin", 1),
      (store_script_param, ":end", 2),
      (store_script_param, ":slot_no", 3),

      (assign, ":num_towns", 0),
      (try_for_range, ":troop_no", ":begin", ":end"),
        (this_or_next|troop_slot_ge, ":troop_no", slot_troop_met, 1),
        (troop_slot_eq, ":troop_no", slot_troop_cur_center, "$current_town"),
        (troop_get_slot, ":town_no", ":troop_no", slot_troop_cur_center),
        (is_between, ":town_no", walled_centers_begin, walled_centers_end),
        # (neg|party_slot_eq, ":town_no", slot_center_ransom_broker, 0),
        (party_slot_eq, ":town_no", ":slot_no", ":troop_no"),
        (val_add, ":num_towns", 1),
        (str_store_party_name_link, s50, ":town_no"),
        (try_begin),
          (eq, ":num_towns", 1),
          (str_store_string, s51, s50),
        (else_try),
          (eq, ":num_towns", 2),
          (str_store_string, s51, "str_s50_and_s51"),
        (else_try),
          (str_store_string, s51, "str_s50_comma_s51"),
        (try_end),

        (try_begin), #list false tavern npcs
          (call_script, "script_cf_find_alternative_town_for_taverngoers", ":town_no", -9),
          (assign, ":alternative_town", reg0),
          (neg|party_slot_ge, ":alternative_town", ":slot_no", ":begin"),
          (val_add, ":num_towns", 1),
          (str_store_party_name_link, s52, ":alternative_town"),
          (try_begin), #this is at least the second town in the string
            (eq, ":num_towns", 2),
            (str_store_string, s51, "str_s52_and_s51"),
          (else_try),
            (str_store_string, s51, "str_s52_comma_s51"),
          (try_end),
        (try_end),
        # (display_message, "@{s51}"),
      (try_end),
      (str_store_troop_name_plural, s10, ":begin"), #default titles "book_merchant" "ransom_broker" etc
      (str_store_string_reg, s11, s51),
      (display_message, "@You can find {s10}s at {s11}."),
  ]),
  #native functionality to increase tavern diversity
  ("cf_find_alternative_town_for_taverngoers",
  [
      (store_script_param_1, ":town_no"),
      (store_script_param_2, ":adder"),
      (store_add, ":alternative_town", ":town_no", ":adder"), #should really randomize this

      # (store_sub, ":num_towns", towns_end, towns_begin),
      (try_begin),
        (ge, ":alternative_town", towns_end),
        (val_sub, ":alternative_town", towns_end),
        (val_add, ":alternative_town", towns_begin),
      (else_try),
        (lt, ":alternative_town", towns_begin),
        (val_add, ":alternative_town", towns_end),
      (try_end),
      ##diplomacy start+
      #The above code makes assumptions about the number of towns that might not be true on other maps.
      #Changing it to support variable sizes would not be hard, but I'm not convinced that it is so
      #desirable in the first place.
      (is_between, ":alternative_town", towns_begin, towns_end),
      # (party_slot_eq, ":alternative_town", slot_party_type, spt_town),
      (assign, reg0, ":alternative_town"),
  ]),

  #script_calculate_ransom_contribution
  #input : troop_no, amount expected, properly set up qst_rescue_prisoner targets
  #assumes no other sources of debt (dialog prevents condition) and quest troop is active and related
  #output : amount lord_no personally pays in reg0, cached in slot_troop_player_debt, cleared when player rejects it
  ("calculate_ransom_contribution", [
    (store_script_param_1, ":lord_no"), #usually $g_talk_troop
    (store_script_param_2, ":ransom_size"), #2000 from quest giver, up to 125*strength for other relatives
    #because kingdom ladies aren't landholders, they give it without consequence of debt if quest fails (also less dialogue to write)
    (assign, ":ransom_amount", 0),

    (try_begin),
      (check_quest_active, "qst_rescue_prisoner"),
      (quest_get_slot, ":prisoner", "qst_rescue_prisoner", slot_quest_target_troop),
      (quest_get_slot, ":cur_ransom", "qst_rescue_prisoner", slot_quest_target_state),
      (try_begin),
        #each +-2 relation has 1% effect on calculation to the effect of 50%/150% initial value
        (call_script, "script_troop_get_relation_with_troop", ":lord_no", ":prisoner"),
        (store_div, ":relation", reg0, 2),
        (val_add, ":relation", 100),
        (val_mul, ":ransom_amount", ":relation"),
        (val_div, ":ransom_amount", 100),
      (try_end),
      # problem is this script has variance in output, we can use the cached slot_quest_target_amount
      (call_script, "script_calculate_ransom_amount_for_troop", ":prisoner"),
      (assign, ":ransom", reg0), #original amount
      (val_add, ":ransom_size", ":cur_ransom"),
      (try_begin), #contributed too much, get remainder before arbitrary cap
        (gt, ":ransom_size", ":ransom"),
        (store_sub, ":ransom_amount", ":ransom", ":cur_ransom"),
      (else_try), #give full amount
        (store_sub, ":ransom_amount", ":ransom_size", ":cur_ransom"), #undo adding existing ransom
      (try_end),

      (try_begin), #active npcs have wealth
        (troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
        (troop_get_slot, ":cur_wealth", ":lord_no", slot_troop_wealth),
        (val_div, ":cur_wealth", 2), #at most half for contributing
        (val_min, ":cur_wealth", ":ransom"),
        (val_min, ":ransom_amount", ":cur_wealth"), #actual amount the lord can give
      (try_end),
      (troop_set_slot, ":lord_no", slot_troop_player_debt, ":ransom_amount"),
    (try_end),
    (assign, reg0, ":ransom_amount"),
    ]
  ),

  #script_lend_money_for_ransom
  #actually parcels out the amount calculated in the above script
  ("lend_money_for_ransom", [
    (store_script_param_1, ":lord_no"), #usually $g_talk_troop
    (try_begin),
      (troop_get_slot, ":ransom_amount", ":lord_no", slot_troop_player_debt),
      (le, ":ransom_amount", 0),
      (store_script_param_2, ":ransom_amount"),
    (try_end),
    (quest_get_slot, ":cur_ransom", "qst_rescue_prisoner", slot_quest_target_state),
    (val_add, ":cur_ransom", ":ransom_amount"), #actual amount to give

    #set up quests
    (quest_set_slot, "qst_rescue_prisoner", slot_quest_target_state, ":cur_ransom"),
    (assign, reg0, ":cur_ransom"),
    #the amount calculated at the start, will differ from expected ransom
    (quest_get_slot, reg1, "qst_rescue_prisoner", slot_quest_target_amount),
    (str_store_string, s1, "@You have raised {reg0}/{reg1} denars for the ransom"),
    (add_quest_note_from_sreg, "qst_rescue_prisoner", 4, s1, 1), #0:date, 1:giver, 2:desc 3:time

    #move actual gold
    (troop_add_gold, "trp_player", ":ransom_amount"),
    (try_begin),
      (troop_slot_eq, ":lord_no", slot_troop_occupation, slto_kingdom_hero),
      (call_script, "script_dplmc_remove_gold_from_lord_and_holdings", ":ransom_amount", ":lord_no"),
      (val_add, ":ransom_amount", dplmc_ransom_debt_mask), #masking this from "real" debt
      (troop_set_slot, ":lord_no", slot_troop_player_debt, ":ransom_amount"),
    (try_end),

    ]
  ),


  #script_cf_dplmc_battle_continuation
  #new camera setup scripts, setting up other calls

  ("cf_dplmc_battle_continuation", [
    (eq, "$g_dplmc_battle_continuation", 0),
    (assign, ":num_allies", 0),
    (try_for_agents, ":agent"),
      (agent_is_ally, ":agent"),
      (agent_is_alive, ":agent"),
      (val_add, ":num_allies", 1),
    (try_end),
    (gt, ":num_allies", 0),
    (try_begin),
      (eq, "$g_dplmc_cam_activated", 0),
      #(store_mission_timer_a, "$g_dplmc_main_hero_fallen_seconds"),
      (assign, "$g_dplmc_cam_activated", "$g_dplmc_cam_default"),

      (display_message, "@You have been knocked out by the enemy. Watch your men continue the fight without you or press Tab to retreat."),
      (store_add, ":string", "$g_dplmc_cam_activated", "str_camera_keyboard"),
      (val_sub, ":string", 1),
      (display_message, ":string"),
      # (display_message, "@To watch the fight you can use 'w, a, s, d, numpad_+/numpad_-' to move and 'numpad_1,2,3,4,6,8' to rotate the cam."),

      (try_begin), #http://forums.taleworlds.com/index.php/topic,322343.0.html
        (eq, "$g_dplmc_charge_when_dead", 1),
        (get_player_agent_no, ":player_agent"),
        (agent_get_team, ":player_team", ":player_agent"),
        (set_show_messages, 0),
        (team_give_order, ":player_team", grc_everyone, mordr_charge),
        (team_give_order, ":player_team", grc_everyone, mordr_use_any_weapon),
        (team_give_order, ":player_team", grc_everyone, mordr_fire_at_will),
        (set_show_messages, 1),
      (try_end),

      (mission_cam_get_position, pos1), #Death pos
      (position_get_rotation_around_z, ":rot_z", pos1),

      (init_position, pos47),
      (position_copy_origin, pos47, pos1), #Copy X,Y,Z pos
      (position_rotate_z, pos47, ":rot_z"), #Copying X-Rotation is likely possible, but I haven't figured it out yet

      (mission_cam_set_mode, 1, 0, 0), #Manual?

      (try_begin), #auto-assign the closest agent
        (eq, "$g_dplmc_cam_activated", camera_follow),
        (call_script, "script_dmod_closest_agent"),
      (try_end),

      (mission_cam_set_position, pos47),
    (try_end),
    ]),

    ("init_keys_array", keys_array()),
    ("setup_camera_keys", [

      # (assign, "$g_dplmc_cam_default", camera_keyboard),
      # (assign, "$g_camera_up", key_w),
      # (assign, "$g_camera_down", key_s),
      # (assign, "$g_camera_left", key_a),
      # (assign, "$g_camera_right", key_d),

      #default custom commander y/z offsets
      (call_script, "script_setup_camera_offset"),
      #these will be retained after being changed inside missions

      #deathcam
      (assign, "$g_cam_tilt_left", key_numpad_1),
      (assign, "$g_cam_tilt_right", key_numpad_3),

      (assign, "$g_camera_adjust_add", key_numpad_plus),
      (assign, "$g_camera_adjust_sub", key_numpad_minus),

      #normally numpad swaps equipment, but we're dead so w/e
      (assign, "$g_camera_rot_up", key_numpad_8),
      (assign, "$g_camera_rot_down", key_numpad_2),
      (assign, "$g_camera_rot_left", key_numpad_4),
      (assign, "$g_camera_rot_right", key_numpad_6),
    ]),

    #call when camera positions get weird
    ("setup_camera_offset",
      [
      (assign, "$g_camera_z", 200),
      (assign, "$g_camera_y", -175),
      (assign, "$g_camera_rotate_x", 0),
      (assign, "$g_camera_rotate_y", 0),
      (assign, "$g_camera_rotate_z", 0),

      ]),

    #initialize all active death cam globals
    ("init_death_cam",
      [
        (assign, "$deathcam_mouse_last_x", 5000),
        (assign, "$deathcam_mouse_last_y", 3750),
        (assign, "$deathcam_mouse_last_notmoved_x", 5000),
        (assign, "$deathcam_mouse_last_notmoved_y", 3750),
        (assign, "$deathcam_mouse_notmoved_x", 5000), #Center screen (10k fixed pos)
        (assign, "$deathcam_mouse_notmoved_y", 3750),
        (assign, "$deathcam_mouse_notmoved_counter", 0),

        (assign, "$deathcam_total_rotx", 0),

        (assign, "$deathcam_sensitivity_x", 200), #4:3 ratio may be best
        (assign, "$deathcam_sensitivity_y", 150), #If modified, change values in common_move_deathcam

        (assign, "$deathcam_prsnt_was_active", 0),

        (assign, "$deathcam_keyboard_rotation_x", 0),
        (assign, "$deathcam_keyboard_rotation_y", 0),

        (assign, "$g_dplmc_cam_activated", 0),
        (assign, "$dmod_current_agent", -1),
        # check if keys are not set/invalid
        (try_begin),
          (neg|is_between, "$g_dplmc_cam_default", camera_keyboard, camera_follow + 1),
          (call_script, "script_setup_camera_keys"),
          (assign, "$g_dplmc_cam_default", camera_keyboard),
        (try_end),

        (get_player_agent_no, "$g_player_agent"),
        (agent_get_team, "$g_player_team", "$g_player_agent"),
      ]),

    ("cf_cancel_camera_keys", [
      (this_or_next|game_key_is_down, gk_view_char),
      (this_or_next|game_key_is_down, gk_zoom),
      (game_key_is_down, gk_cam_toggle),
      (mission_cam_set_mode, 0),
    ]),

    ("dmod_closest_agent", [
          (assign, ":cur_agent", -1),
          (assign, ":distance", 999999),
          (mission_cam_get_position, pos11),
          (position_set_z_to_ground_level, pos11),
          (try_for_agents, ":agent_no"),
            (agent_is_human, ":agent_no"),
            (agent_is_alive, ":agent_no"),
            (agent_is_ally, ":agent_no"),
            #position on the ground
            (agent_get_position, pos13, ":agent_no"),
            # (position_get_screen_projection, pos14, pos13),
            # (get_distance_between_positions, ":cur_distance", pos12, pos14),
            (get_distance_between_positions, ":cur_distance", pos11, pos13),
            (lt, ":cur_distance", ":distance"),
            (assign, ":distance", ":cur_distance"),
            (assign, ":cur_agent", ":agent_no"),
          (try_end),
          (try_begin),
            (neq, ":cur_agent", 1),
            (assign, "$dmod_current_agent", ":cur_agent"),
            (str_store_agent_name, 1, "$dmod_current_agent"),
            (display_message, "@Selected Troop: {s1}"),
          (try_end),

      ]
    ),
    # script_dmod_cycle_forwards
      # Output: New $dmod_current_agent
      # Used to cycle forwards through valid agents
      ("dmod_cycle_forwards",[

         (assign, ":agent_moved", 0),
         (assign, ":first_agent", -1),
         # (get_player_agent_no, ":player_agent"),
         # (agent_get_team, ":player_team", ":player_agent"),

        (try_for_agents, ":agent_no"),
            (neq, ":agent_moved", 1),
            (neq, ":agent_no", "$g_player_agent"),
            (agent_is_human, ":agent_no"),
            (agent_is_alive, ":agent_no"),
            (agent_is_ally, ":agent_no"),
            # (agent_get_team, ":cur_team", ":agent_no"),
            # (this_or_next|eq, ":cur_team", 5), #bodyguards
            # (eq, ":cur_team", ":player_team"),
            (try_begin),
              (lt, ":first_agent", 0),
              (assign, ":first_agent", ":agent_no"),
            (try_end),
            (gt, ":agent_no", "$dmod_current_agent"),
            (assign, "$dmod_current_agent", ":agent_no"),
            (assign, ":agent_moved", 1),
        (try_end),

        (try_begin),
            (eq, ":agent_moved", 0),
            (neq, ":first_agent", -1),
            (assign, "$dmod_current_agent", ":first_agent"),
            (assign, ":agent_moved", 1),
        (else_try),
            (eq, ":agent_moved", 0),
            (eq, ":first_agent", -1),
            (display_message, "@No Troops Left."),
        (try_end),

        (try_begin),
            (eq, ":agent_moved", 1),
            (str_store_agent_name, s1, "$dmod_current_agent"),
            (display_message, "@Selected Troop: {s1}"),
        (try_end),
      #(assign, "$dmod_move_camera", 1),
      ]),

      # script_dmod_cycle_backwards
      # Output: New $dmod_current_agent
      # Used to cycle backwards through valid agents
      ("dmod_cycle_backwards",[

        (assign, ":new_agent", -1),
        (assign, ":last_agent", -1),
        # (get_player_agent_no, ":player_agent"),
        # (agent_get_team, ":player_team", ":player_agent"),

        (try_for_agents, ":agent_no"),
            (neq, ":agent_no", "$g_player_agent"),
            (agent_is_human, ":agent_no"),
            (agent_is_alive, ":agent_no"),
            (agent_is_ally, ":agent_no"),
        # (agent_get_team, ":cur_team", ":agent_no"),
        # (this_or_next|eq, ":cur_team", 5), #bodyguards
        # (eq, ":cur_team", ":player_team"),
            (assign, ":last_agent", ":agent_no"),
            (lt, ":agent_no", "$dmod_current_agent"),
            (assign, ":new_agent", ":agent_no"),
        (try_end),

        (try_begin),
            (eq, ":new_agent", -1),
            (neq, ":last_agent", -1),
            (assign, ":new_agent", ":last_agent"),
        (else_try),
            (eq, ":new_agent", -1),
            (eq, ":last_agent", -1),
            (display_message, "@No Troops Left."),
        (try_end),

        (try_begin),
            (neq, ":new_agent", -1),
            (assign, "$dmod_current_agent", ":new_agent"),
            (str_store_agent_name, 1, "$dmod_current_agent"),
            (display_message, "@Selected Troop: {s1}"),
        (try_end),
      ]),



  #script_start_town_conversation
  #input: center's slot no, entry points
  #used to talk to various center merchant npcs including guildmaster
  ("start_town_conversation",
	[
	  (store_script_param, ":troop_slot_no", 1),
	  (store_script_param, ":entry_no", 2),

      (assign, "$talk_context", tc_town_talk),
	  (try_begin),
		(eq, ":troop_slot_no", slot_town_merchant),
		(assign, ":scene_slot_no", slot_town_store),
	  (else_try),
		(eq, ":troop_slot_no", slot_town_tavernkeeper),
		(assign, ":scene_slot_no", slot_town_tavern),
        (assign, "$talk_context", tc_tavern_talk),
	  (else_try),
		(assign, ":scene_slot_no", slot_town_center),
	  (try_end),

	  (party_get_slot, ":conversation_scene", "$current_town", ":scene_slot_no"),
	  (modify_visitors_at_site, ":conversation_scene"),
	  (reset_visitors),
	  (set_visitor, 0, "trp_player"),

	  (try_begin),
		(gt, "$sneaked_into_town", disguise_none),
		(mission_tpl_entry_set_override_flags, "mt_conversation_encounter", 0, af_override_all),
        #SB : use script call
        (call_script, "script_set_disguise_override_items", "mt_conversation_encounter", 0, 0),
	  (else_try),
		(mission_tpl_entry_set_override_flags, "mt_conversation_encounter", 0, af_override_horse),
		(mission_tpl_entry_clear_override_items, "mt_conversation_encounter", 0),
	  (try_end),
	  (party_get_slot, ":conversation_troop", "$current_town", ":troop_slot_no"),
	  (set_visitor, ":entry_no", ":conversation_troop"),
	  (set_jump_mission,"mt_conversation_encounter"),
	  (jump_to_scene, ":conversation_scene"),
	  (change_screen_map_conversation, ":conversation_troop"),
	]),
    #talking to people outside the court (neutral, tc_castle_gate)

	("start_courtyard_conversation",
	[
      (store_script_param, ":conversation_troop", 1),
      (store_script_param, ":center_no", 2),

      (party_get_slot, ":conversation_scene", ":center_no", slot_town_center), #castle's exterior
      (modify_visitors_at_site, ":conversation_scene"),
      (reset_visitors),
      (try_begin), #player vs troop, not much processing
        (neg|troop_is_hero, ":conversation_troop"),

      (else_try), #talking to lords, compare relative positions
        (assign, ":supplicant", "trp_player"),
        (store_faction_of_party, ":faction_no", ":center_no"),
        (call_script, "script_dplmc_get_troop_standing_in_faction", "trp_player", ":faction_no"),
        (assign, ":player_standing", reg0),
        (call_script, "script_dplmc_get_troop_standing_in_faction", ":conversation_troop", ":faction_no"),
        (assign, ":other_troop_standing", reg0),

        #23 : castle guard (adjacent), 2: lord's hall door
        (assign, ":entry_lower", 23),
        (assign, ":entry_upper", 2),
        #overwrite standing if center owned
        (try_begin),
          (party_slot_eq, ":center_no", slot_town_lord, "trp_player"),
          (assign, ":player_standing", 9999),
        (else_try),
          (party_slot_eq, ":center_no", slot_town_lord, ":conversation_troop"),
          (assign, ":other_troop_standing", 9999),
        (else_try), #strangers, use default street entry point (this may be outside in towns, 0 preferred)
          (this_or_next|eq, ":player_standing", DPLMC_FACTION_STANDING_UNAFFILIATED),
          (eq, ":other_troop_standing", DPLMC_FACTION_STANDING_UNAFFILIATED),
          (assign, ":entry_lower", 1),
        (try_end),

        (try_begin), #player is usually supplicant
          (gt, ":player_standing", ":other_troop_standing"),
          (assign, ":supplicant", ":conversation_troop"),
          (assign, ":conversation_troop", "trp_player"),
        (else_try),
          (is_between, ":center_no", towns_begin, towns_end),
          (eq, ":player_standing", ":other_troop_standing"),
          (assign, ":entry_upper", 27),
          (assign, ":entry_lower", 28),
        (try_end),
      (try_end),

      (mission_tpl_entry_set_override_flags, "mt_conversation_encounter", ":entry_lower", af_override_horse|af_override_head|af_override_weapons),
      (mission_tpl_entry_set_override_flags, "mt_conversation_encounter", ":entry_upper", af_override_horse|af_override_fullhelm),
      (set_visitor, ":entry_lower", ":supplicant"),
      (set_visitor, ":entry_upper", ":conversation_troop"),

      (set_jump_mission,"mt_conversation_encounter"),
      (jump_to_scene, ":conversation_scene"),
      (change_screen_map_conversation, ":conversation_troop"),
    ]),

    #talking to people within the court (after capture for instance)
    ("start_court_conversation",
    [
        (store_script_param, ":conversation_troop", 1),
        (store_script_param, ":center_no", 2),

        (party_get_slot, ":conversation_scene", ":center_no", slot_town_castle),
        (modify_visitors_at_site, ":conversation_scene"),
        (reset_visitors),
        (set_visitor, 0, "trp_player"),
        (mission_tpl_entry_set_override_flags, "mt_conversation_encounter", 0, af_override_horse),

        #clear flags for actual courtly conversations?
        (store_random_in_range, ":entry_no", 16, 32),
        (mission_tpl_entry_set_override_flags, "mt_conversation_encounter", ":entry_no", af_override_horse),
        (try_begin),
          (troop_is_hero, ":conversation_troop"),
          (set_visitor, ":entry_no", ":conversation_troop"),
        (else_try),
          (store_script_param, ":troop_dna", 3),
          (set_visitor, ":entry_no", ":conversation_troop", ":troop_dna"),
        (try_end),
        (set_jump_mission,"mt_conversation_encounter"),
        (jump_to_scene, ":conversation_scene"),
        (change_screen_map_conversation, ":conversation_troop"),
    ]),


    #script_companion_get_mission_string
    #input: companion troop_id
    #output: "{!}{s4}: {s8} ({s5})" to s0
    #unify the menu (rarely called) and troop notes for consistency
    #side-effects include overwriting s9, reg3, etc.
    ("companion_get_mission_string", [
        (store_script_param, ":companion", 1),
        (try_begin), #do not impose conditions here, do so from calling script
            # (this_or_next|main_party_has_troop, ":companion"),
            # (this_or_next|troop_slot_ge, ":companion", slot_troop_current_mission, 1),
                # (eq, "$g_player_minister", ":companion"),
            (str_store_troop_name, s4, ":companion"),
            (str_clear, s5),
            (str_clear, s8),
            (troop_get_slot, ":days_left", ":companion", slot_troop_days_on_mission),
            (troop_get_slot, ":mission", ":companion", slot_troop_current_mission),
            (try_begin),
                (le, ":days_left", 0),
                (str_store_string, s5, "str_whereabouts_unknown"),
            (else_try),
                (eq, ":days_left", 1),
                (str_store_string, s5, "str_expected_back_imminently"),
            (else_try),
                (assign, reg3, ":days_left"),
                (str_store_string, s5, "str_expected_back_in_approximately_reg3_days"),
            (try_end),


            (try_begin),
                (eq, ":mission", npc_mission_kingsupport),
                (str_store_string, s8, "str_gathering_support"),
            (else_try),
                (this_or_next|eq, ":mission", npc_mission_gather_intel),
                (eq, ":mission", dplmc_npc_mission_rescue_prisoner), #new mission
                (troop_get_slot, ":town_with_contacts", ":companion", slot_troop_town_with_contacts),
                (str_store_party_name, s9, ":town_with_contacts"),
                (try_begin),
                  (eq, ":mission", npc_mission_gather_intel),
                  (str_store_string, s8, "str_gathering_intelligence"),
                (else_try),
                  (eq, ":mission", dplmc_npc_mission_rescue_prisoner),
                  (str_store_string, s8, "str_preparing_prison_break"),
                (try_end),
            (else_try),
                (this_or_next|is_between, ":mission", npc_mission_peace_request, npc_mission_rejoin_when_possible),
                (is_between, ":mission", dplmc_npc_mission_war_request, dplmc_npc_mission_rescue_prisoner),

                (troop_get_slot, ":faction", ":companion", slot_troop_mission_object),
                (str_store_faction_name, s9, ":faction"),
                (str_store_string, s8, "str_diplomatic_embassy_to_s9"),
            # (else_try), #diplomacy missions

            (else_try),
                (eq, ":companion", "$g_player_minister"),
                (str_store_string, s8, "str_serving_as_minister"),
                (try_begin),
                  (is_between, "$g_player_court", centers_begin, centers_end),
                  (str_store_party_name, s9, "$g_player_court"),
                  (str_store_string, s5, "str_in_your_court_at_s9"),
                (else_try),
                  (str_store_string, s5, "str_awaiting_the_capture_of_a_fortress_which_can_serve_as_your_court"),
                (try_end),
            (else_try),
                (eq, ":mission", npc_mission_rejoin_when_possible),
                (str_store_string, s8, "str_attempting_to_rejoin_party"),
            (else_try),
                (main_party_has_troop, ":companion"),
                (str_store_string, s8, "str_under_arms"),
                (str_store_string, s5, "str_in_your_party"),
            (else_try),    #Companions who are in a center
                (troop_slot_ge, ":companion", slot_troop_cur_center, centers_begin),
                (str_store_string, s8, "str_separated_from_party"),
                (str_store_string, s5, "str_whereabouts_unknown"),
            (else_try),    #Companions who are (imprisoned) in a center
                (troop_slot_ge, ":companion", slot_troop_prisoner_of_party, centers_begin),
                (str_store_string, s8, "str_missing_after_battle"),
                (str_store_string, s5, "str_whereabouts_unknown"),
            (else_try),
                (try_begin),
                    (check_quest_active, "qst_lend_companion"),
                    (quest_slot_eq, "qst_lend_companion", slot_quest_target_troop, ":companion"),
                    (quest_get_slot, ":lord", "qst_lend_companion", slot_quest_giver_troop),
                    (str_store_troop_name, s5, ":lord"),
                    (str_store_string, s8, "str_accompanying_s5"),
                    (str_store_string, s5, "str_on_loan"),
                (else_try),
                    (check_quest_active, "qst_lend_surgeon"),
                    (quest_slot_eq, "qst_lend_surgeon", slot_quest_target_troop, ":companion"),
                    (quest_get_slot, ":lord", "qst_lend_surgeon", slot_quest_giver_troop),
                    (str_store_troop_name, s5, ":lord"),
                    (str_store_string, s8, "str_accompanying_s5"),
                    (str_store_string, s5, "str_on_loan"),
                (try_end),
            (try_end),

            (str_store_string, s0, "str_s4_s8_s5"),
        (try_end),
        ]
      ),
    #iterates through list of obtainable soldiers (and check if the player has reclassified them to a custom class > grc_cavalry)
    #instead of going through all troops globally, we check the selected center's garrison's upgraded troops
    ("cf_troop_class_activated",
    [
        (store_script_param, ":grc", 1),
        (store_script_param, ":party_no", 2),
        (is_between, ":grc", grc_infantry, grc_everyone),
        (try_begin), #first 3 always available
          (le, ":grc", grc_cavalry),
          (assign, ":end", -1),
        (else_try),
          (party_get_num_companion_stacks, ":end", ":party_no"),

          (try_for_range, ":stack_no", 0, ":end"),
            (party_stack_get_troop_id, ":troop_no", ":party_no", ":stack_no"),
            (neg|troop_is_hero, ":troop_no"),
            (try_begin),
              (troop_get_upgrade_troop, ":upgrade_troop", ":troop_no", 0),
              (gt, ":upgrade_troop", 0),
              (troop_get_class, ":class_no", ":upgrade_troop"),
              (eq, ":class_no", ":grc"),
              (assign, ":end", -1),
            (try_end),
            (try_begin), #not found, check other upgrade
              (neq, ":end", -1),
              (troop_get_upgrade_troop, ":upgrade_troop", ":troop_no", 1),
              (gt, ":upgrade_troop", 0),
              (troop_get_class, ":class_no", ":upgrade_troop"),
              (eq, ":class_no", ":grc"),
              (assign, ":end", -1),
            (try_end),
          (try_end),
        # (try_for_range, ":troop_no", soldiers_begin, soldiers_end),
          # (neg|troop_is_hero, ":troop_no"),
          # (troop_get_class, ":class", ":troop_no"),
        # (try_end),
        (try_end),
        (eq, ":end", -1),

    ]),

    ("cf_troop_is_class",
    [
        (store_script_param, ":grc", 1),
        (store_script_param, ":troop_no", 2),
        (is_between, ":grc", grc_infantry, grc_everyone), #usually $g_constable_training_type
        (gt, ":troop_no", 0), #this is usually obtained through troop_get_upgrade_troop, sanitize it here

        (troop_get_class, ":class_no", ":troop_no"),
        (eq, ":grc", ":class_no"),
    ]),
    #script_dplmc_npc_morale
    ("dplmc_npc_morale",
      [
        (store_script_param_1, ":npc"),
        (store_script_param_2, ":mode"),
        (try_begin), #if we actually care
          (eq, ":mode", 1),
          (call_script, "script_npc_morale", ":npc"),
        (else_try), #we just want the numbers
          (troop_get_slot, ":morality_grievances", ":npc", slot_troop_morality_penalties),
          (troop_get_slot, ":personality_grievances", ":npc", slot_troop_personalityclash_penalties),
          (party_get_morale, ":party_morale", "p_main_party"),

          (store_sub, ":troop_morale", ":party_morale", ":morality_grievances"),
          (val_sub, ":troop_morale", ":personality_grievances"),
          (val_add, ":troop_morale", 50),

          # (assign, reg8, ":troop_morale"),

          (val_mul, ":troop_morale", 3),
          (val_div, ":troop_morale", 4),
          (val_clamp, ":troop_morale", 0, 100),
          (assign, reg0, ":troop_morale"),
        (try_end),
    ]),

    #script_build_background_answer_story
    #input: sreg, other info based off global background_answer variables
    #output: story to s0, side effects are reg11, s10 through s13
    ("build_background_answer_story", [
        (store_script_param_1, ":sreg"),
        (assign, reg11, "$character_gender"),
        (store_sub, ":string", "$background_answer_4", cb4_revenge),
        (val_add, ":string", "str_story_reason_revenge"),
        (str_store_string, s13, ":string"),
        (store_sub, ":string", "$background_answer_3", dplmc_cb3_bravo),
        (val_add, ":string", "str_story_job_bravo"),
        (str_store_string, s12, ":string"),
        (store_sub, ":string", "$background_answer_2", cb2_page), #values for this start from 0
        (val_add, ":string", "str_story_childhood_page"),
        (str_store_string, s11, ":string"),
        (store_sub, ":string", "$background_type", cb_noble),
        (val_add, ":string", "str_story_parent_noble"),
        (str_store_string, s10, ":string"),
        (str_store_string, ":sreg", "str_story_all"),
    ]),

    #whenever the player does something nice, spectators cheer
    ("agents_cheer_during_training", [
      (party_get_morale, ":cur_morale", "p_main_party"),
      (assign, ":boundary", 150),
    #first aid double-stacks since it's not a battle
      (try_for_agents, ":agent_no"),
        (agent_is_active, ":agent_no"),
        (agent_is_human, ":agent_no"),
        # (agent_get_troop_id, ":troop_no", ":agent_no"), #a spectator
        (neg|agent_has_item_equipped, ":agent_no", "itm_practice_boots"),
        (store_random_in_range, ":random_no", ":cur_morale", 250),
        (gt, ":random_no", ":boundary"),
        (val_add, ":boundary", 15),
        (agent_set_animation, ":agent_no", "anim_cheer"),
        (store_random_in_range, ":random_no", 0, 100),
        (agent_set_animation_progress, ":agent_no", ":random_no"),
      (try_end),
    ]),

    #a separate trigger handles when they're actually knocked out
    ("troop_set_training_health_from_agent", [
      (party_get_skill_level, ":first_aid", "p_main_party", "skl_first_aid"),
    #first aid double-stacks since it's not a battle
      (try_for_agents, ":agent_no"),
        # (agent_is_active, ":agent_no"),
        (agent_is_human, ":agent_no"),
        (agent_get_troop_id, ":troop_no", ":agent_no"),
        (troop_is_hero, ":troop_no"),
        (store_troop_health, ":health", ":troop_no", 0), #this is not yet deducted
        (store_agent_hit_points, ":hp", ":agent_no", 0),
        (val_sub, ":hp", ":health"), #this is the difference
        (try_begin),
          (agent_is_alive, ":agent_no"),
          (store_skill_level, ":skill", "skl_first_aid", ":troop_no"),
          (val_add, ":skill", ":first_aid"),
        (else_try),
          (assign, ":skill", ":first_aid"),
        (try_end),
        (val_mul, ":skill", -5),  #as per skill description
        (val_add, ":skill", 100), # 100 - skill effect
        #apply skill effect and set health
        (val_mul, ":hp", ":skill"),
        (val_div, ":hp", 100),
        (val_add, ":hp", ":health"), #subtract modified difference
        (troop_set_health, ":troop_no", ":hp", 0),
      (try_end),
    ]),

    #script_agent_apply_training_health
    #input: player_agent, called from abm_training during melee fights, can also be used for tournament if desired
    ("agent_apply_training_health", [
      (store_script_param_1, ":agent_no"),
      # (store_script_param_2, "$current_town"),

      (party_get_skill_level, ":first_aid", "p_main_party", "skl_first_aid"),
      (party_get_slot, ":relation", "$current_town", slot_center_player_relation), #range from -100 to 100
      (store_sub, ":relation", 200, ":relation"), #300 to 100

      (store_troop_health, ":health", "trp_player", 0), #this is not yet deducted
      (store_agent_hit_points, ":hp", ":agent_no", 0),

      (val_sub, ":hp", ":health"), #this is the difference (non-positive)
      (try_begin),
        (agent_is_alive, ":agent_no"),
        (store_skill_level, ":skill", "skl_first_aid", "trp_player"),
      (else_try),
        (assign, ":skill", 0),
      (try_end),
      (val_add, ":skill", ":first_aid"),
      (val_mul, ":skill", -5),  #as per skill description
      (val_add, ":skill", 100), # 100 - skill effect
      #apply skill effect, relation effect and set health
      (val_mul, ":hp", ":skill"),
      (val_div, ":hp", 100),
      (val_mul, ":hp", ":relation"),
      (val_div, ":hp", 200),
      (val_add, ":health", ":hp"), #subtract modified difference
      (val_max, ":health", 5),
      (troop_set_health, "trp_player", ":health", 0),
    ]),

    # script_party_heal_all_members_aux, opposite of script_party_wound_all_members_aux
    # Input: arg1 = party_no
    ("party_heal_all_members_aux",
      [
        (store_script_param_1, ":party_no"),

        (party_get_num_companion_stacks, ":num_stacks",":party_no"),
        (try_for_range_backwards, ":i_stack", 0, ":num_stacks"),
          (party_stack_get_troop_id, ":stack_troop",":party_no",":i_stack"),
          (try_begin),
            (neg|troop_is_hero, ":stack_troop"),
            # (party_stack_get_size, ":stack_size",":party_no",":i_stack"),
            (party_stack_get_num_wounded, ":stack_size",":party_no",":i_stack"),
            (party_add_members, ":party_no", ":stack_troop", ":stack_size"),
            (party_remove_members_wounded_first, ":party_no", ":stack_troop", ":stack_size"),
          (else_try),
            (troop_set_health, ":stack_troop", 100),
          (try_end),
        (try_end),
        (party_get_num_attached_parties, ":num_attached_parties", ":party_no"),
        (try_for_range, ":attached_party_rank", 0, ":num_attached_parties"),
          (party_get_attached_party_with_rank, ":attached_party", ":party_no", ":attached_party_rank"),
          (call_script, "script_party_heal_all_members_aux", ":attached_party"),
        (try_end),
      ]
    ),

  #script_cf_village_normal_cond
  # INPUT: none
  # OUTPUT: none
  ("cf_village_normal_cond",
    [
    (store_script_param, ":party_no", 1),
    (neg|party_slot_eq, ":party_no", slot_village_state, svs_looted),
    (neg|party_slot_eq, ":party_no", slot_village_state, svs_deserted), #SB : addition here
    (neg|party_slot_eq, ":party_no", slot_village_state, svs_being_raided),
    (neg|party_slot_ge, ":party_no", slot_village_infested_by_bandits, 1),
    ]
  ),

    #script_cf_has_companion_emissary for diplomatic options
  ("cf_has_companion_emissary",
    [
    (assign, ":companion_found", companions_end),
    (try_for_range, ":emissary", companions_begin, companions_end),
      (main_party_has_troop, ":emissary"),
      (assign, ":companion_found", companions_begin),
    (try_end),
    (neq, ":companion_found", companions_end),
    ]),

  #script_get_chest_troop fetches the appropriate placeholder for player storage
  # INPUT: center, usually $current_town
  # OUTPUT: none
  ("get_chest_troop",
  [
    (store_script_param, ":party_no", 1),
    (try_begin),
        (gt, "$g_player_chamberlain", 0),
        (assign, ":chest_troop", "trp_household_possessions"),
    (else_try), #assume troops same order as parties
        # (party_get_slot, ":chest_troop", ":party_no", slot_town_seneschal),
        (val_sub, ":party_no", towns_begin),
        (store_add, ":chest_troop", ":party_no", "trp_town_1_seneschal"),
    (try_end),
    (assign, reg0, ":chest_troop"),
  ]),

	#script_change_faction_troop_morale
	#input - faction, change, display mode
	#output - a colored message
	("change_faction_troop_morale",
	  [(store_script_param, ":faction_no", 1),
	   (store_script_param, ":morale_change", 2),
	   (store_script_param, ":display", 3),
	   (try_begin),
		 (eq, ":display", 1),
		 (neg|faction_slot_eq, ":faction_no", slot_faction_state, sfs_active),
		 (assign, ":display", 0),
	   (try_end),
	   #check if main party has troop of type before displaying
	   (try_begin),
		 (eq, ":display", 1),
		 (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
		 (try_for_range, ":stack", 1, ":num_stacks"),
		   (party_stack_get_troop_id, ":troop", "p_main_party", ":stack"),
		   (store_troop_faction, ":fac", ":troop"),
		   (eq, ":fac", ":faction_no"),
		   (assign, ":num_stacks", 1), #break
		 (try_end),
		 (neq, ":num_stacks", 1), #none found
		 (assign, ":display", 0),
	   (try_end),
	   #effects are still applied regardless - the displayed morale is divided by 100
	   (faction_get_slot, ":morale", ":faction_no", slot_faction_morale_of_player_troops),
	   (store_div, reg1, ":morale", 100),
	   (val_add, ":morale", ":morale_change"),
	   (store_div, reg2, ":morale", 100),
	   (faction_set_slot, ":faction_no", slot_faction_morale_of_player_troops, ":morale"),

	   # (try_begin),
		 # (store_sub, ":diff", reg2, reg1),
		 # (eq, ":diff", 0), #negligible
		 # (assign, ":display", 0),
	   # (try_end),

	   #actual output
	   (try_begin),
		 (eq, ":display", 1),
         (neq, reg1, reg2), #non-zero difference
		 #set up s1
		 #(faction_get_slot, ":adjective", ":faction_no", slot_faction_adjective),
         (str_store_faction_name, s1, ":faction_no"),
		 #(str_store_string, s1, ":adjective"),
		 (str_store_string, s1, "@{s1} troops"),
		 #get increase/decrease, either string will work
		 (assign, ":string", "str_troop_relation_detoriated"),
		 (try_begin),
		   (gt, ":morale_change", 0),
		   (assign, ":string", "str_troop_relation_increased"),
		 (try_end),
		 #get color
		 (faction_get_color, ":color", ":faction_no"),
		 (display_message, ":string", ":color"),
	   (try_end),
	  ]
	),

    #script_encounter_agent_draw_weapon
    #input: none, based on $g_talk_agent
    #output: none, agent wields first available weapon to show aggression
    ("encounter_agent_draw_weapon",
    [
        (store_conversation_agent, "$g_talk_agent"),
        (try_begin),
          (agent_get_item_slot, ":item_no", "$g_talk_agent", ek_item_0),
          (gt, ":item_no", 0),
          (agent_set_wielded_item, "$g_talk_agent", ":item_no"),
        (try_end),

    ]),

    #script_troop_debug_range
    #input: troop, head or tail, sreg
    #output: reg0 as head or tail, sreg holding a short description
    ("cf_troop_debug_range",
    [
        (store_script_param, ":troop_no", 1),
        (store_script_param, ":sreg", 2),
        (store_script_param, ":direction", 3),
        (assign, ":result", ":troop_no"),
        (try_begin),
          (is_between, ":troop_no", heroes_begin, heroes_end),
          (str_store_string, ":sreg", "@hero"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", heroes_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", heroes_end, ":direction"),
          (try_end),
          (try_begin),
            (is_between, ":troop_no", companions_begin, companions_end),
            (str_store_string, ":sreg", "@companion"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", companions_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", companions_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", kings_begin, kings_end),
            (str_store_string, ":sreg", "@king"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", kings_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", kings_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", lords_begin, lords_end),
            (str_store_string, ":sreg", "@lord"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", lords_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", lords_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", pretenders_begin, pretenders_end),
            (str_store_string, ":sreg", "@pretender"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", pretenders_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", pretenders_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", kingdom_ladies_begin, kingdom_ladies_end),
            (str_store_string, ":sreg", "@lady"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", kingdom_ladies_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", kingdom_ladies_end, ":direction"),
            (try_end),
          (try_end),
        (else_try),
          (is_between, ":troop_no", bandits_begin, bandits_end),
          (str_store_string, ":sreg", "@bandit"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", bandits_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", bandits_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", tavern_minstrels_begin, tavern_minstrels_end),
          (str_store_string, ":sreg", "@minstrel"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", tavern_minstrels_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", tavern_minstrels_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", tavern_booksellers_begin, tavern_booksellers_end),
          (str_store_string, ":sreg", "@bookseller"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", tavern_booksellers_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", tavern_booksellers_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", tavern_travelers_begin, tavern_travelers_end),
          (str_store_string, ":sreg", "@traveler"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", tavern_travelers_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", tavern_travelers_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", ransom_brokers_begin, ransom_brokers_end),
          (str_store_string, ":sreg", "@ransom broker"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", ransom_brokers_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", ransom_brokers_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", mercenary_troops_begin, mercenary_troops_end),
          (str_store_string, ":sreg", "@mercenary"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", mercenary_troops_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", mercenary_troops_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", multiplayer_troops_begin, multiplayer_troops_end),
          (str_store_string, ":sreg", "@multiplayer troop"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", multiplayer_troops_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", multiplayer_troops_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", quick_battle_troops_begin, quick_battle_troops_end),
          (str_store_string, ":sreg", "@quick battler"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", quick_battle_troops_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", quick_battle_troops_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", training_ground_trainers_begin, training_ground_trainers_end),
          (str_store_string, ":sreg", "@trainer"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", training_ground_trainers_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", training_ground_trainers_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", arena_masters_begin, arena_masters_end),
          (str_store_string, ":sreg", "@arena master"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", arena_masters_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", arena_masters_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", walkers_begin, walkers_end),
          (str_store_string, ":sreg", "@walker"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", walkers_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", walkers_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", merchants_begin, merchants_end),
          (str_store_string, ":sreg", "@merchant"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", merchants_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", merchants_end, ":direction"),
          (try_end),
          (try_begin),
            (is_between, ":troop_no", armor_merchants_begin, armor_merchants_end),
            (str_store_string, ":sreg", "@armor merchant"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", armor_merchants_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", armor_merchants_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", weapon_merchants_begin, weapon_merchants_end),
            (str_store_string, ":sreg", "@weapon merchant"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", weapon_merchants_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", weapon_merchants_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", tavernkeepers_begin, tavernkeepers_end),
            (str_store_string, ":sreg", "@tavernkeeper"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", tavernkeepers_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", tavernkeepers_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", goods_merchants_begin, goods_merchants_end),
            (str_store_string, ":sreg", "@goods merchant"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", goods_merchants_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", goods_merchants_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", horse_merchants_begin, horse_merchants_end),
            (str_store_string, ":sreg", "@horse merchant"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", horse_merchants_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", horse_merchants_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", mayors_begin, mayors_end),
            (str_store_string, ":sreg", "@guildmaster"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", mayors_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", mayors_end, ":direction"),
            (try_end),
          (else_try),
            (is_between, ":troop_no", village_elders_begin, village_elders_end),
            (str_store_string, ":sreg", "@village elder"),
            (try_begin),
              (eq, ":direction", -1),
              (assign, ":result", village_elders_begin),
            (else_try),
              (eq, ":direction", 1),
              (store_sub, ":result", village_elders_end, ":direction"),
            (try_end),
          (try_end),
        (else_try),
          (is_between, ":troop_no", startup_merchants_begin, startup_merchants_end),
          (str_store_string, ":sreg", "@startup merchant"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", startup_merchants_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", startup_merchants_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", tournament_champions_begin, tournament_champions_end),
          (str_store_string, ":sreg", "@tournament fighter"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", tournament_champions_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", tournament_champions_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", dplmc_employees_begin, dplmc_employees_end),
          (str_store_string, ":sreg", "@court member"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", dplmc_employees_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", dplmc_employees_end, ":direction"),
          (try_end),
        (else_try),
          (is_between, ":troop_no", fighters_begin, fighters_end),
          (str_store_string, ":sreg", "@fighter"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", fighters_begin),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", fighters_end, ":direction"),
          (try_end),
        (else_try), #sarranids
          (is_between, ":troop_no", "trp_sarranid_recruit", "trp_looter"),
          (str_store_string, ":sreg", "str_kingdom_6_adjective"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", "trp_sarranid_recruit"),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", "trp_looter", ":direction"),
          (try_end),
        (else_try), #rhodoks
          (is_between, ":troop_no", "trp_rhodok_tribesman", "trp_sarranid_recruit"),
          (str_store_string, ":sreg", "str_kingdom_5_adjective"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", "trp_rhodok_tribesman"),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", "trp_sarranid_recruit", ":direction"),
          (try_end),
        (else_try), #nords
          (is_between, ":troop_no", "trp_nord_recruit", "trp_rhodok_tribesman"),
          (str_store_string, ":sreg", "str_kingdom_4_adjective"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", "trp_nord_recruit"),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", "trp_rhodok_tribesman", ":direction"),
          (try_end),
        (else_try), #khergits
          (is_between, ":troop_no", "trp_khergit_tribesman", "trp_nord_recruit"),
          (str_store_string, ":sreg", "str_kingdom_3_adjective"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", "trp_khergit_tribesman"),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", "trp_nord_recruit", ":direction"),
          (try_end),
        (else_try), #vaegirs
          (is_between, ":troop_no", "trp_vaegir_recruit", "trp_khergit_tribesman"),
          (str_store_string, ":sreg", "str_kingdom_2_adjective"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", "trp_vaegir_recruit"),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", "trp_khergit_tribesman", ":direction"),
          (try_end),
        (else_try), #swadians
          (is_between, ":troop_no", "trp_swadian_recruit", "trp_vaegir_recruit"),
          (str_store_string, ":sreg", "str_kingdom_1_adjective"),
          (try_begin),
            (eq, ":direction", -1),
            (assign, ":result", "trp_swadian_recruit"),
          (else_try),
            (eq, ":direction", 1),
            (store_sub, ":result", "trp_vaegir_recruit", ":direction"),
          (try_end),
        (try_end),
        (this_or_next|eq, ":direction", 0),
        (neq, ":result", ":troop_no"),
        (assign, reg0, ":result"),

    ]),

    #script_get_proficient_melee_training_weapon
    #input : troop_no
    #output : item_no as the practice weapon
    ("get_proficient_melee_training_weapon",
    [
        (store_script_param, ":troop_no", 1),
        (store_proficiency_level, ":onehands", ":troop_no", wpt_one_handed_weapon),
        (store_proficiency_level, ":twohands", ":troop_no", wpt_two_handed_weapon),
        (store_proficiency_level, ":polearms", ":troop_no", wpt_polearm),

        (assign, ":item_no", -1),
        (try_begin), #practice shield will be added automatically
          (ge, ":onehands", ":twohands"),
          (ge, ":onehands", ":polearms"),
          # (agent_equip_item, ":agent_no", "itm_practice_shield"),
          (assign, ":item_no", "itm_practice_sword"),
        (else_try),
          (ge, ":twohands", ":onehands"),
          (ge, ":twohands", ":polearms"),
          (assign, ":item_no", "itm_heavy_practice_sword"),
        (else_try),
          (ge, ":polearms", ":onehands"),
          (ge, ":polearms", ":twohands"),
          (assign, ":item_no", "itm_practice_staff"),
        (try_end),
        (assign, reg0, ":item_no"),
    ]),

  # script_spawn_looters
  # Input: arg1 = center_no, arg2 = number of looters to spawn
  # Output: none
  ("spawn_looters",
    [
      (store_script_param, ":center_no", 1),
      (store_script_param, ":num_looters", 2),
      # (party_set_slot, ":center_no", slot_center_is_besieged_by, -1), #clear siege
      # (call_script, "script_village_set_state",  ":center_no", 0), #clear siege flag
      (set_spawn_radius, 4),
      (try_for_range, ":unused", 0, ":num_looters"),
        (spawn_around_party, ":center_no", "pt_looters"),
        #(party_set_ai_behavior, reg0, ai_bhvr_avoid_party),
        #(party_set_ai_object, reg0, ":center_no"),
      (try_end),
    ]),

  #script_troop_transfer_gold
  ("troop_transfer_gold",
    [
      (store_script_param, ":source", 1),
      (store_script_param, ":destination", 2),
      (store_script_param, ":amount", 3),
      (store_troop_gold, ":cur_amount", ":source"),
      (try_begin),
        (gt, ":amount", 0), #0 means move all
        (val_min, ":cur_amount", ":amount"),
      (try_end),
      (troop_remove_gold, ":source", ":cur_amount"),
      # (troop_add_gold, ":destination", ":cur_amount"),
      (call_script, "script_troop_add_gold", ":destination", ":cur_amount"),
      (assign, reg0, ":cur_amount"),
    ]),
  # script_move_inventory_and_gold
  # generally this is used to move the backup to the player
  # Input: arg1 = source, arg2 = destnation
  # Output: none

  ("move_inventory_and_gold",
    [
      (store_script_param, ":source", 1),
      (store_script_param, ":destination", 2),
      (store_script_param, ":move_gold", 3),
      #assume trp_temp_troop is an available placeholder

      (troop_sort_inventory, ":source"), #order them, too lazy to maintain 2 loops
      (troop_get_inventory_capacity, ":inv_cap", ":source"),
      (troop_get_inventory_capacity, ":player_cap", ":destination"),
      (assign, ":inv_slot", ek_food + 1), #start from the bottom, skip source's equipment
      (try_for_range, ":i_slot", ek_food + 1, ":player_cap"),
        (troop_get_inventory_slot, ":cur_item", ":destination", ":i_slot"),
        (eq, ":cur_item", -1), #empty slot
        (troop_get_inventory_slot, ":item", ":source", ":inv_slot"),
        (troop_set_inventory_slot, ":destination", ":i_slot", ":item"),
        #(try_begin),
          #(neq, ":cur_item", -1), #?????
          (troop_get_inventory_slot_modifier, ":imod", ":source", ":inv_slot"),
          (troop_set_inventory_slot_modifier, ":destination", ":i_slot", ":imod"),
          (try_begin),
            (troop_inventory_slot_get_item_amount, ":amount", ":source", ":inv_slot"),
            (gt, ":amount", 0),
            (troop_inventory_slot_set_item_amount, ":destination", ":i_slot", ":amount"),
          (try_end),
        #(try_end),
        (troop_set_inventory_slot, ":source", ":inv_slot", -1),
        (val_add, ":inv_slot", 1),

        (try_begin), #loop break
          (ge, ":inv_slot", ":inv_cap"),
          (assign, ":player_cap", -1),
        (try_end),
      (try_end),
      (troop_clear_inventory, ":source"), #clear off the rest if no capacity in destination
      #do gold addition
      (try_begin),
        (eq, ":move_gold", -1), #move all
        (store_troop_gold, ":cur_amount", ":source"),
        (troop_remove_gold, ":source", ":cur_amount"),
        (troop_add_gold, ":destination", ":cur_amount"),
      (else_try),
        (gt, ":move_gold", 0),  #specific amount
        (call_script, "script_troop_transfer_gold", ":source", ":destination", ":move_gold"),
      (try_end),
    ]),

   #script_get_disguise_string
   #calculate the string offset by iteratively dividing by 2
   ("get_disguise_string", [
      (store_script_param, ":cur_val", 1),
      (store_script_param, ":sreg", 2),
      (store_add, ":end_val", "str_pilgrim_disguise", num_disguises),
      (str_clear, ":sreg"),
      (try_for_range, ":string", "str_pilgrim_disguise", ":end_val"),
        (eq, ":cur_val", 1), #
        (assign, ":end_val", -1), #loop break
        (str_store_string, ":sreg", ":string"),
      (else_try),
        (val_div, ":cur_val", 2), #divide by 2, next iteration
      (try_end),
      ]),
   #script_acquire_disguise
   #lets the player use the disguise by setting the slot, shows message
   ("acquire_disguise", [
      (store_script_param, ":disguise", 1),
      (troop_get_slot, ":cur_disguise", "trp_player", slot_troop_player_disguise_sets),
      (val_or, ":cur_disguise", ":disguise"),
      (troop_set_slot, "trp_player", slot_troop_player_disguise_sets, ":cur_disguise"),
      (call_script, "script_get_disguise_string", ":disguise", 0),
      # (str_store_string, s0, reg0),
      (display_message, "@Acquired {s0}'s clothing", message_alert),
      ]),
   #script_set_disguise_overide_items
   #see also start of module_mission_templates for static list of items
   #note that the override flags are not being set here
   ("set_disguise_override_items", [
      (store_script_param, ":mission_template", 1),
      (store_script_param, ":entry_no", 2),
      (store_script_param, ":with_weapon", 3),

      (mission_tpl_entry_clear_override_items, ":mission_template", ":entry_no"),
      (try_begin),
        (eq, "$sneaked_into_town", disguise_pilgrim),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_pilgrim_disguise"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_pilgrim_hood"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_wrapping_boots"),
        (try_begin),
          (eq, ":with_weapon", 1),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_practice_staff"),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_throwing_daggers"),
        (try_end),
      (else_try),
        (eq, "$sneaked_into_town", disguise_farmer),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_felt_hat"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_coarse_tunic"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_nomad_boots"),
        (try_begin),
          (eq, ":with_weapon", 1),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_battle_fork"),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_cleaver"),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_stones"),
        (try_end),
      (else_try),
        (eq, "$sneaked_into_town", disguise_hunter),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_black_hood"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_leather_gloves"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_light_leather"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_light_leather_boots"),
        (try_begin),
          (eq, ":with_weapon", 1),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_sword_khergit_1"),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_hunting_bow"),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_barbed_arrows"),
        (try_end),
      (else_try),
        (eq, "$sneaked_into_town", disguise_merchant),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_leather_jacket"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_woolen_hose"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_felt_steppe_cap"),
        (try_begin),
          (eq, ":with_weapon", 1),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_dagger"),
        (try_end),
      (else_try),
        (eq, "$sneaked_into_town", disguise_guard),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_footman_helmet"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_mail_mittens"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_mail_shirt"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_leather_jerkin"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_mail_chausses"),
        (try_begin),
          (eq, ":with_weapon", 1),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_fighting_pick"),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_tab_shield_round_c"),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_war_spear"),
        (try_end),
      (else_try),
        (eq, "$sneaked_into_town", disguise_bard),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_linen_tunic"),
        (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_leather_boots"),
        (try_begin),
          (eq, ":with_weapon", 1),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_winged_mace"),
          (mission_tpl_entry_add_override_item, ":mission_template", ":entry_no", "itm_lyre"),
        (try_end),
      (try_end),
   ]),


    ("get_dest_color_from_rgb",
    [
      (store_script_param, ":red", 1),
      (store_script_param, ":green", 2),
      (store_script_param, ":blue", 3),

      (assign, ":cur_color", 0xFF000000),
      (val_mul, ":green", 0x100),
      (val_mul, ":red", 0x10000),
      (val_add, ":cur_color", ":blue"),
      (val_add, ":cur_color", ":green"),
      (val_add, ":cur_color", ":red"),
      (assign, reg0, ":cur_color"),
    ]),

    ("convert_rgb_code_to_html_code",
    [
      (store_script_param, ":red", 1),
      (store_script_param, ":green", 2),
      (store_script_param, ":blue", 3),

      # (str_store_string, s0, "@#"),

      (store_div, reg11, ":red", 0x10),
      #(store_add, ":dest_string", "str_key_0", reg11"),
      #(str_store_string, s1, ":dest_string"),
      #(str_store_string, s0, "@{s0}{s1}"),

      (store_mod, reg12, ":red", 0x10),
      #(store_add, ":dest_string", "str_key_0", ":r_2"),
      #(str_store_string, s1, ":dest_string"),
      #(str_store_string, s0, "@{s0}{s1}"),

      (store_div, reg13, ":green", 0x10),
      #(store_add, ":dest_string", "str_key_0", ":g_1"),
      #(str_store_string, s1, ":dest_string"),
      #(str_store_string, s0, "@{s0}{s1}"),

      (store_mod, reg14, ":green", 0x10),
      #(store_add, ":dest_string", "str_key_0", ":g_2"),
      #(str_store_string, s1, ":dest_string"),
      #(str_store_string, s0, "@{s0}{s1}"),

      (store_div, reg15, ":blue", 0x10),
      #(store_add, ":dest_string", "str_key_0", ":b_1"),
      #(str_store_string, s1, ":dest_string"),
      #(str_store_string, s0, "@{s0}{s1}"),

      (store_mod, reg16, ":blue", 0x10),
      #(store_add, ":dest_string", "str_key_0", ":b_2"),
      #(str_store_string, s1, ":dest_string"),
      #(str_store_string, s0, "@{s0}{s1}"),
      (str_store_string, s0, "str_html_color"),
    ]),

    ("convert_slot_no_to_color",
    [
      (store_script_param, ":cur_color", 1),

      (store_mod, ":blue", ":cur_color", 6),
      (val_div, ":cur_color", 6),
      (store_mod, ":green", ":cur_color", 6),
      (val_div, ":cur_color", 6),
      (store_mod, ":red", ":cur_color", 6),
      (val_mul, ":blue", 0x33),
      (val_mul, ":green", 0x33),
      (val_mul, ":red", 0x33),
      (assign, ":dest_color", 0xFF000000),
      (val_mul, ":green", 0x100),
      (val_mul, ":red", 0x10000),
      (val_add, ":dest_color", ":blue"),
      (val_add, ":dest_color", ":green"),
      (val_add, ":dest_color", ":red"),
      (assign, reg0, ":dest_color"),
    ]),

    ("change_color",
    [
      (call_script, "script_get_dest_color_from_rgb", reg2, reg3, reg4),
      (assign, ":cur_color", reg0),
      (overlay_set_color, "$g_presentation_obj_2", ":cur_color"),
      (try_begin),
        (eq, "$g_presentation_state", recolor_kingdom),
        (troop_get_slot, ":cur_faction", "trp_temp_array_a", "$temp"),
        (faction_set_color, ":cur_faction", ":cur_color"),
      (else_try),
        (eq, "$g_presentation_state", recolor_heraldic),
        (troop_get_slot, ":banner", "trp_player", slot_troop_banner_scene_prop),
        (val_sub, ":banner", banner_scene_props_begin),
        (troop_set_slot, "trp_banner_background_color_array", ":banner", ":cur_color"),
      (else_try),
        (eq, "$g_presentation_state", recolor_groups),
        (troop_set_slot, "trp_multiplayer_data", "$temp", ":cur_color"),
      (try_end),
      (call_script, "script_convert_rgb_code_to_html_code", reg2, reg3, reg4),
      (overlay_set_text, "$g_presentation_obj_9", "str_html"),
    ]),


#WSE

#script_wse_multiplayer_message_received
# Called each time a composite multiplayer message is received
# INPUT
# script param 1 = sender player no
# script param 2 = event no
("wse_multiplayer_message_received", [
	(store_script_param, ":player_no", 1),
	(store_script_param, ":event_no", 2),
]),

#script_wse_game_saved
# Called each time after game is saved successfully
("wse_game_saved", [
]),

#script_wse_chat_message_received
# Called each time a chat message is received (both for servers and clients)
# INPUT
# script param 1 = sender player no
# script param 2 = chat type (0 = global, 1 = team)
# s0 = message
# OUTPUT
# trigger result = anything non-zero suppresses default chat behavior. Server will not even broadcast messages to clients.
# result string = changes message text for default chat behavior (if not suppressed).
("wse_chat_message_received", [
	(store_script_param, ":player_no", 1),
	(store_script_param, ":chat_type", 2),
]),

#script_wse_console_command_received
# Called each time a command is typed on the dedicated server console or received with RCON (after parsing standard commands)
# INPUT
# script param 1 = command type (0 - local, 1 - remote)
# s0 = text
# OUTPUT
# trigger result = anything non-zero if the command succeeded
# result string = message to display on success (if empty, default message will be used)
("wse_console_command_received", [
	(store_script_param, ":command_type", 1),
]),

#script_wse_get_agent_scale
# Called each time an agent is created
# INPUT
# script param 1 = troop no
# script param 2 = horse item no
# script param 3 = horse item modifier
# script param 4 = player no
# OUTPUT
# trigger result = agent scale (fixed point)
("wse_get_agent_scale", [
	(store_script_param, ":troop_no", 1),
	(store_script_param, ":horse_item_no", 2),
	(store_script_param, ":horse_item_modifier", 3),
	(store_script_param, ":player_no", 4),

    # (set_fixed_point_multiplier, 100),

    # (assign, ":scale", 100),

    # # (try_begin),
        # # (gt, ":horse_item_no", -1),
        # # (eq, ":horse_item_modifier", imodbit_heavy),
        # # (val_add, ":scale", 5),
        # # (set_trigger_result, ":scale"),
    # # (try_end),

    # (try_begin),
        # (gt, ":troop_no", -1),
        # (neg|troop_is_hero, ":troop_no"),
        # (troop_get_type, ":type", ":troop_no"),
        # (lt, ":type", 2),
        # (store_random_in_range, ":scale", 95, 105),
        # (store_attribute_level, ":str", ":troop_no", ca_strength),
        # (val_sub, ":str", 6),
        # (val_div, ":str", 3),
        # (val_add, ":scale", ":str"),

        # (try_begin),
            # (eq, ":type", 1),
            # (val_mul, ":scale", 93),
            # (val_div, ":scale", 100),
        # (try_end),

        # # (assign, reg0, ":scale"),
        # # (display_message, "@{reg0}"),

        # (set_trigger_result, ":scale"),
    # (try_end),


]),

#script_wse_window_opened
# Called each time a window (party/inventory/character) is opened
# INPUT
# script param 1 = window no
# script param 2 = window param 1
# script param 3 = window param 2
# OUTPUT
# trigger result = presentation that replaces the window (if not set or negative, window will open normally)
("wse_window_opened", [
	(store_script_param, ":window_no", 1),
	(store_script_param, ":window_param_1", 2),
	(store_script_param, ":window_param_2", 3),
]),

#script_game_missile_dives_into_water
# Called each time a missile dives into water
# INPUT
# script param 1 = missile item no
# script param 2 = missile item modifier
# script param 3 = launcher item no
# script param 4 = launcher item modifier
# script param 5 = shooter agent no
# script param 6 = missile no
# pos1 = water impact position and rotation
("game_missile_dives_into_water", [
	(store_script_param, ":missile_item_no", 1),
	(store_script_param, ":missile_item_modifier", 2),
	(store_script_param, ":launcher_item_no", 3),
	# (store_script_param, ":launcher_item_modifier", 4),
	# (store_script_param, ":shooter_agent_no", 5),
	# (store_script_param, ":missile_no", 6),

    (play_sound_at_position, "snd_jump_end_water", pos1),
    (particle_system_burst, "psys_game_water_splash_2", pos1, 40),

]),

#script_all_enemies_routed
# This script checks that all enemies are routed or killed.
# INPUT: none
# OUTPUT: reg0 = enemies routed 0 or 1
("all_enemies_routed", [
  (assign, ":enemies_remaining", 0),
  (try_for_agents, ":agent"),
    (neg|agent_is_ally, ":agent"),
    (agent_is_alive, ":agent"),
    (agent_is_human, ":agent"),
    (agent_get_slot, ":routing", ":agent", slot_agent_is_running_away),
    (eq, ":routing", 0),
    (val_add, ":enemies_remaining", 1),
  (try_end),
  (assign, reg10, ":enemies_remaining"),
]),

#jacobhinds Morale Code BEGIN

#script_cf_calculate_battle_ratio
#assigns battle size difference
#Inputs = none
#Outputs = none
	("cf_calculate_battle_ratio",
		[
			#bugfix; prevents earlier scripts from enforcing
			#fixed_point_* operations
			#(set_fixed_point_multiplier, 1),

			(assign, "$battle_ratio", 0),

			(assign, "$j_num_us_ready", 0),
			(assign, "$j_num_us_wounded", 0),
			(assign, "$j_num_us_routed", 0),
			(assign, "$j_num_us_dead", 0),

			(assign, "$j_num_allies_ready", 0),
			(assign, "$j_num_allies_wounded", 0),
			(assign, "$j_num_allies_routed", 0),
			(assign, "$j_num_allies_dead", 0),

			(assign, "$j_num_enemies_ready", 0),
			(assign, "$j_num_enemies_wounded", 0),
			(assign, "$j_num_enemies_routed", 0),
			(assign, "$j_num_enemies_dead", 0),

			#count and categorize agents (me, ally, enemy/wounded, dead, routed, alive)
			(try_for_agents, ":cur_agent"),
			  (agent_is_human, ":cur_agent"),
			  (agent_get_party_id, ":agent_party", ":cur_agent"),
			  (try_begin),
				(eq, ":agent_party", "p_main_party"),
				(try_begin),
				  (agent_is_alive, ":cur_agent"),
				  (val_add, "$j_num_us_ready", 1),
				(else_try),
				  (agent_is_wounded, ":cur_agent"),
				  (val_add, "$j_num_us_wounded", 1),
				(else_try),
				  (agent_is_routed, ":cur_agent"),
				  (val_add, "$j_num_us_routed", 1),
				(else_try),
				  (val_add, "$j_num_us_dead", 1),
				(try_end),
			  (else_try),
				(agent_is_ally, ":cur_agent"),
				(try_begin),
				  (agent_is_alive, ":cur_agent"),
				  (val_add, "$j_num_allies_ready", 1),
				(else_try),
				  (agent_is_wounded, ":cur_agent"),
				  (val_add, "$j_num_allies_wounded", 1),
				(else_try),
				  (agent_is_routed, ":cur_agent"),
				  (val_add, "$j_num_allies_routed", 1),
				(else_try),
				  (val_add, "$j_num_allies_dead", 1),
				(try_end),
			  (else_try),
				(try_begin),
				  (agent_is_alive, ":cur_agent"),
				  (val_add, "$j_num_enemies_ready", 1),
				(else_try),
				  (agent_is_wounded, ":cur_agent"),
				  (val_add, "$j_num_enemies_wounded", 1),
				(else_try),
				  (agent_is_routed, ":cur_agent"),
				  (val_add, "$j_num_enemies_routed", 1),
				(else_try),
				  (val_add, "$j_num_enemies_dead", 1),
				(try_end),
			  (try_end),
			(try_end),

			#don't think I need these
			# (assign, ":ratio", 0),
			# (assign, ":ratio_3", 0),
			# (assign, ":difference", 0),
			# (assign, ":enemy_sqrt", 0),
			# (assign, ":ally_sqrt", 0),

			# ALLY STRENGTH
			(assign, ":ally_strength", 1),
			(val_add, ":ally_strength", "$j_num_enemies_routed"),
			(val_add, ":ally_strength", "$j_num_enemies_dead"),
			(val_add, ":ally_strength", "$j_num_enemies_wounded"),
			#ready is counted three times
			(val_add, ":ally_strength", "$j_num_us_ready"),
			(val_add, ":ally_strength", "$j_num_us_ready"),
			(val_add, ":ally_strength", "$j_num_us_ready"),
			(val_add, ":ally_strength", "$j_num_allies_ready"),
			(val_add, ":ally_strength", "$j_num_allies_ready"),
			(val_add, ":ally_strength", "$j_num_allies_ready"),

			# ENEMY STRENGTH
			(assign, ":enemy_strength", 1),
			(val_add, ":enemy_strength", "$j_num_us_dead"),
			(val_add, ":enemy_strength", "$j_num_us_wounded"),
			(val_add, ":enemy_strength", "$j_num_us_routed"),
			(val_add, ":enemy_strength", "$j_num_allies_dead"),
			(val_add, ":enemy_strength", "$j_num_allies_wounded"),
			(val_add, ":enemy_strength", "$j_num_allies_routed"),
			#ready is counted three times
			(val_add, ":enemy_strength", "$j_num_enemies_ready"),
			(val_add, ":enemy_strength", "$j_num_enemies_ready"),
			(val_add, ":enemy_strength", "$j_num_enemies_ready"),

			#(A*10/E)
			#10/1 ratio = 10,000 morale penalty
			(store_mul, ":enemy_value", ":enemy_strength", battle_ratio_multiple),
			(val_div, ":enemy_value", ":ally_strength"),

			#(E*10/A)
			(store_mul, ":ally_value", ":ally_strength", battle_ratio_multiple),
			(val_div, ":ally_value", ":enemy_strength"),

			#if enemy value is greater, use negative of that.
			(try_begin),
				(gt, ":enemy_value", ":ally_value"),
				(val_sub, ":enemy_value", battle_ratio_multiple),
				(store_sub, ":enemy_value", 0, ":enemy_value"),
				(assign, "$battle_ratio", ":enemy_value"),
			(else_try),
				(val_sub, ":ally_value", battle_ratio_multiple),
				(assign, "$battle_ratio", ":ally_value"),
			(try_end),

			#(val_clamp, "$battle_ratio", -max_ratio, max_ratio),

			# (assign, reg2, ":enemy_value"),
			# (assign, reg1, ":ally_value"),

			#(assign, reg0, "$battle_ratio"),
			#(display_message, "@Battle Ratio:{reg0}"),


			#(sqrt A - sqrt E)^3 + (A-E) (unused)

				#(sqrt A - sqrt E)^3
				# (store_sqrt, ":enemy_sqrt", ":enemy_strength"),
				# (store_sqrt, ":ally_sqrt", ":ally_strength"),
				# (store_sub, ":ratio", ":ally_sqrt", ":enemy_sqrt"),
				# #I get the feeling store_pow doesn't work or is deprecated in some way; keep getting weird results
				# #perhaps use cumbersome approach instead:
				# (store_pow, ":ratio_3", ":ratio", 3),
				# # (store_mul, ":ratio_3", ":ratio", ":ratio"), #squared
				# # (val_mul, ":ratio_3", ":ratio"), #cubed

				# #(A-E)
				# (store_sub, ":difference", ":ally_strength", ":enemy_strength"),

			# (store_add, "$battle_ratio", ":difference", ":ratio_3"),
			# (val_mul, "$battle_ratio", 10),
			# (val_mul, "$battle_ratio", 10),

		#housekeeping BEGIN
			# (assign, reg2, "$battle_ratio"),
			# (assign, reg3, ":ally_strength"),
			# (assign, reg4, ":enemy_strength"),
			# (display_message, "@{reg3}/{reg4}={reg2}"),

			#find average morale for each side
			# (assign, ":enemy_morale", 1),
			# (assign, ":ally_morale", 1),
			# (assign, ":ally_amount", 1),

			#store morale for all troops
			# (try_for_agents,":cur_agent"),
				# (agent_is_human, ":cur_agent"),
				# (agent_is_alive, ":cur_agent"),
				# (agent_get_slot, ":agent_courage_score", ":cur_agent", slot_agent_courage_score),
				# (try_begin),
					# (agent_is_ally, ":cur_agent"),
					# (val_add, ":ally_morale", ":agent_courage_score"),
				# (else_try),
					# (val_add, ":enemy_morale", ":agent_courage_score"),
				# (try_end),
			# (try_end),

			# (store_add, ":ally_amount", "$j_num_us_ready", "$j_num_allies_ready"),

			# (store_div, reg6, ":ally_morale", ":ally_amount"),
			# (store_div, reg7, ":enemy_morale", "$j_num_enemies_ready"),
			# (display_message, "@Morale: {reg6}/{reg7}"),

			#check that fixed_point_whatever or something else isn't screwing me over
			#answer: it is, and tends to fluctuate
			# (store_sqrt, ":four", 16),
			# (assign, reg5, ":four"),
			# (display_message, "@the square root of sixteen is {reg5}"),
		#housekeeping END

			#100-10	= ~400
			#100-30	= ~150
			#100-50	= ~75

			#50-10	= ~100
			#50-30	= ~25
			#50-40	= ~10
		]
	),

#scipt_cf_agent_can_rout
#determines whether a troop can rout or not (more than 10% casualties)
#input: cur_agent
("cf_agent_can_rout", [
	(store_script_param, ":agent", 1),

	(try_begin),
		(agent_is_ally, ":agent"),
		#count ready allies
		(assign, ":ready", "$j_num_us_ready"),
		(val_add, ":ready", "$j_num_allies_ready"),

		#count deady allies
		(store_add, ":deady", "$j_num_us_wounded", "$j_num_us_routed"),
		(val_add, ":deady", "$j_num_us_dead"),
		(val_add, ":deady", "$j_num_allies_wounded"),
		(val_add, ":deady", "$j_num_allies_routed"),
		(val_add, ":deady", "$j_num_allies_dead"),
		(val_mul, ":deady", 10),
	(else_try),
		#count ready enemies
		(assign, ":ready", "$j_num_enemies_ready"),

		#count deady enemies
		(store_add, ":deady", "$j_num_enemies_wounded", "$j_num_enemies_routed"),
		(val_add, ":deady", "$j_num_enemies_dead"),
		(val_mul, ":deady", 10),
	(try_end),
	# (display_message, "@agents cannot rout"),
	(gt, ":deady", ":ready"),
	# (display_message, "@agents can rout"),
]),
#jacobhinds Morale Code END

###dckplmc scripts - begin TODO: append in different file

  # script_setup_camp_scene
  # Input: arg1 = center_no, arg2 = mission_template_no
  # Output: none
  ("setup_camp_scene",
    [
      (party_get_current_terrain, ":terrain_type", "p_main_party"),
      (assign, ":scene_to_use", "scn_camp_scene_plain"),
      (try_begin),
        (this_or_next|eq, ":terrain_type", rt_steppe),
        (eq, ":terrain_type", rt_steppe_forest),
        (assign, ":scene_to_use", "scn_camp_scene_steppe"),
      (else_try),
        (this_or_next|eq, ":terrain_type", rt_plain),
        (eq, ":terrain_type", rt_forest),
        (assign, ":scene_to_use", "scn_camp_scene_plain"),
      (else_try),
        (this_or_next|eq, ":terrain_type", rt_snow),
        (eq, ":terrain_type", rt_snow_forest),
        (assign, ":scene_to_use", "scn_camp_scene_snow"),
      (else_try),
        (this_or_next|eq, ":terrain_type", rt_desert),
        (eq, ":terrain_type", rt_desert_forest),
        (assign, ":scene_to_use", "scn_camp_scene_desert"),
      (else_try),
        (this_or_next|eq, ":terrain_type", rt_river),
        (eq, ":terrain_type", rt_water), #figure this out later
        (assign, ":scene_to_use", "scn_sea_1"),

        (party_get_slot, ":ship_type", "p_main_party", slot_party_ship_type),
        (try_begin),
          (eq, ":ship_type", 1),
          (assign, ":scene_to_use", "scn_sea_1"),
        (else_try),
          (eq, ":ship_type", 2),
          (assign, ":scene_to_use", "scn_sea_2"),
        (else_try),
          (eq, ":ship_type", 3),
          (assign, ":scene_to_use", "scn_sea_3"),
        (else_try),
          (eq, ":ship_type", 4),
          (assign, ":scene_to_use", "scn_sea_4"),
        (try_end),

       (try_for_range, ":entry_no", 33, 40),
         (mission_tpl_entry_set_override_flags, "mt_camp", ":entry_no", af_override_horse),
       (try_end),

      (else_try),
        (eq, ":terrain_type", rt_bridge),
		(try_for_parties, ":party_no"),
			(is_between, ":party_no", "p_bridge_1", "p_looter_spawn_point"),
			(store_distance_to_party_from_party, ":distance", ":party_no", "p_main_party"),
			(lt, ":distance", 2),
			(party_get_icon, ":icon", ":party_no"),
			(try_begin),
				(eq, ":icon", "icon_bridge_snow_a"),
				(assign, ":scene_to_use", "scn_camp_scene_snow"),
			(else_try),
				(assign, ":scene_to_use", "scn_camp_scene_plain"),
			(try_end),
		(try_end),
      (try_end),
	  (modify_visitors_at_site, ":scene_to_use"),
	  (reset_visitors),
	# (set_visitor,1,"trp_follower_woman"),

	(assign, ":cur_entry", 2),

    (assign, ":entry_1_assigned", 0),

    (troop_get_slot, ":spouse", "trp_player", slot_troop_spouse),

   (party_get_num_companion_stacks, ":num_stacks", "p_main_party"),
   (try_for_range, ":troop_iterator", 0, ":num_stacks"), #1st pass: grab all heroes
	 (party_stack_get_troop_id, ":cur_troop_id", "p_main_party", ":troop_iterator"),
	 (troop_is_hero, ":cur_troop_id"),
	 (neq, ":cur_troop_id", "trp_player"),
	 (try_begin),
		(ge, ":cur_entry", 40),
		(assign, ":num_stacks", -1), #break the loop
	 (else_try),
         (eq, ":cur_troop_id", ":spouse"),
		 (set_visitor, 1, ":cur_troop_id"), #is spouse
         (assign, ":entry_1_assigned", 1),
	 (else_try),
		 (set_visitor, ":cur_entry", ":cur_troop_id"),
		 (val_add, ":cur_entry", 1),
	 (try_end),
   (try_end),

   #2nd pass: get anyone else
   (try_for_range, ":troop_iterator", 0, ":num_stacks"),
	 (party_stack_get_troop_id, ":cur_troop_id", "p_main_party", ":troop_iterator"),
	 (neq, ":cur_troop_id", "trp_player"),
	 (neg|troop_is_hero, ":cur_troop_id"),
	 (try_begin),
		(ge, ":cur_entry", 40),
		(assign, ":num_stacks", -1), #break the loop
	 (else_try),
		 (party_stack_get_size, ":stack_size","p_main_party",":troop_iterator"),
		 (party_stack_get_num_wounded, ":num_wounded","p_main_party",":troop_iterator"),
		 (val_sub, ":stack_size", ":num_wounded"),
		 (gt, ":stack_size", 0),
		 (try_for_range, ":stack_iterator", 0, ":stack_size"), #nested loop ayy lmao
			 (try_begin),
				(ge, ":cur_entry", 40),
				(assign, ":stack_size", -1), #break the loop
             (else_try),
                 (neq, ":entry_1_assigned", 1),
                 (this_or_next|eq, ":cur_troop_id", "trp_prostitute"),
                 (eq, ":cur_troop_id", "trp_courtesan"),
                 (set_visitor, 1, ":cur_troop_id"),
                 (assign, ":entry_1_assigned", 1),
			 (else_try),
				 (store_random_in_range,":troop_dna",0,1000),
				 (set_visitor, ":cur_entry", ":cur_troop_id", ":troop_dna"),
                 (troop_set_slot, "trp_temp_array_c", ":cur_entry", ":troop_dna"),
				 (val_add, ":cur_entry", 1),
			 (try_end),
		 (try_end),
	  (try_end),
   (try_end),

	#prisoners
	(assign, ":cur_entry", 40),
	(party_get_num_prisoner_stacks, ":prisoner_stacks","p_main_party"),
    (try_for_range, ":troop_iterator", 0, ":prisoner_stacks"), #1st pass: grab all heroes
	 (party_prisoner_stack_get_troop_id, ":cur_troop_id", "p_main_party", ":troop_iterator"),
	 (troop_is_hero, ":cur_troop_id"),
	 (neq, ":cur_troop_id", "trp_player"),
	 (try_begin),
		(ge, ":cur_entry", 48),
		(assign, ":troop_iterator", ":prisoner_stacks"), #break the loop
	 (else_try),
		 (set_visitor, ":cur_entry", ":cur_troop_id"),
		 (store_add, ":cur_entry", ":cur_entry", 1),
	 (try_end),
   (try_end),

   #2nd pass: get anyone else
   (party_get_num_prisoner_stacks, ":prisoner_stacks","p_main_party"),
   (try_for_range, ":troop_iterator", 0, ":prisoner_stacks"),
	 (party_prisoner_stack_get_troop_id, ":cur_troop_id", "p_main_party", ":troop_iterator"),
	 (neg|troop_is_hero, ":cur_troop_id"),
	 (try_begin),
		(ge, ":cur_entry", 48),
		(assign, ":troop_iterator", ":num_stacks"), #break the loop
	 (else_try),
		 (party_prisoner_stack_get_size, ":stack_size","p_main_party",":troop_iterator"),
		 (gt, ":stack_size", 0),
		 (try_for_range, ":stack_iterator", 0, ":stack_size"), #nested loop ayy lmao
			 (try_begin),
				(ge, ":cur_entry", 48),
				(assign, ":stack_size", -1), #break the loop
			 (else_try),
				 (store_random_in_range,":troop_dna",0,1000),
				 (set_visitor, ":cur_entry", ":cur_troop_id", ":troop_dna"),
                 (troop_set_slot, "trp_temp_array_c", ":cur_entry", ":troop_dna"),
				 (val_add, ":cur_entry", 1),
			 (try_end),
		 (try_end),
	  (try_end),
   (try_end),

	(mission_tpl_entry_clear_override_items,"mt_camp",1),
	(store_random_in_range,":r",0,2),
	(try_begin),
		(eq,":r",0),
		(mission_tpl_entry_add_override_item,"mt_camp",1,"itm_lute"),
	(else_try),
		(mission_tpl_entry_add_override_item,"mt_camp",1,"itm_lyre"),
	(try_end),

	  (assign, "$talk_context", tc_camp_talk),
      (jump_to_scene,":scene_to_use"),
  ]),

  #script_training_ground_sub_routine_2_for_melee_details_fuck
  # INPUT:
  # value
  #OUTPUT:
  # none
  ("training_ground_sub_routine_2_for_melee_details_fuck",
   [
     (store_script_param, ":value", 1),
     (val_sub, ":value", 1),
     (try_begin),
       (eq, ":value", -3),
	   (assign, reg0, -1),
     (else_try),
       (eq, ":value", -2),
       (call_script, "script_remove_random_fit_party_member_from_stack_selection"),
     (else_try),
       (call_script, "script_remove_fit_party_member_from_stack_selection", ":value"),
     (try_end),
     (assign, ":troop_id", reg0),
     (store_sub, ":slot_index", "$temp_2", 1),
     (troop_set_slot, "trp_temp_array_a", ":slot_index", ":troop_id"),
     (troop_set_slot, "trp_temp_array_b", ":slot_index", -1),
     (try_begin),
       (eq, "$temp", "$temp_2"),
       (call_script, "script_start_fucking", "$temp", "$g_training_ground_melee_training_scene"),
     (else_try),
       (val_add, "$temp_2", 1),
       (jump_to_menu, "mnu_fuck_3"),
     (try_end),
     ]),

  #script_start_fucking
  # INPUT:
  # value
  #OUTPUT:
  # none
  ("start_fucking",
   [
     (store_script_param, ":training_param", 1),
     (store_script_param, ":scene", 2),

		  (set_jump_mission,"mt_fucking"),
		  (modify_visitors_at_site, ":scene"),
		  (reset_visitors),

       (try_for_range, ":i", 0, ":training_param"),
         (troop_get_slot, ":cur_troop", "trp_temp_array_a", ":i"),
         (troop_get_slot, ":cur_troop_dna", "trp_temp_array_b", ":i"),
		 (ge, ":cur_troop", 0),

		(call_script, "script_dplmc_store_troop_is_female_reg", ":cur_troop", 65),
		(assign, ":is_female", reg65),

        (try_begin),
            (eq, "$g_player_is_captive", 1),
            (mission_tpl_entry_set_override_flags, "mt_fucking", 2, af_override_horse|af_override_body|af_override_weapons),
            (mission_tpl_entry_set_override_flags, "mt_fucking", 3, af_override_horse|af_override_body),
            (mission_tpl_entry_set_override_flags, "mt_fucking", 4, af_override_horse|af_override_body),
        (try_end),

		 #(neq, ":cur_troop", "bandit_leaders_end"),
		 (try_begin),
			(eq, ":i", 0),
			(assign, ":cur_entry_point", 1),
		 (else_try),
			(eq, ":i", 1),
			(try_begin),
				(eq, "$g_sex_position", 0),
				(assign, ":cur_entry_point", 2),
			(else_try),
				(assign, ":cur_entry_point", 3),
			(try_end),
			(try_begin),
				(eq, ":is_female", 1),
				(mission_tpl_entry_add_override_item,"mt_fucking",":cur_entry_point","itm_strapon"),
			(try_end),
		 (else_try),
			(eq, ":i", 2),
			(assign, ":cur_entry_point", 5),
		 (else_try),
			(eq, ":i", 3),
			(assign, ":cur_entry_point", 4),
			(try_begin),
				(eq, ":is_female", 1),
				(mission_tpl_entry_add_override_item,"mt_fucking",":cur_entry_point","itm_strapon"),
			(try_end),
		 (else_try),
			(assign, ":cur_entry_point", 0),
		 (try_end),


         (try_begin),
            (troop_get_type, ":type", ":cur_troop"),
            (lt, ":type", 2),
            (val_add, ":type", 2),
            (troop_set_type, ":cur_troop", ":type"),
         (try_end),
         (try_begin),
           (this_or_next|troop_is_hero, ":cur_troop"),
            (lt, ":cur_troop_dna", 0),
            (set_visitor, ":cur_entry_point", ":cur_troop"),
         (else_try),
            (set_visitor, ":cur_entry_point", ":cur_troop", ":cur_troop_dna"),
         (try_end),
       (try_end),

		(set_visitor, 0, "trp_bandit_leaders_end"),

		  (jump_to_scene,":scene"),
		  (change_screen_mission),



     ]),




  # #Formations Scripts
  # script_field_start_position by motomataru
  # Input: team
  # Output: pos2 = current army position advanced by cavalry wedge depth over
  # infantry formation depth
  # Originally written to prevent map border accidents when setting up player
  # army at its spawn point
  ("field_start_position", [
      (store_script_param, ":fteam", 1),

      (assign, ":depth_cavalry", 0),
      (assign, ":largest_mounted_division_size", 0),
      (team_get_leader, ":fleader", ":fteam"),

      (try_begin),
        (ge, ":fleader", 0),
        (agent_get_position, pos2, ":fleader"),
      (else_try),
        (call_script, "script_battlegroup_get_position", pos2, ":fteam", grc_everyone),
      (try_end),

      (try_for_range, ":division", 0, 9),
        (store_add, ":slot", slot_team_d0_type, ":division"),
        (team_slot_eq, ":fteam", ":slot", sdt_cavalry),
        (store_add, ":slot", slot_team_d0_size, ":division"),
        (team_get_slot, reg0, ":fteam", ":slot"),
        (lt, ":largest_mounted_division_size", reg0),
        (assign, ":largest_mounted_division_size", reg0),
      (try_end),

      (try_begin),
        (gt, ":largest_mounted_division_size", 0),
        (val_mul, ":largest_mounted_division_size", 2),
        (convert_to_fixed_point, ":largest_mounted_division_size"),
        (store_sqrt, ":depth_cavalry", ":largest_mounted_division_size"),
        (convert_from_fixed_point, ":depth_cavalry"),
        (val_sub, ":depth_cavalry", 1),

        (store_mul, reg0, formation_start_spread_out, 50),
        (val_add, reg0, formation_minimum_spacing_horse_length),
        (val_mul, ":depth_cavalry", reg0),

        (store_mul, ":depth_infantry", formation_start_spread_out, 50),
        (val_add, ":depth_infantry", formation_minimum_spacing),
        (val_mul, ":depth_infantry", 2),
        (val_sub, ":depth_cavalry", ":depth_infantry"),

        (gt, ":depth_cavalry", 0),
        (call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, ":fteam", grc_everyone),
        (call_script, "script_point_y_toward_position", pos2, Enemy_Team_Pos),
        (position_move_y, pos2, ":depth_cavalry"),
      (try_end),]),

  # script_division_reset_places by motomataru
  # Input: none
  # Output: none
  # Resets globals for placing divisions around player for
  # script_battlegroup_place_around_leader
  ("division_reset_places", [
      (assign, "$next_cavalry_place", formation_minimum_spacing_horse_width),	#first spot RIGHT of the player
      (assign, "$next_archer_place", 1000),	#first spot 10m FRONT of the player
      (assign, "$next_infantry_place", -1 * formation_minimum_spacing_horse_width),	#first spot LEFT of the player
  ]),

  # script_battlegroup_place_around_leader by motomataru
  # Input: team, division, team leader
  # Output: pos61 division position, moves pos1
  ("battlegroup_place_around_leader", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":fleader", 3),

      (try_begin),
        (le, ":fleader", 0),
        (display_message, "@{!}script_battlegroup_place_around_leader: invalid leader agent (bad call)"),

      (else_try),
        (agent_get_group, reg0, ":fleader"),
        (neq, reg0, ":fteam"),
        (display_message, "@{!}script_battlegroup_place_around_leader: leader team mismatch (bad call)"),

      (else_try),
        (agent_get_position, pos1, ":fleader"),
        (call_script, "script_battlegroup_place_around_pos1", ":fteam", ":fdivision", ":fleader"),
      (try_end),]),

  # script_battlegroup_place_around_pos1 by motomataru
  # Input: team, division
  # Output: pos61 division position, moves pos1
  ("battlegroup_place_around_pos1", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":fleader", 3),

      (assign, ":store_fpm", 1),
      (convert_to_fixed_point, ":store_fpm"),
      (set_fixed_point_multiplier, 100),

      (store_sub, ":player_division", "$FormAI_player_in_division", 1),
      (try_begin),
        (eq, ":player_division", ":fdivision"),
        (assign, ":first_member_is_player", 1),
      (else_try),
        (assign, ":first_member_is_player", 0),
      (try_end),

      (try_begin),
        (eq, "$FormAI_autorotate", 1),
        (call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, ":fteam", grc_everyone),
        (neq, reg0, 0),	#more than 0 enemies still alive?
        (call_script, "script_point_y_toward_position", pos1, Enemy_Team_Pos),
      (try_end),

      (store_add, ":slot", slot_team_d0_type, ":fdivision"),
      (team_get_slot, ":sd_type", ":fteam", ":slot"),
      (store_add, ":slot", slot_team_d0_size, ":fdivision"),
      (team_get_slot, ":num_troops", ":fteam", ":slot"),
      (store_add, ":slot", slot_team_d0_formation, ":fdivision"),
      (team_get_slot, ":fformation", ":fteam", ":slot"),
      (store_add, ":slot", slot_team_d0_formation_space, ":fdivision"),
      (team_get_slot, ":formation_extra_spacing", ":fteam", ":slot"),

      #handle memorized placement
      (try_begin),
        (eq, ":first_member_is_player", 0),
        (store_add, ":slot", slot_faction_d0_mem_relative_x_flag, ":fdivision"),
        (faction_get_slot, ":value", "fac_player_faction", ":slot"),	#only used for player now
        (neq, ":value", 0),

        (position_move_x, pos1, ":value", 0),
        (store_add, ":slot", slot_faction_d0_mem_relative_y, ":fdivision"),
        (faction_get_slot, ":value", "fac_player_faction", ":slot"),	#only used for player now
        (position_move_y, pos1, ":value", 0),
        (copy_position, pos61, pos1),
        (try_begin),
          (gt, ":fformation", formation_none),
          (try_begin),
            (this_or_next | eq, ":sd_type", sdt_cavalry),
            (eq, ":sd_type", sdt_harcher),
            (call_script, "script_form_cavalry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", 0),
          (else_try),
            (eq, ":sd_type", sdt_archer),
            (call_script, "script_get_centering_amount", formation_default, ":num_troops", ":formation_extra_spacing"),
            (val_mul, reg0, -1),
            (position_move_x, pos1, reg0, 0),
            (call_script, "script_form_archers", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", 0, ":fformation"),
          (else_try),
            (call_script, "script_get_centering_amount", ":fformation", ":num_troops", ":formation_extra_spacing"),
            (position_move_x, pos1, reg0, 0),
            (call_script, "script_form_infantry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", 0, ":fformation"),
          (try_end),
        (try_end),

      #default placement per division type
      (else_try),
        (this_or_next | eq, ":sd_type", sdt_cavalry),
        (eq, ":sd_type", sdt_harcher),
        (try_begin),
          (eq, ":first_member_is_player", 0),
          (position_move_x, pos1, "$next_cavalry_place", 0),
        (try_end),

        (try_begin),
          (gt, ":fformation", formation_none),
          (store_mul, ":troop_space", ":formation_extra_spacing", 50),
          (val_add, ":troop_space", formation_minimum_spacing_horse_width),
          (convert_to_fixed_point, ":num_troops"),
          (store_sqrt, ":formation_width", ":num_troops"),
          (val_mul, ":formation_width", ":troop_space"),
          (convert_from_fixed_point, ":formation_width"),
          (val_sub, ":formation_width", ":troop_space"),
          (store_div, reg0, ":formation_width", 2),
          (position_move_x, pos1, reg0, 0),	#cavalry set up RIGHT of leader
          (copy_position, pos61, pos1),
          (call_script, "script_form_cavalry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", ":first_member_is_player"),

        #handle Native's way of doing things
        (else_try),
          (store_mul, ":troop_space", ":formation_extra_spacing", 133),	#cm added by each Spread Out
          (val_add, ":troop_space", 150),	#minimum spacing

          #WFaS multi-ranks
          (try_begin),
            (eq, ":fformation", formation_2_row),
            (val_div, ":num_troops", 2),
          (else_try),
            (eq, ":fformation", formation_3_row),
            (val_div, ":num_troops", 3),
          (else_try),
            (eq, ":fformation", formation_4_row),
            (val_div, ":num_troops", 4),
          (else_try),
            (eq, ":fformation", formation_5_row),
            (val_div, ":num_troops", 5),

          (else_try),	#WB multi-ranks
            (lt, ":formation_extra_spacing", 0),
            (assign, ":troop_space", 200),
            (val_mul, ":formation_extra_spacing", -1),
            (val_add, ":formation_extra_spacing", 1),
            (val_div, ":num_troops", ":formation_extra_spacing"),
          (try_end),

          (store_mul, ":formation_width", ":num_troops", ":troop_space"),
          (store_div, reg0, ":formation_width", 2),
          (position_move_x, pos1, reg0, 0),	#cavalry set up RIGHT of leader
          (copy_position, pos61, pos1),
        (try_end),

        (try_begin),
          (eq, ":first_member_is_player", 0),
          (val_add, "$next_cavalry_place", ":formation_width"),
          (val_add, "$next_cavalry_place", formation_minimum_spacing_horse_width),
        (try_end),

      (else_try),
        (eq, ":sd_type", sdt_archer),
        (try_begin),
          (eq, ":first_member_is_player", 0),
          (position_move_y, pos1, "$next_archer_place"),	#archers set up FRONT of leader
          (val_add, "$next_archer_place", 500),	#next archers 5m FRONT of these
        (try_end),
        (copy_position, pos61, pos1),
        (try_begin),
          (gt, ":fformation", formation_none),
          (call_script, "script_get_centering_amount", formation_default, ":num_troops", ":formation_extra_spacing"),
          (val_mul, reg0, -1),
          (position_move_x, pos1, reg0, 0),
          (call_script, "script_form_archers", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", ":first_member_is_player", ":fformation"),
        (try_end),

      (else_try),
        (eq, ":sd_type", sdt_skirmisher),
        (try_begin),
          (eq, ":first_member_is_player", 0),
          (position_move_y, pos1, "$next_archer_place"),	#skirmishers set up FRONT of leader
          (val_add, "$next_archer_place", 500),	#next archers 5m FRONT of these
        (try_end),
        (copy_position, pos61, pos1),
        (try_begin),
          (gt, ":fformation", formation_none),
          (call_script, "script_get_centering_amount", ":fformation", ":num_troops", ":formation_extra_spacing"),
          (position_move_x, pos1, reg0, 0),
          (call_script, "script_form_infantry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", ":first_member_is_player", ":fformation"),
        (try_end),

      (else_try),
        (try_begin),
          (eq, ":first_member_is_player", 0),
          (position_move_x, pos1, "$next_infantry_place", 0),
        (try_end),
        (copy_position, pos61, pos1),

        (try_begin),
          (gt, ":fformation", formation_none),
          (call_script, "script_form_infantry", ":fteam", ":fdivision", ":fleader", ":formation_extra_spacing", ":first_member_is_player", ":fformation"),
          (call_script, "script_get_centering_amount", ":fformation", ":num_troops", ":formation_extra_spacing"),
          (store_mul, ":formation_width", 2, reg0),
          (store_mul, ":troop_space", ":formation_extra_spacing", 50),
          (val_add, ":troop_space", formation_minimum_spacing),
          (val_add, ":formation_width", ":troop_space"),
          (val_mul, reg0, -1),	#infantry set up LEFT of leader
          (position_move_x, pos61, reg0, 0),

        #handle Native's way of doing things
        (else_try),
          (store_mul, ":troop_space", ":formation_extra_spacing", 75),	#Native minimum spacing not consistent but less than this
          (val_add, ":troop_space", 100),	#minimum spacing

          #WFaS multi-ranks
          (try_begin),
            (eq, ":fformation", formation_2_row),
            (val_div, ":num_troops", 2),
          (else_try),
            (eq, ":fformation", formation_3_row),
            (val_div, ":num_troops", 3),
          (else_try),
            (eq, ":fformation", formation_4_row),
            (val_div, ":num_troops", 4),
          (else_try),
            (eq, ":fformation", formation_5_row),
            (val_div, ":num_troops", 5),

          (else_try),	#WB multi-ranks
            (lt, ":formation_extra_spacing", 0),
            (assign, ":troop_space", 150),
            (val_mul, ":formation_extra_spacing", -1),
            (val_add, ":formation_extra_spacing", 1),
            (val_div, ":num_troops", ":formation_extra_spacing"),
          (try_end),

          (store_mul, ":formation_width", ":num_troops", ":troop_space"),
          (store_div, reg0, ":formation_width", 2),
          (val_mul, reg0, -1),	#infantry set up LEFT of leader
          (position_move_x, pos61, reg0, 0),
        (try_end),

        (try_begin),
          (eq, ":first_member_is_player", 0),
          (val_sub, "$next_infantry_place", ":formation_width"),	#next infantry 1m LEFT of these
          (val_sub, "$next_infantry_place", 100),
        (try_end),
      (try_end),

      (store_add, ":slot", slot_team_d0_move_order, ":fdivision"),
      (team_set_slot, ":fteam", ":slot", mordr_hold),
      (set_show_messages, 0),
      (team_get_movement_order, reg0, ":fteam", ":fdivision"),
      (try_begin),
        (neq, reg0, mordr_hold),
        (team_give_order, ":fteam", ":fdivision", mordr_hold),
      (try_end),
      (call_script, "script_set_formation_destination", ":fteam", ":fdivision", pos61),
      (set_show_messages, 1),
      (set_fixed_point_multiplier, ":store_fpm"),]),

  # script_form_cavalry by motomataru
  # Input: (pos1), team, division, agent number of team leader, spacing, flag
  # TRUE to include team leader in formation
  # Output: none
  # Form in wedge, (now not) excluding horse archers
  # Creates formation starting at pos1
  ("form_cavalry", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":fleader", 3),
      (store_script_param, ":formation_extra_spacing", 4),
      (store_script_param, ":include_leader", 5),
      (store_mul, ":extra_space", ":formation_extra_spacing", 50),
      (store_add, ":x_distance", formation_minimum_spacing_horse_width, ":extra_space"),
      (store_add, ":y_distance", formation_minimum_spacing_horse_length, ":extra_space"),
      (assign, ":max_level", 0),
      (try_for_agents, ":agent"),
        (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
        (agent_get_troop_id, ":troop_id", ":agent"),
        (store_character_level, ":troop_level", ":troop_id"),
        (gt, ":troop_level", ":max_level"),
        (assign, ":max_level", ":troop_level"),
      (end_try),
      (assign, ":column", 1),
      (assign, ":rank_dimension", 1),
      (store_mul, ":neg_y_distance", ":y_distance", -1),
      (store_mul, ":neg_x_distance", ":x_distance", -1),
      (store_div, ":wedge_adj", ":x_distance", 2),
      (store_div, ":neg_wedge_adj", ":neg_x_distance", 2),
      (assign, ":form_left", 1),
      (try_begin),
        (eq, ":include_leader", 0),
        (store_add, ":slot", slot_team_d0_first_member, ":fdivision"),
        (team_set_slot, ":fteam", ":slot", -1),
      (else_try),	#after leader, move to next position (copied from below)
        (team_set_slot, ":fteam", ":slot", ":fleader"),
        (try_begin),
          (eq, ":form_left", 1),
          (position_move_x, pos1, ":neg_x_distance", 0),
        (else_try),
          (position_move_x, pos1, ":x_distance", 0),
        (try_end),
        (val_add, ":column", 1),
        (gt, ":column", ":rank_dimension"),
        (position_move_y, pos1, ":neg_y_distance", 0),
        (try_begin),
          (neq, ":form_left", 1),
          (assign, ":form_left", 1),
          (position_move_x, pos1, ":neg_wedge_adj", 0),
        (else_try),
          (assign, ":form_left", 0),
          (position_move_x, pos1, ":wedge_adj", 0),
        (try_end),
        (assign, ":column", 1),
        (val_add, ":rank_dimension", 1),
      (try_end),

      (val_add, ":max_level", 1),
      (try_for_range_backwards, ":rank_level", 0, ":max_level"),	#put troops with highest exp in front
        (try_for_agents, ":agent"),
          (agent_get_troop_id, ":troop_id", ":agent"),
          (store_character_level, ":troop_level", ":troop_id"),
          (eq, ":troop_level", ":rank_level"),
          (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
          (agent_set_scripted_destination, ":agent", pos1, 1),
          (try_begin),	#First Agent
            (store_add, ":slot", slot_team_d0_first_member, ":fdivision"),
            (neg | team_slot_ge, ":fteam", ":slot", 0),
            (team_set_slot, ":fteam", ":slot", ":agent"),
          (try_end),
          (try_begin),
            (eq, ":form_left", 1),
            (position_move_x, pos1, ":neg_x_distance", 0),
          (else_try),
            (position_move_x, pos1, ":x_distance", 0),
          (try_end),
          (val_add, ":column", 1),
          (gt, ":column", ":rank_dimension"),
          (position_move_y, pos1, ":neg_y_distance", 0),
          (try_begin),
            (neq, ":form_left", 1),
            (assign, ":form_left", 1),
            (position_move_x, pos1, ":neg_wedge_adj", 0),
          (else_try),
            (assign, ":form_left", 0),
            (position_move_x, pos1, ":wedge_adj", 0),
          (try_end),
          (assign, ":column", 1),
          (val_add, ":rank_dimension", 1),
        (end_try),
      (end_try),]),

  # script_form_archers by motomataru
  # Input: (pos1), team, division, agent number of team leader, spacing, flag
  # TRUE to include team leader in formation, formation
  # Output: none
  # Form in line, staggered if formation = formation_ranks
  # Creates formation starting at pos1
  ("form_archers", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":fleader", 3),
      (store_script_param, ":formation_extra_spacing", 4),
      (store_script_param, ":include_leader", 5),
      (store_script_param, ":archers_formation", 6),
      (store_mul, ":extra_space", ":formation_extra_spacing", 50),
      (store_add, ":distance", formation_minimum_spacing, ":extra_space"),		#minimum distance between troops
      (assign, ":total_move_y", 0),	#staggering variable
      (try_begin),
        (eq, ":include_leader", 0),
        (store_add, ":slot", slot_team_d0_first_member, ":fdivision"),
        (team_set_slot, ":fteam", ":slot", -1),
      (else_try),	#after leader, move to next position (copied from below)
        (team_set_slot, ":fteam", ":slot", ":fleader"),
        (position_move_x, pos1, ":distance", 0),
        (try_begin),
          (eq, ":archers_formation", formation_ranks),
          (val_add, ":total_move_y", 75),
          (try_begin),
            (le, ":total_move_y", 150),
            (position_move_y, pos1, 75, 0),
          (else_try),
            (position_move_y, pos1, -150, 0),
            (assign, ":total_move_y", 0),
          (try_end),
        (try_end),
      (try_end),

      (try_for_agents, ":agent"),
        (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
        (agent_set_scripted_destination, ":agent", pos1, 1),
        (try_begin),	#First Agent
          (store_add, ":slot", slot_team_d0_first_member, ":fdivision"),
          (neg | team_slot_ge, ":fteam", ":slot", 0),
          (team_set_slot, ":fteam", ":slot", ":agent"),
        (try_end),
        (position_move_x, pos1, ":distance", 0),
        (try_begin),
          (eq, ":archers_formation", formation_ranks),
          (val_add, ":total_move_y", 75),
          (try_begin),
            (le, ":total_move_y", 150),
            (position_move_y, pos1, 75, 0),
          (else_try),
            (position_move_y, pos1, -150, 0),
            (assign, ":total_move_y", 0),
          (try_end),
        (try_end),
      (try_end),]),

  # script_form_infantry by motomataru
  # Input: (pos1), team, division, agent number of team leader, spacing, flag
  # TRUE to include team leader in formation, formation
  # Output: none
  # If input "formation" is formation_default, will select a formation based on
  # faction
  # Creates formation starting at pos1
  ("form_infantry", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":fleader", 3),
      (store_script_param, ":formation_extra_spacing", 4),
      (store_script_param, ":include_leader", 5),
      (store_script_param, ":infantry_formation", 6),
      (store_mul, ":extra_space", ":formation_extra_spacing", 50),
      (store_add, ":distance", formation_minimum_spacing, ":extra_space"),		#minimum distance between troops
      (store_mul, ":neg_distance", ":distance", -1),
      (store_add, ":slot", slot_team_d0_size, ":fdivision"),
      (team_get_slot, ":num_troops", ":fteam", ":slot"),
      (try_begin),
        (eq, ":infantry_formation", formation_default),
        (call_script, "script_get_default_formation", ":fteam"),
        (assign, ":infantry_formation", reg0),
      (try_end),
      (team_get_weapon_usage_order, ":weapon_order", ":fteam", ":fdivision"),
      (team_get_hold_fire_order, ":fire_order", ":fteam", ":fdivision"),
      (assign, ":form_left", 1),
      (assign, ":column", 1),
      (assign, ":rank", 1),

      (try_begin),
        (eq, ":infantry_formation", formation_square),
        (convert_to_fixed_point, ":num_troops"),
        (store_sqrt, ":square_dimension", ":num_troops"),
        (convert_from_fixed_point, ":square_dimension"),
        (val_add, ":square_dimension", 1),
        (try_begin),
          (eq, ":include_leader", 0),
          (store_add, ":slot", slot_team_d0_first_member, ":fdivision"),
          (team_set_slot, ":fteam", ":slot", -1),
        (else_try),	#after leader, move to next position (copied from below)
          (team_set_slot, ":fteam", ":slot", ":fleader"),
          (try_begin),
            (eq, ":form_left", 1),
            (position_move_x, pos1, ":neg_distance", 0),
          (else_try),
            (position_move_x, pos1, ":distance", 0),
          (try_end),
          (val_add, ":column", 1),
          (gt, ":column", ":square_dimension"),
          (position_move_y, pos1, ":neg_distance", 0),
          (try_begin),
            (neq, ":form_left", 1),
            (assign, ":form_left", 1),
            (position_move_x, pos1, ":neg_distance", 0),
          (else_try),
            (assign, ":form_left", 0),
            (position_move_x, pos1, ":distance", 0),
          (try_end),
          (assign, ":column", 1),
          (val_add, ":rank", 1),
        (try_end),

        (try_for_agents, ":agent"),
          (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
          (call_script, "script_switch_to_noswing_weapons", ":agent", ":distance"),

          (try_begin),
            (eq, "$battle_phase", BP_Deploy),
            (agent_set_scripted_destination, ":agent", pos1),
          (else_try),
            (call_script, "script_formation_process_agent_move", ":fteam", ":fdivision", ":agent", ":rank"),
          (try_end),

          (try_begin),
            (eq, formation_reequip, 1),
            (eq, ":weapon_order", wordr_use_any_weapon),
            (try_begin),
              (this_or_next | eq, ":rank", 1),
              (this_or_next | ge, ":rank", ":square_dimension"),
              (this_or_next | eq, ":column", 1),
              (ge, ":column", ":square_dimension"),
              (call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
              (agent_set_slot, ":agent", slot_agent_inside_formation, 0),
              (agent_ai_set_always_attack_in_melee, ":agent", 0),
            (else_try),
              (agent_get_slot, ":closest_enemy", ":agent", slot_agent_nearest_enemy_agent),
              (try_begin),
                (neq, ":closest_enemy", -1),
                (agent_get_position, pos0, ":closest_enemy"),
                (get_distance_between_positions, ":enemy_distance", pos0, pos1),
                (le, ":enemy_distance", ":distance"),	#enemy closer than friends?
                (neg | position_is_behind_position, pos0, pos1),
                (call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
                (try_begin),
                  (position_is_behind_position, pos1, pos0),
                  (agent_ai_set_always_attack_in_melee, ":agent", 1),
                (else_try),
                  (agent_ai_set_always_attack_in_melee, ":agent", 0),
                (try_end),
              (else_try),
                (call_script, "script_equip_best_melee_weapon", ":agent", 0, 1, ":fire_order"),
                (agent_ai_set_always_attack_in_melee, ":agent", 1),
              (try_end),
              (agent_set_slot, ":agent", slot_agent_inside_formation, 1),
            (try_end),
          (try_end),
          (try_begin),
            (eq, ":form_left", 1),
            (position_move_x, pos1, ":neg_distance", 0),
          (else_try),
            (position_move_x, pos1, ":distance", 0),
          (try_end),
          (val_add, ":column", 1),
          (gt, ":column", ":square_dimension"),
          (position_move_y, pos1, ":neg_distance", 0),
          (try_begin),
            (neq, ":form_left", 1),
            (assign, ":form_left", 1),
            (position_move_x, pos1, ":neg_distance", 0),
          (else_try),
            (assign, ":form_left", 0),
            (position_move_x, pos1, ":distance", 0),
          (try_end),
          (assign, ":column", 1),
          (val_add, ":rank", 1),
        (end_try),

      (else_try),
        (eq, ":infantry_formation", formation_wedge),
        (try_for_range, reg0, 0, 50),
          (troop_set_slot, "trp_temp_array_a", reg0, 0),
        (try_end),
        (assign, ":max_level", 0),
        (try_for_agents, ":agent"),
          (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
          (call_script, "script_switch_to_noswing_weapons", ":agent", ":distance"),
          (agent_get_troop_id, ":troop_id", ":agent"),
          (store_character_level, ":troop_level", ":troop_id"),
          (troop_set_slot, "trp_temp_array_a", ":troop_level", 1),
          (gt, ":troop_level", ":max_level"),
          (assign, ":max_level", ":troop_level"),
        (end_try),

        (assign, ":rank_dimension", 1),
        (store_div, ":wedge_adj", ":distance", 2),
        (store_div, ":neg_wedge_adj", ":neg_distance", 2),
        (try_begin),
          (eq, ":include_leader", 0),
          (store_add, ":slot", slot_team_d0_first_member, ":fdivision"),
          (team_set_slot, ":fteam", ":slot", -1),
        (else_try),	#after leader, move to next position (copied from below)
          (team_set_slot, ":fteam", ":slot", ":fleader"),
          (try_begin),
            (eq, ":form_left", 1),
            (position_move_x, pos1, ":neg_distance", 0),
          (else_try),
            (position_move_x, pos1, ":distance", 0),
          (try_end),
          (val_add, ":column", 1),
          (gt, ":column", ":rank_dimension"),
          (position_move_y, pos1, ":neg_distance", 0),
          (try_begin),
            (neq, ":form_left", 1),
            (assign, ":form_left", 1),
            (position_move_x, pos1, ":neg_wedge_adj", 0),
          (else_try),
            (assign, ":form_left", 0),
            (position_move_x, pos1, ":wedge_adj", 0),
          (try_end),
          (assign, ":column", 1),
          (val_add, ":rank_dimension", 1),
        (try_end),

        (val_add, ":max_level", 1),
        (try_for_range_backwards, ":rank_level", 0, ":max_level"),	#put troops with highest exp in front
          (troop_slot_eq, "trp_temp_array_a", ":rank_level", 1),
          (try_for_agents, ":agent"),
            (agent_get_troop_id, ":troop_id", ":agent"),
            (store_character_level, ":troop_level", ":troop_id"),
            (eq, ":troop_level", ":rank_level"),
            (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),

            (try_begin),
              (eq, "$battle_phase", BP_Deploy),
              (agent_set_scripted_destination, ":agent", pos1),
            (else_try),
              (call_script, "script_formation_process_agent_move", ":fteam", ":fdivision", ":agent", ":rank_dimension"),
            (try_end),

            (try_begin),
              (eq, formation_reequip, 1),
              (eq, ":weapon_order", wordr_use_any_weapon),
              (try_begin),
                (this_or_next | eq, ":column", 1),
                (ge, ":column", ":rank_dimension"),
                (call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
                (agent_set_slot, ":agent", slot_agent_inside_formation, 0),
                (agent_ai_set_always_attack_in_melee, ":agent", 0),
              (else_try),
                (agent_get_slot, ":closest_enemy", ":agent", slot_agent_nearest_enemy_agent),
                (try_begin),
                  (neq, ":closest_enemy", -1),
                  (agent_get_position, pos0, ":closest_enemy"),
                  (get_distance_between_positions, ":enemy_distance", pos0, pos1),
                  (le, ":enemy_distance", ":distance"),	#enemy closer than friends?
                  (neg | position_is_behind_position, pos0, pos1),
                  (call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
                  (try_begin),
                    (position_is_behind_position, pos1, pos0),
                    (agent_ai_set_always_attack_in_melee, ":agent", 1),
                  (else_try),
                    (agent_ai_set_always_attack_in_melee, ":agent", 0),
                  (try_end),
                (else_try),
                  (call_script, "script_equip_best_melee_weapon", ":agent", 0, 1, ":fire_order"),
                  (agent_ai_set_always_attack_in_melee, ":agent", 1),
                (try_end),
                (agent_set_slot, ":agent", slot_agent_inside_formation, 1),
              (try_end),
            (try_end),
            (try_begin),
              (eq, ":form_left", 1),
              (position_move_x, pos1, ":neg_distance", 0),
            (else_try),
              (position_move_x, pos1, ":distance", 0),
            (try_end),
            (val_add, ":column", 1),
            (gt, ":column", ":rank_dimension"),
            (position_move_y, pos1, ":neg_distance", 0),
            (try_begin),
              (neq, ":form_left", 1),
              (assign, ":form_left", 1),
              (position_move_x, pos1, ":neg_wedge_adj", 0),
            (else_try),
              (assign, ":form_left", 0),
              (position_move_x, pos1, ":wedge_adj", 0),
            (try_end),
            (assign, ":column", 1),
            (val_add, ":rank_dimension", 1),
          (end_try),
        (end_try),

      (else_try),
        (eq, ":infantry_formation", formation_ranks),
        (try_for_range, reg0, 0, 50),
          (troop_set_slot, "trp_temp_array_a", reg0, 0),
        (try_end),
        (call_script, "script_calculate_default_ranks", ":num_troops"),
        (store_div, ":rank_dimension", ":num_troops", reg1),
        (val_add, ":rank_dimension", 1),
        (assign, ":max_level", 0),
        (try_for_agents, ":agent"),
          (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
          (call_script, "script_switch_to_noswing_weapons", ":agent", ":distance"),
          (agent_get_troop_id, ":troop_id", ":agent"),
          (store_character_level, ":troop_level", ":troop_id"),
          (troop_set_slot, "trp_temp_array_a", ":troop_level", 1),
          (gt, ":troop_level", ":max_level"),
          (assign, ":max_level", ":troop_level"),
        (end_try),

        (try_begin),
          (eq, ":include_leader", 0),
          (store_add, ":slot", slot_team_d0_first_member, ":fdivision"),
          (team_set_slot, ":fteam", ":slot", -1),
        (else_try),	#after leader, move to next position (copied from below)
          (team_set_slot, ":fteam", ":slot", ":fleader"),
          (try_begin),
            (eq, ":form_left", 1),
            (position_move_x, pos1, ":neg_distance", 0),
          (else_try),
            (position_move_x, pos1, ":distance", 0),
          (try_end),
          (val_add, ":column", 1),

          (gt, ":column", ":rank_dimension"),	#next rank?
          (position_move_y, pos1, ":neg_distance", 0),
          (try_begin),
            (neq, ":form_left", 1),
            (assign, ":form_left", 1),
            (position_move_x, pos1, ":neg_distance", 0),
          (else_try),
            (assign, ":form_left", 0),
            (position_move_x, pos1, ":distance", 0),
          (try_end),
          (assign, ":column", 1),
          (val_add, ":rank", 1),
        (try_end),

        (val_add, ":max_level", 1),
        (try_for_range_backwards, ":rank_level", 0, ":max_level"),	#put troops with highest exp in front
          (troop_slot_eq, "trp_temp_array_a", ":rank_level", 1),
          (try_for_agents, ":agent"),
            (agent_get_troop_id, ":troop_id", ":agent"),
            (store_character_level, ":troop_level", ":troop_id"),
            (eq, ":troop_level", ":rank_level"),
            (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),

            (try_begin),
              (eq, "$battle_phase", BP_Deploy),
              (agent_set_scripted_destination, ":agent", pos1),
            (else_try),
              (call_script, "script_formation_process_agent_move", ":fteam", ":fdivision", ":agent", ":rank"),
            (try_end),

            (try_begin),
              (eq, formation_reequip, 1),
              (eq, ":weapon_order", wordr_use_any_weapon),
              (try_begin),
                (eq, ":rank", 1),
                (call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
                (agent_set_slot, ":agent", slot_agent_inside_formation, 0),
                (agent_ai_set_always_attack_in_melee, ":agent", 0),
              (else_try),
                (agent_get_slot, ":closest_enemy", ":agent", slot_agent_nearest_enemy_agent),
                (try_begin),
                  (neq, ":closest_enemy", -1),
                  (agent_get_position, pos0, ":closest_enemy"),
                  (get_distance_between_positions, ":enemy_distance", pos0, pos1),
                  (le, ":enemy_distance", ":distance"),	#enemy closer than friends?
                  (neg | position_is_behind_position, pos0, pos1),
                  (call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
                  (try_begin),
                    (position_is_behind_position, pos1, pos0),
                    (agent_ai_set_always_attack_in_melee, ":agent", 1),
                  (else_try),
                    (agent_ai_set_always_attack_in_melee, ":agent", 0),
                  (try_end),
                (else_try),
                  (call_script, "script_equip_best_melee_weapon", ":agent", 0, 1, ":fire_order"),
                  (agent_ai_set_always_attack_in_melee, ":agent", 1),
                (try_end),
                (agent_set_slot, ":agent", slot_agent_inside_formation, 1),
              (try_end),
            (try_end),
            (try_begin),
              (eq, ":form_left", 1),
              (position_move_x, pos1, ":neg_distance", 0),
            (else_try),
              (position_move_x, pos1, ":distance", 0),
            (try_end),
            (val_add, ":column", 1),

            (gt, ":column", ":rank_dimension"),	#next rank?
            (position_move_y, pos1, ":neg_distance", 0),
            (try_begin),
              (neq, ":form_left", 1),
              (assign, ":form_left", 1),
              (position_move_x, pos1, ":neg_distance", 0),
            (else_try),
              (assign, ":form_left", 0),
              (position_move_x, pos1, ":distance", 0),
            (try_end),
            (assign, ":column", 1),
            (val_add, ":rank", 1),
          (end_try),
        (end_try),

      (else_try),
        (eq, ":infantry_formation", formation_shield),
        (call_script, "script_calculate_default_ranks", ":num_troops"),
        (store_div, ":rank_dimension", ":num_troops", reg1),
        (val_add, ":rank_dimension", 1),
        (try_begin),
          (eq, ":include_leader", 0),
          (store_add, ":slot", slot_team_d0_first_member, ":fdivision"),
          (team_set_slot, ":fteam", ":slot", -1),
        (else_try),	#after leader, move to next position (copied from below)
          (team_set_slot, ":fteam", ":slot", ":fleader"),
          (try_begin),
            (eq, ":form_left", 1),
            (position_move_x, pos1, ":neg_distance", 0),
          (else_try),
            (position_move_x, pos1, ":distance", 0),
          (try_end),
          (val_add, ":column", 1),

          (gt, ":column", ":rank_dimension"),	#next rank?
          (position_move_y, pos1, ":neg_distance", 0),
          (try_begin),
            (neq, ":form_left", 1),
            (assign, ":form_left", 1),
            (position_move_x, pos1, ":neg_distance", 0),
          (else_try),
            (assign, ":form_left", 0),
            (position_move_x, pos1, ":distance", 0),
          (try_end),
          (assign, ":column", 1),
          (val_add, ":rank", 1),
        (try_end),

        (troop_set_slot, "trp_temp_array_a", 0, 0),	#short weap agent array
        (troop_set_slot, "trp_temp_array_b", 0, 0),	#medium weap agent array
        (troop_set_slot, "trp_temp_array_c", 0, 0),	#long weap agent array

        (try_for_agents, ":agent"),
          (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":fleader", ":agent"),
          (call_script, "script_switch_to_noswing_weapons", ":agent", ":distance"),

          (assign, ":cur_score", 0),
          (try_for_range, ":item_slot", ek_item_0, ek_head),
            (agent_get_item_slot, ":item", ":agent", ":item_slot"),
            (gt, ":item", itm_no_item),
            (item_get_type, ":weapon_type", ":item"),
            (neq, ":weapon_type", itp_type_shield),

            (try_begin),
              (call_script, "script_cf_is_weapon_ranged", ":item", 1),

            (else_try),
              (item_get_weapon_length, ":item_length", ":item"),
              (lt, ":cur_score", ":item_length"),
              (assign, ":cur_score", ":item_length"),
            (try_end),
          (try_end),

          (try_begin),
            (eq, ":cur_score", 0),	#no melee weapons
            (assign, ":cur_array", "trp_temp_array_c"),
          (else_try),
            (le, ":cur_score", Third_Max_Weapon_Length),
            (assign, ":cur_array", "trp_temp_array_a"),
          (else_try),
            (gt, ":cur_score", 2 * Third_Max_Weapon_Length),
            (assign, ":cur_array", "trp_temp_array_c"),
          (else_try),
            (assign, ":cur_array", "trp_temp_array_b"),
          (try_end),

          (troop_get_slot, ":array_end", ":cur_array", 0),
          (val_add, ":array_end", 1),
          (troop_set_slot, ":cur_array", ":array_end", ":agent"),
          (troop_set_slot, ":cur_array", 0, ":array_end"),
          (agent_set_slot, ":agent", slot_agent_positioned, 0),
        (try_end),

        #find shields first
        (store_add, ":arrays_end", "trp_temp_array_c", 1),
        (try_for_range, ":cur_array", "trp_temp_array_a", ":arrays_end"),
          (troop_get_slot, ":array_end", ":cur_array", 0),
          (val_add, ":array_end", 1),

          (try_for_range, ":slot", 1, ":array_end"),
            (troop_get_slot, ":agent", ":cur_array", ":slot"),
            (assign, ":form_up", 0),

            (try_for_range, ":item_slot", ek_item_0, ek_head),
              (agent_get_item_slot, ":item", ":agent", ":item_slot"),
              (gt, ":item", itm_no_item),
              (item_get_type, ":weapon_type", ":item"),
              (eq, ":weapon_type", itp_type_shield),
              (item_get_weapon_length, reg0, ":item"),	#gets shield width, which is always defined (see header_items)
              (ge, reg0, 25),	#wider than troop?
              (assign, ":form_up", 1),
            (try_end),

            (eq, ":form_up", 1),
            (agent_set_slot, ":agent", slot_agent_positioned, 1),
            (agent_set_slot, ":agent", slot_agent_inside_formation, 0),

            (try_begin),
              (eq, "$battle_phase", BP_Deploy),
              (agent_set_scripted_destination, ":agent", pos1),
            (else_try),
              (call_script, "script_formation_process_agent_move", ":fteam", ":fdivision", ":agent", ":rank"),
            (try_end),

            (try_begin),
              (eq, formation_reequip, 1),
              (eq, ":weapon_order", wordr_use_any_weapon),
              (call_script, "script_equip_best_melee_weapon", ":agent", 1, 0, ":fire_order"),	#best weapon, force shield
            (try_end),

            (try_begin),
              (eq, ":form_left", 1),
              (position_move_x, pos1, ":neg_distance", 0),
            (else_try),
              (position_move_x, pos1, ":distance", 0),
            (try_end),
            (val_add, ":column", 1),

            (gt, ":column", ":rank_dimension"),	#next rank?
            (position_move_y, pos1, ":neg_distance", 0),
            (try_begin),
              (neq, ":form_left", 1),
              (assign, ":form_left", 1),
              (position_move_x, pos1, ":neg_distance", 0),
            (else_try),
              (assign, ":form_left", 0),
              (position_move_x, pos1, ":distance", 0),
            (try_end),
            (assign, ":column", 1),
            (val_add, ":rank", 1),

            #break loops
            (assign, ":array_end", ":slot"),
            (assign, ":arrays_end", ":cur_array"),
          (try_end),
        (try_end),

        #add rest of division
        (store_add, ":arrays_end", "trp_temp_array_c", 1),
        (try_for_range, ":cur_array", "trp_temp_array_a", ":arrays_end"),
          (troop_get_slot, ":array_end", ":cur_array", 0),
          (val_add, ":array_end", 1),

          (try_for_range, ":slot", 1, ":array_end"),
            (troop_get_slot, ":agent", ":cur_array", ":slot"),
            (agent_slot_eq, ":agent", slot_agent_positioned, 0),
            (agent_set_slot, ":agent", slot_agent_positioned, 1),

            (try_begin),
              (eq, ":rank", 1),
              (agent_set_slot, ":agent", slot_agent_inside_formation, 0),
            (else_try),
              (agent_set_slot, ":agent", slot_agent_inside_formation, 1),
            (try_end),

            (try_begin),
              (eq, "$battle_phase", BP_Deploy),
              (agent_set_scripted_destination, ":agent", pos1),
            (else_try),
              (call_script, "script_formation_process_agent_move", ":fteam", ":fdivision", ":agent", ":rank"),
            (try_end),

            (try_begin),
              (eq, formation_reequip, 1),
              (eq, ":weapon_order", wordr_use_any_weapon),

              (try_begin),
                (eq, ":rank", 1),
                (call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),
                (agent_ai_set_always_attack_in_melee, ":agent", 0),

              #enemy closer than friends?
              (else_try),
                (agent_get_slot, ":closest_enemy", ":agent", slot_agent_nearest_enemy_agent),
                (neq, ":closest_enemy", -1),
                (agent_get_position, pos0, ":closest_enemy"),
                (get_distance_between_positions, ":enemy_distance", pos0, pos1),
                (le, ":enemy_distance", ":distance"),
                (neg | position_is_behind_position, pos0, pos1),
                (call_script, "script_equip_best_melee_weapon", ":agent", 0, 0, ":fire_order"),

                #behind enemy?
                (try_begin),
                  (position_is_behind_position, pos1, pos0),
                  (agent_ai_set_always_attack_in_melee, ":agent", 1),
                (else_try),
                  (agent_ai_set_always_attack_in_melee, ":agent", 0),
                (try_end),

              #equip longest weapon and avoid defensive
              (else_try),
                (call_script, "script_equip_best_melee_weapon", ":agent", 0, 1, ":fire_order"),
                (agent_ai_set_always_attack_in_melee, ":agent", 1),
              (try_end),
            (try_end),

            (try_begin),
              (eq, ":form_left", 1),
              (position_move_x, pos1, ":neg_distance", 0),
            (else_try),
              (position_move_x, pos1, ":distance", 0),
            (try_end),
            (val_add, ":column", 1),

            (gt, ":column", ":rank_dimension"),	#next rank?
            (position_move_y, pos1, ":neg_distance", 0),
            (try_begin),
              (neq, ":form_left", 1),
              (assign, ":form_left", 1),
              (position_move_x, pos1, ":neg_distance", 0),
            (else_try),
              (assign, ":form_left", 0),
              (position_move_x, pos1, ":distance", 0),
            (try_end),
            (assign, ":column", 1),
            (val_add, ":rank", 1),
          (try_end),
        (try_end),
      (try_end),

      #calculate percent in place from counts from section above (see
      #script_formation_process_agent_move)
      (store_add, ":slot", slot_team_d0_size, ":fdivision"),
      (team_get_slot, ":num_troops", ":fteam", ":slot"),
      (store_add, ":slot", slot_team_d0_percent_in_place, ":fdivision"),

      (try_begin),
        (eq, ":num_troops", 0),
        (team_set_slot, ":fteam", ":slot", 0),
      (else_try),
        (team_get_slot, reg0, ":fteam", ":slot"),
        (val_mul, reg0, 100),
        (val_div, reg0, ":num_troops"),
        (team_set_slot, ":fteam", ":slot", reg0),
      (try_end),
  ]),

  # script_get_default_formation by motomataru
  # Input: team id
  # Output: reg0 default formation
  ("get_default_formation", [
      (store_script_param, ":fteam", 1),
      (team_get_slot, ":ffaction", ":fteam", slot_team_faction),
      (try_begin),
        (this_or_next | eq, ":ffaction", fac_player_supporters_faction),
        (eq, ":ffaction", fac_player_faction),
        (is_between, "$players_kingdom", npc_kingdoms_begin, npc_kingdoms_end),
        (assign, ":ffaction", "$players_kingdom"),
      (try_end),

      (try_begin),
        (is_between, ":ffaction", "fac_player_faction", kingdoms_end),
        (faction_slot_ge, ":ffaction", slot_faction_culture, 1),
        (faction_get_slot, ":ffaction", ":ffaction", slot_faction_culture),
      (try_end),

      #assign default formation
      (try_begin),
        (eq, ":ffaction", fac_kingdom_1),	#Swadians
        (assign, reg0, formation_shield),	#use shields, stabby weapons
      (else_try),
        (eq, ":ffaction", fac_kingdom_2),	#Vaegirs
        (assign, reg0, formation_ranks),	#have a mix, so favor those nasty axes
      (else_try),
        (eq, ":ffaction", fac_kingdom_3),	#Khergit
        (assign, reg0, formation_none),	#Khergit have underdeveloped infantry
      (else_try),
        (eq, ":ffaction", fac_kingdom_4),	#Nords
        (assign, reg0, formation_ranks),	#favor swung weapons
      (else_try),
        (eq, ":ffaction", fac_kingdom_5),	#Rhodoks
        (assign, reg0, formation_shield),	#have a mix, so favor those big shields and pikes
      (else_try),
        (eq, ":ffaction", fac_kingdom_6),	#Sarranid
        (assign, reg0, formation_shield),
      (else_try),
        (this_or_next | eq, ":ffaction", fac_player_supporters_faction),
        (eq, ":ffaction", fac_player_faction),	#independent player
        (assign, reg0, formation_ranks),
      (else_try),
        (assign, reg0, formation_none),	#riffraff don't use formations
      (try_end),]),

  # script_switch_to_noswing_weapons by motomataru
  # Input: agent, formation spacing
  # Output: none
  ("switch_to_noswing_weapons", [
      (store_script_param, ":agent", 1),
      (store_script_param, ":formation_spacing", 2),
      (try_for_range, ":item_slot", ek_item_0, ek_head),
        (agent_get_item_slot, ":item", ":agent", ":item_slot"),
        (call_script, "script_cf_is_thrusting_weapon", ":item"),
        (item_get_weapon_length, ":weap_len",":item"),

        (try_begin),
          (ge, ":weap_len", ":formation_spacing"),	#avoid switching when weapon still has room to be swung
          (item_get_slot, ":noswing_version", ":item", slot_item_alternate),
          (gt, ":noswing_version", "itm_items_end"),
          (agent_unequip_item, ":agent", ":item", ":item_slot"),	#assumes first ek_* are the weapons
          (agent_equip_item, ":agent", ":noswing_version", ":item_slot"),	#assumes first ek_* are the weapons

        #undo legacy switches
        (else_try),
          (gt, ":item", "itm_items_end"),
          (item_get_slot, ":original_version", ":item", slot_item_alternate),
          (agent_unequip_item, ":agent", ":item", ":item_slot"),	#assumes first ek_* are the weapons
          (agent_equip_item, ":agent", ":original_version", ":item_slot"),	#assumes first ek_* are the weapons
        (try_end),
      (try_end),]),

  # script_switch_from_noswing_weapons by motomataru
  # Input: agent
  # Output: none
  ("switch_from_noswing_weapons", [
      (store_script_param, ":agent", 1),
      (try_for_range, ":item_slot", ek_item_0, ek_head),
        (agent_get_item_slot, ":item", ":agent", ":item_slot"),
        (gt, ":item", "itm_items_end"),
        (item_get_slot, ":original_version", ":item", slot_item_alternate),
        (agent_unequip_item, ":agent", ":item", ":item_slot"),	#assumes first ek_* are the weapons
        (agent_equip_item, ":agent", ":original_version", ":item_slot"),	#assumes first ek_* are the weapons
      (try_end),]),

  # script_formation_process_agent_move by motomataru
  # Input: (pos1), team, division, agent, which rank of formation agent is in
  # Output: (pos1) may change to reference first agent's anticipated position
  # This function sets scripted destination and performs other tasks related to
  # making the formation look nice on the move (and more)
  ("formation_process_agent_move", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":agent", 3),
      (store_script_param, ":rank", 4),

      (agent_set_scripted_destination, ":agent", pos1, 1),

      (agent_get_position, Current_Pos, ":agent"),
      (get_distance_between_positions, ":distance_to_go", Current_Pos, pos1),

      (store_add, ":slot", slot_team_d0_speed_limit, ":fdivision"),
      (team_get_slot, ":speed_limit", ":fteam", ":slot"),

      (agent_get_speed, Speed_Pos, ":agent"),
      (position_transform_position_to_parent, Temp_Pos, Current_Pos, Speed_Pos),
      (call_script, "script_point_y_toward_position", Current_Pos, Temp_Pos),	#get direction of travel
      (store_mul, ":expected_travel", reg0, formation_reform_interval),
      (store_div, ":speed", ":expected_travel", Km_Per_Hour_To_Cm),

      #First Agent
      (try_begin),
        (store_add, ":slot", slot_team_d0_first_member, ":fdivision"),
        (neg | team_slot_ge, ":fteam", ":slot", 0),
        (team_set_slot, ":fteam", ":slot", ":agent"),

        (try_begin),	#reset speed when first member stopped
          (le, ":speed", 5),	#minimum observed speed
          (store_add, ":slot", slot_team_d0_speed_limit, ":fdivision"),
          (team_set_slot, ":fteam", ":slot", Top_Speed),
          (agent_set_speed_limit, ":agent", Top_Speed),

        (else_try),	#first member in motion
          (val_mul, ":speed", 2),	#after terrain & encumbrance, agents tend to move about half their speed limit
          (try_begin),	#speed up if everyone caught up
            (store_add, ":slot", slot_team_d0_percent_in_place, ":fdivision"),
            (team_slot_ge, ":fteam", ":slot", 100),
            (try_begin),
              (ge, ":speed", ":speed_limit"),
              (val_add, ":speed_limit", 1),
            (try_end),
          (else_try),	#else slow down
            (val_min, ":speed_limit", ":speed"),
            (val_sub, ":speed_limit", 1),
            (val_max, ":speed_limit", 5),	#minimum observed speed
          (try_end),

          #build formation from first agent
          (store_add, ":slot", slot_team_d0_prev_first_member, ":fdivision"),
          (team_slot_eq, ":fteam", ":slot", ":agent"),	#looking at same first member as last call?

          (call_script, "script_battlegroup_get_position", Temp_Pos, ":fteam", ":fdivision"),
          (get_distance_between_positions, ":distance_from_group", Current_Pos, Temp_Pos),
          (call_script, "script_battlegroup_get_action_radius", ":fteam", ":fdivision"),
          (val_div, reg0, 2),	#function returns length of bg
          (val_sub, ":distance_from_group", reg0),
          (lt, ":distance_from_group", 2000),	#within 20m of rest of division?

          (store_mul, ":expected_travel", ":speed_limit", Km_Per_Hour_To_Cm),
          (lt, ":expected_travel", ":distance_to_go"),	#more than one call from destination?

          (store_add, ":slot", slot_team_d0_speed_limit, ":fdivision"),
          (team_set_slot, ":fteam", ":slot", ":speed_limit"),
          (agent_set_speed_limit, ":agent", ":speed_limit"),

          (copy_position, Temp_Pos, Current_Pos),
          (call_script, "script_point_y_toward_position", Temp_Pos, pos1),
          (position_move_y, Temp_Pos, ":expected_travel", 0),	#anticipate where first member will be next
          (position_copy_rotation, Temp_Pos, pos1),	#conserve destination facing of formation
          (copy_position, pos1, Temp_Pos),	#reference the rest of the formation to first member's anticipated position
        (try_end),

        (store_add, ":slot", slot_team_d0_percent_in_place, ":fdivision"),
        (team_set_slot, ":fteam", ":slot", 1),	#reinit: always count first member as having arrived
        (store_add, ":slot", slot_team_d0_prev_first_member, ":fdivision"),
        (team_set_slot, ":fteam", ":slot", ":agent"),

      #Not First Agent
      (else_try),
        (try_begin),
          (le, ":speed", 0),
          (assign, ":speed_limit", Top_Speed),
        (else_try),
          (neg | position_is_behind_position, pos1, Current_Pos),
          (store_div, ":speed_limit", ":distance_to_go", Km_Per_Hour_To_Cm),
          (val_max, ":speed_limit", 1),
        (else_try),
          (store_add, ":slot", slot_team_d0_is_fighting, ":fdivision"),
          (team_slot_eq, ":fteam", ":slot", 0),
          (assign, ":speed_limit", 1),
        (else_try),
          (assign, ":speed_limit", Top_Speed),
        (try_end),
        (agent_set_speed_limit, ":agent", ":speed_limit"),
        (try_begin),
          (this_or_next | le, ":speed", 0),	#reached previous destination or blocked OR
          (this_or_next | lt, ":speed_limit", Top_Speed),	#destination within reach OR
          (position_is_behind_position, pos1, Current_Pos),	#agent ahead of formation
          (store_add, ":slot", slot_team_d0_percent_in_place, ":fdivision"),
          (team_get_slot, reg0, ":fteam", ":slot"),
          (val_add, reg0, 1),
          (team_set_slot, ":fteam", ":slot", reg0),
        (try_end),
      (try_end),

      #Housekeeping
      (agent_set_slot, ":agent", slot_agent_formation_rank, ":rank"),]),

  # script_pick_native_formation by motomataru
  # Input: team, division
  # Output: reg0 with formation_*_row (see module_constants)
  #         reg1 with number of rows
  ("pick_native_formation", [
      (store_script_param, ":team", 1),
      (store_script_param, ":division", 2),

      (store_add, ":slot", slot_team_d0_size, ":division"),
      (team_get_slot, ":bg_size", ":team", ":slot"),

      (try_begin),
        (eq, ":bg_size", 0),	#script_store_battlegroup_data is not being called
        (team_get_leader, ":leader", ":team"),
        (try_for_agents, ":agent"),
          (call_script, "script_cf_valid_formation_member", ":team", ":division", ":leader", ":agent"),
          (val_add, ":bg_size", 1),
        (try_end),
      (try_end),

      (call_script, "script_calculate_default_ranks", ":bg_size"),
      (try_begin),
        (eq, reg1, 1),
        (assign, reg0, formation_1_row),
      (else_try),
        (eq, reg1, 2),
        (assign, reg0, formation_2_row),
      (else_try),
        (eq, reg1, 3),
        (assign, reg0, formation_3_row),
      (else_try),
        (this_or_next | eq, reg1, 4),
        (eq, Native_Formations_Implementation, WB_Implementation),
        (assign, reg0, formation_4_row),
        (assign, reg1, 4),
      (else_try),
        (assign, reg0, formation_5_row),
        (assign, reg1, 5),
      (try_end)]),

  # script_calculate_default_ranks by motomataru
  # Input: number of troops
  # Output: reg1 with number of rows
  # calculates number of rows closest to the old Roman 5:1 cohort arrangement
  # (80 troops in 4 rows)
  # quadratic formula to solve (5R^2 + 5(R+1)^2)/2
  ("calculate_default_ranks", [
      (store_script_param, ":bg_size", 1),

      (val_mul, ":bg_size", 20),
      (val_sub, ":bg_size", 25),
      (convert_to_fixed_point, ":bg_size"),
      (store_sqrt, reg1, ":bg_size"),
      (convert_from_fixed_point, reg1),
      (val_sub, reg1, 5),
      (val_div, reg1, 10),
      (val_add, reg1, 1),]),

  # script_get_centering_amount by motomataru
  # Input: formation type, number of troops, extra spacing
  #        Use formation type formation_default to use script for archer line
  # Output: reg0 number of centimeters to adjust x-position to center formation
  ("get_centering_amount", [
      (store_script_param, ":troop_formation", 1),
      (store_script_param, ":num_troops", 2),
      (store_script_param, ":extra_spacing", 3),
      (store_mul, ":troop_space", ":extra_spacing", 50),
      (val_add, ":troop_space", formation_minimum_spacing),
      (assign, reg0, 0),
      (try_begin),
        (eq, ":troop_formation", formation_square),
        (convert_to_fixed_point, ":num_troops"),
        (store_sqrt, reg0, ":num_troops"),
        (convert_from_fixed_point, reg0),
        (val_mul, reg0, ":troop_space"),
        # (val_sub, reg0, ":troop_space"), MOTO not needed because column added in
        # script_form_infantry
      (else_try),
        (this_or_next | eq, ":troop_formation", formation_ranks),
        (eq, ":troop_formation", formation_shield),
        (call_script, "script_calculate_default_ranks", ":num_troops"),
        (assign, ":num_ranks", reg1),
        (store_div, reg0, ":num_troops", ":num_ranks"),
        (try_begin),
          (store_mod, reg1, ":num_troops", ":num_ranks"),
          (eq, reg1, 0),
          (val_sub, reg0, 1),
        (try_end),
        (val_mul, reg0, ":troop_space"),
      (else_try),
        (eq, ":troop_formation", formation_default),	#assume these are archers in a line
        (store_mul, reg0, ":num_troops", ":troop_space"),
      (try_end),
      (val_div, reg0, 2),]),

  # script_formation_end
  # Input: team, division
  # Output: none
  ("formation_end", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (try_begin),
        (store_add, ":slot", slot_team_d0_formation, ":fdivision"),
        (neg | team_slot_eq, ":fteam", ":slot", formation_none),
        (team_slot_ge, ":fteam", ":slot", formation_none),

        (try_begin),
          (eq, Native_Formations_Implementation, WFaS_Implementation),
          (team_set_slot, ":fteam", ":slot", formation_2_row),
        (else_try),
          (team_set_slot, ":fteam", ":slot", formation_none),
        (try_end),

        (team_get_leader, ":leader", ":fteam"),

        (try_for_agents, ":agent"),
          (agent_is_alive, ":agent"),
          (agent_is_human, ":agent"),
          (agent_get_group, ":team", ":agent"),
          (eq, ":team", ":fteam"),
          (neq, ":leader", ":agent"),
          (agent_get_division, ":bgdivision", ":agent"),
          (eq, ":bgdivision", ":fdivision"),
          (agent_clear_scripted_mode, ":agent"),
          (call_script, "script_switch_from_noswing_weapons", ":agent"),
          (agent_ai_set_always_attack_in_melee, ":agent", 0),
          (agent_set_speed_limit, ":agent", 100),
          (agent_set_slot, ":agent", slot_agent_formation_rank, 0),
          (agent_set_slot, ":agent", slot_agent_inside_formation, 0),
        (try_end),

        (try_begin),
          (eq, ":fteam", "$fplayer_team_no"),
          (store_add, ":slot", slot_team_d0_formation_space, ":fdivision"),
          (team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),

          #adjust for differences between the systems of spreading out (Native spreads
          #out about twice as much)
          (try_begin),
            (eq, Native_Formations_Implementation, WFaS_Implementation),
            (assign, ":max_spacing", 3),
          (else_try),
            (assign, ":max_spacing", 2),
          (try_end),

          (store_mul, ":double_max", ":max_spacing", 2),

          (try_begin),
            (ge, ":div_spacing", ":double_max"),	#beyond Native max
            (assign, ":div_spacing", ":max_spacing"),
          (else_try),
            (gt, ":div_spacing", 0),
            (set_show_messages, 0),
            (team_give_order, "$fplayer_team_no", ":fdivision", mordr_stand_closer),
            (set_show_messages, 1),
            (val_div, ":div_spacing", 2),
          (try_end),

          (team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),
        (try_end),
      (try_end),]),

  # script_formation_move_position by motomataru
  # Input: team, division, formation current position, (1 to advance or -1 to
  # withdraw or 0 to redirect)
  # Output: pos1 (offset for centering)
  ("formation_move_position", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":fcurrentpos", 3),
      (store_script_param, ":direction", 4),
      (copy_position, pos1, ":fcurrentpos"),
      (call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, ":fteam", grc_everyone),
      (try_begin),
        (neq, reg0, 0),	#more than 0 enemies still alive?
        (copy_position, pos1, ":fcurrentpos"),	#restore current formation "position"
        (call_script, "script_point_y_toward_position", pos1, Enemy_Team_Pos),	#record angle from center to enemy
        (assign, ":distance_to_enemy", reg0),
        (call_script, "script_get_formation_destination", pos61, ":fteam", ":fdivision"),
        (get_distance_between_positions, ":move_amount", pos1, pos61),	#distance already moving from previous orders
        (val_add, ":move_amount", 1000),
        (try_begin),
          (gt, ":direction", 0),	#moving forward?
          (gt, ":move_amount", ":distance_to_enemy"),
          (assign, ":move_amount", ":distance_to_enemy"),
        (try_end),
        (val_mul, ":move_amount", ":direction"),
        (position_move_y, pos1, ":move_amount", 0),
        (position_get_x, ":from_x", pos1),
        (position_get_y, ":from_y", pos1),
        (try_begin),
          (is_between, ":from_x", "$g_bound_left", "$g_bound_right"),
          (is_between, ":from_y", "$g_bound_bottom", "$g_bound_top"),
          (try_begin),
            (lt, ":distance_to_enemy", 1000),	#less than a move away?
            (position_copy_rotation, pos1, pos61),	#avoid rotating formation
          (try_end),
          (call_script, "script_set_formation_destination", ":fteam", ":fdivision", pos1),
          (store_add, ":slot", slot_team_d0_size, ":fdivision"),
          (team_get_slot, ":num_troops", ":fteam", ":slot"),
          (store_add, ":slot", slot_team_d0_formation_space, ":fdivision"),
          (team_get_slot, ":formation_extra_spacing", ":fteam", ":slot"),
          (try_begin),
            (store_add, ":slot", slot_team_d0_type, ":fdivision"),
            (neg | team_slot_eq, ":fteam", ":slot", sdt_archer),
            (store_add, ":slot", slot_team_d0_formation, ":fdivision"),
            (team_get_slot, ":fformation", ":fteam", ":slot"),
            (call_script, "script_get_centering_amount", ":fformation", ":num_troops", ":formation_extra_spacing"),
          (else_try),
            (call_script, "script_get_centering_amount", formation_default, ":num_troops", ":formation_extra_spacing"),
            (val_mul, reg0, -1),
          (try_end),
          (position_move_x, pos1, reg0, 0),

          #out of bounds
        (else_try),
          (copy_position, pos1, ":fcurrentpos"),	#restore current formation "position"
        (try_end),
      (try_end),]),

  # script_cf_battlegroup_valid_formation
  # Input: team, division, formation
  # Output: reg0: troop count/1 if too few troops/0 if wrong type
  ("cf_battlegroup_valid_formation", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":fformation", 3),

      (assign, ":valid_type", 0),
      (store_add, ":slot", slot_team_d0_type, ":fdivision"),
      (team_get_slot, ":sd_type", ":fteam", ":slot"),
      (try_begin), #Eventually make this more complex with the sub-divisions
        (this_or_next | eq, ":sd_type", sdt_cavalry),
        (eq, ":sd_type", sdt_harcher),
        (assign, ":size_minimum", formation_min_cavalry_troops),
        (try_begin),
          (eq, ":fformation", formation_wedge),
          (assign, ":valid_type", 1),
        (try_end),
      (else_try),
        (eq, ":sd_type", sdt_archer),
        (assign, ":size_minimum", formation_min_foot_troops),
        (try_begin),
          # (this_or_next|eq, ":fformation", formation_ranks), uncheck for proper
          # ranks
          (eq, ":fformation", formation_default),
          (assign, ":valid_type", 1),
        (try_end),
      (else_try),
        (assign, ":size_minimum", formation_min_foot_troops),
        (gt, ":fformation", formation_none),
        (assign, ":valid_type", 1), #all types valid
      (try_end),

      (try_begin),
        (eq, ":valid_type", 0),
        (assign, ":num_troops", 0),
      (else_try),
        (store_add, ":slot", slot_team_d0_size, ":fdivision"),
        (team_get_slot, ":num_troops", ":fteam", ":slot"),
        (lt, ":num_troops", ":size_minimum"),
        (assign, ":num_troops", 1),
      (try_end),

      (assign, reg0, ":num_troops"),
      (gt, ":num_troops", 1)]),

  # script_cf_valid_formation_member by motomataru #CABA - Modified for
  # Classify_agent phase out
  # Input: team, division, agent number of team leader, test agent
  # Output: failure indicates agent is not member of formation
  ("cf_valid_formation_member", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":fleader", 3),
      (store_script_param, ":agent", 4),
      (neq, ":fleader", ":agent"),
      (agent_get_division, ":bgdivision", ":agent"),
      (eq, ":bgdivision", ":fdivision"),
      (agent_get_group, ":team", ":agent"),
      (eq, ":team", ":fteam"),
      (agent_is_alive, ":agent"),
      (agent_is_human, ":agent"),
      (agent_slot_eq, ":agent", slot_agent_is_running_away, 0),]),

  # #Player team formations functions
  # script_player_attempt_formation
  # Inputs: arg1: division
  #			arg2: formation identifier (formation_*)
  #         arg3: flag 1 to form at current location (rather than next to
  #         player), flag 2 to form as if player were at Target_Pos
  # Output: none
  # Designed JUST for infantry
  ("player_attempt_formation", [
      (store_script_param, ":fdivision", 1),
      (store_script_param, ":fformation", 2),
      (store_script_param, ":form_on_spot", 3),
      (set_fixed_point_multiplier, 100),
      (try_begin),
        (eq, ":fformation", formation_ranks),
        (str_store_string, s1, "@ranks"),
      (else_try),
        (eq, ":fformation", formation_shield),
        (str_store_string, s1, "@shield wall"),
      (else_try),
        (eq, ":fformation", formation_wedge),
        (str_store_string, s1, "@wedge"),
      (else_try),
        (eq, ":fformation", formation_square),
        (str_store_string, s1, "@square"),
      (else_try),
        (str_store_string, s1, "@up"),
      (try_end),
      (str_store_class_name, s2, ":fdivision"),

      (try_begin),
        (call_script, "script_cf_battlegroup_valid_formation", "$fplayer_team_no", ":fdivision", ":fformation"),
        (try_begin),	#new formation?
          (store_add, ":slot", slot_team_d0_formation, ":fdivision"),
          (neg | team_slot_eq, "$fplayer_team_no", ":slot", ":fformation"),
          (team_set_slot, "$fplayer_team_no", ":slot", ":fformation"),
          (store_add, reg1, ":fdivision", 1),
          (display_message, "@Division {reg1} {s2} forming {s1}."),
          (store_add, ":slot", slot_team_d0_fclock, ":fdivision"),
          (team_set_slot, "$fplayer_team_no", ":slot", 1),
          (store_add, ":slot", slot_team_d0_target_team, ":fdivision"),
          (team_set_slot, "$fplayer_team_no", ":slot", -1),

          (store_add, ":slot", slot_team_d0_formation_space, ":fdivision"),
          (team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),

          #bring unformed divisions into sync with formations' minimum
          (set_show_messages, 0),
          (assign, reg0, ":div_spacing"),
          (try_for_range, reg1, reg0, formation_start_spread_out),	#spread out for ease of forming up
            (team_give_order, "$fplayer_team_no", ":fdivision", mordr_spread_out),
            (val_add, ":div_spacing", 1),
          (try_end),
          (set_show_messages, 1),

          (team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),
        (try_end),

        #divisions must stop to order themselves
        (store_add, ":slot", slot_team_d0_move_order, ":fdivision"),
        (team_get_slot, ":div_order", "$fplayer_team_no", ":slot"),
        (try_begin),
          (this_or_next | eq, ":div_order", mordr_stand_ground),
          (this_or_next | eq, ":div_order", mordr_charge),
          (eq, ":div_order", mordr_retreat),
          (call_script, "script_battlegroup_get_position", pos1, "$fplayer_team_no", ":fdivision"),
          (team_give_order, "$fplayer_team_no", ":fdivision", mordr_hold),
          (call_script, "script_set_formation_destination", "$fplayer_team_no", ":fdivision", pos1),
        (try_end),

      (else_try),
        (assign, ":return_val", reg0),
        (call_script, "script_formation_end", "$fplayer_team_no", ":fdivision"),
        (gt, ":fformation", formation_none),
        (store_add, reg1, ":fdivision", 1),
        (try_begin),
          (gt, ":return_val", 0),
          (display_message, "@Not enough troops in division {reg1} {s2} to form {s1}."),
        (else_try),
          (store_add, ":slot", slot_team_d0_type, ":fdivision"),
          (team_get_slot, reg0, "$fplayer_team_no", ":slot"),
          (call_script, "script_str_store_division_type_name", s3, reg0),
          (display_message, "@Division {reg1} {s2} is an {s3} division and cannot form {s1}."),
        (try_end),
      (try_end),

      (try_begin),
        (eq, ":form_on_spot", 0),
        (call_script, "script_battlegroup_place_around_leader", "$fplayer_team_no", ":fdivision", "$fplayer_agent_no"),
      (else_try),
        (eq, ":form_on_spot", 2),
        (copy_position, pos1, Target_Pos),
        (call_script, "script_battlegroup_place_around_pos1", "$fplayer_team_no", ":fdivision", "$fplayer_agent_no"),
      (try_end),]),

  # script_player_formation_end
  # Input: division
  # Output: none
  ("player_formation_end", [
      (store_script_param, ":fdivision", 1),

      (call_script, "script_formation_end", "$fplayer_team_no", ":fdivision"),

      (store_add, ":slot", slot_team_d0_type, ":fdivision"),
      (str_store_class_name, s1, ":fdivision"),
      (try_begin),
        (this_or_next | team_slot_eq, "$fplayer_team_no", ":slot", sdt_infantry),
        (team_slot_eq, "$fplayer_team_no", ":slot", sdt_polearm),
        (display_message, "@{s1}: infantry formation disassembled."),
      (else_try),
        (team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
        (display_message, "@{s1}: archer formation disassembled."),
      (else_try),
        (team_slot_eq, "$fplayer_team_no", ":slot", sdt_skirmisher),
        (display_message, "@{s1}: skirmisher formation disassembled."),
      (else_try),
        (this_or_next | team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
        (team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
        (display_message, "@{s1}: cavalry formation disassembled."),
      (else_try),
        (display_message, "@{s1}: formation disassembled."),
      (try_end),]),

  # script_player_order_formations by motomataru TODO add native weapon
  # commands
  # Inputs: arg1: order to formation (mordr_*)
  # Output: none
  ("player_order_formations", [
      (store_script_param, ":forder", 1),
      (set_fixed_point_multiplier, 100),

      (try_begin), #On hold, any formations reform in new location
        (eq, ":forder", mordr_hold),
        (call_script, "script_division_reset_places"),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_target_team, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", -1),
          (store_add, ":slot", slot_team_d0_size, ":division"),	#apply to all divisions (not just formations)
          (team_slot_ge, "$fplayer_team_no", ":slot", 1),
          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (call_script, "script_player_attempt_formation", ":division", ":formation", 0),
        (try_end),

      (else_try),	#Follow is hold repeated frequently
        (eq, ":forder", mordr_follow),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_target_team, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", -1),
          (store_add, ":slot", slot_team_d0_size, ":division"),	#apply to all divisions (not just formations)
          (team_slot_ge, "$fplayer_team_no", ":slot", 1),

          (store_add, ":slot", slot_team_d0_formation, ":division"),	#update formations
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (call_script, "script_player_attempt_formation", ":division", ":formation", 0),

          (store_add, ":slot", slot_team_d0_move_order, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", ":forder"),
        (try_end),

      (else_try),	#charge or retreat ends formation
        (this_or_next | eq, ":forder", mordr_charge),
        (eq, ":forder", mordr_retreat),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_target_team, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", -1),
          (store_add, ":slot", slot_team_d0_move_order, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", ":forder"),

          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (gt, ":formation", formation_none),
          (call_script, "script_player_formation_end", ":division"),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_form_1_row),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (try_begin),
            (gt, ":formation", formation_none),
            (call_script, "script_formation_end", "$fplayer_team_no", ":division"),
          (try_end),
          (team_set_slot, "$fplayer_team_no", ":slot", formation_1_row),
          (store_add, ":slot", slot_team_d0_formation_num_ranks, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 1),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_form_2_row),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (try_begin),
            (gt, ":formation", formation_none),
            (call_script, "script_formation_end", "$fplayer_team_no", ":division"),
          (try_end),
          (team_set_slot, "$fplayer_team_no", ":slot", formation_2_row),
          (store_add, ":slot", slot_team_d0_formation_num_ranks, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 2),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_form_3_row),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (try_begin),
            (gt, ":formation", formation_none),
            (call_script, "script_formation_end", "$fplayer_team_no", ":division"),
          (try_end),
          (team_set_slot, "$fplayer_team_no", ":slot", formation_3_row),
          (store_add, ":slot", slot_team_d0_formation_num_ranks, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 3),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_form_4_row),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (try_begin),
            (gt, ":formation", formation_none),
            (call_script, "script_formation_end", "$fplayer_team_no", ":division"),
          (try_end),
          (team_set_slot, "$fplayer_team_no", ":slot", formation_4_row),
          (store_add, ":slot", slot_team_d0_formation_num_ranks, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 4),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_form_5_row),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (try_begin),
            (gt, ":formation", formation_none),
            (call_script, "script_formation_end", "$fplayer_team_no", ":division"),
          (try_end),
          (team_set_slot, "$fplayer_team_no", ":slot", formation_5_row),
          (store_add, ":slot", slot_team_d0_formation_num_ranks, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 5),
        (try_end),

      (else_try),	#dismount ends formation
        (eq, ":forder", mordr_dismount),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (neg | team_slot_eq, "$fplayer_team_no", ":slot", formation_none),
          (team_slot_ge, "$fplayer_team_no", ":slot", formation_none),
          (try_begin),
            (store_add, ":slot", slot_team_d0_type, ":division"),
            (this_or_next | team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
            (team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
            (call_script, "script_formation_end", "$fplayer_team_no", ":division"),
            (display_message, "@Cavalry formation disassembled."),

          (else_try),	#address bug that cavalry in scripted mode won't dismount
            (try_for_agents, ":agent"),
              (agent_is_alive, ":agent"),
              (agent_is_human, ":agent"),
              (agent_get_group, ":team", ":agent"),
              (eq, ":team", "$fplayer_team_no"),
              (neq, "$fplayer_agent_no", ":agent"),
              (agent_get_division, ":bgdivision", ":agent"),
              (eq, ":bgdivision", ":division"),
              (agent_clear_scripted_mode, ":agent"),
              (agent_set_speed_limit, ":agent", 100),
            (try_end),
          (try_end),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_advance),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_target_team, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", -1),
          (store_add, ":slot", slot_team_d0_move_order, ":division"),
          (team_get_slot, ":prev_order", "$fplayer_team_no", ":slot"),
          (team_set_slot, "$fplayer_team_no", ":slot", ":forder"),

          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (gt, ":formation", formation_none),

          (store_add, ":slot", slot_team_d0_fclock, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 1),

          (call_script, "script_formation_current_position", pos63, "$fplayer_team_no", ":division"),
          (try_begin),
            (neq, ":prev_order", mordr_advance),
            (call_script, "script_set_formation_destination", "$fplayer_team_no", ":division", pos63),
          (try_end),
          (call_script, "script_formation_move_position", "$fplayer_team_no", ":division", pos63, 1),

          (store_add, ":slot", slot_team_d0_formation_space, ":division"),
          (team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
          (store_add, ":slot", slot_team_d0_type, ":division"),
          (try_begin),
            (team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
            (call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0, ":formation"),
          (else_try),
            (this_or_next | team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
            (team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
            (call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0),
          (else_try),
            (call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0, ":formation"),
          (try_end),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_fall_back),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_target_team, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", -1),
          (store_add, ":slot", slot_team_d0_move_order, ":division"),
          (team_get_slot, ":prev_order", "$fplayer_team_no", ":slot"),
          (team_set_slot, "$fplayer_team_no", ":slot", ":forder"),

          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (gt, ":formation", formation_none),

          (store_add, ":slot", slot_team_d0_fclock, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 1),

          (call_script, "script_formation_current_position", pos63, "$fplayer_team_no", ":division"),
          (try_begin),
            (neq, ":prev_order", mordr_fall_back),
            (call_script, "script_set_formation_destination", "$fplayer_team_no", ":division", pos63),
          (try_end),
          (call_script, "script_formation_move_position", "$fplayer_team_no", ":division", pos63, -1),

          (store_add, ":slot", slot_team_d0_formation_space, ":division"),
          (team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
          (store_add, ":slot", slot_team_d0_type, ":division"),
          (try_begin),
            (team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
            (call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0, ":formation"),
          (else_try),
            (this_or_next | team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
            (team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
            (call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0),
          (else_try),
            (call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0, ":formation"),
          (try_end),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_stand_closer),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),

          (try_begin),
            (eq, Native_Formations_Implementation, WB_Implementation),
            (assign, ":min_spacing", -3),	#WB formations go down to four ranks by using Stand Closer
          (else_try),
            (assign, ":min_spacing", 0),
          (try_end),

          (store_add, ":slot", slot_team_d0_formation_space, ":division"),
          (team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
          (gt, ":div_spacing", ":min_spacing"),
          (val_sub, ":div_spacing", 1),
          (team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),

          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (gt, ":formation", formation_none),

          (store_add, ":slot", slot_team_d0_fclock, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 1),

          (try_begin),	#bring unformed divisions into sync with formations' minimum
            (lt, ":div_spacing", 0),
            (set_show_messages, 0),
            (assign, reg0, ":div_spacing"),
            (try_for_range, reg1, reg0, 0),
              (team_give_order, "$fplayer_team_no", ":division", mordr_spread_out),
              (val_add, ":div_spacing", 1),
            (try_end),
            (set_show_messages, 1),
            (store_add, ":slot", slot_team_d0_formation_space, ":division"),
            (team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),

          (else_try),
            (call_script, "script_get_formation_destination", pos1, "$fplayer_team_no", ":division"),
            (try_begin),
              (store_add, ":slot", slot_team_d0_first_member, ":division"),
              (team_slot_eq, "$fplayer_team_no", ":slot", "$fplayer_agent_no"),
              (assign, ":first_member_is_player", 1),
            (else_try),
              (assign, ":first_member_is_player", 0),
            (try_end),
            (store_add, ":slot", slot_team_d0_type, ":division"),
            (try_begin),
              (team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
              (store_add, ":slot", slot_team_d0_size, ":division"),
              (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
              (call_script, "script_get_centering_amount", formation_default, ":troop_count", ":div_spacing"),
              (val_mul, reg0, -1),
              (position_move_x, pos1, reg0),
              (call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
            (else_try),
              (this_or_next | team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
              (team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
              (call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player"),
            (else_try),
              (store_add, ":slot", slot_team_d0_size, ":division"),
              (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
              (call_script, "script_get_centering_amount", ":formation", ":troop_count", ":div_spacing"),
              (position_move_x, pos1, reg0),
              (call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
            (try_end),
          (try_end),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_spread_out),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),

          (try_begin),
            (eq, Native_Formations_Implementation, WFaS_Implementation),
            (assign, ":max_spacing", 3),
          (else_try),
            (assign, ":max_spacing", 2),
          (try_end),

          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (store_add, ":slot", slot_team_d0_formation_space, ":division"),
          (team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
          (try_begin),
            (this_or_next | lt, ":div_spacing", ":max_spacing"),
            (gt, ":formation", formation_none),
            (val_add, ":div_spacing", 1),
          (try_end),
          (team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),

          (gt, ":formation", formation_none),

          (store_add, ":slot", slot_team_d0_fclock, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 1),

          #bring unformed divisions into sync with formations' minimum
          (set_show_messages, 0),
          (assign, reg0, ":div_spacing"),
          (try_for_range, reg1, reg0, 1),
            (team_give_order, "$fplayer_team_no", ":division", mordr_spread_out),
            (val_add, ":div_spacing", 1),
          (try_end),
          (set_show_messages, 1),
          (store_add, ":slot", slot_team_d0_formation_space, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", ":div_spacing"),

          (call_script, "script_get_formation_destination", pos1, "$fplayer_team_no", ":division"),
          (try_begin),
            (store_add, ":slot", slot_team_d0_first_member, ":division"),
            (team_slot_eq, "$fplayer_team_no", ":slot", "$fplayer_agent_no"),
            (assign, ":first_member_is_player", 1),
          (else_try),
            (assign, ":first_member_is_player", 0),
          (try_end),
          (store_add, ":slot", slot_team_d0_type, ":division"),
          (try_begin),
            (team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
            (store_add, ":slot", slot_team_d0_size, ":division"),
            (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
            (call_script, "script_get_centering_amount", formation_default, ":troop_count", ":div_spacing"),
            (val_mul, reg0, -1),
            (position_move_x, pos1, reg0),
            (call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
          (else_try),
            (this_or_next | team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
            (team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
            (call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player"),
          (else_try),
            (store_add, ":slot", slot_team_d0_size, ":division"),
            (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
            (call_script, "script_get_centering_amount", ":formation", ":troop_count", ":div_spacing"),
            (position_move_x, pos1, reg0),
            (call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
          (try_end),
        (try_end),

      (else_try),
        (eq, ":forder", mordr_stand_ground),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_target_team, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", -1),
          (store_add, ":slot", slot_team_d0_move_order, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", ":forder"),

          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":formation", "$fplayer_team_no", ":slot"),
          (gt, ":formation", formation_none),

          (store_add, ":slot", slot_team_d0_fclock, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 1),

          (call_script, "script_formation_current_position", pos63, "$fplayer_team_no", ":division"),
          (copy_position, pos1, pos63),
          (store_add, ":slot", slot_team_d0_formation_space, ":division"),
          (team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),

          (try_begin),
            (store_add, ":slot", slot_team_d0_first_member, ":division"),
            (team_slot_eq, "$fplayer_team_no", ":slot", "$fplayer_agent_no"),
            (assign, ":first_member_is_player", 1),
          (else_try),
            (assign, ":first_member_is_player", 0),
          (try_end),
          (store_add, ":slot", slot_team_d0_type, ":division"),
          (try_begin),
            (team_slot_eq, "$fplayer_team_no", ":slot", sdt_archer),
            (store_add, ":slot", slot_team_d0_size, ":division"),
            (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
            (call_script, "script_get_centering_amount", formation_default, ":troop_count", ":div_spacing"),
            (val_mul, reg0, -1),
            (position_move_x, pos1, reg0),
            (call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
          (else_try),
            (this_or_next | team_slot_eq, "$fplayer_team_no", ":slot", sdt_cavalry),
            (team_slot_eq, "$fplayer_team_no", ":slot", sdt_harcher),
            (call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player"),
          (else_try),
            (store_add, ":slot", slot_team_d0_size, ":division"),
            (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
            (call_script, "script_get_centering_amount", ":formation", ":troop_count", ":div_spacing"),
            (position_move_x, pos1, reg0),
            (call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":formation"),
          (try_end),
          (call_script, "script_set_formation_destination", "$fplayer_team_no", ":division", pos63),
        (try_end),
      (try_end)]),

  # script_memorize_division_placements by motomataru
  # Inputs: none
  # Output: none
  ("memorize_division_placements", [
      (set_fixed_point_multiplier, 100),
      (call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, "$fplayer_team_no", grc_everyone),
      (assign, ":num_enemies", reg0),

      (try_for_range, ":division", 0, 9),
        (class_is_listening_order, "$fplayer_team_no", ":division"),
        (store_add, ":slot", slot_team_d0_size, ":division"),
        (team_slot_ge, "$fplayer_team_no", ":slot", 1),

        (store_add, ":slot", slot_team_d0_formation, ":division"),
        (team_get_slot, ":value", "$fplayer_team_no", ":slot"),
        (store_add, ":slot", slot_faction_d0_mem_formation, ":division"),
        (faction_set_slot, "fac_player_faction", ":slot", ":value"),

        (store_add, ":slot", slot_team_d0_formation_space, ":division"),
        (team_get_slot, ":value", "$fplayer_team_no", ":slot"),
        (store_add, ":slot", slot_faction_d0_mem_formation_space, ":division"),
        (faction_set_slot, "fac_player_faction", ":slot", ":value"),

        (agent_get_position, pos1, "$fplayer_agent_no"),
        (try_begin),
          (neq, ":num_enemies", 0),	#more than 0 enemies still alive?
          (call_script, "script_point_y_toward_position", pos1, Enemy_Team_Pos),
        (try_end),
        # (call_script, "script_get_formation_destination", Current_Pos,
        # "$fplayer_team_no", ":division"),
        (team_get_order_position, Current_Pos, "$fplayer_team_no", ":division"),	#use this to capture Native Advance and Fall Back positioning
        (position_transform_position_to_local, Temp_Pos, pos1, Current_Pos), #Temp_Pos = vector to division w.r.t.  leader facing enemy

        (position_get_x, ":value", Temp_Pos),
        (store_add, ":slot", slot_faction_d0_mem_relative_x_flag, ":division"),
        (faction_set_slot, "fac_player_faction", ":slot", ":value"),

        (position_get_y, ":value", Temp_Pos),
        (store_add, ":slot", slot_faction_d0_mem_relative_y, ":division"),
        (faction_set_slot, "fac_player_faction", ":slot", ":value"),

        (store_add, ":slot", slot_team_d0_type, ":division"),
        (team_get_slot, ":value", "$fplayer_team_no", ":slot"),
        (call_script, "script_str_store_division_type_name", s1, ":value"),
        (store_add, reg0, ":division", 1),
        (display_message, "@The placement of {s1} division {reg0} memorized."),
      (try_end),]),

  # script_default_division_placements by motomataru
  # Inputs: none
  # Output: none
  ("default_division_placements", [
      (try_for_range, ":division", 0, 9),
        (class_is_listening_order, "$fplayer_team_no", ":division"),
        (store_add, ":slot", slot_faction_d0_mem_relative_x_flag, ":division"),	#use as flag
        (faction_set_slot, "fac_player_faction", ":slot", 0),

        (store_add, ":slot", slot_team_d0_size, ":division"),
        (team_slot_ge, "$fplayer_team_no", ":slot", 1),
        (store_add, ":slot", slot_team_d0_type, ":division"),
        (team_get_slot, ":value", "$fplayer_team_no", ":slot"),
        (call_script, "script_str_store_division_type_name", s1, ":value"),
        (store_add, reg0, ":division", 1),
        (display_message, "@The placement of {s1} division {reg0} set to default."),
      (try_end),]),

  # script_process_place_divisions by motomataru
  # Inputs: none
  # Output: none
  # Expects team_set_order_position has been done
  ("process_place_divisions", [
      (assign, ":num_bgroups", 0),
      (try_for_range, ":division", 0, 9),
        (class_is_listening_order, "$fplayer_team_no", ":division"),
        (store_add, ":slot", slot_team_d0_target_team, ":division"),
        (team_set_slot, "$fplayer_team_no", ":slot", -1),
        (store_add, ":slot", slot_team_d0_size, ":division"),
        (team_slot_ge, "$fplayer_team_no", ":slot", 1),
        (store_add, ":slot", slot_team_d0_fclock, ":division"),
        (team_set_slot, "$fplayer_team_no", ":slot", 1),
        (team_get_order_position, pos1, "$fplayer_team_no", ":division"),
        (val_add, ":num_bgroups", 1),
      (try_end),

      (try_begin),
        (gt, ":num_bgroups", 0),
        (copy_position, Target_Pos, pos1),	#kludge around team_get_order_position rotation problems

        (try_begin),
          (eq, "$battle_phase", BP_Deploy),

          (try_begin),
            (eq, "$g_is_quick_battle", 1),
            (assign, reg0, 5),
          (else_try),
            (party_get_skill_level, reg0, "p_main_party", "skl_tactics"),
          (try_end),
          (store_mul, ":range_limit", reg0, 1000),

          (agent_get_position, Temp_Pos, "$fplayer_agent_no"),
          (get_distance_between_positions, reg0, Target_Pos, Temp_Pos),
          (lt, ":range_limit", reg0),
          (display_message, "@Your party's tactical skill limits how far away you can deploy your troops!"),
          (call_script, "script_point_y_toward_position", Temp_Pos, Target_Pos),
          (copy_position, Target_Pos, Temp_Pos),
          (position_move_y, Target_Pos, ":range_limit"),
        (try_end),

        #player designating target battlegroup?
        (assign, ":distance_to_enemy", Far_Away),
        (try_for_range, ":team", 0, 4),
          (teams_are_enemies, ":team", "$fplayer_team_no"),
          (team_slot_ge, ":team", slot_team_size, 1),
          (try_for_range, ":division", 0, 9),
            (store_add, ":slot", slot_team_d0_size, ":division"),
            (team_slot_ge, ":team", ":slot", 1),
            (call_script, "script_battlegroup_get_position", Temp_Pos, ":team", ":division"),
            (get_distance_between_positions, reg0, Target_Pos, Temp_Pos),
            (gt, ":distance_to_enemy", reg0),
            (assign, ":distance_to_enemy", reg0),
            (assign, ":closest_enemy_team", ":team"),
            (assign, ":closest_enemy_division", ":division"),
          (try_end),
        (try_end),

        (call_script, "script_battlegroup_get_action_radius", ":closest_enemy_team", ":closest_enemy_division"),
        (assign, ":radius_enemy_battlegroup", reg0),

        (try_begin),
          (le, ":distance_to_enemy", ":radius_enemy_battlegroup"),	#target position within radius of an enemy battlegroup?
          (le, ":distance_to_enemy", AI_charge_distance),	#limit so player can place divisions near large enemy battlegroups without
          #selecting them
          (call_script, "script_battlegroup_get_position", Target_Pos, ":closest_enemy_team", ":closest_enemy_division"),
          (gt, ":num_bgroups", 1),
          (store_add, ":slot", slot_team_d0_type, ":closest_enemy_division"),
          (team_get_slot, reg0, ":closest_enemy_team", ":slot"),
          (call_script, "script_str_store_division_type_name", s1, reg0),
          (display_message, "@...and attack enemy {s1} division!"),
        (try_end),

        (call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, "$fplayer_team_no", grc_everyone),
        (call_script, "script_point_y_toward_position", Target_Pos, Enemy_Team_Pos),

        #place player divisions
        (agent_get_position, pos49, "$fplayer_agent_no"),
        (try_for_range, ":division", 0, 9),
          (class_is_listening_order, "$fplayer_team_no", ":division"),
          (store_add, ":slot", slot_team_d0_size, ":division"),
          (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
          (gt, ":troop_count", 0),

          (try_begin),
            (le, ":distance_to_enemy", ":radius_enemy_battlegroup"),	#target position within radius of an enemy battlegroup?
            (le, ":distance_to_enemy", AI_charge_distance),	#limit so player can place divisions near large enemy battlegroups without
            #selecting them
            (store_add, ":slot", slot_team_d0_target_team, ":division"),
            (team_set_slot, "$fplayer_team_no", ":slot", ":closest_enemy_team"),
            (store_add, ":slot", slot_team_d0_target_division, ":division"),
            (team_set_slot, "$fplayer_team_no", ":slot", ":closest_enemy_division"),
          (try_end),

          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":fformation", "$fplayer_team_no", ":slot"),

          (try_begin),
            (gt, ":num_bgroups", 1),
            (agent_set_position, "$fplayer_agent_no", Target_Pos),	#fake out script_battlegroup_place_around_leader
            (call_script, "script_player_attempt_formation", ":division", ":fformation", 0),
          (else_try),
            (try_begin),
              (le, ":distance_to_enemy", ":radius_enemy_battlegroup"),	#target position within radius of an enemy battlegroup?
              (le, ":distance_to_enemy", AI_charge_distance),	#limit so player can place divisions near large enemy battlegroups without
              #selecting them
              (call_script, "script_battlegroup_get_attack_destination", Target_Pos, "$fplayer_team_no", ":division", ":closest_enemy_team", ":closest_enemy_division"),
              (store_add, ":slot", slot_team_d0_type, ":closest_enemy_division"),
              (team_get_slot, reg0, ":closest_enemy_team", ":slot"),
              (call_script, "script_str_store_division_type_name", s1, reg0),
              (display_message, "@...and attack enemy {s1} division!"),
            (try_end),

            (call_script, "script_set_formation_destination", "$fplayer_team_no", ":division", Target_Pos),

            (gt, ":fformation", formation_none),
            (store_add, ":slot", slot_team_d0_formation_space, ":division"),
            (team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
            (try_begin),
              (store_add, ":slot", slot_team_d0_type, ":division"),
              (team_get_slot, ":sd_type", "$fplayer_team_no", ":slot"),
              (neq, ":sd_type", sdt_cavalry),
              (neq, ":sd_type", sdt_harcher),
              (try_begin),
                (eq, ":sd_type", sdt_archer),
                (call_script, "script_get_centering_amount", formation_default, ":troop_count", ":div_spacing"),
                (val_mul, reg0, -1),
                (assign, ":script", "script_form_archers"),
              (else_try),
                (call_script, "script_get_centering_amount", ":fformation", ":troop_count", ":div_spacing"),
                (assign, ":script", "script_form_infantry"),
              (try_end),
              (position_move_x, Target_Pos, reg0),
            (else_try),
              (assign, ":script", "script_form_cavalry"),
            (try_end),
            (copy_position, pos1, Target_Pos),
            (call_script, ":script", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", 0, ":fformation"),
          (try_end),
          (store_add, ":slot", slot_team_d0_move_order, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", mordr_hold),
        (try_end), #division loop
        (agent_set_position, "$fplayer_agent_no", pos49),
      (try_end),	#num_bgroups > 0
  ]),

  # script_process_player_division_positioning by motomataru
  # Inputs: none
  # Output: none
  # Expects Enemy_Team_Pos
  ("process_player_division_positioning", [
      (call_script, "script_division_reset_places"),

      #implement HOLD OVER THERE when player lets go of key
      (try_begin),
        (ge, "$gk_order_hold_over_there", HOT_F1_held),
        (neg | game_key_is_down, gk_order_1),
        (assign, "$gk_order_hold_over_there", HOT_no_order),
        (call_script, "script_process_place_divisions"),
      (try_end),	#HOLD OVER THERE

      #periodic functions
      (assign, ":save_autorotate", "$FormAI_autorotate"),
      (assign, "$FormAI_autorotate", 0),
      (try_for_range, ":division", 0, 9),
        (store_add, ":slot", slot_team_d0_size, ":division"),
        (team_get_slot, ":troop_count", "$fplayer_team_no", ":slot"),
        (gt, ":troop_count", 0),

        (store_add, ":slot", slot_team_d0_target_team, ":division"),
        (team_get_slot, ":target_team", "$fplayer_team_no", ":slot"),
        (store_add, ":slot", slot_team_d0_target_division, ":division"),
        (team_get_slot, ":target_division", "$fplayer_team_no", ":slot"),
        (try_begin),
          (ge, ":target_team", 0),	#enemy battlegroup targeted?
          (store_add, ":slot", slot_team_d0_size, ":target_division"),
          (team_get_slot, reg0, ":target_team", ":slot"),

          (le, reg0, 0),	#target destroyed?
          (store_add, ":slot", slot_team_d0_target_team, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", -1),

          (store_add, ":slot", slot_team_d0_type, ":target_division"),
          (team_get_slot, reg0, ":target_team", ":slot"),
          (call_script, "script_str_store_division_type_name", s1, reg0),

          (str_store_class_name, s2, ":division"),
          (display_message, "@{s2}: returning after destroying enemy {s1} division."),
          (store_add, ":slot", slot_team_d0_move_order, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", mordr_follow),
        (try_end),

        (store_add, ":slot", slot_team_d0_fclock, ":division"),
        (team_get_slot, ":fclock", "$fplayer_team_no", ":slot"),
        (store_mod, ":time_slice", ":fclock", Reform_Trigger_Modulus),
        (val_add, ":fclock", 1),
        (team_set_slot, "$fplayer_team_no", ":slot", ":fclock"),

        (try_begin),
          (store_add, ":slot", slot_team_d0_move_order, ":division"),
          (team_slot_eq, "$fplayer_team_no", ":slot", mordr_follow),
          (call_script, "script_battlegroup_place_around_leader", "$fplayer_team_no", ":division", "$fplayer_agent_no"),
          (team_set_slot, "$fplayer_team_no", ":slot", mordr_follow),	#override script_battlegroup_place_around_leader

        #periodically reform
        (else_try),
          (eq, ":time_slice", 0),
          (team_get_movement_order, reg0, "$fplayer_team_no", ":division"),
          (neq, reg0, mordr_stand_ground),

          (call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, "$fplayer_team_no", grc_everyone),
          (store_add, ":slot", slot_team_d0_formation, ":division"),
          (team_get_slot, ":fformation", "$fplayer_team_no", ":slot"),
          (try_begin),
            (gt, ":fformation", formation_none),
            (store_add, ":slot", slot_team_d0_formation_space, ":division"),
            (team_get_slot, ":div_spacing", "$fplayer_team_no", ":slot"),
            (store_add, ":slot", slot_team_d0_type, ":division"),
            (team_get_slot, ":sd_type", "$fplayer_team_no", ":slot"),

            (try_begin),
              (store_add, ":slot", slot_team_d0_first_member, ":division"),
              (team_slot_eq, "$fplayer_team_no", ":slot", "$fplayer_agent_no"),
              (assign, ":first_member_is_player", 1),
            (else_try),
              (assign, ":first_member_is_player", 0),
            (try_end),

            (try_begin),
              (ge, ":target_team", 0),	#enemy battlegroup targeted?
              (try_begin),
                (this_or_next | eq, ":sd_type", sdt_archer),
                (this_or_next | eq, ":sd_type", sdt_harcher),
                (eq, ":sd_type", sdt_skirmisher),
                (store_add, ":slot", slot_team_d0_is_fighting, ":division"),
                (team_slot_ge, "$fplayer_team_no", ":slot", 1),	#ranged are firing?
                (call_script, "script_formation_current_position", pos1, "$fplayer_team_no", ":division"),	#stop advancing
              (else_try),
                (call_script, "script_battlegroup_get_attack_destination", pos1, "$fplayer_team_no", ":division", ":target_team", ":target_division"),
              (try_end),

            (else_try),
              (call_script, "script_get_formation_destination", pos1, "$fplayer_team_no", ":division"),
              (store_add, ":slot", slot_team_d0_is_fighting, ":division"),
              (team_get_slot, ":is_fighting", "$fplayer_team_no", ":slot"),
              (try_begin),
                (neq, ":sd_type", sdt_cavalry),
                (neq, ":sd_type", sdt_harcher),
                (neq, ":is_fighting", 0),
                (eq, ":first_member_is_player", 0),
                (position_move_y, pos1, -2000),
              (try_end),
              (call_script, "script_point_y_toward_position", pos1, Enemy_Team_Pos),
              (try_begin),
                (neq, ":sd_type", sdt_cavalry),
                (neq, ":sd_type", sdt_harcher),
                (neq, ":is_fighting", 0),
                (eq, ":first_member_is_player", 0),
                (position_move_y, pos1, 2000),
              (try_end),
            (try_end),

            (call_script, "script_set_formation_destination", "$fplayer_team_no", ":division", pos1),

            (try_begin),
              (eq, ":sd_type", sdt_archer),
              (call_script, "script_get_centering_amount", formation_default, ":troop_count", ":div_spacing"),
              (val_mul, reg0, -1),
              (position_move_x, pos1, reg0),
            (else_try),
              (neq, ":sd_type", sdt_cavalry),
              (neq, ":sd_type", sdt_harcher),
              (call_script, "script_get_centering_amount", ":fformation", ":troop_count", ":div_spacing"),
              (position_move_x, pos1, reg0),
            (try_end),

            (try_begin),
              (eq, ":sd_type", sdt_archer),
              (call_script, "script_form_archers", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":fformation"),
            (else_try),
              (this_or_next | eq, ":sd_type", sdt_cavalry),
              (eq, ":sd_type", sdt_harcher),
              (try_begin),
                (ge, ":target_team", 0),	#enemy battlegroup targeted?
                (call_script, "script_formation_current_position", pos29, "$fplayer_team_no", ":division"),
                (call_script, "script_battlegroup_get_position", Enemy_Team_Pos, ":target_team", ":target_division"),
                (get_distance_between_positions, ":distance_to_enemy", pos29, Enemy_Team_Pos),

                (call_script, "script_battlegroup_get_action_radius", "$fplayer_team_no", ":division"),
                (assign, ":combined_radius", reg0),
                (call_script, "script_battlegroup_get_action_radius", ":target_team", ":target_division"),
                (val_add, ":combined_radius", reg0),

                (le, ":distance_to_enemy", ":combined_radius"),
                (call_script, "script_formation_end", "$fplayer_team_no", ":division"),
                (str_store_class_name, s1, ":division"),
                (display_message, "@{s1}: cavalry formation disassembled."),
                (set_show_messages, 0),
                (team_give_order, "$fplayer_team_no", ":division", mordr_charge),
                (set_show_messages, 1),
              (else_try),
                (call_script, "script_form_cavalry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player"),
              (try_end),
            (else_try),
              (call_script, "script_form_infantry", "$fplayer_team_no", ":division", "$fplayer_agent_no", ":div_spacing", ":first_member_is_player", ":fformation"),
            (try_end),

          (else_try),	#divisions not in formation
            (ge, ":target_team", 0),	#enemy battlegroup targeted?
            (store_add, ":slot", slot_team_d0_target_division, ":division"),
            (team_get_slot, ":target_division", "$fplayer_team_no", ":slot"),
            (try_begin),
              (this_or_next | eq, ":sd_type", sdt_archer),
              (this_or_next | eq, ":sd_type", sdt_harcher),
              (eq, ":sd_type", sdt_skirmisher),
              (store_add, ":slot", slot_team_d0_is_fighting, ":division"),
              (team_slot_ge, "$fplayer_team_no", ":slot", 1),	#ranged are firing?
              (call_script, "script_battlegroup_get_position", pos1, "$fplayer_team_no", ":division"),	#stop advancing
            (else_try),
              (call_script, "script_battlegroup_get_attack_destination", pos1, "$fplayer_team_no", ":division", ":target_team", ":target_division"),
            (try_end),
            (call_script, "script_set_formation_destination", "$fplayer_team_no", ":division", pos1),
            (team_get_movement_order, ":existing_order", "$fplayer_team_no", ":division"),
            (try_begin),
              (ge, ":target_team", 0),	#enemy battlegroup targeted?
              (call_script, "script_battlegroup_get_position", pos29, "$fplayer_team_no", ":division"),
              (call_script, "script_battlegroup_get_position", Enemy_Team_Pos, ":target_team", ":target_division"),
              (get_distance_between_positions, ":distance_to_enemy", pos29, Enemy_Team_Pos),

              (call_script, "script_battlegroup_get_action_radius", "$fplayer_team_no", ":division"),
              (assign, ":combined_radius", reg0),
              (call_script, "script_battlegroup_get_action_radius", ":target_team", ":target_division"),
              (val_add, ":combined_radius", reg0),

              (le, ":distance_to_enemy", ":combined_radius"),
              (try_begin),
                (neq, ":existing_order", mordr_charge),
                (set_show_messages, 0),
                (team_give_order, "$fplayer_team_no", ":division", mordr_charge),
                (set_show_messages, 1),
              (try_end),
            (else_try),
              (neq, ":existing_order", mordr_hold),
              (set_show_messages, 0),
              (team_give_order, "$fplayer_team_no", ":division", mordr_hold),
              (set_show_messages, 1),
            (try_end),
          (try_end),
        (try_end),	#Periodic Reform
      (try_end),	#Division Loop

      (assign, "$FormAI_autorotate", ":save_autorotate"),]),


  # #Utilities used by formations
  # script_cf_is_thrusting_weapon by motomataru
  # Input: item
  # Output: T/F
  ("cf_is_thrusting_weapon", [
      (store_script_param, ":item", 1),
      (is_between, ":item", weapons_begin, weapons_end),
      (item_get_thrust_damage, ":thrust_damage", ":item"),
      (item_get_swing_damage, ":swing_damage", ":item"),
      (val_mul, ":thrust_damage", 3),	#it seems thrusts connect faster than swings (as they should) although the
      #animations seem to take the same time
      (val_div, ":thrust_damage", 2),	#factor this in with approximation 2*PI/4 (distance swing must travel vs.
      #thrust) This ignores length, which creates too large a differential.  This is
      #a happy medium.
      (ge, ":thrust_damage", ":swing_damage"),]),

  # script_cf_is_weapon_ranged by motomataru
  # Input: weapon ID, flag 0/1 to consider thrown weapons
  # Output: T/F
  ("cf_is_weapon_ranged", [
      (store_script_param, ":weapon", 1),
      (store_script_param, ":include_thrown", 2),

      (assign, ":test_val", 0),
      (try_begin),
        (ge, ":weapon", 0),
        (item_get_type, ":type", ":weapon"),
        (try_begin),
          (this_or_next | eq, ":type", itp_type_bow),
          (this_or_next | eq, ":type", itp_type_crossbow),
          (this_or_next | eq, ":type", itp_type_pistol),
          (eq, ":type", itp_type_musket),
          (assign, ":test_val", 1),
        (else_try),
          (eq, ":type", itp_type_thrown),
          (neq, ":include_thrown", 0),
          (assign, ":test_val", 1),
        (try_end),
      (try_end),

      (neq, ":test_val", 0),]),

  # script_equip_best_melee_weapon by motomataru
  # Input: agent id, flag to force shield, flag to force for length ALONE,
  # current fire order
  # Output: none
  ("equip_best_melee_weapon", [
      (store_script_param, ":agent", 1),
      (store_script_param, ":force_shield", 2),
      (store_script_param, ":force_length", 3),
      (store_script_param, ":fire_order", 4),

      (agent_get_wielded_item, ":cur_wielded", ":agent", 0),
      (try_begin),
        (call_script, "script_cf_is_weapon_ranged", ":cur_wielded", 0),
        (agent_get_ammo, ":ammo", ":agent", 1),
        (gt, ":ammo", 0),

      (else_try),
        #priority items
        (assign, ":shield", itm_no_item),
        (assign, ":weapon", itm_no_item),
        (try_for_range, ":item_slot", ek_item_0, ek_head),
          (agent_get_item_slot, ":item", ":agent", ":item_slot"),
          (gt, ":item", itm_no_item),
          (item_get_type, ":weapon_type", ":item"),
          (try_begin),
            (eq, ":weapon_type", itp_type_shield),
            (assign, ":shield", ":item"),
          (else_try),
            (eq, ":weapon_type", itp_type_thrown),
            (eq, ":fire_order", aordr_fire_at_will),
            # (agent_get_ammo, ":ammo", ":agent", 0), #assume infantry would have no
            # other kind of ranged weapon
            # (gt, ":ammo", 0),
            (assign, ":weapon", ":item"),	#use thrown weapons first
          (try_end),
        (try_end),

        #select weapon
        (try_begin),
          (eq, ":weapon", itm_no_item),
          (assign, ":cur_score", 0),
          (try_for_range, ":item_slot", ek_item_0, ek_head),
            (agent_get_item_slot, ":item", ":agent", ":item_slot"),
            (gt, ":item", itm_no_item),
            (item_get_type, ":weapon_type", ":item"),
            (neq, ":weapon_type", itp_type_shield),

            (try_begin),
              (item_has_property, ":item", itp_two_handed),
              (assign, reg0, 1),
            (else_try),
              (assign, reg0, 0),
            (try_end),

            (this_or_next | eq, reg0, 0),
            (this_or_next | eq, ":force_shield", 0),
            (eq, ":shield", itm_no_item),

            (try_begin),
              (call_script, "script_cf_is_weapon_ranged", ":item", 1),

            (else_try),
              (try_begin),
                (neq, ":force_length", 0),
                (item_get_weapon_length, ":item_length", ":item"),
                (try_begin),
                  (lt, ":cur_score", ":item_length"),
                  (assign, ":cur_score", ":item_length"),
                  (assign, ":weapon", ":item"),
                (try_end),
              (else_try),
                (agent_get_troop_id, ":troop_id", ":agent"),
                (troop_is_guarantee_horse, ":troop_id"),
                (agent_get_horse, ":horse", ":agent"),
                (le, ":horse", 0),
                (try_for_range, ":item_slot", ek_item_0, ek_head),
                  (agent_get_item_slot, ":item", ":agent", ":item_slot"),
                  (gt, ":item", itm_no_item),
                  (item_get_type, ":weapon_type", ":item"),
                  (eq, ":weapon_type", itp_type_one_handed_wpn),
                  (item_get_swing_damage, ":swing", ":item"),
                  (gt, ":swing", 19),
                  (assign, ":weapon", ":item"),
                (try_end),
              (else_try),
                (agent_get_troop_id, ":troop_id", ":agent"),
                (assign, ":imod", imod_plain),
                (try_begin),    #only heroes have item modifications
                  (troop_is_hero, ":troop_id"),
                  (try_for_range, ":troop_item_slot",  ek_item_0, ek_head),    # heroes have only 4 possible weapons (equipped)
                    (troop_get_inventory_slot, reg0, ":troop_id", ":troop_item_slot"),  #Find Item Slot with same item ID as Equipped Weapon
                    (eq, reg0, ":item"),
                    (troop_get_inventory_slot_modifier, ":imod", ":troop_id", ":troop_item_slot"),
                  (try_end),
                (try_end),
                (call_script, "script_evaluate_item", ":item", ":imod"),
                (lt, ":cur_score", reg0),
                (assign, ":cur_score", reg0),
                (assign, ":weapon", ":item"),
              (try_end),
            (try_end),  #melee weapon
          (try_end),  #weapon slot loop
        (try_end),  #select weapon

        #equip selected items if needed
        (try_begin),
          (neq, ":cur_wielded", ":weapon"),
          (try_begin),
            (gt, ":shield", itm_no_item),
            (agent_get_wielded_item, reg0, ":agent", 1),
            (neq, reg0, ":shield"),	#reequipping secondary will UNequip (from experience)
            (agent_set_wielded_item, ":agent", ":shield"),
          (try_end),
          (gt, ":weapon", itm_no_item),
          (agent_set_wielded_item, ":agent", ":weapon"),
        (try_end),
      (try_end),]),

  # script_set_formation_destination by motomataru
  # Input: team, troop class, position
  # Kluge around buggy *_order_position functions for teams 0-3
  ("set_formation_destination", [
      (store_script_param, ":fteam", 1),
      (store_script_param, ":fdivision", 2),
      (store_script_param, ":fposition", 3),

      (position_get_x, ":x", ":fposition"),
      (position_get_y, ":y", ":fposition"),
      (position_get_rotation_around_z, ":zrot", ":fposition"),

      (store_add, ":slot", slot_team_d0_destination_x, ":fdivision"),
      (team_set_slot, ":fteam", ":slot", ":x"),
      (store_add, ":slot", slot_team_d0_destination_y, ":fdivision"),
      (team_set_slot, ":fteam", ":slot", ":y"),
      (store_add, ":slot", slot_team_d0_destination_zrot, ":fdivision"),
      (team_set_slot, ":fteam", ":slot", ":zrot"),

      (team_set_order_position, ":fteam", ":fdivision", ":fposition"),]),

  # script_get_formation_destination by motomataru
  # Input: position, team, troop class
  # Output: input position (pos0 used)
  # Kluge around buggy *_order_position functions for teams 0-3
  ("get_formation_destination", [
      (store_script_param, ":fposition", 1),
      (store_script_param, ":fteam", 2),
      (store_script_param, ":fdivision", 3),
      (init_position, ":fposition"),
      # (try_begin),
      #(is_between, ":fteam", 0, 4), #Caba - this will always pass MOTO except in
      #mods with more than four teams (eg SWC arena) but now obsolete by other
      #limits
      (store_add, ":slot", slot_team_d0_destination_x, ":fdivision"),
      (team_get_slot, ":x", ":fteam", ":slot"),
      (store_add, ":slot", slot_team_d0_destination_y, ":fdivision"),
      (team_get_slot, ":y", ":fteam", ":slot"),
      (store_add, ":slot", slot_team_d0_destination_zrot, ":fdivision"),
      (team_get_slot, ":zrot", ":fteam", ":slot"),

      (position_set_x, ":fposition", ":x"),
      (position_set_y, ":fposition", ":y"),
      (position_rotate_z, ":fposition", ":zrot"),
      # (else_try),
      # (store_add, ":slot", slot_team_d0_first_member, ":fdivision"), #only
      # defined for divisions in formation
      # (team_get_slot, reg0, ":fteam", ":slot"),
      # (try_begin), # "launder" team_get_order_position shutting down
      # position_move_x
      # (gt, reg0, -1),
      # (team_get_order_position, ":fposition", ":fteam", ":fdivision"),
      # (agent_get_position, pos0, reg0),
      # (agent_set_position, reg0, ":fposition"),
      # (agent_get_position, ":fposition", reg0),
      # (agent_set_position, reg0, pos0),
      # (try_end),
      # (try_end),
      (position_set_z_to_ground_level, ":fposition"),]),

  # script_formation_current_position by motomataru
  # Input: destination position (not pos0), team, division
  # Output: in destination position
  # As opposed to script_battlegroup_get_position, this obtains target rotation
  # from formation destination and positions at the center of the front
  ("formation_current_position", [
      (store_script_param, ":fposition", 1),
      (store_script_param, ":fteam", 2),
      (store_script_param, ":fdivision", 3),
      (call_script, "script_battlegroup_get_position", ":fposition", ":fteam", ":fdivision"),
      (call_script, "script_get_formation_destination", pos0, ":fteam", ":fdivision"),
      (position_copy_rotation, ":fposition", pos0),
      (call_script, "script_battlegroup_dist_center_to_front", ":fteam", ":fdivision"),
      (position_move_y, ":fposition", reg0, 0),]),

  # script_str_store_division_type_name by motomataru
  # Input: destination, division type (sdt_*)
  # Output: none
  ("str_store_division_type_name", [
      (store_script_param, ":str_reg", 1),
      (store_script_param, ":division_type", 2),
      (try_begin),
        (eq, ":division_type", sdt_infantry),
        (str_store_string, ":str_reg", "@infantry"),
      (else_try),
        (eq, ":division_type", sdt_archer),
        (str_store_string, ":str_reg", "@archer"),
      (else_try),
        (eq, ":division_type", sdt_cavalry),
        (str_store_string, ":str_reg", "@cavalry"),
      (else_try),
        (eq, ":division_type", sdt_polearm),
        (str_store_string, ":str_reg", "@polearm"),
      (else_try),
        (eq, ":division_type", sdt_skirmisher),
        (str_store_string, ":str_reg", "@skirmisher"),
      (else_try),
        (eq, ":division_type", sdt_harcher),
        (str_store_string, ":str_reg", "@mounted archer"),
      (else_try),
        (eq, ":division_type", sdt_support),
        (str_store_string, ":str_reg", "@support"),
      (else_try),
        (eq, ":division_type", sdt_bodyguard),
        (str_store_string, ":str_reg", "@bodyguard"),
      (else_try),
        (str_store_string, ":str_reg", "@undetermined type of"),
      (try_end),]),

  # script_formation_to_native_order by motomataru
  # Input: team, division, formation
  # Output: issues team_give_order with appropriate command to make formation
  ("formation_to_native_order", [
      (store_script_param, ":team", 1),
      (store_script_param, ":division", 2),
      (store_script_param, ":formation", 3),

      (try_begin),
        (gt, ":formation", formation_none),	#custom formation (bad call)

      (else_try),
        (eq, Native_Formations_Implementation, WB_Implementation),
        (store_add, ":slot", slot_team_d0_formation_space, ":division"),
        (team_get_slot, ":spacing", ":team", ":slot"),
        (val_sub, ":spacing", ":formation"),	#formation constants indicate number of "Stand Closer"
        (set_show_messages, 0),
        (try_for_range, reg0, 0, ":spacing"),
          (team_give_order, ":team", ":division", mordr_stand_closer),
        (try_end),
        (set_show_messages, 1),
        (team_set_slot, ":team", ":slot", ":spacing"),

      #WFAS implementation
      (else_try),
        (eq, ":formation", formation_1_row),
        (team_give_order, ":team", ":division", mordr_form_1_row),
      (else_try),
        (eq, ":formation", formation_2_row),
        (team_give_order, ":team", ":division", mordr_form_2_row),
      (else_try),
        (eq, ":formation", formation_3_row),
        (team_give_order, ":team", ":division", mordr_form_3_row),
      (else_try),
        (eq, ":formation", formation_4_row),
        (team_give_order, ":team", ":division", mordr_form_4_row),
      (else_try),
        (eq, ":formation", formation_5_row),
        (team_give_order, ":team", ":division", mordr_form_5_row),
      (try_end)]),

  # script_point_y_toward_position by motomataru
  # Input: from position, to position
  # Output: reg0 distance in cm
  # Basically, points the first position at the second, so then simple move_y
  # will move back and forth and move_x side to side
  # Things like cast_ray work with this as well
  ("point_y_toward_position", [
      (store_script_param, ":from_position", 1),
      (store_script_param, ":to_position", 2),
      (assign, ":save_fpm", 1),
      (convert_to_fixed_point, ":save_fpm"),
      (set_fixed_point_multiplier, 100),  #to match cm returned by get_distance_between_positions

      #remove current rotation
      (position_get_x, ":from_x", ":from_position"),
      (position_get_y, ":from_y", ":from_position"),
      (position_get_z, ":from_z", ":from_position"),
      (init_position, ":from_position"),
      (position_set_x, ":from_position", ":from_x"),
      (position_set_y, ":from_position", ":from_y"),
      (position_set_z, ":from_position", ":from_z"),

      #horizontal rotation
      (position_get_x, ":change_in_x", ":to_position"),
      (val_sub, ":change_in_x", ":from_x"),
      (position_get_y, ":change_in_y", ":to_position"),
      (val_sub, ":change_in_y", ":from_y"),

      (try_begin),
        (this_or_next | neq, ":change_in_y", 0),
        (neq, ":change_in_x", 0),
        (store_atan2, ":theta", ":change_in_y", ":change_in_x"),
        (assign, ":ninety", 90),
        (convert_to_fixed_point, ":ninety"),
        (val_sub, ":theta", ":ninety"),	#point Y axis at to position
        (position_rotate_z_floating, ":from_position", ":theta"),
      (try_end),

      #vertical rotation
      (get_distance_between_positions, ":distance_between", ":from_position", ":to_position"),
      (try_begin),
        (gt, ":distance_between", 0),
        (position_get_z, ":dist_z_to_sine", ":to_position"),
        (val_sub, ":dist_z_to_sine", ":from_z"),
        (val_div, ":dist_z_to_sine", ":distance_between"),
        (store_asin, ":theta", ":dist_z_to_sine"),
        (position_rotate_x_floating, ":from_position", ":theta"),
      (try_end),

      (assign, reg0, ":distance_between"),
      (set_fixed_point_multiplier, ":save_fpm"),]),

  #script_agent_fix_division
  #Input: agent_id
  #Output: nothing (agent divisions changed, slot set)
  #To fix AI troop divisions from the engine applying player's party divisions
  #on all agents
  #This is called after agent_reassign_team, so can safely assume correct team
  #is set
  ("agent_fix_division", [
      (store_script_param_1, ":agent"),
      (agent_set_slot, ":agent", slot_agent_new_division, -1),
      (get_player_agent_no, ":player"),	#after_mission_start triggers are called after spawn, so globals can't be used
      #yet

      (try_begin),
        (ge, ":player", 0),
        (neq, ":agent", ":player"),
        (agent_is_human, ":agent"),
        (agent_get_group, ":player_team", ":player"),
        (agent_get_group, ":team", ":agent"),
        (this_or_next | main_hero_fallen),
        (neq, ":team", ":player_team"),

        (assign, ":target_division", grc_infantry),
        (agent_get_horse, ":horse", ":agent"),
        (agent_get_troop_id, ":troop_no", ":agent"),

        #logic from script_troop_default_division
        #limited to the three divisions the AI currently uses
        (try_begin),
          (this_or_next | ge, ":horse", 0),
          (troop_is_guarantee_horse, ":troop_no"),
          (assign, ":target_division", grc_cavalry),

          #(troop_is_guarantee_ranged, ":troop_no"),
          # (try_for_range, ":ranged", "itm_darts", "itm_flintlock_pistol"),
              # (agent_has_item_equipped, ":agent", ":ranged"),
              # (agent_get_ammo, reg1, ":agent", 0),
              # (gt, reg1, 0),
              # (assign, ":target_division", sdt_harcher),
          # (try_end),


          # (try_begin),
          # (eq, ":flag_0_for_expanded", 0),
          # (try_for_range, reg0, 0, ":inv_cap"),
          # (troop_get_inventory_slot, ":item", ":troop_no", reg0),
          # (call_script, "script_cf_is_weapon_ranged", ":item", 1),
          # (assign, ":target_division", sdt_harcher),
          # (try_end),
          # (try_end),

        (else_try),
          (troop_is_guarantee_ranged, ":troop_no"),
          # (assign, ":has_ranged", 0),

          (try_for_range, ":item_slot", ek_item_0, ek_head),
            (agent_get_item_slot, ":item", ":agent", ":item_slot"),
            (call_script, "script_cf_is_weapon_ranged", ":item", 1),
            (agent_get_ammo, reg1, ":agent", 0),
            (ge, reg1, minimum_ranged_ammo),  #more than two to throw on a charge?
            # (item_get_type, reg1, ":item"),
            # (try_begin),
            # (eq, reg1, itp_type_thrown),
            # (eq, ":flag_0_for_expanded", 0),
            # (neq, ":target_division", grc_archers),
            # (assign, ":target_division", sdt_skirmisher),
            # (else_try),
            (assign, ":target_division", grc_archers),
            # (try_end),
            # (assign, ":has_ranged", 1),
          (try_end),

          # (neq, ":has_ranged", 0),

          # (else_try),
          # (eq, ":flag_0_for_expanded", 0),
          # (try_for_range, reg0, 0, ":inv_cap"),
          # (troop_get_inventory_slot, ":item", ":troop_no", reg0),
          # (call_script, "script_cf_is_thrusting_weapon", ":item"),
          # (item_get_type, reg1, ":item"),
          # (eq, reg1, itp_type_polearm),
          # (assign, ":target_division", sdt_polearm),
          # (try_end),
        (try_end),

        (agent_get_division, ":division", ":agent"),
        (neq, ":division", ":target_division"),
        (agent_set_division, ":agent", ":target_division"),
        (agent_set_slot, ":agent", slot_agent_new_division, ":target_division"),
      (try_end),]),

  # script_store_battlegroup_type
  # Input: team, division
  # Output: reg0 and slot_team_dx_type with sdt_* value
  # Automatically called from store_battlegroup_data
  ("store_battlegroup_type", [
      (store_script_param_1, ":fteam"),
      (store_script_param_2, ":fdivision"),

      (assign, ":count_infantry", 0),
      (assign, ":count_archer", 0),
      (assign, ":count_cavalry", 0),
      (assign, ":count_harcher", 0),
      (assign, ":count_polearms", 0),
      (assign, ":count_skirmish", 0),
      (assign, ":count_support", 0),
      (assign, ":count_bodyguard", 0),

      (team_get_leader, ":leader", ":fteam"),

      (try_for_agents, ":cur_agent"),
        (call_script, "script_cf_valid_formation_member", ":fteam", ":fdivision", ":leader", ":cur_agent"),
        (agent_get_troop_id, ":cur_troop", ":cur_agent"),
        (agent_get_ammo, ":cur_ammo", ":cur_agent", 0),

        (try_begin),
          (neg | troop_is_hero, ":cur_troop"),
          (try_begin), #Cavalry
            (agent_get_horse, reg0, ":cur_agent"),
            (ge, reg0, 0),
            (try_begin),
              (ge, ":cur_ammo", minimum_ranged_ammo),
              (val_add, ":count_harcher", 1),
            (else_try),
              (val_add, ":count_cavalry", 1),
            (try_end),
          (else_try), #Archers
            (ge, ":cur_ammo", minimum_ranged_ammo),
            # #use when troops are equipped with ranged at start of battle
            # (agent_get_class, ":bgclass", ":cur_agent"),
            # (eq, ":bgclass", grc_archers),
            # #end use when troops equipped with ranged at start of battle
            (assign, ":end", ek_head),
            (try_for_range, ":i", ek_item_0, ":end"),
              (agent_get_item_slot, ":item", ":cur_agent", ":i"),
              (gt, ":item", 0),
              (item_get_type, ":weapontype", ":item"),
              (is_between, ":weapontype", itp_type_bow, itp_type_thrown),  # bow or crossbow
              (assign, ":end", ek_item_0), #loop Break
            (try_end),
            (try_begin),
              (eq, ":end", ek_head), #failed to find bow or crossbow
              (val_add, ":count_skirmish", 1),
            (else_try),
              (val_add, ":count_archer", 1),
            (try_end),
          (else_try), #Infantry
            (assign, ":end", ek_head),
            (try_for_range, ":i", ek_item_0, ":end"),
              (agent_get_item_slot, ":item", ":cur_agent", ":i"),
              (call_script, "script_cf_is_thrusting_weapon", ":item"),
              (item_get_type, ":weapontype", ":item"),
              (eq, ":weapontype", itp_type_polearm),
              (assign, ":end", ek_item_0), #loop Break
            (try_end),
            (try_begin),
              (eq, ":end", ek_head), #failed to find a polearm
              (val_add, ":count_infantry", 1),
            (else_try),
              (val_add, ":count_polearms", 1),
            (try_end),
          (try_end),
        (else_try), #Heroes
          (assign, ":support_skills", 0), #OPEN TO SUGGESTIONS HERE ?skl_trade, skl_spotting, skl_pathfinding,
          #skl_tracking?
          (store_skill_level, reg0, skl_engineer, ":cur_troop"),
          (val_add, ":support_skills", reg0),
          (store_skill_level, reg0, skl_first_aid, ":cur_troop"),
          (val_add, ":support_skills", reg0),
          (store_skill_level, reg0, skl_surgery, ":cur_troop"),
          (val_add, ":support_skills", reg0),
          (store_skill_level, reg0, skl_wound_treatment, ":cur_troop"),
          (val_add, ":support_skills", reg0),
          (try_begin),
            (gt, ":support_skills", 5),
            (val_add, ":count_support", 1),
          (else_try),
            (val_add, ":count_bodyguard", 1),
          (try_end),
        (try_end), #Regular v Hero
      (try_end), #Agent Loop

      #Do Comparisons With Counts, set ":div_type"
      (assign, ":slot", slot_team_d0_type),
      (team_set_slot, scratch_team, ":slot", ":count_infantry"),
      (val_add, ":slot", 1),
      (team_set_slot, scratch_team, ":slot", ":count_archer"),
      (val_add, ":slot", 1),
      (team_set_slot, scratch_team, ":slot", ":count_cavalry"),
      (val_add, ":slot", 1),
      (team_set_slot, scratch_team, ":slot", ":count_polearms"),
      (val_add, ":slot", 1),
      (team_set_slot, scratch_team, ":slot", ":count_skirmish"),
      (val_add, ":slot", 1),
      (team_set_slot, scratch_team, ":slot", ":count_harcher"),
      (val_add, ":slot", 1),
      (team_set_slot, scratch_team, ":slot", ":count_support"),
      (val_add, ":slot", 1),
      (team_set_slot, scratch_team, ":slot", ":count_bodyguard"),

      (assign, ":count_to_beat", 0),
      (assign, ":count_total", 0),
      (try_for_range, ":type", sdt_infantry, sdt_infantry + 8), #only 8 sdt_types at the moment
        (store_add, ":slot", slot_team_d0_type, ":type"),
        (team_get_slot, ":count", scratch_team, ":slot"),
        (val_add, ":count_total", ":count"),
        (lt, ":count_to_beat", ":count"),
        (assign, ":count_to_beat", ":count"),
        (assign, ":div_type", ":type"),
      (try_end),

      (val_mul, ":count_to_beat", 2),
      (try_begin),
        (lt, ":count_to_beat", ":count_total"), #Less than half of this division
        (assign, ":count_to_beat", 0),
        (assign, ":div_type", -1),
        (try_for_range, ":type", sdt_infantry, sdt_infantry + 3), #check main types for a majority
          (store_add, ":slot", slot_team_d0_type, ":type"),
          (team_get_slot, ":count", scratch_team, ":slot"),
          (val_add, ":slot", 3),	#subtype is three more than main type
          (team_get_slot, reg0, scratch_team, ":slot"),
          (val_add, ":count", reg0),
          (lt, ":count_to_beat", ":count"),
          (assign, ":count_to_beat", ":count"),
          (assign, ":div_type", ":type"),
        (try_end),

        (val_mul, ":count_to_beat", 2),
        (lt, ":count_to_beat", ":count_total"), #Less than half of this division
        (assign, ":div_type", sdt_unknown), #Or 0
      (try_end),

      #hard-code traditional infantry division (avoid player confusion for mods
      #which arm troops with ranged at start of battle)
      (try_begin),
        (eq, ":fdivision", grc_infantry),
        (neq, ":div_type", sdt_polearm),
        (assign, ":div_type", sdt_infantry),
      (try_end),

      (store_add, ":slot", slot_team_d0_type, ":fdivision"),
      (team_set_slot, ":fteam", ":slot", ":div_type"),
      (assign, reg0, ":div_type"),]),

  # script_store_battlegroup_data by motomataru #EDITED TO SLOTS FOR MANY
  # DIVISIONS BY CABA'DRIN
  # Input: none
  # Output: sets positions and globals to track data on ALL groups in a battle
  # Globals used: pos0, pos1, reg0
  ("store_battlegroup_data", [
      (assign, ":team0_leader", 0),
      (assign, ":team0_x_leader", 0),
      (assign, ":team0_y_leader", 0),
      (assign, ":team0_zrot_leader", 0),
      (assign, ":team0_level_leader", 0),
      (assign, ":team1_leader", 0),
      (assign, ":team1_x_leader", 0),
      (assign, ":team1_y_leader", 0),
      (assign, ":team1_zrot_leader", 0),
      (assign, ":team1_level_leader", 0),
      (assign, ":team2_leader", 0),
      (assign, ":team2_x_leader", 0),
      (assign, ":team2_y_leader", 0),
      (assign, ":team2_zrot_leader", 0),
      (assign, ":team2_level_leader", 0),
      (assign, ":team3_leader", 0),
      (assign, ":team3_x_leader", 0),
      (assign, ":team3_y_leader", 0),
      (assign, ":team3_zrot_leader", 0),
      (assign, ":team3_level_leader", 0),

      #save some info
      (try_for_range, ":division", 0, 9),
        (store_add, ":slot", slot_team_d0_size, ":division"),
        (try_begin),
          (team_slot_ge, "$fplayer_team_no", ":slot", 1),
          (store_add, ":slot", slot_team_d0_exists, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 1),

        (else_try),
          (store_add, ":slot", slot_team_d0_exists, ":division"),
          (team_set_slot, "$fplayer_team_no", ":slot", 0),
        (try_end),
      (try_end),

      #Team Slots reset every mission, like agent slots, but just to be sure for
      #when it gets called during the mission
      (try_for_range, ":slot", reset_team_stats_begin, reset_team_stats_end), #Those within the "RESET GROUP" in formations_constants
        (try_for_range, ":team", 0, 4),
          (team_set_slot, ":team", ":slot", 0),
        (try_end),
      (try_end),

      (try_for_agents, ":cur_agent"),
        (agent_set_slot, ":cur_agent", slot_agent_nearest_enemy_agent, -1),

        (agent_is_alive, ":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_slot_eq, ":cur_agent", slot_agent_is_running_away, 0),

        (agent_get_group, ":bgteam", ":cur_agent"),
        (agent_get_division, ":bgdivision", ":cur_agent"),
        (agent_get_class, ":agent_class", ":cur_agent"),
        (agent_get_position, pos1, ":cur_agent"),

        (try_begin),
          (agent_is_non_player, ":cur_agent"),

          (store_add, ":slot", slot_team_d0_type, ":bgdivision"),
          (team_get_slot, ":bgtype", ":bgteam", ":slot"),
          (this_or_next | eq, ":bgtype", sdt_cavalry),	#assigned to horsed division
          (eq, ":bgtype", sdt_harcher),

          (team_get_riding_order, reg0, ":bgteam", ":bgdivision"),
          (neq, reg0, rordr_dismount),

          (team_get_order_position, pos0, ":bgteam", ":bgdivision"),
          (get_distance_between_positions, ":old_distance", pos0, pos1),
          (gt, ":old_distance", AI_charge_distance),	#agent is out of formation?

          (assign, ":target_type", ":bgtype"),

          (try_begin),
            (eq, ":agent_class", grc_infantry),	#Native has transferred this agent to infantry
            (assign, ":target_type", sdt_infantry),

            (try_for_range, ":item_slot", ek_item_0, ek_head),
              (eq, ":bgteam", "$fplayer_team_no"),	#AI doesn't use extended right now
              (agent_get_item_slot, ":item", ":cur_agent", ":item_slot"),
              (call_script, "script_cf_is_thrusting_weapon", ":item"),
              (item_get_type, reg0, ":item"),
              (eq, reg0, itp_type_polearm),
              (assign, ":target_type", sdt_polearm),
            (try_end),

          (else_try),
            (eq, ":agent_class", grc_archers),	#Native has transferred this agent to archers
            (assign, ":target_type", sdt_archer),

            (try_for_range, ":item_slot", ek_item_0, ek_head),
              (eq, ":bgteam", "$fplayer_team_no"),	#AI doesn't use extended right now
              (agent_get_item_slot, ":item", ":cur_agent", ":item_slot"),
              (call_script, "script_cf_is_weapon_ranged", ":item", 1),
              (agent_get_ammo, reg1, ":cur_agent", 0),
              (ge, reg1, minimum_ranged_ammo),  #more than two to throw on a charge?
              (item_get_type, reg0, ":item"),
              (eq, reg0, itp_type_thrown),
              (assign, ":target_type", sdt_skirmisher),
            (try_end),
          (try_end),

          (neq, ":target_type", ":bgtype"),
          (assign, ":bgdivision", ":target_type"),

          (try_for_range_backwards, ":new_division", 0, 9),
            (store_add, ":slot", slot_team_d0_size, ":new_division"),
            (team_get_slot, reg0, ":bgteam", ":slot"),
            (gt, reg0, 0),

            (store_add, ":slot", slot_team_d0_type, ":new_division"),
            (team_get_slot, reg0, ":bgteam", ":slot"),
            (eq, reg0, ":target_type"),

            (assign, ":bgdivision", ":new_division"),
          (try_end),

          (try_begin),
            (store_add, ":slot", slot_team_d0_exists, ":bgdivision"),
            (team_slot_eq, "$fplayer_team_no", ":slot", 0),	#division does not yet exist?
            (agent_is_alive, "$fplayer_agent_no"),
            (store_add, ":slot", slot_team_d0_move_order, ":bgdivision"),
            (neg | team_slot_eq, "$fplayer_team_no", ":slot", mordr_follow),
            (team_set_slot, "$fplayer_team_no", ":slot", mordr_follow),
            (set_show_messages, 0),
            (team_give_order, "$fplayer_team_no", ":bgdivision", mordr_follow),
            (set_show_messages, 1),
          (try_end),

          (agent_set_slot, ":cur_agent", slot_agent_new_division, ":bgdivision"),	#reassign
          (agent_set_division, ":cur_agent", ":bgdivision"),

        (else_try),	#Maintain any changed divisions (apparently agents get switched back)
          (agent_is_non_player, ":cur_agent"),
          (agent_slot_ge, ":cur_agent", slot_agent_new_division, 0),
          (neg | agent_slot_eq, ":cur_agent", slot_agent_new_division, ":bgdivision"),
          (agent_get_slot, ":bgdivision", ":cur_agent", slot_agent_new_division),
          (agent_set_division, ":cur_agent", ":bgdivision"),
        (try_end),
        (agent_get_troop_id, ":cur_troop", ":cur_agent"),
        (try_begin),
          (game_in_multiplayer_mode),
          (try_begin),
            (is_between, ":cur_troop", multiplayer_troops_begin, multiplayer_troops_end),	#it's a player
            (assign, ":bgdivision", -1),
          (try_end),
        (else_try),
          (team_get_leader, ":leader", ":bgteam"),
          (eq, ":leader", ":cur_agent"),
          (assign, ":bgdivision", -1),
        (try_end),
        (store_character_level, ":cur_level", ":cur_troop"),
        (agent_get_ammo, ":cur_ammo", ":cur_agent", 0),

        #get weapon characteristics
        (assign, ":cur_weapon_type", 0),
        (assign, ":cur_weapon_length", 0),
        (assign, ":cur_swung_weapon_length", 0),
        (agent_get_wielded_item, ":cur_weapon", ":cur_agent", 0),
        (try_begin),
          (is_between, ":cur_weapon", weapons_begin, weapons_end),
          # (neg | is_between, ":cur_weapon", estandartes_begin, estandartes_end),	#put exceptions here, such as standards, that will otherwise force a lot of
          #extra spacing for nothing
          (item_get_weapon_length, ":cur_weapon_length", ":cur_weapon"),

          (try_begin),
            (call_script, "script_cf_is_thrusting_weapon", ":cur_weapon"),
          (else_try),
            (assign, ":cur_swung_weapon_length", ":cur_weapon_length"),
          (try_end),
        (try_end),

        #add up armor
        (assign, ":cur_avg_armor", 0),
        (try_for_range, ":item_slot", ek_head, ek_horse),
          (agent_get_item_slot, ":armor", ":cur_agent", ":item_slot"),
          (gt, ":armor", itm_no_item),
          (item_get_head_armor, reg0, ":armor"),
          (val_add, ":cur_avg_armor", reg0),
          (item_get_body_armor, reg0, ":armor"),
          (val_add, ":cur_avg_armor", reg0),
          (item_get_leg_armor, reg0, ":armor"),
          (val_add, ":cur_avg_armor", reg0),
        (try_end),
        (agent_get_wielded_item, ":armor", ":cur_agent", 1),	#include shield
        (try_begin),
          (gt, ":armor", itm_no_item),
          (item_get_type, ":item_type", ":armor"),
          (eq, ":item_type", itp_type_shield),
          (item_get_body_armor, reg0, ":armor"),
          (val_add, ":cur_avg_armor", reg0),
        (try_end),
        (val_div, ":cur_avg_armor", 3),	#average the zones (head, body, leg)

        #average with horse armor for mounted agents
        (agent_get_horse, ":cur_horse", ":cur_agent"),
        (try_begin),
          (gt, ":cur_horse", -1),
          (agent_get_item_id, ":itm_horse", ":cur_horse"),
          (gt, ":itm_horse", itm_no_item),
          (item_get_body_armor, reg0, ":itm_horse"),
          (val_add, ":cur_avg_armor", reg0),
          (val_div, ":cur_avg_armor", 2),
        (try_end),

        (position_get_x, ":x_value", pos1),
        (position_get_y, ":y_value", pos1),
        (position_get_rotation_around_z, ":zrot_value", pos1),
        (try_begin),
          (eq, ":bgdivision", -1), #Leaders
          (try_begin),
            (eq, ":bgteam", 0),
            (assign, ":team0_leader", 1),
            (assign, ":team0_x_leader", ":x_value"),
            (assign, ":team0_y_leader", ":y_value"),
            (assign, ":team0_zrot_leader", ":zrot_value"),
            (assign, ":team0_level_leader", ":cur_level"),
          (else_try),
            (eq, ":bgteam", 1),
            (assign, ":team1_leader", 1),
            (assign, ":team1_x_leader", ":x_value"),
            (assign, ":team1_y_leader", ":y_value"),
            (assign, ":team1_zrot_leader", ":zrot_value"),
            (assign, ":team1_level_leader", ":cur_level"),
          (else_try),
            (eq, ":bgteam", 2),
            (assign, ":team2_leader", 1),
            (assign, ":team2_x_leader", ":x_value"),
            (assign, ":team2_y_leader", ":y_value"),
            (assign, ":team2_zrot_leader", ":zrot_value"),
            (assign, ":team2_level_leader", ":cur_level"),
          (else_try),
            (eq, ":bgteam", 3),
            (assign, ":team3_leader", 1),
            (assign, ":team3_x_leader", ":x_value"),
            (assign, ":team3_y_leader", ":y_value"),
            (assign, ":team3_zrot_leader", ":zrot_value"),
            (assign, ":team3_level_leader", ":cur_level"),
          (try_end),
        (else_try),
          # (agent_get_ammo, reg0, ":cur_agent", 1), #Division in Melee
          (try_begin),
            # (le, reg0, 0), #not wielding ranged weapon?
            (agent_get_attack_action, reg0, ":cur_agent"),
            (gt, reg0, 0),
            (store_add, ":slot", slot_team_d0_is_fighting, ":bgdivision"),
            (team_get_slot, reg0, ":bgteam", ":slot"),
            (val_add, reg0, 1),
            (team_set_slot, ":bgteam", ":slot", reg0),
          (try_end),

          (store_add, ":slot", slot_team_d0_size, ":bgdivision"), #Division Count
          (team_get_slot, ":value", ":bgteam", ":slot"),
          (val_add, ":value", 1),
          (team_set_slot, ":bgteam", ":slot", ":value"),

          (try_begin),
            (ge, ":cur_ammo", minimum_ranged_ammo),
            (store_add, ":slot", slot_team_d0_percent_ranged, ":bgdivision"), #Division Percentage are Archers
            (team_get_slot, ":value", ":bgteam", ":slot"),
            (val_add, ":value", 1),
            (team_set_slot, ":bgteam", ":slot", ":value"),
          (else_try),
            (store_add, ":slot", slot_team_d0_low_ammo, ":bgdivision"), #Division Running out of Ammo Flag
            (team_set_slot, ":bgteam", ":slot", 1),
          (try_end),

          (try_begin),
            (eq, ":cur_weapon_type", itp_type_thrown),
            (store_add, ":slot", slot_team_d0_percent_throwers, ":bgdivision"), #Division Percentage are Throwers
            (team_get_slot, ":value", ":bgteam", ":slot"),
            (val_add, ":value", 1),
            (team_set_slot, ":bgteam", ":slot", ":value"),
          (try_end),

          (store_add, ":slot", slot_team_d0_level, ":bgdivision"), #Division Level
          (team_get_slot, ":value", ":bgteam", ":slot"),
          (val_add, ":value", ":cur_level"),
          (team_set_slot, ":bgteam", ":slot", ":value"),

          (store_add, ":slot", slot_team_d0_weapon_length, ":bgdivision"), #Division Weapon Length
          (team_get_slot, ":value", ":bgteam", ":slot"),
          (val_add, ":value", ":cur_weapon_length"),
          (team_set_slot, ":bgteam", ":slot", ":value"),

          (store_add, ":slot", slot_team_d0_swung_weapon_length, ":bgdivision"), #Division Swung Weapon Length
          (team_get_slot, ":value", ":bgteam", ":slot"),
          (try_begin),
            (lt, ":value", ":cur_swung_weapon_length"),
            (team_set_slot, ":bgteam", ":slot", ":cur_swung_weapon_length"),
          (try_end),

          (store_add, ":slot", slot_team_d0_armor, ":bgdivision"), #Division Armor
          (team_get_slot, ":value", ":bgteam", ":slot"),
          (val_add, ":value", ":cur_avg_armor"),
          (team_set_slot, ":bgteam", ":slot", ":value"),

          (try_begin),	#Division First Rank Shortest Weapon Length
            (agent_slot_eq, ":cur_agent", slot_agent_formation_rank, 1),
            (store_add, ":slot", slot_team_d0_front_weapon_length, ":bgdivision"),
            (team_get_slot, ":value", ":bgteam", ":slot"),
            (this_or_next | eq, ":value", 0),
            (gt, ":value", ":cur_weapon_length"),
            (team_set_slot, ":bgteam", ":slot", ":cur_weapon_length"),
          (try_end),

          (store_add, ":slot", slot_team_d0_avg_x, ":bgdivision"), #Position X
          (team_get_slot, ":value", ":bgteam", ":slot"),
          (val_add, ":value", ":x_value"),
          (team_set_slot, ":bgteam", ":slot", ":value"),

          (store_add, ":slot", slot_team_d0_avg_y, ":bgdivision"), #Position Y
          (team_get_slot, ":value", ":bgteam", ":slot"),
          (val_add, ":value", ":y_value"),
          (team_set_slot, ":bgteam", ":slot", ":value"),

          (store_add, ":slot", slot_team_d0_avg_zrot, ":bgdivision"), #Rotation
          (team_get_slot, ":value", ":bgteam", ":slot"),
          (val_add, ":value", ":zrot_value"),
          (team_set_slot, ":bgteam", ":slot", ":value"),
        (try_end), #Leader vs Regular

        (try_begin),
          (eq, ":agent_class", grc_archers),
          (team_get_slot, ":value", ":bgteam", slot_team_num_archers),
          (val_add, ":value", 1),
          (team_set_slot, ":bgteam", slot_team_num_archers, ":value"),

        (else_try),
          (eq, ":agent_class", grc_cavalry),
          (team_get_slot, ":value", ":bgteam", slot_team_num_cavalry),
          (val_add, ":value", 1),
          (team_set_slot, ":bgteam", slot_team_num_cavalry, ":value"),

        (else_try),
          (eq, ":agent_class", grc_infantry),
          (team_get_slot, ":value", ":bgteam", slot_team_num_infantry),
          (val_add, ":value", 1),
          (team_set_slot, ":bgteam", slot_team_num_infantry, ":value"),
        (try_end),

        #find nearest enemy agent
        (assign, ":nearest_runner", -1),
        (agent_ai_get_num_cached_enemies, ":num_nearby_agents", ":cur_agent"),
        (try_for_range, reg0, 0, ":num_nearby_agents"),
          (agent_ai_get_cached_enemy, ":enemy_agent", ":cur_agent", reg0),
          (agent_is_alive, ":enemy_agent"),

          (try_begin),
            (eq, ":nearest_runner", -1),
            (assign, ":nearest_runner", ":enemy_agent"),

          (else_try),
            (agent_get_position, pos0, ":enemy_agent"),
            (get_distance_between_positions, ":new_distance", pos0, pos1),
            (agent_get_position, pos0, ":nearest_runner"),
            (get_distance_between_positions, ":old_distance", pos0, pos1),
            (lt, ":new_distance", ":old_distance"),
            (assign, ":nearest_runner", ":enemy_agent"),
          (try_end),

          (agent_slot_eq, ":enemy_agent", slot_agent_is_running_away, 0),

          (try_begin),
            (agent_get_slot, ":closest_enemy", ":cur_agent", slot_agent_nearest_enemy_agent),
            (eq, ":closest_enemy", -1),
            (agent_set_slot, ":cur_agent", slot_agent_nearest_enemy_agent, ":enemy_agent"),

          (else_try),
            (agent_get_position, pos0, ":enemy_agent"),
            (get_distance_between_positions, ":new_distance", pos0, pos1),
            (agent_get_position, pos0, ":closest_enemy"),
            (get_distance_between_positions, ":old_distance", pos0, pos1),
            (lt, ":new_distance", ":old_distance"),
            (agent_set_slot, ":cur_agent", slot_agent_nearest_enemy_agent, ":enemy_agent"),
          (try_end),
        (try_end),
        (try_begin),
          (agent_slot_eq, ":cur_agent", slot_agent_nearest_enemy_agent, -1),
          (agent_set_slot, ":cur_agent", slot_agent_nearest_enemy_agent, ":nearest_runner"),
        (try_end),

        #exploit closest agent data
        (try_begin),
          (agent_get_slot, ":closest_enemy", ":cur_agent", slot_agent_nearest_enemy_agent),
          (neq, ":closest_enemy", -1),
          (agent_get_position, pos0, ":closest_enemy"),
          (get_distance_between_positions, ":closest_distance", pos0, pos1),

          #check target of AI agent behavior
          (try_begin),
            (agent_is_non_player, ":cur_agent"),

            (agent_ai_get_behavior_target, ":cur_targeted_agent", ":cur_agent"),
            (neq, ":closest_enemy", ":cur_targeted_agent"),

            (this_or_next | neg | agent_is_non_player, ":closest_enemy"),	#AI can always sense player behind them (balancing factor, dedicated to
            #Idibil)
            (neg | position_is_behind_position, pos0, pos1),

            (lt, ":closest_distance", 2000),	#Assuming rethink is expensive, don't bother beyond 20m

            (store_add, ":slot", slot_team_d0_formation, ":bgdivision"),
            (team_get_slot, ":value", ":bgteam", ":slot"),
            (this_or_next | eq, formation_rethink_for_formations_only, 0),
            (gt, ":value", formation_none),

            (agent_force_rethink, ":cur_agent"),
          (try_end),

          #update division information
          (try_begin),
            (ge, ":bgdivision", 0),	#not leaders

            (try_begin),
              (lt, ":closest_distance", 350),
              (agent_get_division, reg0, ":closest_enemy"),
              (store_add, ":slot", slot_team_d0_enemy_supporting_melee, reg0),
              (agent_get_group, reg0, ":closest_enemy"),
              (team_get_slot, ":value", reg0, ":slot"),
              (val_add, ":value", 1),
              (team_set_slot, reg0, ":slot", ":value"),
            (try_end),

            (store_add, ":slot", slot_team_d0_closest_enemy_dist, ":bgdivision"),
            (team_get_slot, ":old_distance", ":bgteam", ":slot"),
            (try_begin),
              (this_or_next | eq, ":old_distance", 0),
              (lt, ":closest_distance", ":old_distance"),
              (team_set_slot, ":bgteam", ":slot", ":closest_distance"),
              (store_add, ":slot", slot_team_d0_closest_enemy, ":bgdivision"),
              (team_set_slot, ":bgteam", ":slot", ":closest_enemy"),
            (try_end),

            (assign, ":doit", 0),
            (agent_get_class, ":enemy_agent_class", ":closest_enemy"),
            (store_add, ":slot", slot_team_d0_type, ":bgdivision"),
            (team_get_slot, ":value", ":bgteam", ":slot"),

            #AI infantry division tracks non-infantry to preferably chase
            (try_begin),
              (this_or_next | eq, ":value", sdt_polearm),
              (eq, ":value", sdt_infantry),
              (neq, ":enemy_agent_class", grc_cavalry),
              (assign, ":doit", 1),

              #AI archer division tracks infantry to avoid
            (else_try),
              (this_or_next | eq, ":value", sdt_archer),
              (eq, ":value", sdt_skirmisher),
              (eq, ":enemy_agent_class", grc_infantry),
              (assign, ":doit", 1),
            (try_end),

            (eq, ":doit", 1),
            (store_add, ":slot", slot_team_d0_closest_enemy_special_dist, ":bgdivision"),
            (team_get_slot, ":old_distance", ":bgteam", ":slot"),
            (try_begin),
              (this_or_next | eq, ":old_distance", 0),
              (lt, ":closest_distance", ":old_distance"),
              (team_set_slot, ":bgteam", ":slot", ":closest_distance"),
              (store_add, ":slot", slot_team_d0_closest_enemy_special, ":bgdivision"),
              (team_set_slot, ":bgteam", ":slot", ":closest_enemy"),
            (try_end),
          (try_end),	#update division info
        (try_end),	#exploit closest agent data
      (try_end), #Agent Loop

      #calculate team sizes, sum positions; within calculate battle group averages
      (try_for_range, ":team", 0, 4),
        (assign, ":team_size", 0),
        (assign, ":team_level", 0),
        (assign, ":team_x", 0),
        (assign, ":team_y", 0),
        (assign, ":team_zrot", 0),

        (try_for_range, ":division", 0, 9),
          #sum for team averages
          (store_add, ":slot", slot_team_d0_size, ":division"),
          (team_get_slot, ":division_size", ":team", ":slot"),
          (gt, ":division_size", 0),
          (val_add, ":team_size", ":division_size"),

          (store_add, ":slot", slot_team_d0_level, ":division"),
          (team_get_slot, ":division_level", ":team", ":slot"),
          (val_add, ":team_level", ":division_level"),

          (store_add, ":slot", slot_team_d0_avg_x, ":division"),
          (team_get_slot, ":division_x", ":team", ":slot"),
          (val_add, ":team_x", ":division_x"),

          (store_add, ":slot", slot_team_d0_avg_y, ":division"),
          (team_get_slot, ":division_y", ":team", ":slot"),
          (val_add, ":team_y", ":division_y"),

          (store_add, ":slot", slot_team_d0_avg_zrot, ":division"),
          (team_get_slot, ":division_zrot", ":team", ":slot"),
          (val_add, ":team_zrot", ":division_zrot"),

          #calculate battle group averages
          (store_add, ":slot", slot_team_d0_level, ":division"),
          (val_div, ":division_level", ":division_size"),
          (team_set_slot, ":team", ":slot", ":division_level"),

          (store_add, ":slot", slot_team_d0_percent_ranged, ":division"),
          (team_get_slot, ":value", ":team", ":slot"),
          (val_mul, ":value", 100),
          (val_div, ":value", ":division_size"),
          (team_set_slot, ":team", ":slot", ":value"),

          (store_add, ":slot", slot_team_d0_percent_throwers, ":division"),
          (team_get_slot, ":value", ":team", ":slot"),
          (val_mul, ":value", 100),
          (val_div, ":value", ":division_size"),
          (team_set_slot, ":team", ":slot", ":value"),

          (store_add, ":slot", slot_team_d0_weapon_length, ":division"),
          (team_get_slot, ":value", ":team", ":slot"),
          (val_div, ":value", ":division_size"),
          (team_set_slot, ":team", ":slot", ":value"),

          # (store_add, ":slot", slot_team_d0_swung_weapon_length, ":division"), MOTO
          # systematic testing shows best to use max swung weapon length as basis for
          # formation spacing
          # (team_get_slot, ":value", ":team", ":slot"),
          # (val_div, ":value", ":division_size"),
          # (team_set_slot, ":team", ":slot", ":value"),

          # (store_add, ":slot", slot_team_d0_front_agents, ":division"), MOTO front
          # rank should be within shortest weapon distance, not average
          # (team_get_slot, reg0, ":team", ":slot"),
          # (try_begin),
          # (gt, reg0, 0),
          # (store_add, ":slot", slot_team_d0_front_weapon_length, ":division"),
          # (team_get_slot, ":value", ":team", ":slot"),
          # (val_div, ":value", reg0),
          # (team_set_slot, ":team", ":slot", ":value"),
          # (try_end),

          (store_add, ":slot", slot_team_d0_avg_x, ":division"),
          (val_div, ":division_x", ":division_size"),
          (team_set_slot, ":team", ":slot", ":division_x"),

          (store_add, ":slot", slot_team_d0_avg_y, ":division"),
          (val_div, ":division_y", ":division_size"),
          (team_set_slot, ":team", ":slot", ":division_y"),

          (store_add, ":slot", slot_team_d0_avg_zrot, ":division"),
          (val_div, ":division_zrot", ":division_size"),
          (team_set_slot, ":team", ":slot", ":division_zrot"),

          (store_add, ":slot", slot_team_d0_type, ":division"),
          (team_get_slot, reg0, ":team", ":slot"),
          (try_begin),
            (neg | is_between, reg0, 0, 8),	#TODO reset on reinforcements
            (call_script, "script_store_battlegroup_type", ":team", ":division"),
          (try_end),
        (try_end), #Division Loop

        #Team Leader Additions
        (try_begin),
          (eq, ":team", 0),
          (val_add, ":team_size", ":team0_leader"),
          (val_add, ":team_level", ":team0_level_leader"),
          (val_add, ":team_x", ":team0_x_leader"),
          (val_add, ":team_y", ":team0_y_leader"),
          (val_add, ":team_zrot", ":team0_zrot_leader"),
        (else_try),
          (eq, ":team", 1),
          (val_add, ":team_size", ":team1_leader"),
          (val_add, ":team_level", ":team1_level_leader"),
          (val_add, ":team_x", ":team1_x_leader"),
          (val_add, ":team_y", ":team1_y_leader"),
          (val_add, ":team_zrot", ":team1_zrot_leader"),
        (else_try),
          (eq, ":team", 2),
          (val_add, ":team_size", ":team2_leader"),
          (val_add, ":team_level", ":team2_level_leader"),
          (val_add, ":team_x", ":team2_x_leader"),
          (val_add, ":team_y", ":team2_y_leader"),
          (val_add, ":team_zrot", ":team2_zrot_leader"),
        (else_try),
          (eq, ":team", 3),
          (val_add, ":team_size", ":team3_leader"),
          (val_add, ":team_level", ":team3_level_leader"),
          (val_add, ":team_x", ":team3_x_leader"),
          (val_add, ":team_y", ":team3_y_leader"),
          (val_add, ":team_zrot", ":team3_zrot_leader"),
        (try_end),

        #calculate team averages
        (gt, ":team_size", 0),
        (team_set_slot, ":team", slot_team_size, ":team_size"),
        (val_div, ":team_level", ":team_size"),
        (team_set_slot, ":team", slot_team_level, ":team_level"),

        (val_div, ":team_x", ":team_size"),
        (team_set_slot, ":team", slot_team_avg_x, ":team_x"),
        (val_div, ":team_y", ":team_size"),
        (team_set_slot, ":team", slot_team_avg_y, ":team_y"),
        (val_div, ":team_zrot", ":team_size"),
        (team_set_slot, ":team", slot_team_avg_zrot, ":team_zrot"),
      (try_end), #Team Loop
  ]),

  # script_cf_division_data_available by motomataru
  ("cf_division_data_available", [
      (assign, ":evidence", 0),
      (try_for_range, ":team", 0, 4),
        (team_slot_ge, ":team", slot_team_size, 1),
        (assign, ":evidence", 1),
      (try_end),
      (neq, ":evidence", 0)]),

  # script_battlegroup_get_position by motomataru #CABA - EDITED TO USE SLOTS,
  # NOT STORED POS NUMBERS
  # Input: destination position, team, division
  # Output: battle group position
  #			average team position if division input NOT set to 0-8
  ("battlegroup_get_position", [
      (store_script_param, ":bgposition", 1),
      (store_script_param, ":bgteam", 2),
      (store_script_param, ":bgdivision", 3),

      (assign, ":x", 0),
      (assign, ":y", 0),
      (init_position, ":bgposition"),
      (try_begin),
        (neg | is_between, ":bgdivision", 0, 9),
        (team_slot_ge, ":bgteam", slot_team_size, 1),
        (team_get_slot, ":x", ":bgteam", slot_team_avg_x),
        (team_get_slot, ":y", ":bgteam", slot_team_avg_y),
        (team_get_slot, ":zrot", ":bgteam", slot_team_avg_zrot),
      (else_try),
        (is_between, ":bgdivision", 0, 9),
        (store_add, ":slot", slot_team_d0_size, ":bgdivision"),
        (team_slot_ge, ":bgteam", ":slot", 1),

        (store_add, ":slot", slot_team_d0_avg_x, ":bgdivision"),
        (team_get_slot, ":x", ":bgteam", ":slot"),

        (store_add, ":slot", slot_team_d0_avg_y, ":bgdivision"),
        (team_get_slot, ":y", ":bgteam", ":slot"),

        (store_add, ":slot", slot_team_d0_avg_zrot, ":bgdivision"),
        (team_get_slot, ":zrot", ":bgteam", ":slot"),
      (try_end),
      (position_set_x, ":bgposition", ":x"),
      (position_set_y, ":bgposition", ":y"),
      (position_rotate_z, ":bgposition", ":zrot", 0),
      (position_set_z_to_ground_level, ":bgposition"),]),

  # script_battlegroup_get_attack_destination by motomataru
  # Input: destination position, team, division, target team, target division
  # Output: melee position against target battlegroup
  ("battlegroup_get_attack_destination", [
      (store_script_param, ":bgposition", 1),
      (store_script_param, ":bgteam", 2),
      (store_script_param, ":bgdivision", 3),
      (store_script_param, ":enemy_team", 4),
      (store_script_param, ":enemy_division", 5),

      (store_add, ":slot", slot_team_d0_formation, ":bgdivision"),
      (team_get_slot, ":bgformation", ":bgteam", ":slot"),
      (try_begin),
        (le, ":bgformation", formation_none),
        (call_script, "script_battlegroup_get_position", ":bgposition", ":bgteam", ":bgdivision"),
      (else_try),
        (call_script, "script_formation_current_position", ":bgposition", ":bgteam", ":bgdivision"),
      (try_end),

      #distance to enemy center
      (store_add, ":slot", slot_team_d0_formation, ":enemy_division"),
      (team_get_slot, ":enemy_formation", ":enemy_team", ":slot"),
      (call_script, "script_battlegroup_get_position", Enemy_Team_Pos, ":enemy_team", ":enemy_division"),
      (get_distance_between_positions, ":distance_to_move", ":bgposition", Enemy_Team_Pos),

      (call_script, "script_battlegroup_get_action_radius", ":bgteam", ":bgdivision"),
      (assign, ":bgwidth", reg0),
      (call_script, "script_battlegroup_get_action_radius", ":enemy_team", ":enemy_division"),
      (store_add, ":combined_width", ":bgwidth", reg0),

      (assign, ":min_radius", reg0),
      (val_min, ":min_radius", ":bgwidth"),
      (val_div, ":min_radius", 2),	#function returns length of bg

      (try_begin),
        (gt, ":bgformation", formation_none),	#in formation AND
        (le, ":distance_to_move", ":combined_width"),	#close to enemy
        (store_mul, reg0, -350, formation_reform_interval),	#back up one move (to avoid wild swings / reversals on overruns)
        (position_move_y, ":bgposition", reg0),
        (get_distance_between_positions, ":distance_to_move", ":bgposition", Enemy_Team_Pos),
      (try_end),

      #subtract enemy center to edge-of-contact (determined by minimum half-width
      #between the two battlegroups)
      (call_script, "script_get_distance_to_battlegroup", ":enemy_team", ":enemy_division", ":bgposition"),
      (store_mul, ":angle_adjusted_half_depth", ":min_radius", reg2),	#reg2 is cosine glancing angle, FP
      (convert_from_fixed_point, ":angle_adjusted_half_depth"),
      (try_begin),
        (neq, ":enemy_formation", formation_wedge),
        (call_script, "script_battlegroup_dist_center_to_front", ":enemy_team", ":enemy_division"),
        (val_max, ":angle_adjusted_half_depth", reg0),
      (try_end),
      (val_sub, ":distance_to_move", ":angle_adjusted_half_depth"),

      #modify by bg center to edge-of-contact, if needed
      (call_script, "script_battlegroup_dist_center_to_front", ":bgteam", ":bgdivision"),
      (assign, ":bg_half_depth", reg0),
      (try_begin),
        (le, ":bgformation", formation_none),
        (val_sub, ":distance_to_move", ":bg_half_depth"),	#position from script_battlegroup_get_position is in middle of bg
      (else_try),
        (eq, ":bgformation", formation_wedge),
        (call_script, "script_battlegroup_dist_center_to_front", ":enemy_team", ":enemy_division"),
        (val_add, ":distance_to_move", reg0),	#move in from nearest edge found by script_get_distance_to_battlegroup
        (val_add, ":distance_to_move", ":bg_half_depth"),	#drive wedge through target formation!
      (try_end),

      #modify by speed differential
      (try_begin),
        (gt, ":enemy_formation", formation_none),
        (neq, ":enemy_formation", formation_default),

        (store_add, ":slot", slot_team_d0_first_member, ":enemy_division"),
        (team_get_slot, reg0, ":enemy_team", ":slot"),
        (agent_is_active, reg0),

        (agent_get_speed, Speed_Pos, reg0),
        (init_position, Temp_Pos),
        (get_distance_between_positions, ":enemy_formation_speed", Speed_Pos, Temp_Pos),
        (val_mul, ":enemy_formation_speed", formation_reform_interval),	#calculate distance to next call

        (try_begin),
          (position_is_behind_position, ":bgposition", Enemy_Team_Pos),	#attacking from rear?
          (val_add, ":distance_to_move", ":enemy_formation_speed"),	#catch up to anticipated position
        (else_try),	#attacking enemy formation from front
          (store_add, ":slot", slot_team_d0_is_fighting, ":bgdivision"),
          (team_slot_eq, ":bgteam", ":slot", 0),
          (val_sub, ":distance_to_move", ":enemy_formation_speed"),	#avoid overrunning enemy
        (try_end),
      (try_end),

      (store_add, ":slot", slot_team_d0_front_weapon_length, ":bgdivision"),
      (team_get_slot, ":striking_distance", ":bgteam", ":slot"),
      (val_sub, ":distance_to_move", ":striking_distance"),

      (call_script, "script_point_y_toward_position", ":bgposition", Enemy_Team_Pos),
      (position_move_y, ":bgposition", ":distance_to_move"),]),

  # script_battlegroup_dist_center_to_front by motomataru
  # Input: team, division
  # Output: reg0 distance to front of battlegroup from center in cm
  ("battlegroup_dist_center_to_front", [
      (store_script_param, ":bgteam", 1),
      (store_script_param, ":bgdivision", 2),

      (store_add, ":slot", slot_team_d0_formation_space, ":bgdivision"),
      (team_get_slot, ":spacing", ":bgteam", ":slot"),
      (store_add, ":slot", slot_team_d0_formation, ":bgdivision"),
      (team_get_slot, ":bgformation", ":bgteam", ":slot"),

      (try_begin),
        (eq, ":bgformation", formation_none),	#single row
        (assign, ":depth", 0),

        #WFaS multi-ranks
      (else_try),
        (eq, ":bgformation", formation_2_row),
        (assign, ":depth", 100),
      (else_try),
        (eq, ":bgformation", formation_3_row),
        (assign, ":depth", 200),
      (else_try),
        (eq, ":bgformation", formation_4_row),
        (assign, ":depth", 300),
      (else_try),
        (eq, ":bgformation", formation_5_row),
        (assign, ":depth", 400),

      (else_try),	#WB multi-ranks
        (lt, ":spacing", 0),
        (store_mul, ":depth", ":spacing", -1),
        (val_mul, ":depth", 100),

      #Non Native
      (else_try),
        (store_add, ":slot", slot_team_d0_size, ":bgdivision"),
        (team_get_slot, ":size_enemy_battlegroup", ":bgteam", ":slot"),
        (store_mul, ":row_depth", ":spacing", 50),
        (val_add, ":row_depth", formation_minimum_spacing),

        (this_or_next | eq, ":bgformation", formation_ranks),
        (eq, ":bgformation", formation_shield),
        (call_script, "script_calculate_default_ranks", ":size_enemy_battlegroup"),
        (val_sub, reg1, 1),
        (store_mul, ":depth", ":row_depth", reg1),

      (else_try),
        (convert_to_fixed_point, ":size_enemy_battlegroup"),
        (store_sqrt, ":columns", ":size_enemy_battlegroup"),

        (eq, ":bgformation", formation_square),
        (convert_from_fixed_point, ":columns"),
        (val_add, ":columns", 1),	#see script_form_infantry
        (store_div, ":rows", ":size_enemy_battlegroup", ":columns"),
        (store_mul, ":depth", ":row_depth", ":rows"),
        (convert_from_fixed_point, ":depth"),
        (val_sub, ":depth", ":row_depth"),

      (else_try),
        (eq, ":bgformation", formation_wedge),
        (store_mul, ":depth", ":row_depth", ":columns"),	#approximation
        (convert_from_fixed_point, ":depth"),
      (try_end),

      (try_begin),
        (neq, ":bgformation", formation_wedge),
        (store_div, reg0, ":depth", 2),
      (else_try),
        (store_mul, reg0, ":depth", 2),	#another approximation (height - inner radius)
        (val_div, reg0, 3),
      (try_end),]),

  # script_battlegroup_get_action_radius by motomataru
  # Input: team, division
  # Output: reg0 radius of battlegroup's "zone of control" (now length of
  # battlegroup in cm)
  ("battlegroup_get_action_radius", [
      (store_script_param, ":bgteam", 1),
      (store_script_param, ":bgdivision", 2),

      (store_add, ":slot", slot_team_d0_size, ":bgdivision"),
      (team_get_slot, ":size_battlegroup", ":bgteam", ":slot"),
      (store_add, ":slot", slot_team_d0_formation, ":bgdivision"),
      (team_get_slot, ":formation", ":bgteam", ":slot"),
      (store_add, ":slot", slot_team_d0_type, ":bgdivision"),
      (team_get_slot, ":div_type", ":bgteam", ":slot"),
      (store_add, ":slot", slot_team_d0_formation_space, ":bgdivision"),
      (team_get_slot, ":spacing", ":bgteam", ":slot"),

      (try_begin),
        (this_or_next | eq, ":div_type", sdt_archer),
        (le, ":formation", formation_none),	#Native formation

        (store_mul, ":troop_space", ":spacing", 75),	#Native minimum spacing not consistent but about this
        (val_add, ":troop_space", 100),	#minimum spacing

        #WFaS multi-ranks
        (try_begin),
          (eq, ":formation", formation_2_row),
          (val_div, ":size_battlegroup", 2),
        (else_try),
          (eq, ":formation", formation_3_row),
          (val_div, ":size_battlegroup", 3),
        (else_try),
          (eq, ":formation", formation_4_row),
          (val_div, ":size_battlegroup", 4),
        (else_try),
          (eq, ":formation", formation_5_row),
          (val_div, ":size_battlegroup", 5),

        (else_try),	#WB multi-ranks
          (lt, ":spacing", 0),
          (assign, ":troop_space", 150),
          (val_mul, ":spacing", -1),
          (val_add, ":spacing", 1),
          (val_div, ":size_battlegroup", ":spacing"),
        (try_end),

        (store_mul, ":formation_width", ":size_battlegroup", ":troop_space"),
        (store_div, reg0, ":formation_width", 2),

      (else_try),
        (eq, ":formation", formation_wedge),
        (call_script, "script_get_centering_amount", formation_square, ":size_battlegroup", ":spacing"),	#approximation
        (val_mul, reg0, 7),
        (val_div, reg0, 6),
      (else_try),
        (try_begin),
          (lt, ":spacing", 0),
          (assign, reg0, ":bgteam"),
          (assign, reg1, ":bgdivision"),
          (assign, reg2, ":formation"),
          (display_message, "@{!}battlegroup_get_action_radius: negative radius for team {reg0} division {reg1} formation {reg2}"),
        (try_end),
        (call_script, "script_get_centering_amount", ":formation", ":size_battlegroup", ":spacing"),
      (try_end),

      (val_mul, reg0, 2),]),

  # script_team_get_position_of_enemies by motomataru
  # Input: destination position, team, troop class/division
  # Output: destination position: average position if reg0 > 0
  #			reg0: number of enemies
  # Run script_store_battlegroup_data before calling!
  ("team_get_position_of_enemies", [
      (store_script_param, ":enemy_position", 1),
      (store_script_param, ":team_no", 2),
      (store_script_param, ":troop_type", 3),
      (assign, ":pos_x", 0),
      (assign, ":pos_y", 0),
      (assign, ":total_size", 0),
      (try_begin),
        (neq, ":troop_type", grc_everyone),
        (assign, ":closest_distance", Far_Away),
        (call_script, "script_battlegroup_get_position", Temp_Pos, ":team_no", grc_everyone),
      (try_end),

      (try_for_range, ":other_team", 0, 4),
        (teams_are_enemies, ":other_team", ":team_no"),
        (try_begin),
          (eq, ":troop_type", grc_everyone),
          (team_get_slot, ":team_size", ":other_team", slot_team_size),
          (try_begin),
            (gt, ":team_size", 0),
            (call_script, "script_battlegroup_get_position", ":enemy_position", ":other_team", grc_everyone),
            (position_get_x, reg0, ":enemy_position"),
            (val_mul, reg0, ":team_size"),
            (val_add, ":pos_x", reg0),
            (position_get_y, reg0, ":enemy_position"),
            (val_mul, reg0, ":team_size"),
            (val_add, ":pos_y", reg0),
          (try_end),
        (else_try),	#for multiple divisions, should find the CLOSEST of a given type
          (assign, ":team_size", 0),
          (try_for_range, ":enemy_battle_group", 0, 9),
            (store_add, ":slot", slot_team_d0_size, ":enemy_battle_group"),
            (team_get_slot, ":troop_count", ":other_team", ":slot"),
            (gt, ":troop_count", 0),
            (store_add, ":slot", slot_team_d0_type, ":enemy_battle_group"),
            (team_get_slot, ":bg_type", ":other_team", ":slot"),
            (store_sub, ":bg_root_type", ":bg_type", 3), #subtype is three more than main type
            (this_or_next | eq, ":bg_type", ":troop_type"),
            (eq, ":bg_root_type", ":troop_type"),
            (val_add, ":team_size", ":troop_count"),
            (call_script, "script_battlegroup_get_position", ":enemy_position", ":other_team", ":enemy_battle_group"),
            (get_distance_between_positions, reg0, Temp_Pos, ":enemy_position"),
            (lt, reg0, ":closest_distance"),
            (assign, ":closest_distance", reg0),
            (position_get_x, ":pos_x", ":enemy_position"),
            (position_get_y, ":pos_y", ":enemy_position"),
          (try_end),
        (try_end),
        (val_add, ":total_size", ":team_size"),
      (try_end),

      (try_begin),
        (eq, ":total_size", 0),
        (init_position, ":enemy_position"),
      (else_try),
        (eq, ":troop_type", grc_everyone),
        (val_div, ":pos_x", ":total_size"),
        (position_set_x, ":enemy_position", ":pos_x"),
        (val_div, ":pos_y", ":total_size"),
        (position_set_y, ":enemy_position", ":pos_y"),
        (position_set_z_to_ground_level, ":enemy_position"),
      (else_try),
        (position_set_x, ":enemy_position", ":pos_x"),
        (position_set_y, ":enemy_position", ":pos_y"),
        (position_set_z_to_ground_level, ":enemy_position"),
      (try_end),

      (assign, reg0, ":total_size"),]),

  # script_get_distance_to_battlegroup by motomataru
  # Gets distance from "from position" to the theoretical nearest side of the
  # battlegroup, accounting for rotation of battlegroup
  # Input: bg team, bg division, from position
  # Output: reg2 abs (cos (BG direction - 90 - direction from "from position"))
  # fixed point
  #         reg1 BG radius x reg2 in cms
  #         reg0 distance in cms between BG position and "from position" minus
  #         reg1 (could be negative)
  # Uses pos0, pos61
  ("get_distance_to_battlegroup", [
      (store_script_param, ":bgteam", 1),
      (store_script_param, ":bgdivision", 2),
      (store_script_param, ":from_pos", 3),

      (store_add, ":slot", slot_team_d0_formation, ":bgdivision"),
      (team_get_slot, ":bgformation", ":bgteam", ":slot"),
      (call_script, "script_battlegroup_get_action_radius", ":bgteam", ":bgdivision"),
      (store_div, ":radius", reg0, 2),	#function returns length of bg
      (assign, ":min_cos_theta", 1),
      (convert_to_fixed_point, ":min_cos_theta"),
      (try_begin),
        (eq, ":bgformation", formation_wedge),
        (val_mul, ":min_cos_theta", 58),	#relation inscribed circle radius to half side: 1 / sqrt 3
        (val_div, ":min_cos_theta", 100),
      (else_try),
        (gt, ":radius", 0),
        (call_script, "script_battlegroup_dist_center_to_front", ":bgteam", ":bgdivision"),
        (val_mul, ":min_cos_theta", reg0),
        (val_div, ":min_cos_theta", ":radius"),
      (else_try),
        (assign, ":min_cos_theta", 0),
      (try_end),

      #acquire rotations
      (call_script, "script_battlegroup_get_position", pos0, ":bgteam", ":bgdivision"),
      (try_begin),
        (gt, ":bgformation", formation_none),
        (neq, ":bgformation", formation_default),
        (call_script, "script_get_formation_destination", pos61, ":bgteam", ":bgdivision"),
        (position_copy_rotation, pos0, pos61),
      (try_end),

      (copy_position, pos61, ":from_pos"),
      (call_script, "script_point_y_toward_position", pos61, pos0),
      (assign, ":distance_to_battlegroup", reg0),

      #calculate difference from center of bg
      (get_angle_between_positions, ":theta", pos61, pos0),
      (val_sub, ":theta", 9000),
      (store_cos, ":cos_theta", ":theta"),
      (val_abs, ":cos_theta"),
      (val_max, ":cos_theta", ":min_cos_theta"),	#doing depth considerations this way allows calling func to use angle; it also
      #avoids Pythagorean calcs

      (store_mul, reg1, ":radius", ":cos_theta"),
      (convert_from_fixed_point, reg1),
      (val_sub, ":distance_to_battlegroup", reg1),
      (assign, reg0, ":distance_to_battlegroup"),
      (assign, reg2, ":cos_theta"),]),

  # script_get_item_modifier_effects
  # Input: itp_*, imod_*
  # Output: reg0 damage effect
  #         reg1 speed effect
  #         reg2 armor effect
  #         reg3 hit points effect
  #         reg4 difficulty effect
  #         reg5 price factor
  #         s0 descriptor string
  # derived from autoloot by Rubik
  ("get_item_modifier_effects", [(store_script_param, ":type", 1),
      (store_script_param, ":imod", 2),

      (assign, ":damage", 0),
      (assign, ":speed", 0),
      (assign, ":armor", 0),
      (assign, ":hit_points", 0),
      (assign, ":difficulty", 0),
      (assign, ":price_factor", 100),

      (try_begin),
        (eq, ":type", itp_type_horse),
        (try_begin),
          (eq, ":imod", imod_lame),
          (assign, ":speed", -10),
          (assign, ":price_factor", 40),
          (str_store_string, s0, "@Lame"),
        (else_try),
          (eq, ":imod", imod_swaybacked),
          (assign, ":speed", -4),
          (assign, ":price_factor", 60),
          (str_store_string, s0, "@Swaybacked"),
        (else_try),
          (eq, ":imod", imod_timid),
          (assign, ":speed", 2),
          (assign, ":price_factor", 120),
          (str_store_string, s0, "@Timid"),
        (else_try),
          (eq, ":imod", imod_meek),
          (assign, ":speed", 2),
          (assign, ":price_factor", 120),
          (str_store_string, s0, "@Meek"),
        (else_try),
          (eq, ":imod", imod_stubborn),
          (assign, ":hit_points", 5),
          (assign, ":difficulty", 1),
          (assign, ":price_factor", 90),
          (str_store_string, s0, "@Stubborn"),
        (else_try),
          (eq, ":imod", imod_heavy),
          (assign, ":damage", 4),
          (assign, ":armor", 3),
          (assign, ":hit_points", 10),
          (assign, ":price_factor", 150),
          (str_store_string, s0, "@Heavy"),
        (else_try),
          (eq, ":imod", imod_spirited),
          (assign, ":damage", 1),
          (assign, ":speed", 2),
          (assign, ":price_factor", 160),
          (str_store_string, s0, "@Spirited"),
        (else_try),
          (eq, ":imod", imod_champion),
          (assign, ":damage", 2),
          (assign, ":speed", 4),
          (assign, ":difficulty", 2),
          (assign, ":price_factor", 170),
          (str_store_string, s0, "@Champion"),
        (try_end),

      (else_try),
        (eq, ":type", itp_type_shield),
        (try_begin),
          (eq, ":imod", imod_cracked),
          (assign, ":armor", -4),
          (assign, ":hit_points", -56),
          (assign, ":price_factor", 50),
          (str_store_string, s0, "@Cracked"),
        (else_try),
          (eq, ":imod", imod_battered),
          (assign, ":armor", -2),
          (assign, ":hit_points", -26),
          (assign, ":price_factor", 75),
          (str_store_string, s0, "@Battered"),
        (else_try),
          (eq, ":imod", imod_thick),
          (assign, ":armor", 2),
          (assign, ":hit_points", 47),
          (assign, ":price_factor", 120),
          (str_store_string, s0, "@Thick"),
        (else_try),
          (eq, ":imod", imod_reinforced),
          (assign, ":armor", 4),
          (assign, ":hit_points", 63),
          (assign, ":price_factor", 150),
          (str_store_string, s0, "@Reinforced"),
        (try_end),

      (else_try),
        (ge, ":type", itp_type_head_armor),
        (le, ":type", itp_type_hand_armor),
        (try_begin),
          (eq, ":imod", imod_cracked),
          (assign, ":armor", -4),
          (assign, ":price_factor", 50),
          (str_store_string, s0, "@Cracked"),
        (else_try),
          (eq, ":imod", imod_rusty),
          (assign, ":armor", -3),
          (assign, ":price_factor", 55),
          (str_store_string, s0, "@Rusty"),
        (else_try),
          (eq, ":imod", imod_tattered),
          (assign, ":armor", -3),
          (assign, ":price_factor", 40),
          (str_store_string, s0, "@Tattered"),
        (else_try),
          (eq, ":imod", imod_ragged),
          (assign, ":armor", -2),
          (assign, ":price_factor", 60),
          (str_store_string, s0, "@Ragged"),
        (else_try),
          (eq, ":imod", imod_battered),
          (assign, ":armor", -2),
          (assign, ":price_factor", 75),
          (str_store_string, s0, "@Battered"),
        (else_try),
          (eq, ":imod", imod_crude),
          (assign, ":armor", -1),
          (assign, ":price_factor", 83),
          (str_store_string, s0, "@Crude"),
        (else_try),
          (eq, ":imod", imod_sturdy),
          (assign, ":armor", 1),
          (assign, ":price_factor", 120),
          (str_store_string, s0, "@Sturdy"),
        (else_try),
          (eq, ":imod", imod_thick),
          (assign, ":armor", 2),
          (assign, ":price_factor", 140),
          (str_store_string, s0, "@Thick"),
        (else_try),
          (eq, ":imod", imod_hardened),
          (assign, ":armor", 3),
          (assign, ":price_factor", 160),
          (str_store_string, s0, "@Hardened"),
        (else_try),
          (eq, ":imod", imod_reinforced),
          (assign, ":armor", 4),
          (assign, ":price_factor", 180),
          (str_store_string, s0, "@Reinforced"),
        (else_try),
          (eq, ":imod", imod_lordly),
          (assign, ":armor", 5),
          (assign, ":price_factor", 400),
          (str_store_string, s0, "@Lordly"),
        (try_end),

      (else_try),
        (this_or_next | eq, ":type", itp_type_one_handed_wpn),
        (this_or_next | eq, ":type", itp_type_two_handed_wpn),
        (this_or_next | eq, ":type", itp_type_polearm),
        (this_or_next | eq, ":type", itp_type_bow),
        (this_or_next | eq, ":type", itp_type_crossbow),
        (this_or_next | eq, ":type", itp_type_pistol),
        (eq, ":type", itp_type_musket),

        (try_begin),
          (eq, ":imod", imod_rotten),		#idea is to use this for a completly broken weapon
          (assign, ":damage", -20),
          (assign, ":price_factor", 5),
          (str_store_string, s0, "@Broken"),
        (else_try),
          (eq, ":imod", imod_cracked),
          (assign, ":damage", -5),
          (assign, ":price_factor", 40),
          (str_store_string, s0, "@Cracked"),
        (else_try),
          (eq, ":imod", imod_rusty),
          (assign, ":damage", -3),
          (assign, ":price_factor", 55),
          (str_store_string, s0, "@Rusty"),
        (else_try),
          (eq, ":imod", imod_bent),
          (assign, ":damage", -3),
          (assign, ":speed", -3),
          (assign, ":price_factor", 60),
          (str_store_string, s0, "@Bent"),
        (else_try),
          (eq, ":imod", imod_chipped),
          (assign, ":damage", -1),
          (assign, ":price_factor", 72),
          (str_store_string, s0, "@Chipped"),
        (else_try),
          (eq, ":imod", imod_heavy),
          (assign, ":damage", 2),
          (assign, ":speed", -2),
          (assign, ":difficulty", 1),
          (assign, ":price_factor", 120),
          (str_store_string, s0, "@Heavy"),
        (else_try),
          (eq, ":imod", imod_strong),
          (assign, ":damage", 3),
          (assign, ":speed", -3),
          (assign, ":difficulty", 2),
          (assign, ":price_factor", 150),
          (str_store_string, s0, "@Strong"),
        (else_try),
          (eq, ":imod", imod_balanced),
          (assign, ":damage", 3),
          (assign, ":speed", 3),
          (assign, ":price_factor", 165),
          (str_store_string, s0, "@Balanced"),
        (else_try),
          (eq, ":imod", imod_tempered),
          (assign, ":damage", 4),
          (assign, ":price_factor", 180),
          (str_store_string, s0, "@Tempered"),
        (else_try),
          (eq, ":imod", imod_masterwork),
          (assign, ":damage", 5),
          (assign, ":speed", 1),
          (assign, ":difficulty", 4),
          (assign, ":price_factor", 400),
          (str_store_string, s0, "@Masterwork"),
        (else_try),
          (eq, ":imod", imod_crude),
          (assign, ":damage", -2),
          (assign, ":price_factor", 83),
        (try_end),

      (else_try),
        (this_or_next | eq, ":type", itp_type_arrows),
        (this_or_next | eq, ":type", itp_type_bolts),
        (this_or_next | eq, ":type", itp_type_bullets),
        (eq, ":type", itp_type_thrown),

        (try_begin),
          (eq, ":imod", imod_large_bag),
          #       (assign, ":damage", 1), #just make better than plain
          (assign, ":price_factor", 110),
          (str_store_string, s0, "@Large Bag of"),
        (else_try),
          (eq, ":imod", imod_bent),
          (assign, ":damage", -3),
          (assign, ":price_factor", 65),
          (str_store_string, s0, "@Bent"),
        (else_try),
          (eq, ":imod", imod_cracked),
          (assign, ":damage", -5),
          (assign, ":price_factor", 50),
          (str_store_string, s0, "@Cracked"),
        (else_try),
          (eq, ":imod", imod_heavy),
          (assign, ":damage", 2),
          (assign, ":price_factor", 130),
          (str_store_string, s0, "@Heavy"),
        (else_try),
          (eq, ":imod", imod_balanced),
          (assign, ":damage", 3),
          (assign, ":price_factor", 150),
          (str_store_string, s0, "@Balanced"),
        (try_end),
      (try_end),

      (assign, reg0, ":damage"),
      (assign, reg1, ":speed"),
      (assign, reg2, ":armor"),
      (assign, reg3, ":hit_points"),
      (assign, reg4, ":difficulty"),
      (assign, reg5, ":price_factor"),]),

  # script_evaluate_item moto chief
  # Input: item_id, item_mod
  # Output: reg0 value meant to compare items of a given type
  ("evaluate_item", [
      (store_script_param, ":item_id", 1),
      (store_script_param, ":item_mod", 2),

      (assign, ":ret_val", 0),
      (try_begin),
        (gt, ":item_id", "itm_no_item"),

        (item_get_type, ":item_type", ":item_id"),
        (call_script, "script_get_item_modifier_effects", ":item_type", ":item_mod"),
        (assign, ":damage", reg0),
        (assign, ":speed", reg1),
        (assign, ":armor", reg2),
        (assign, ":hit_points", reg3),

        #Armor
        (try_begin),
          (ge, ":item_type", itp_type_head_armor),
          (le, ":item_type", itp_type_hand_armor),

          #construct comparison value
          (item_get_head_armor, ":value", ":item_id"),
          (val_add, ":armor", ":value"),
          (item_get_body_armor, ":value", ":item_id"),
          (val_add, ":armor", ":value"),
          (item_get_leg_armor, ":value", ":item_id"),
          (val_add, ":armor", ":value"),
          (assign, ":ret_val", ":armor"),

          #Ranged Weapons
        (else_try),
          (call_script, "script_cf_is_weapon_ranged", ":item_id", 1),

          #construct comparison value
          (item_get_thrust_damage, ":value", ":item_id"),
          (val_add, ":damage", ":value"),

          (item_get_speed_rating, ":value", ":item_id"),
          (val_add, ":value", ":speed"),
          (val_mul, ":damage", ":value"),

          (item_get_missile_speed,  ":value", ":item_id"),
          (val_mul, ":damage", ":value"),

          (item_get_accuracy, ":value", ":item_id"),
          (val_mul, ":damage", ":value"),
          (assign, ":ret_val", ":damage"),

          #Melee Weapons
        (else_try),
          (ge, ":item_type", itp_type_one_handed_wpn),
          (le, ":item_type", itp_type_polearm),

          #construct comparison value
          (item_get_thrust_damage, ":value", ":item_id"),
          (item_get_swing_damage, reg2, ":item_id"),
          (val_max, ":value", reg2),  #TW formula.  Also avoids problems with script_switch_to_noswing_weapons
          (val_add, ":damage", ":value"),

          (item_get_speed_rating, ":value", ":item_id"),
          (val_add, ":value", ":speed"),
          (val_mul, ":damage", ":value"),

          (item_get_weapon_length, ":value", ":item_id"),
          (convert_to_fixed_point, ":value"),
          (store_sqrt, reg2, ":value"),
          (convert_from_fixed_point, reg2),
          (val_mul, ":damage", reg2),
          (assign, ":ret_val", ":damage"),

          #Shields
        (else_try),
          (eq, ":item_type", itp_type_shield),

          #construct comparison value
          (item_get_body_armor, ":value", ":item_id"),
          (val_add, ":armor", ":value"),

          (item_get_hit_points, ":value", ":item_id"),
          (val_add, ":value", ":hit_points"),
          (val_div, ":value", 17),  #attempt to make it comparable to armors
          (val_add, ":armor", ":value"),

          #shields' protection modified by size, speed
          (item_get_weapon_length, ":value", ":item_id"),
          (val_mul, ":armor", ":value"),
          (val_div, ":armor", Outfit_Thorax_Length),

          (item_get_speed_rating, ":value", ":item_id"),
          (val_add, ":value", ":speed"),
          (val_mul, ":armor", ":value"),
          (val_div, ":armor", Outfit_Fast_Weapon_Speed),

          (val_mul, ":armor", 3), #fudge factor
          (assign, ":ret_val", ":armor"),

          #Horses
        (else_try),
          (eq, ":item_type", itp_type_horse),

          #construct comparison value
          (item_get_body_armor, ":value", ":item_id"),
          (val_add, ":armor", ":value"),
          (val_mul, ":armor", 4), #figure it takes 3-4 hits to kill a horse, so this is the hit value of each
          #point of armor

          (item_get_hit_points, ":value", ":item_id"),
          (val_add, ":value", ":hit_points"),
          (val_add, ":armor", ":value"),

          (item_get_horse_speed, ":value", ":item_id"),
          (val_add, ":value", ":speed"),
          (val_mul, ":armor", ":value"),
          (assign, ":ret_val", ":armor"),

          #Missiles
        (else_try),
          (this_or_next | eq, ":item_type", itp_type_arrows),
          (this_or_next | eq, ":item_type", itp_type_bolts),
          (eq, ":item_type", itp_type_bullets),
        (try_end),
      (try_end),

      (assign, reg0, ":ret_val"),]),

  ("init_noswing_weapons", make_noswing_weapons(items)),

# # M&B Standard AI with changes for formations #CABA - OK; Need expansion when new AI divisions to work with
  # script_formation_battle_tactic_init_aux
  # Input: team_no, battle_tactic
  # Output: none
  ("formation_battle_tactic_init_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
      (team_get_leader, ":ai_leader", ":team_no"),
      (try_begin),
        (eq, ":battle_tactic", btactic_hold),
        (agent_get_position, pos1, ":ai_leader"),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30),
        (copy_position, pos1, pos52),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30), # call again just in case we are not at peak point.
        (copy_position, pos1, pos52),
        (call_script, "script_find_high_ground_around_pos1", ":team_no", 30), # call again just in case we are not at peak point.
        (team_give_order, ":team_no", grc_everyone, mordr_hold),
        (team_set_order_position, ":team_no", grc_everyone, pos52),
        (team_give_order, ":team_no", grc_archers, mordr_advance),
        (team_give_order, ":team_no", grc_archers, mordr_advance),
      (else_try),
        (eq, ":battle_tactic", btactic_follow_leader),
        (team_get_leader, ":ai_leader", ":team_no"),
        (ge, ":ai_leader", 0),
        (agent_set_speed_limit, ":ai_leader", 8),
        (agent_get_position, pos60, ":ai_leader"),
        (team_give_order, ":team_no", grc_everyone, mordr_hold),
        (team_set_order_position, ":team_no", grc_everyone, pos60),
      (try_end),
# formations additions
	  (call_script, "script_division_reset_places"),
	  (call_script, "script_get_default_formation", ":team_no"),
	  (assign, ":fformation", reg0),

	  (try_begin),
		(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_infantry, ":fformation"),
		(store_add, ":slot", slot_team_d0_formation, grc_infantry),
		(team_set_slot, ":team_no", ":slot", ":fformation"),
		(store_add, ":slot", slot_team_d0_formation_space, grc_infantry),
		(team_set_slot, ":team_no", ":slot", 0),
	  (else_try),
		(call_script, "script_formation_end", ":team_no", grc_infantry),
	  (try_end),
	  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_infantry),

	  (try_begin),
		(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_archers, formation_default),
		(store_add, ":slot", slot_team_d0_formation, grc_archers),
		(team_set_slot, ":team_no", ":slot", formation_default),
		(store_add, ":slot", slot_team_d0_formation_space, grc_archers),
		(team_set_slot, ":team_no", ":slot", 2),
	  (else_try),
		(call_script, "script_formation_end", ":team_no", grc_archers),
	  (try_end),
	  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_archers),

	  (try_begin),
		(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_cavalry, formation_wedge),
		(store_add, ":slot", slot_team_d0_formation, grc_cavalry),
		(team_set_slot, ":team_no", ":slot", formation_wedge),
		(store_add, ":slot", slot_team_d0_formation_space, grc_cavalry),
		(team_set_slot, ":team_no", ":slot", 0),
	  (else_try),
		(call_script, "script_formation_end", ":team_no", grc_cavalry),
	  (try_end),
	  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_cavalry),

	  (team_give_order, ":team_no", grc_archers, mordr_spread_out),
	  (team_give_order, ":team_no", grc_archers, mordr_spread_out),
# end formations additions
  ]),

  # script_formation_battle_tactic_apply_aux #CABA - OK; Need expansion when new AI divisions to work with
  # Input: team_no, battle_tactic
  # Output: battle_tactic
  ("formation_battle_tactic_apply_aux",
    [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_tactic", 2),
      (store_mission_timer_a, ":mission_time"),
      (try_begin),
        (eq, ":battle_tactic", btactic_hold),
        (copy_position, pos1, pos52),
        (call_script, "script_get_closest3_distance_of_enemies_at_pos1", ":team_no", 1),
        (assign, ":avg_dist", reg0),
        (assign, ":min_dist", reg1),
        (try_begin),
          (this_or_next|lt, ":min_dist", 1000),
          (lt, ":avg_dist", 4000),
          (assign, ":battle_tactic", 0),
		  (call_script, "script_formation_end", ":team_no", grc_infantry),	#formations
		  (call_script, "script_formation_end", ":team_no", grc_archers),	#formations
		  (call_script, "script_formation_end", ":team_no", grc_cavalry),	#formations
          (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (try_end),
      (else_try),
        (eq, ":battle_tactic", btactic_follow_leader),
        (team_get_leader, ":ai_leader", ":team_no"),
        (try_begin),
          (agent_is_alive, ":ai_leader"),
          (agent_set_speed_limit, ":ai_leader", 9),
          (call_script, "script_team_get_average_position_of_enemies", ":team_no"),
          (copy_position, pos60, pos0),
          (ge, ":ai_leader", 0),
          (agent_get_position, pos61, ":ai_leader"),
          (position_transform_position_to_local, pos62, pos61, pos60), #pos62 = vector to enemy w.r.t leader
          (position_normalize_origin, ":distance_to_enemy", pos62),
          (convert_from_fixed_point, ":distance_to_enemy"),
          (assign, reg17, ":distance_to_enemy"),
          (position_get_x, ":dir_x", pos62),
          (position_get_y, ":dir_y", pos62),
          (val_mul, ":dir_x", 23),
          (val_mul, ":dir_y", 23), #move 23 meters
          (position_set_x, pos62, ":dir_x"),
          (position_set_y, pos62, ":dir_y"),

          (position_transform_position_to_parent, pos63, pos61, pos62), #pos63 is 23m away from leader in the direction of the enemy.
          (position_set_z_to_ground_level, pos63),

          (team_give_order, ":team_no", grc_everyone, mordr_hold),
          (team_set_order_position, ":team_no", grc_everyone, pos63),
#formations code
		  (call_script, "script_point_y_toward_position", pos63, pos60),
		  (agent_get_position, pos49, ":ai_leader"),
		  (agent_set_position, ":ai_leader", pos63),	#fake out script_battlegroup_place_around_leader
		  (call_script, "script_division_reset_places"),
		  (call_script, "script_get_default_formation", ":team_no"),
		  (assign, ":fformation", reg0),

		  (try_begin),
			(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_infantry, ":fformation"),
			(store_add, ":slot", slot_team_d0_formation, grc_infantry),
			(team_set_slot, ":team_no", ":slot", ":fformation"),
			(store_add, ":slot", slot_team_d0_formation_space, grc_infantry),
			(team_set_slot, ":team_no", ":slot", 0),
		  (else_try),
			(call_script, "script_formation_end", ":team_no", grc_infantry),
		  (try_end),
		  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_infantry),

		  (try_begin),
			(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_archers, formation_default),
			(store_add, ":slot", slot_team_d0_formation, grc_archers),
			(team_set_slot, ":team_no", ":slot", formation_default),
			(store_add, ":slot", slot_team_d0_formation_space, grc_archers),
			(team_set_slot, ":team_no", ":slot", 2),
		  (else_try),
			(call_script, "script_formation_end", ":team_no", grc_archers),
		  (try_end),
		  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_archers),

		  (try_begin),
			(call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_cavalry, formation_wedge),
			(store_add, ":slot", slot_team_d0_formation, grc_cavalry),
			(team_set_slot, ":team_no", ":slot", formation_wedge),
			(store_add, ":slot", slot_team_d0_formation_space, grc_cavalry),
			(team_set_slot, ":team_no", ":slot", 0),
		  (else_try),
			(call_script, "script_formation_end", ":team_no", grc_cavalry),
		  (try_end),
		  (call_script, "script_battlegroup_place_around_leader", ":team_no", grc_cavalry),

		  (agent_set_position, ":ai_leader", pos49),
#end formations code
          (agent_get_position, pos1, ":ai_leader"),
          (try_begin),
            (lt, ":distance_to_enemy", 50),
            (ge, ":mission_time", 30),
            (assign, ":battle_tactic", 0),
			(call_script, "script_formation_end", ":team_no", grc_infantry),	#formations
			(call_script, "script_formation_end", ":team_no", grc_archers),	#formations
			(call_script, "script_formation_end", ":team_no", grc_cavalry),	#formations
            (team_give_order, ":team_no", grc_everyone, mordr_charge),
            (agent_set_speed_limit, ":ai_leader", 60),
          (try_end),
        (else_try),
          (assign, ":battle_tactic", 0),
		  (call_script, "script_formation_end", ":team_no", grc_infantry),	#formations
		  (call_script, "script_formation_end", ":team_no", grc_archers),	#formations
		  (call_script, "script_formation_end", ":team_no", grc_cavalry),	#formations
          (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (try_end),
      (try_end),

      (try_begin), # charge everyone after a while
        (neq, ":battle_tactic", 0),
        (ge, ":mission_time", 300),
        (assign, ":battle_tactic", 0),
		(call_script, "script_formation_end", ":team_no", grc_infantry),	#formations
		(call_script, "script_formation_end", ":team_no", grc_archers),	#formations
		(call_script, "script_formation_end", ":team_no", grc_cavalry),	#formations
        (team_give_order, ":team_no", grc_everyone, mordr_charge),
        (team_get_leader, ":ai_leader", ":team_no"),
        (agent_set_speed_limit, ":ai_leader", 60),
      (try_end),
      (assign, reg0, ":battle_tactic"),
  ]),

  # Replacement script for battle_tactic_init_aux to switch between using
  # M&B Standard AI with changes for formations and original based on
  # NOTE: original script "battle_tactic_init_aux" should be renamed to "orig_battle_tactic_init_aux"
  # constant formation_native_ai_use_formation ( 0: original, 1: use formation )
  # script_battle_tactic_init_aux
  # Input: team_no, battle_tactic
  # Output: none
  ("battle_tactic_init_aux",
	[
	  (store_script_param, ":team_no", 1),
	  (store_script_param, ":battle_tactic", 2),
	  (try_begin),
		(eq, formation_native_ai_use_formation, 1),
		(call_script, "script_formation_battle_tactic_init_aux", ":team_no", ":battle_tactic"),
	  (else_try),
		(call_script, "script_orig_battle_tactic_init_aux", ":team_no", ":battle_tactic"),
	  (try_end),
	]),

  # Replacement script for battle_tactic_init_aux to switch between using
  # M&B Standard AI with changes for formations and original based on
  # NOTE: original script "battle_tactic_apply_aux" should be renamed to "orig_battle_tactic_apply_aux"
  # constant formation_native_ai_use_formation ( 0: original, 1: use formation )
  # script_battle_tactic_apply_aux
  # Input: team_no, battle_tactic
  # Output: battle_tactic
  ("battle_tactic_apply_aux",
	[
	  (store_script_param, ":team_no", 1),
	  (store_script_param, ":battle_tactic", 2),
	  (try_begin),
		(eq, formation_native_ai_use_formation, 1),
		(call_script, "script_formation_battle_tactic_apply_aux", ":team_no", ":battle_tactic"),
	  (else_try),
		(call_script, "script_orig_battle_tactic_apply_aux", ":team_no", ":battle_tactic"),
	  (try_end),
  ]),

  # # AI with Formations Scripts
  # script_calculate_decision_numbers by motomataru
  # Input: AI team, size relative to battle in %
  # Output: reg0 - battle presence plus level bump, reg1 - level bump (team avg
  # level / 3)
  ("calculate_decision_numbers", [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":battle_presence", 2),
      (try_begin),
        (team_get_slot, reg0, ":team_no", slot_team_level),
        (store_div, reg1, reg0, 3),
        (store_add, reg0, ":battle_presence", reg1),	#decision w.r.t.  all enemy teams
      (try_end)]),


  # script_team_field_ranged_tactics by motomataru
  # Input: AI team, size relative to largest team in %, size relative to battle
  # in %
  # Output: none
  ("team_field_ranged_tactics", [
      (store_script_param, ":team_no", 1),
      (store_script_param, ":rel_army_size", 2),
      (store_script_param, ":battle_presence", 3),
      (assign, ":division", grc_archers), #Pre-Many Divisions
      (assign, ":bg_pos", Archers_Pos), #Pre-Many Divisions

      (try_begin),
        (store_add, ":slot", slot_team_d0_size, ":division"),
        (team_slot_eq, ":team_no", ":slot", 0),
        (try_begin),	#undo reversion to BP_Jockey (see below)
          (lt, "$battle_phase", BP_Fight),
          (call_script, "script_cf_any_fighting"),
          (call_script, "script_cf_count_casualties"),
          (assign, "$battle_phase", BP_Fight),
        (try_end),

      (else_try),
        (call_script, "script_battlegroup_get_position", ":bg_pos", ":team_no", ":division"),
        (call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, ":team_no", grc_everyone),
        (call_script, "script_point_y_toward_position", ":bg_pos", Enemy_Team_Pos),

        (store_add, ":slot", slot_team_d0_closest_enemy_special_dist, ":division"),	#distance to nearest enemy infantry agent
        (team_get_slot, ":distance_to_enemy", ":team_no", ":slot"),
        (try_begin),
          (eq, ":distance_to_enemy", 0),
          (call_script, "script_get_nearest_enemy_battlegroup_location", Nearest_Enemy_Battlegroup_Pos, ":team_no", ":bg_pos"),
          (assign, ":distance_to_enemy", reg0),
        (try_end),

        (try_begin),	#avoid being provoked from defensive position
          (ge, "$battle_phase", BP_Fight),
          (try_begin),
            (call_script, "script_cf_any_fighting"),
          (else_try),
            (assign, "$battle_phase", BP_Jockey),
            (assign, "$clock_reset", 0),
          (try_end),
        (try_end),

        (store_add, ":slot", slot_team_d0_is_fighting, ":division"),
        (team_get_slot, ":is_firing", ":team_no", ":slot"),
        (store_add, ":slot", slot_team_d0_size, grc_infantry),
        (team_get_slot, ":num_infantry", ":team_no", ":slot"),

        (call_script, "script_calculate_decision_numbers", ":team_no", ":battle_presence"),
        (assign, ":decision_index", reg0),
        (assign, ":level_bump", reg1),

        (try_begin),
          (gt, ":decision_index", 86),	#outpower enemies more than 6:1?
          (team_get_movement_order, reg0, ":team_no", ":division"),
          (try_begin),
            (neq, reg0, mordr_charge),
            (team_give_order, ":team_no", ":division", mordr_charge),
          (try_end),

        (else_try),
          (lt, ":decision_index", 14),	#outpowered more than 6:1?
          (eq, ":num_infantry", 0),	#no infantry to delay enemy?
          (team_get_movement_order, reg0, ":team_no", ":division"),
          (try_begin),
            (neq, reg0, mordr_retreat),
            (team_give_order, ":team_no", ":division", mordr_retreat),
          (try_end),

        (else_try),
          (ge, "$battle_phase", BP_Jockey),
          (store_add, ":slot", slot_team_d0_low_ammo, ":division"),
          (team_slot_ge, ":team_no", ":slot", 1),	#running out of ammo?
          (team_get_movement_order, reg0, ":team_no", ":division"),
          (try_begin),
            (neq, reg0, mordr_charge),
            (team_give_order, ":team_no", ":division", mordr_charge),
          (try_end),

        (else_try),
          (ge, "$battle_phase", BP_Fight),
          (eq, ":is_firing", 0),
          (gt, ":decision_index", Advance_More_Point),
          (le, ":distance_to_enemy", AI_long_range),	#closer than reposition?
          (team_give_order, ":team_no", ":division", mordr_advance),

        #hold somewhere
        (else_try),
          (store_add, ":decision_index", ":rel_army_size", ":level_bump"),	#decision w.r.t. largest enemy team
          (assign, ":move_archers", 0),

          (init_position, Team_Starting_Point),
          (team_get_slot, reg0, ":team_no", slot_team_starting_x),
          (position_set_x, Team_Starting_Point, reg0),
          (team_get_slot, reg0, ":team_no", slot_team_starting_y),
          (position_set_y, Team_Starting_Point, reg0),
          (position_set_z_to_ground_level, Team_Starting_Point),

          (try_begin),
            (eq, "$battle_phase", BP_Setup),
            (assign, ":move_archers", 1),
          (else_try),
            (ge, "$battle_phase", BP_Fight),
            (try_begin),
              (neg | is_between, ":distance_to_enemy", AI_charge_distance, AI_long_range),
              (assign, ":move_archers", 1),
            (else_try),
              (lt, ":decision_index", Hold_Point),	#probably coming from a defensive position (see below)
              (eq, "$FormAI_AI_no_defense", 0),	#player hasn't set disallow defense option?
              (eq, ":is_firing", 0),	#probably because player team has retreated
              (assign, ":move_archers", 1),
            (try_end),
          (else_try),	#jockey phase
            (this_or_next | gt, "$FormAI_AI_no_defense", 0),	#player has set disallow defense option OR
            (ge, ":decision_index", Hold_Point),	#not starting in a defensive position (see below)
            (try_begin),
              (gt, ":distance_to_enemy", AI_long_range),	#enemy very far off
              (assign, ":move_archers", 1),
            (else_try),
              (call_script, "script_point_y_toward_position", Team_Starting_Point, ":bg_pos"),
              (position_get_rotation_around_z, reg0, Team_Starting_Point),
              (position_get_rotation_around_z, reg1, ":bg_pos"),
              (val_sub, reg0, reg1),
              (this_or_next | is_between, reg0, -45, 45),	#only move if within "cone of advancement" to prevent constant adjusting at
              #border OR
              (eq, ":is_firing", 0),	#if not firing for some reason (hill in way?)

              (try_begin),
                (eq, ":num_infantry", 0),	#no infantry to wait for
                (assign, ":move_archers", 1),
              (else_try),
                (call_script, "script_battlegroup_get_position", Infantry_Pos, ":team_no", grc_infantry),
                (get_distance_between_positions, ":infantry_to_enemy", Infantry_Pos, Enemy_Team_Pos),
                (get_distance_between_positions, ":archers_to_enemy", ":bg_pos", Enemy_Team_Pos),
                (val_sub, ":infantry_to_enemy", ":archers_to_enemy"),
                (le, ":infantry_to_enemy", 1500),	#don't outstrip infantry when closing
                (assign, ":move_archers", 1),
              (try_end),
            (try_end),
          (try_end),

          (try_begin),
            (gt, ":move_archers", 0),
            (try_begin),
              (lt, ":decision_index", Hold_Point),	#outnumbered?
              (eq, "$FormAI_AI_no_defense", 0),	#player hasn't set disallow defense option?
              (lt, "$battle_phase", BP_Fight),
              (neq, ":team_no", 1),	#not attacker?
              (neq, ":team_no", 3),	#not ally of attacker?
              (store_div, ":distance_to_move", ":distance_to_enemy", 6),	#middle of rear third of battlefield
              (assign, ":hill_search_radius", ":distance_to_move"),

            (else_try),
              (try_begin),
                (ge, "$battle_phase", BP_Fight),
                (copy_position, ":bg_pos", Team_Starting_Point),
                (call_script, "script_point_y_toward_position", ":bg_pos", Enemy_Team_Pos),
                (try_begin),
                  (gt, ":num_infantry", 0),
                  (store_add, ":slot", slot_team_d0_closest_enemy, grc_infantry),
                  (team_get_slot, ":enemy_agent_nearest_infantry", ":team_no", ":slot"),
                  (le, ":enemy_agent_nearest_infantry", 0),
                  (agent_get_team, ":target_team", ":enemy_agent_nearest_infantry"),
                  (agent_get_division, ":target_division", ":enemy_agent_nearest_infantry"),
                  (call_script, "script_battlegroup_get_position", Nearest_Enemy_Battlegroup_Pos, ":target_team", ":target_division"),
                  (get_distance_between_positions, ":distance_to_enemy", ":bg_pos", Nearest_Enemy_Battlegroup_Pos),
                (else_try),
                  (call_script, "script_get_nearest_enemy_battlegroup_location", Nearest_Enemy_Battlegroup_Pos, ":team_no", ":bg_pos"),
                  (assign, ":distance_to_enemy", reg0),
                (try_end),
              (try_end),

              (try_begin),
                (eq, "$battle_phase", BP_Setup),
                (assign, ":shot_distance", AI_long_range),
              (else_try),
                (assign, ":shot_distance", AI_firing_distance),
                (store_sub, reg1, AI_firing_distance, AI_charge_distance),
                (val_sub, reg1, 200),	#subtract two meters to prevent automatically provoking melee from forward
                #enemy infantry
                (store_add, ":slot", slot_team_d0_percent_throwers, ":division"),
                (team_get_slot, reg0, ":team_no", ":slot"),
                (val_mul, reg1, reg0),
                (val_div, reg1, 100),
                (val_sub, ":shot_distance", reg1),
              (try_end),

              (store_sub, ":distance_to_move", ":distance_to_enemy", ":shot_distance"),
              (store_div, ":hill_search_radius", ":shot_distance", 3),	#limit so as not to run into enemy
              (try_begin),
                (lt, "$battle_phase", BP_Fight),
                (try_begin),
                  (this_or_next | eq, "$battle_phase", BP_Setup),
                  (lt, ":battle_presence", Advance_More_Point),	#expect to meet halfway?
                  (val_div, ":distance_to_move", 2),
                (try_end),
              (try_end),
            (try_end),

            (position_move_y, ":bg_pos", ":distance_to_move", 0),
            (try_begin),
              (lt, "$battle_phase", BP_Fight),
              (copy_position, pos1, ":bg_pos"),
              (store_div, reg0, ":hill_search_radius", 100),
              (call_script, "script_find_high_ground_around_pos1_corrected", ":bg_pos", reg0),
            (try_end),
          (try_end),

          (team_get_movement_order, reg0, ":team_no", ":division"),
          (try_begin),
            (neq, reg0, mordr_hold),
            (team_give_order, ":team_no", ":division", mordr_hold),
          (try_end),
          (call_script, "script_set_formation_destination", ":team_no", ":division", ":bg_pos"),
        (try_end),
      (try_end)]),


  # script_team_field_melee_tactics by motomataru #EDITED FOR SLOTS BY
  # CABA...many divisions changes necessary
  # Input: AI team, size relative to largest team in %, size relative to battle
  # in %
  # Output: none
  ("team_field_melee_tactics", [
      (store_script_param, ":team_no", 1),
      #	(store_script_param, ":rel_army_size", 2),
      (store_script_param, ":battle_presence", 3),
      (call_script, "script_calculate_decision_numbers", ":team_no", ":battle_presence"),

      #mop up if outnumber enemies more than 6:1
      (try_begin),
        (gt, reg0, 86),
        (try_for_range, ":division", 0, 9),
          (store_add, ":slot", slot_team_d0_size, ":division"),
          (team_slot_ge, ":team_no", ":slot", 1),
          (store_add, ":slot", slot_team_d0_type, ":division"),
          (neg | team_slot_eq, ":team_no", ":slot", sdt_archer),
          (neg | team_slot_eq, ":team_no", ":slot", sdt_skirmisher),
          (call_script, "script_formation_end", ":team_no", ":division"),
          (team_get_movement_order, reg0, ":team_no", ":division"),
          (try_begin),
            (neq, reg0, mordr_charge),
            (team_give_order, ":team_no", ":division", mordr_charge),
          (try_end),
        (try_end),

      (else_try),
        (assign, ":num_enemies", 0),
        (try_for_range, ":enemy_team_no", 0, 4),
          (teams_are_enemies, ":enemy_team_no", ":team_no"),
          (team_get_slot, ":value", ":enemy_team_no", slot_team_size),
          (val_add, ":num_enemies", ":value"),
        (try_end),

        (gt, ":num_enemies", 0),
        (call_script, "script_team_get_position_of_enemies", Enemy_Team_Pos, ":team_no", grc_everyone),

        (store_add, ":slot", slot_team_d0_size, grc_archers),
        (team_get_slot, ":num_archers", ":team_no", ":slot"),
        (try_begin),
          (eq, ":num_archers", 0),
          (assign, ":enemy_bg_nearest_archers_dist", Far_Away),
          (assign, ":archer_order", mordr_charge),
        (else_try),
          (call_script, "script_battlegroup_get_position", Archers_Pos, ":team_no", grc_archers),
          (call_script, "script_point_y_toward_position", Archers_Pos, Enemy_Team_Pos),
          (call_script, "script_get_nearest_enemy_battlegroup_location", pos0, ":team_no", Archers_Pos),
          (assign, ":enemy_bg_nearest_archers_dist", reg0),
          (team_get_movement_order, ":archer_order", ":team_no", grc_archers),
        (try_end),

        (store_add, ":slot", slot_team_d0_size, grc_infantry),
        (team_get_slot, ":num_infantry", ":team_no", ":slot"),
        (try_begin),
          (eq, ":num_infantry", 0),
          (assign, ":enemy_bg_nearest_infantry_dist", Far_Away),
          (assign, ":enemy_agent_nearest_infantry_dist", Far_Away),
        (else_try),
          (call_script, "script_battlegroup_get_position", Infantry_Pos, ":team_no", grc_infantry),
          (call_script, "script_get_nearest_enemy_battlegroup_location", pos0, ":team_no", Infantry_Pos),
          (assign, ":enemy_bg_nearest_infantry_dist", reg0),
          (store_add, ":slot", slot_team_d0_closest_enemy_dist, grc_infantry),
          (team_get_slot, ":enemy_agent_nearest_infantry_dist", ":team_no", ":slot"),
          (eq, ":enemy_agent_nearest_infantry_dist", 0),	#happens when player turns off closest agent mechanism (see mod options)
          (assign, ":enemy_agent_nearest_infantry_dist", ":enemy_bg_nearest_infantry_dist"),
        (try_end),

        (store_add, ":slot", slot_team_d0_size, grc_cavalry),
        (team_get_slot, ":num_cavalry", ":team_no", ":slot"),
        (try_begin),
          (eq, ":num_cavalry", 0),
          (assign, ":enemy_bg_nearest_cavalry_dist", Far_Away),
          (assign, ":enemy_agent_nearest_cavalry_dist", Far_Away),
        (else_try),
          (call_script, "script_battlegroup_get_position", Cavalry_Pos, ":team_no", grc_cavalry),
          (call_script, "script_get_nearest_enemy_battlegroup_location", pos0, ":team_no", Cavalry_Pos),
          (assign, ":enemy_bg_nearest_cavalry_dist", reg0),
          (store_add, ":slot", slot_team_d0_closest_enemy_dist, grc_cavalry),
          (team_get_slot, ":enemy_agent_nearest_cavalry_dist", ":team_no", ":slot"),
          (eq, ":enemy_agent_nearest_cavalry_dist", 0),	#happens when player turns off closest agent mechanism (see mod options)
          (assign, ":enemy_agent_nearest_cavalry_dist", ":enemy_bg_nearest_infantry_dist"),
        (try_end),

        (try_begin),
          (lt, "$battle_phase", BP_Fight),
          (this_or_next | le, ":enemy_bg_nearest_infantry_dist", AI_charge_distance),
          (this_or_next | le, ":enemy_bg_nearest_cavalry_dist", AI_charge_distance),
          (le, ":enemy_bg_nearest_archers_dist", AI_charge_distance),
          (assign, "$battle_phase", BP_Fight),
        (else_try),
          (lt, "$battle_phase", BP_Jockey),
          (this_or_next | le, ":enemy_agent_nearest_infantry_dist", AI_long_range),
          (le, ":enemy_agent_nearest_cavalry_dist", AI_long_range),
          (assign, "$battle_phase", BP_Jockey),
        (try_end),

        (team_get_leader, ":team_leader", ":team_no"),
        (assign, ":place_leader_by_infantry", 0),

        #infantry AI
        (store_add, ":slot", slot_team_d0_closest_enemy, grc_infantry),
        (team_get_slot, ":enemy_agent_nearest_infantry", ":team_no", ":slot"),
        (try_begin),
          (this_or_next | le, ":num_infantry", 0),
          (le, ":enemy_agent_nearest_infantry", 0),
          (assign, ":infantry_order", ":archer_order"),

          #deal with mounted heroes that team_give_order() treats as infantry
          ##CABA...could change their division?
          (team_get_movement_order, reg0, ":team_no", grc_infantry),
          (try_begin),
            (neq, reg0, ":infantry_order"),
            (team_give_order, ":team_no", grc_infantry, ":infantry_order"),
          (try_end),
          (try_begin),
            (gt, ":num_archers", 0),
            (copy_position, pos1, Archers_Pos),
            (position_move_y, pos1, 1000, 0),
            (call_script, "script_set_formation_destination", ":team_no", grc_infantry, pos1),
          (else_try),
            (call_script, "script_set_formation_destination", ":team_no", grc_infantry, Cavalry_Pos),
          (try_end),

        (else_try),
          (agent_get_position, Nearest_Enemy_Troop_Pos, ":enemy_agent_nearest_infantry"),
          (agent_get_team, ":enemy_agent_nearest_infantry_team", ":enemy_agent_nearest_infantry"),
          (agent_get_division, ":enemy_agent_nearest_infantry_div", ":enemy_agent_nearest_infantry"),

          (assign, ":sum_level_enemy_infantry", 0),
          (try_for_range, ":enemy_team_no", 0, 4),
            (teams_are_enemies, ":enemy_team_no", ":team_no"),
            (try_for_range, ":enemy_division", 0, 9),
              (store_add, ":slot", slot_team_d0_type, ":enemy_division"),
              (team_get_slot, ":value", ":enemy_team_no", ":slot"),
              (this_or_next | eq, ":value", sdt_polearm),
              (eq, ":value", sdt_infantry),
              (store_add, ":slot", slot_team_d0_size, ":enemy_division"),
              (team_get_slot, ":value", ":enemy_team_no", ":slot"),
              (store_add, ":slot", slot_team_d0_level, ":enemy_division"),
              (team_get_slot, reg0, ":enemy_team_no", ":slot"),
              (val_mul, ":value", reg0),
              (val_add, ":sum_level_enemy_infantry", ":value"),
            (try_end),
          (try_end),

          (store_mul, ":percent_level_enemy_infantry", ":sum_level_enemy_infantry", 100),
          (val_div, ":percent_level_enemy_infantry", ":num_enemies"),
          (try_begin),
            (teams_are_enemies, ":team_no", "$fplayer_team_no"),
            (assign, ":combined_level", 0),
            (assign, ":combined_team_size", 0),
            (assign, ":combined_num_infantry", ":num_infantry"),
          (else_try),
            (store_add, ":slot", slot_team_d0_level, grc_infantry),
            (team_get_slot, ":combined_level", "$fplayer_team_no", ":slot"),
            (team_get_slot, ":combined_team_size", "$fplayer_team_no", slot_team_size),
            (store_add, ":slot", slot_team_d0_size, grc_infantry),
            (team_get_slot, ":combined_num_infantry", "$fplayer_team_no", ":slot"),
            (val_add, ":combined_num_infantry", ":num_infantry"),
          (try_end),
          (store_mul, ":percent_level_infantry", ":combined_num_infantry", 100),
          (store_add, ":slot", slot_team_d0_level, grc_infantry),
          (team_get_slot, ":level_infantry", ":team_no", ":slot"),
          (val_add, ":combined_level", ":level_infantry"),
          (val_mul, ":percent_level_infantry", ":combined_level"),
          (team_get_slot, reg0, ":team_no", slot_team_size),
          (val_add, ":combined_team_size", reg0),
          (val_div, ":percent_level_infantry", ":combined_team_size"),

          (assign, ":infantry_order", mordr_charge),
          (try_begin),	#enemy far away AND ranged not charging
            (gt, ":enemy_bg_nearest_archers_dist", AI_charge_distance),
            (gt, ":enemy_agent_nearest_infantry_dist", AI_charge_distance),
            (neq, ":archer_order", mordr_charge),
            (try_begin),	#fighting not started OR not enough infantry
              (this_or_next | le, "$battle_phase", BP_Jockey),
              (lt, ":percent_level_infantry", ":percent_level_enemy_infantry"),
              (assign, ":infantry_order", mordr_hold),
            (try_end),
          (try_end),

          # bum rush enemy archers?
          (try_begin),
            # (le, ":level_infantry", AI_Poor_Troop_Level), unfortunately leaves them
            # susceptible to rings of archers
            (store_add, ":slot", slot_team_d0_type, ":enemy_agent_nearest_infantry_div"),
            (this_or_next | team_slot_eq, ":enemy_agent_nearest_infantry_team", ":enemy_agent_nearest_infantry_div", sdt_archer),
            (team_slot_eq, ":enemy_agent_nearest_infantry_team", ":enemy_agent_nearest_infantry_div", sdt_skirmisher),
            (get_distance_between_positions, reg0, Infantry_Pos, Nearest_Enemy_Troop_Pos),
            (le, reg0, AI_charge_distance),
            (call_script, "script_formation_end", ":team_no", grc_infantry),
            (team_get_movement_order, reg0, ":team_no", grc_infantry),
            (try_begin),
              (neq, reg0, mordr_charge),
              (team_give_order, ":team_no", grc_infantry, mordr_charge),
            (try_end),

          #else attempt to make formation somewhere
          (else_try),
            (store_add, ":slot", slot_team_d0_formation, grc_infantry),
            (team_get_slot, ":infantry_formation", ":team_no", ":slot"),
            (team_get_leader, ":enemy_leader", ":enemy_agent_nearest_infantry_team"),

            #consider new formation
            (try_begin),
              (store_add, ":slot", slot_team_d0_is_fighting, grc_infantry),
              (this_or_next | le, ":infantry_formation", formation_none),
              (this_or_next | eq, ":infantry_formation", formation_default),
              (team_slot_eq, ":team_no", ":slot", 0),

              (call_script, "script_get_default_formation", ":team_no"),
              (assign, ":infantry_formation", reg0),
              (agent_get_class, ":enemy_nearest_troop_class", ":enemy_agent_nearest_infantry"),

              (assign, ":num_enemy_cavalry", 0),
              (try_for_range, ":enemy_team_no", 0, 4),
                (teams_are_enemies, ":enemy_team_no", ":team_no"),
                (team_get_slot, ":value", ":enemy_team_no", slot_team_num_cavalry),
                (val_add, ":num_enemy_cavalry", ":value"),
              (try_end),

              (store_mul, ":percent_enemy_cavalry", ":num_enemy_cavalry", 100),
              (val_div, ":percent_enemy_cavalry", ":num_enemies"),
              (try_begin),
                (gt, ":infantry_formation", formation_none),
                (try_begin),
                  (gt, ":percent_enemy_cavalry", 66),
                  (assign, ":infantry_formation", formation_square),
                (else_try),
                  (neq, ":enemy_nearest_troop_class", grc_cavalry),
                  (neq, ":enemy_nearest_troop_class", grc_archers),
                  (neq, ":enemy_agent_nearest_infantry", ":enemy_leader"),
                  (ge, ":num_infantry", 21),
                  (store_add, ":slot", slot_team_d0_size, ":enemy_agent_nearest_infantry_div"),
                  (team_get_slot, reg0, ":enemy_agent_nearest_infantry_team", ":slot"),
                  (gt, reg0, ":num_infantry"),	#got fewer troops?
                  (store_add, ":slot", slot_team_d0_armor, grc_infantry),
                  (team_get_slot, ":average_armor", ":team_no", ":slot"),
                  (store_add, ":slot", slot_team_d0_armor, ":enemy_agent_nearest_infantry_div"),
                  (team_get_slot, reg0, ":enemy_agent_nearest_infantry_team", ":slot"),
                  (gt, ":average_armor", reg0),	#got better armor?
                  (assign, ":infantry_formation", formation_wedge),
                (try_end),
              (try_end),
            (try_end),	#consider new formation

            (try_begin),
              (call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_infantry, ":infantry_formation"),
              (store_add, ":slot", slot_team_d0_formation, grc_infantry),
              (team_set_slot, ":team_no", ":slot", ":infantry_formation"),

              #adjust spacing for long swung weapons
              (store_add, ":slot", slot_team_d0_swung_weapon_length, grc_infantry),
              (team_get_slot, ":spacing", ":team_no", ":slot"),
              (val_add, ":spacing", 25),	#rounding for 50cm
              (val_div, ":spacing", 50),
              (store_add, ":slot", slot_team_d0_formation_space, grc_infantry),
              (team_set_slot, ":team_no", ":slot", ":spacing"),

              (assign, ":place_leader_by_infantry", 1),

            (else_try),
              (call_script, "script_formation_end", ":team_no", grc_infantry),
              (team_get_movement_order, reg0, ":team_no", grc_infantry),
              (try_begin),
                (neq, reg0, ":infantry_order"),
                (team_give_order, ":team_no", grc_infantry, ":infantry_order"),
              (try_end),
              (eq, ":infantry_order", mordr_hold),
              (assign, ":place_leader_by_infantry", 1),
            (try_end),

            #hold near archers?
            (try_begin),
              (eq, ":infantry_order", mordr_hold),
              (gt, ":num_archers", 0),
              # (copy_position, pos1, Archers_Pos),
              (team_get_order_position, pos1, ":team_no", grc_archers),	#anticipate archers
              (position_move_x, pos1, -100, 0),
              (try_begin),
                (this_or_next | eq, ":enemy_agent_nearest_infantry_div", grc_cavalry),
                (gt, ":percent_level_infantry", ":percent_level_enemy_infantry"),
                (call_script, "script_battlegroup_dist_center_to_front", ":team_no", grc_infantry),	#make sure to clear archers
                (store_mul, ":distance_to_move", reg0, 2),
                (val_add, ":distance_to_move", 1000),
                (position_move_y, pos1, ":distance_to_move", 0),	#move ahead of archers in anticipation of charges
              (else_try),
                (position_move_y, pos1, -1000, 0),
              (try_end),

            #obtain destination
            (else_try),
              (assign, ":target_division", -1),
              (try_begin),
                (store_add, ":slot", slot_team_d0_is_fighting, grc_infantry),
                (team_slot_eq, ":team_no", ":slot", 0),	#not engaged?
                (gt, ":enemy_bg_nearest_archers_dist", AI_charge_distance),	#don't have to protect archers?
                # (lt, ":percent_enemy_cavalry", 100), #non-cavalry exist?  MOTO next
                # command tests

                #prefer non-cavalry target (that infantry can catch)
                (store_add, ":slot", slot_team_d0_closest_enemy_special_dist, grc_infantry),
                (team_get_slot, ":distance_to_enemy_troop", ":team_no", ":slot"),
                (gt, ":distance_to_enemy_troop", 0),
                (store_add, ":slot", slot_team_d0_closest_enemy_special, grc_infantry),
                (team_get_slot, ":enemy_nearest_non_cav_agent", ":team_no", ":slot"),
                (gt, ":enemy_nearest_non_cav_agent", 0),
                (agent_get_position, pos60, ":enemy_nearest_non_cav_agent"),
                (agent_get_team, ":enemy_non_cav_team", ":enemy_nearest_non_cav_agent"),
                (team_get_leader, reg0, ":enemy_non_cav_team"),
                (try_begin),
                  (eq, ":enemy_nearest_non_cav_agent", reg0),	#team leader?
                  (assign, ":distance_to_enemy_group", Far_Away),
                (else_try),
                  (agent_get_division, ":target_division", ":enemy_nearest_non_cav_agent"),
                  (store_add, ":slot", slot_team_d0_target_team, grc_infantry),
                  (team_set_slot, ":team_no", ":slot", ":enemy_non_cav_team"),
                  (store_add, ":slot", slot_team_d0_target_division, grc_infantry),
                  (team_set_slot, ":team_no", ":slot", ":target_division"),
                  (call_script, "script_battlegroup_get_attack_destination", pos1, ":team_no", grc_infantry, ":enemy_non_cav_team", ":target_division"),
                  (call_script, "script_get_distance_to_battlegroup", ":enemy_non_cav_team", ":target_division", Infantry_Pos),
                  (assign, ":distance_to_enemy_group", reg0),
                (try_end),

              #chase nearest target
              (else_try),
                (assign, ":distance_to_enemy_troop", ":enemy_agent_nearest_infantry_dist"),
                (copy_position, pos60, Nearest_Enemy_Troop_Pos),
                (try_begin),
                  (eq, ":enemy_agent_nearest_infantry", ":enemy_leader"),
                  (assign, ":distance_to_enemy_group", Far_Away),
                (else_try),
                  (assign, ":target_division", ":enemy_agent_nearest_infantry_div"),
                  (store_add, ":slot", slot_team_d0_target_team, grc_infantry),
                  (team_set_slot, ":team_no", ":slot", ":enemy_agent_nearest_infantry_team"),
                  (store_add, ":slot", slot_team_d0_target_division, grc_infantry),
                  (team_set_slot, ":team_no", ":slot", ":target_division"),
                  (call_script, "script_battlegroup_get_attack_destination", pos1, ":team_no", grc_infantry, ":enemy_agent_nearest_infantry_team", ":target_division"),
                  (call_script, "script_get_distance_to_battlegroup", ":enemy_agent_nearest_infantry_team", ":target_division", Infantry_Pos),
                  (assign, ":distance_to_enemy_group", reg0),
                (try_end),
              (try_end),

              #reassemble if too scattered
              (try_begin),
                (call_script, "script_get_distance_to_battlegroup", ":team_no", grc_infantry, pos60),	#we're using enemy troop as a reference
                (val_sub, reg0, ":distance_to_enemy_troop"),
                (gt, reg0, 1500),	#division center too far from where it should be (probably because of
                #reinforcing troops)
                (position_copy_origin, pos1, Infantry_Pos),	#gather at average position
                (call_script, "script_battlegroup_dist_center_to_front", ":team_no", grc_infantry),
                (assign, ":distance_to_move", reg0),
                (store_mul, reg0, 350, formation_reform_interval),
                (val_add, ":distance_to_move", reg0),	#one interval movement
                (position_move_y, pos1, ":distance_to_move"),	#keep rear moving forward

              #attack leader if is closest troop
              (else_try),
                (eq, ":target_division", -1),
                (position_copy_origin, pos1, pos60),
                (call_script, "script_point_y_toward_position", Infantry_Pos, pos1),
                (position_copy_rotation, pos1, Infantry_Pos),

              #move no farther than nearest troop if its unit is far off
              (else_try),
                (call_script, "script_battlegroup_dist_center_to_front", ":team_no", grc_infantry),
                (val_add, ":distance_to_enemy_troop", reg0),	#distance to center of bg from nearest edge
                (store_sub, reg0, ":distance_to_enemy_group", ":distance_to_enemy_troop"),
                (gt, reg0, AI_charge_distance),
                (position_copy_origin, pos1, Infantry_Pos),
                (position_move_y, pos1, ":distance_to_enemy_troop"),

              #shift dead player troops right to clear allies when both attacking the
              #same enemy battlegroup
              (else_try),
                (eq, ":team_no", "$fplayer_team_no"),
                (store_add, ":ally_team", "$fplayer_team_no", 2),
                (neg | teams_are_enemies, ":ally_team", "$fplayer_team_no"),
                (store_add, ":slot", slot_team_d0_size, grc_infantry),
                (team_slot_ge, ":ally_team", ":slot", 1),
                (store_add, ":slot", slot_team_d0_target_team, grc_infantry),
                (team_get_slot, ":target_team", "$fplayer_team_no", ":slot"),
                (team_slot_eq, ":ally_team", ":slot", ":target_team"),
                (store_add, ":slot", slot_team_d0_target_division, grc_infantry),
                (team_slot_eq, ":ally_team", ":slot", ":target_division"),
                (call_script, "script_battlegroup_get_position", pos0, ":ally_team", grc_infantry),
                (get_distance_between_positions, ":distance_to_ally", Infantry_Pos, pos0),
                (lt, ":distance_to_ally", ":distance_to_enemy_group"),	#shift only when not in melee to avoid rotation
                (call_script, "script_battlegroup_get_action_radius", ":ally_team", grc_infantry),	#move larger group less to maintain center
                (val_div, reg0, 2),	#function returns length of bg
                (position_move_x, pos1, reg0),

              #shift allies left to clear dead player troops when both attacking the
              #same enemy battlegroup
              (else_try),
                (main_hero_fallen),
                (eq, AI_Replace_Dead_Player, 1),
                (neq, ":team_no", "$fplayer_team_no"),
                (neg | teams_are_enemies, ":team_no", "$fplayer_team_no"),
                (store_add, ":slot", slot_team_d0_size, grc_infantry),
                (team_slot_ge, "$fplayer_team_no", ":slot", 1),
                (store_add, ":slot", slot_team_d0_target_team, grc_infantry),
                (team_get_slot, ":target_team", "$fplayer_team_no", ":slot"),
                (team_slot_eq, ":team_no", ":slot", ":target_team"),
                (store_add, ":slot", slot_team_d0_target_division, grc_infantry),
                (team_slot_eq, "$fplayer_team_no", ":slot", ":target_division"),
                (call_script, "script_battlegroup_get_position", pos0, "$fplayer_team_no", grc_infantry),
                (get_distance_between_positions, ":distance_to_ally", Infantry_Pos, pos0),
                (lt, ":distance_to_ally", ":distance_to_enemy_group"),	#shift only when not in melee to avoid rotation
                (call_script, "script_battlegroup_get_action_radius", "$fplayer_team_no", grc_infantry),	#move larger group less to maintain center
                (val_div, reg0, -2),	#function returns length of bg
                (position_move_x, pos1, reg0),
              (try_end),
            (try_end),	#obtain destination

            (call_script, "script_set_formation_destination", ":team_no", grc_infantry, pos1),

            (try_begin),
              (store_add, ":slot", slot_team_d0_formation, grc_infantry),
              (neg | team_slot_eq, ":team_no", ":slot", formation_none),
              (team_slot_ge, ":team_no", ":slot", formation_none),
              (call_script, "script_get_centering_amount", ":infantry_formation", ":num_infantry", ":spacing"),
              (position_move_x, pos1, reg0),
              (call_script, "script_form_infantry", ":team_no", grc_infantry, ":team_leader", ":spacing", 0, ":infantry_formation"),
            (try_end),
          (try_end),	#attempt to make formation somewhere
        (try_end),

        #cavalry AI
        (try_begin),
          (gt, ":num_cavalry", 0),

          #get distance to nearest enemy battlegroup(s)
          (store_add, ":slot", slot_team_d0_armor, grc_cavalry),
          (team_get_slot, ":average_armor", ":team_no", ":slot"),
          (assign, ":nearest_threat_distance", Far_Away),
          (assign, ":nearest_target_distance", Far_Away),
          (assign, ":num_targets", 0),
          (try_for_range, ":enemy_team_no", 0, 4),
            (team_slot_ge, ":enemy_team_no", slot_team_size, 1),
            (teams_are_enemies, ":enemy_team_no", ":team_no"),
            (try_for_range, ":enemy_division", 0, 9),
              (store_add, ":slot", slot_team_d0_size, ":enemy_division"),
              (team_get_slot, ":size_enemy_battle_group", ":enemy_team_no", ":slot"),
              (gt, ":size_enemy_battle_group", 0),
              (call_script, "script_battlegroup_get_position", pos0, ":enemy_team_no", ":enemy_division"),
              (get_distance_between_positions, ":distance_of_enemy", Cavalry_Pos, pos0),
              (try_begin),	#threat or target?
                (store_add, ":slot", slot_team_d0_weapon_length, ":enemy_division"),
                (team_get_slot, reg0, ":enemy_team_no", ":slot"),
                (assign, ":decision_index", reg0),
                (store_add, ":slot", slot_team_d0_armor, ":enemy_division"),
                (team_get_slot, reg0, ":enemy_team_no", ":slot"),
                (val_mul, ":decision_index", reg0),
                (val_mul, ":decision_index", ":size_enemy_battle_group"),
                (val_div, ":decision_index", ":average_armor"),
                (val_div, ":decision_index", ":num_cavalry"),
                (try_begin),
                  (neq, ":enemy_division", grc_cavalry),
                  (val_div, ":decision_index", 2),	#double count cavalry vs.  foot soldiers
                (try_end),
                (gt, ":decision_index", 100),
                (try_begin),
                  (gt, ":nearest_threat_distance", ":distance_of_enemy"),
                  (copy_position, Nearest_Threat_Pos, pos0),
                  (assign, ":nearest_threat_distance", ":distance_of_enemy"),
                (try_end),
              (else_try),
                (val_add, ":num_targets", 1),
                (gt, ":nearest_target_distance", ":distance_of_enemy"),
                (copy_position, Nearest_Target_Pos, pos0),
                (assign, ":nearest_target_distance", ":distance_of_enemy"),
                (store_add, ":slot", slot_team_d0_target_team, grc_cavalry),
                (team_set_slot, ":team_no", ":slot", ":enemy_team_no"),
                (store_add, ":slot", slot_team_d0_target_division, grc_cavalry),
                (team_set_slot, ":team_no", ":slot", ":enemy_division"),
              (try_end),
            (try_end),
          (try_end),
          (try_begin),
            (eq, ":nearest_threat_distance", Far_Away),
            (assign, ":nearest_target_guarded", 0),
          (else_try),
            (eq, ":nearest_target_distance", Far_Away),
            (assign, ":nearest_target_guarded", 1),
          (else_try),
            (get_distance_between_positions, reg0, Nearest_Target_Pos, Nearest_Threat_Pos),
            (store_div, reg1, AI_charge_distance, 2),
            (try_begin),	#ignore target too close to threat
              (le, reg0, reg1),
              (assign, ":nearest_target_guarded", 1),
            (else_try),
              (assign, ":nearest_target_guarded", 0),
            (try_end),
          (try_end),

          (assign, ":cavalry_order", mordr_charge), ##CABA HERE
          (try_begin),
            (teams_are_enemies, ":team_no", 0),
            (neg | team_slot_ge, 1, slot_team_reinforcement_stage, AI_Max_Reinforcements),
            (neg | team_slot_eq, 1, slot_team_reinforcement_stage, "$attacker_reinforcement_stage"),
            (assign, ":cavalry_order", mordr_hold),
          (else_try),
            (teams_are_enemies, ":team_no", 1),
            (neg | team_slot_ge, 0, slot_team_reinforcement_stage, AI_Max_Reinforcements),
            (neg | team_slot_eq, 0, slot_team_reinforcement_stage, "$defender_reinforcement_stage"),
            (assign, ":cavalry_order", mordr_hold),
          (else_try),
            (neq, ":infantry_order", mordr_charge),
            (try_begin),
              (le, "$battle_phase", BP_Jockey),
              (assign, ":cavalry_order", mordr_hold),
            (else_try),
              (eq, ":nearest_target_distance", Far_Away),
              (try_begin),
                (eq, ":num_archers", 0),
                (assign, ":distance_to_archers", 0),
              (else_try),
                (get_distance_between_positions, ":distance_to_archers", Cavalry_Pos, Archers_Pos),
              (try_end),
              (try_begin),
                (this_or_next | gt, ":enemy_agent_nearest_cavalry_dist", AI_charge_distance),
                (gt, ":distance_to_archers", AI_charge_distance),
                (assign, ":cavalry_order", mordr_hold),
              (try_end),
            (try_end),
          (try_end),

          (try_begin),
            (eq, ":team_no", 0),
            (assign, ":cav_destination", Team0_Cavalry_Destination),
          (else_try),
            (eq, ":team_no", 1),
            (assign, ":cav_destination", Team1_Cavalry_Destination),
          (else_try),
            (eq, ":team_no", 2),
            (assign, ":cav_destination", Team2_Cavalry_Destination),
          (else_try),
            (eq, ":team_no", 3),
            (assign, ":cav_destination", Team3_Cavalry_Destination),
          (try_end),
          (store_add, ":slot", slot_team_d0_percent_ranged, grc_cavalry),
          (team_get_slot, reg0, ":team_no", ":slot"),

          #horse archers don't use wedge
          (try_begin),
            (ge, reg0, 50),
            (call_script, "script_formation_end", ":team_no", grc_cavalry),
            (try_begin),
              (eq, ":num_archers", 0),
              (team_get_movement_order, reg0, ":team_no", grc_cavalry),
              (try_begin),
                (neq, reg0, mordr_charge),
                (team_give_order, ":team_no", grc_cavalry, mordr_charge),
              (try_end),
            (else_try),
              (team_get_movement_order, reg0, ":team_no", grc_cavalry),
              (try_begin),
                (neq, reg0, ":cavalry_order"),
                (team_give_order, ":team_no", grc_cavalry, ":cavalry_order"),
              (try_end),
              (copy_position, ":cav_destination", Archers_Pos),
              (position_move_y, ":cav_destination", -500, 0),
              (call_script, "script_set_formation_destination", ":team_no", grc_cavalry, ":cav_destination"),
            (try_end),

          #close in with no unguarded target farther off, free fight
          (else_try),
            (eq, ":cavalry_order", mordr_charge),
            (this_or_next | eq, ":num_archers", 0),
            (le, ":enemy_agent_nearest_cavalry_dist", AI_charge_distance),
            (try_begin),
              (eq, ":num_targets", 1),
              (eq, ":nearest_target_guarded", 0),
              (gt, ":nearest_target_distance", ":nearest_threat_distance"),
              (assign, reg0, 0),
            (else_try),
              (ge, ":num_targets", 2),
              (eq, ":nearest_target_guarded", 1),
              (assign, reg0, 0),
            (else_try),
              (assign, reg0, 1),
            (try_end),
            (eq, reg0, 1),
            (call_script, "script_formation_end", ":team_no", grc_cavalry),
            (team_get_movement_order, reg0, ":team_no", grc_cavalry),
            (try_begin),
              (neq, reg0, mordr_charge),
              (team_give_order, ":team_no", grc_cavalry, mordr_charge),
            (try_end),

          #grand charge if target closer than threat AND not guarded
          (else_try),
            (lt, ":nearest_target_distance", ":nearest_threat_distance"),
            (eq, ":nearest_target_guarded", 0),
            (call_script, "script_formation_end", ":team_no", grc_cavalry),
            (team_get_movement_order, reg0, ":team_no", grc_cavalry),
            (try_begin),
              (neq, reg0, mordr_hold),
              (team_give_order, ":team_no", grc_cavalry, mordr_hold),
            (try_end),

            #lead archers up to firing point
            (try_begin),
              (gt, ":nearest_target_distance", AI_firing_distance),
              (eq, ":cavalry_order", mordr_hold),
              (try_begin),
                (eq, ":num_archers", 0),
                (copy_position, ":cav_destination", Cavalry_Pos),	#must be reinforcements, so gather at average position
              (else_try),
                (copy_position, ":cav_destination", Archers_Pos),
                (position_move_y, ":cav_destination", AI_charge_distance, 0),
              (try_end),

            #then CHARRRRGE!
            (else_try),
              (copy_position, ":cav_destination", Cavalry_Pos),
              (call_script, "script_point_y_toward_position", ":cav_destination", Nearest_Target_Pos),
              (position_move_y, ":cav_destination", ":nearest_target_distance", 0),
            (try_end),
            (call_script, "script_set_formation_destination", ":team_no", grc_cavalry, ":cav_destination"),

          #make a wedge somewhere
          (else_try),
            (try_begin),
              (eq, ":cavalry_order", mordr_charge),
              (neq, ":nearest_target_distance", Far_Away),
              (copy_position, ":cav_destination", Cavalry_Pos),
              (call_script, "script_point_y_toward_position", ":cav_destination", Nearest_Target_Pos),
              (position_move_y, ":cav_destination", ":nearest_target_distance", 0),
              (position_move_y, ":cav_destination", AI_charge_distance, 0),	#charge on through to the other side
            (else_try),
              (neq, ":cavalry_order", mordr_charge),
              (eq, ":num_archers", 0),
              (copy_position, ":cav_destination", Cavalry_Pos),	#must be reinforcements, so gather at average position
            (else_try),
              (copy_position, ":cav_destination", Archers_Pos),	#hold near archers
              (position_move_x, ":cav_destination", 500, 0),
              (position_move_y, ":cav_destination", -1000, 0),
            (try_end),

            #move around threat in the way to destination
            (try_begin),
              (neq, ":nearest_threat_distance", Far_Away),
              (call_script, "script_point_y_toward_position", Cavalry_Pos, Nearest_Threat_Pos),
              (call_script, "script_point_y_toward_position", Nearest_Threat_Pos, ":cav_destination"),
              (position_get_rotation_around_z, reg0, Cavalry_Pos),
              (position_get_rotation_around_z, reg1, Nearest_Threat_Pos),
              (store_sub, ":rotation_diff", reg0, reg1),
              (try_begin),
                (lt, ":rotation_diff", -180),
                (val_add, ":rotation_diff", 360),
              (else_try),
                (gt, ":rotation_diff", 180),
                (val_sub, ":rotation_diff", 360),
              (try_end),

              (try_begin),
                (is_between, ":rotation_diff", -135, 136),
                (copy_position, ":cav_destination", Cavalry_Pos),
                (assign, ":distance_to_move", AI_firing_distance),
                (try_begin),	#target is left of threat
                  (is_between, ":rotation_diff", -135, 0),
                  (val_mul, ":distance_to_move", -1),
                (try_end),
                (position_move_x, ":cav_destination", ":distance_to_move", 0),
                (store_sub, ":distance_to_move", ":nearest_threat_distance", AI_firing_distance),
                (position_move_y, ":cav_destination", ":distance_to_move", 0),
                (call_script, "script_point_y_toward_position", ":cav_destination", Cavalry_Pos),
                (position_rotate_z, ":cav_destination", 180),
              (try_end),
            (try_end),
            (get_scene_boundaries, pos0, pos1),
            (position_get_x, reg0, ":cav_destination"),
            (position_get_x, reg1, pos0),
            (val_max, reg0, reg1),
            (position_get_x, reg1, pos1),
            (val_min, reg0, reg1),
            (position_set_x, ":cav_destination", reg0),
            (position_get_y, reg0, ":cav_destination"),
            (position_get_y, reg1, pos0),
            (val_max, reg0, reg1),
            (position_get_y, reg1, pos1),
            (val_min, reg0, reg1),
            (position_set_y, ":cav_destination", reg0),
            (position_set_z_to_ground_level, ":cav_destination"),

            (try_begin),
              (call_script, "script_cf_battlegroup_valid_formation", ":team_no", grc_cavalry, formation_wedge),
              (copy_position, pos1, ":cav_destination"),
              (call_script, "script_form_cavalry", ":team_no", grc_cavalry, ":team_leader", 0, 0),
              (store_add, ":slot", slot_team_d0_formation, grc_cavalry),
              (team_set_slot, ":team_no", ":slot", formation_wedge),
              # (team_give_order, ":team_no", grc_cavalry, mordr_hold),
            (else_try),
              (call_script, "script_formation_end", ":team_no", grc_cavalry),
              (team_get_movement_order, reg0, ":team_no", grc_cavalry),
              (try_begin),
                (neq, reg0, ":cavalry_order"),
                (team_give_order, ":team_no", grc_cavalry, ":cavalry_order"),
              (try_end),
            (try_end),
            (call_script, "script_set_formation_destination", ":team_no", grc_cavalry, ":cav_destination"),
          (try_end),
        (try_end),

        #place leader
        (try_begin),
          (ge, ":team_leader", 0),
          (agent_is_alive, ":team_leader"),
          (agent_slot_eq, ":team_leader", slot_agent_is_running_away, 0),
          (try_begin),
            (le, ":num_infantry", 0),
            (try_begin),
              (this_or_next | le, ":num_archers", 0),
              (eq, ":archer_order", mordr_retreat),

              (assign, ":more_reinforcements", 1),
              (try_begin),
                (teams_are_enemies, ":team_no", 0),
                (team_slot_ge, 1, slot_team_reinforcement_stage, AI_Max_Reinforcements),
                (assign, ":more_reinforcements", 0),
              (else_try),
                (teams_are_enemies, ":team_no", 1),
                (team_slot_ge, 0, slot_team_reinforcement_stage, AI_Max_Reinforcements),
                (assign, ":more_reinforcements", 0),
              (try_end),
              (eq, ":more_reinforcements", 0),

              (agent_get_troop_id, ":troop_id", ":team_leader"), #for now do not let heroes to run away from battle
              (neg|troop_is_hero, ":troop_id"),
              (agent_clear_scripted_mode, ":team_leader"),
              (agent_start_running_away, ":team_leader"),
              (agent_set_slot, ":team_leader",  slot_agent_is_running_away, 1),
            (else_try),
              (eq, ":archer_order", mordr_charge),
              (agent_clear_scripted_mode, ":team_leader"),
            (else_try),
              (copy_position, pos1, Archers_Pos),
              (position_move_y, pos1, -1000, 0),
              (agent_set_scripted_destination, ":team_leader", pos1, 1),
            (try_end),
          (else_try),
            (neq, ":place_leader_by_infantry", 0),
            (call_script, "script_battlegroup_get_position", pos1, ":team_no", grc_infantry),
            (team_get_order_position, pos0, ":team_no", grc_infantry),
            (call_script, "script_point_y_toward_position", pos1, pos0),
            (call_script, "script_battlegroup_get_action_radius", ":team_no", grc_infantry),
            (val_div, reg0, 2),	#bring to edge of battlegroup
            (position_move_x, pos1, reg0, 0),
            (position_move_x, pos1, 100, 0),
            (agent_set_scripted_destination, ":team_leader", pos1, 1),
          (else_try),
            (agent_clear_scripted_mode, ":team_leader"),
          (try_end),
        (try_end),
      (try_end),

  ]),

  # script_field_tactics by motomataru
  # Input: flag 1 to include ranged
  # Output: none
  ("field_tactics", [
      (store_script_param, ":include_ranged", 1),

      (assign, ":largest_team_size", 0),
      (assign, ":battle_size", 0),
      (try_for_range, ":ai_team", 0, 4),
        (team_get_slot, ":team_size", ":ai_team", slot_team_size),
        (gt, ":team_size", 0),
        (team_get_slot, ":team_cav_size", ":ai_team", slot_team_num_cavalry),
        (store_add, ":team_adj_size", ":team_size", ":team_cav_size"),	#double count cavalry to capture effect on battlefield
        (val_add, ":battle_size", ":team_adj_size"),

        (try_begin),
          (neq, ":ai_team", "$fplayer_team_no"),
          (neg | teams_are_enemies, ":ai_team", "$fplayer_team_no"),
          (team_get_slot, ":player_team_adj_size", "$fplayer_team_no", slot_team_adj_size),
          (val_add, ":team_adj_size", ":player_team_adj_size"),	#ally team takes player team into account
          (team_set_slot, "$fplayer_team_no", slot_team_adj_size, ":team_adj_size"),	#and vice versa
        (try_end),
        (team_set_slot, ":ai_team", slot_team_adj_size, ":team_adj_size"),

        (lt, ":largest_team_size", ":team_adj_size"),
        (assign, ":largest_team_size", ":team_adj_size"),
      (try_end),

      #apply tactics to every AI team
      (set_show_messages, 0),
      (try_for_range, ":ai_team", 0, 4),
        (team_get_slot, ":ai_team_size", ":ai_team", slot_team_adj_size),
        (gt, ":ai_team_size", 0),

        (assign, ":do_it", 0),
        (try_begin),
          (neq, ":ai_team", "$fplayer_team_no"),
          (assign, ":do_it", 1),
        (else_try),
          (main_hero_fallen),    #have AI take over for mods with post-player battle action
          (eq, AI_Replace_Dead_Player, 1),
          (assign, ":do_it", 1),
        (try_end),
        (eq, ":do_it", 1),

        (team_get_slot, ":ai_faction", ":ai_team", slot_team_faction),
        (try_begin),
          (neq, AI_for_kingdoms_only, 0),
          (neq, ":ai_faction", fac_deserters),	#deserters have military training
          (neq, ":ai_faction", fac_black_khergits),
          (neq, ":ai_faction", fac_dark_knights),
          #(neq, ":ai_faction", fac_mountain_bandits),	#scoti, frank and dena pirates have military training Chief anade
          (neg | is_between, ":ai_faction", kingdoms_begin, kingdoms_end),

          (call_script, "script_formation_end", ":ai_team", grc_everyone),
          (team_get_movement_order, reg0, ":ai_team", grc_everyone),
          (try_begin),
            (neq, reg0, mordr_charge),
            (team_give_order, ":ai_team", grc_everyone, mordr_charge),
          (try_end),

        #uses tactics
        (else_try),
          (val_mul, ":ai_team_size", 100),
          (store_div, ":team_percentage", ":ai_team_size", ":largest_team_size"),
          (store_div, ":team_battle_presence", ":ai_team_size", ":battle_size"),
          (try_begin),
            (eq, ":include_ranged", 1),
            (try_begin),
              (store_mod, ":team_phase", ":ai_team", 2),
              (eq, ":team_phase", 0),
              (assign, ":time_slice", 0),
            (else_try),
              (store_div, ":time_slice", Reform_Trigger_Modulus, 2),
            (try_end),

            (store_mod, reg0, "$ranged_clock", Reform_Trigger_Modulus),
            (this_or_next | eq, reg0, ":time_slice"),
            (eq, "$battle_phase", BP_Setup),
            (call_script, "script_team_field_ranged_tactics", ":ai_team", ":team_percentage", ":team_battle_presence"),
          (try_end),

          (try_begin),
            (gt, "$fplayer_team_no", 0),	#not a spectator
            (neg | main_hero_fallen),
            (store_add, ":slot", slot_team_d0_target_team, grc_infantry),
            (team_slot_eq, ":ai_team", ":slot", "$fplayer_team_no"),
            (store_add, ":slot", slot_team_d0_target_division, grc_infantry),
            (team_get_slot, ":enemy_division", ":ai_team", ":slot"),
            (store_add, ":slot", slot_team_d0_size, ":enemy_division"),
            (team_slot_ge, "$fplayer_team_no", ":slot", 1),
            (store_add, ":slot", slot_team_d0_fclock, ":enemy_division"),
            (team_get_slot, ":fclock", "$fplayer_team_no", ":slot"),
            (store_mod, reg0, ":fclock", Reform_Trigger_Modulus),
            (store_div, ":time_slice", Reform_Trigger_Modulus, 2),
          (else_try),
            (store_mod, reg0, "$ranged_clock", Reform_Trigger_Modulus),
            (store_mod, ":team_phase", ":ai_team", 2),
            (eq, ":team_phase", 0),
            (assign, ":time_slice", 0),
          (else_try),
            (store_div, ":time_slice", Reform_Trigger_Modulus, 2),
          (try_end),

          (eq, reg0, ":time_slice"),
          (call_script, "script_team_field_melee_tactics", ":ai_team", ":team_percentage", ":team_battle_presence"),
        (try_end),
      (try_end),
      (set_show_messages, 1),]),


  # # Utilities used by AI by motomataru

  # script_find_high_ground_around_pos1_corrected by motomataru
  # Input: arg1: destination position
  #			arg2: search_radius (in meters)
  #			pos1 should hold center_position_no
  # Output: destination contains highest ground within a <search_radius> meter
  # square around pos1
  # Also uses position registers: pos0
  ("find_high_ground_around_pos1_corrected", [
      (store_script_param, ":destination_pos", 1),
      (store_script_param, ":search_radius", 2),
      (assign, ":fixed_point_multiplier", 1),
      (convert_to_fixed_point, ":fixed_point_multiplier"),
      (set_fixed_point_multiplier, 1),

      (position_get_x, ":o_x", pos1),
      (position_get_y, ":o_y", pos1),
      (store_sub, ":min_x", ":o_x", ":search_radius"),
      (store_sub, ":min_y", ":o_y", ":search_radius"),
      (store_add, ":max_x", ":o_x", ":search_radius"),
      (store_add, ":max_y", ":o_y", ":search_radius"),

      (get_scene_boundaries, ":destination_pos", pos0),
      (position_get_x, ":scene_min_x", ":destination_pos"),
      (position_get_x, ":scene_max_x", pos0),
      (position_get_y, ":scene_min_y", ":destination_pos"),
      (position_get_y, ":scene_max_y", pos0),
      (val_max, ":min_x", ":scene_min_x"),
      (val_max, ":min_y", ":scene_min_y"),
      (val_min, ":max_x", ":scene_max_x"),
      (val_min, ":max_y", ":scene_max_y"),

      (assign, ":highest_pos_z", -100),
      (copy_position, ":destination_pos", pos1),
      (init_position, pos0),

      (try_for_range, ":i_x", ":min_x", ":max_x"),
        (try_for_range, ":i_y", ":min_y", ":max_y"),
          (position_set_x, pos0, ":i_x"),
          (position_set_y, pos0, ":i_y"),
          (position_set_z_to_ground_level, pos0),
          (position_get_z, ":cur_pos_z", pos0),
          (try_begin),
            (gt, ":cur_pos_z", ":highest_pos_z"),
            (copy_position, ":destination_pos", pos0),
            (assign, ":highest_pos_z", ":cur_pos_z"),
          (try_end),
        (try_end),
      (try_end),

      (set_fixed_point_multiplier, ":fixed_point_multiplier"),]),


  # script_cf_count_casualties by motomataru
  # Input: none
  # Output: evalates T/F, reg0 num casualties
  ("cf_count_casualties", [
      (assign, ":num_casualties", 0),
      (try_for_agents,":cur_agent"),
        (try_begin),
          (this_or_next | agent_is_wounded, ":cur_agent"),
          (this_or_next | agent_slot_eq, ":cur_agent", slot_agent_is_running_away, 1),
          (neg | agent_is_alive, ":cur_agent"),
          (val_add, ":num_casualties", 1),
        (try_end),
      (try_end),
      (assign, reg0, ":num_casualties"),
      (gt, ":num_casualties", 0)]),


  # script_cf_any_fighting by motomataru
  # Input: none
  # Output: evalates T/F
  ("cf_any_fighting", [
      (assign, ":any_fighting", 0),
      (try_for_range, ":team", 0, 4),
        (team_slot_ge, ":team", slot_team_size, 1),
        (eq, ":any_fighting", 0),
        (assign, ":num_divs", 9),
        (try_for_range, ":division", 0, ":num_divs"),
          (store_add, ":slot", slot_team_d0_is_fighting, ":division"),
          (team_slot_ge, ":team", ":slot", 1),
          (assign, ":any_fighting", 1),
          (assign, ":num_divs", 0),
        (try_end),
      (try_end),

      #lag this check to be sure
      (store_mission_timer_c, ":time_stamp"),
      (try_begin),	#time lag
        (gt, ":any_fighting", 0),
        (assign, "$teams_last_fighting", ":time_stamp"),
      (try_end),
      (assign, ":fighting_finished", formation_reform_interval),
      (val_max, ":fighting_finished", 5),
      (val_add, ":fighting_finished", "$teams_last_fighting"),
      (gt, ":fighting_finished", ":time_stamp"),]),


  # script_get_nearest_enemy_battlegroup_location by motomataru
  # Input: destination position, fron team, from position
  # Output: destination position, reg0 with distance
  # Run script_store_battlegroup_data before calling!
  ("get_nearest_enemy_battlegroup_location", [
      (store_script_param, ":bgposition", 1),
      (store_script_param, ":team_no", 2),
      (store_script_param, ":from_pos", 3),
      (assign, ":distance_to_nearest_enemy_battlegoup", Far_Away),
      (try_for_range, ":enemy_team_no", 0, 4),
        (team_slot_ge, ":enemy_team_no", slot_team_size, 1),
        (teams_are_enemies, ":enemy_team_no", ":team_no"),
        (try_for_range, ":enemy_division", 0, 9),
          (store_add, ":slot", slot_team_d0_size, ":enemy_division"),
          (team_slot_ge, ":enemy_team_no", ":slot", 1),
          (call_script, "script_battlegroup_get_position", pos0, ":enemy_team_no", ":enemy_division"),
          (get_distance_between_positions, reg0, pos0, ":from_pos"),
          (try_begin),
            (gt, ":distance_to_nearest_enemy_battlegoup", reg0),
            (assign, ":distance_to_nearest_enemy_battlegoup", reg0),
            (copy_position, ":bgposition", pos0),
          (try_end),
        (try_end),
      (try_end),
      (assign, reg0, ":distance_to_nearest_enemy_battlegoup")]),
  # #AI end



	("find_nearest_enemy_position",
		[
			(store_script_param, ":agent", 1),
			(store_script_param, ":agent_team", 2),
			(store_script_param, ":threshold", 3), #if under threshold then stop searching
			(assign, ":nearest_dist", 100000),
			(assign, ":nearest_agent", -1),
			(agent_get_position, pos1, ":agent"),
			(try_for_agents, ":agent2"),
				(gt, ":nearest_dist", ":threshold"),
				(agent_is_alive, ":agent2"),
				(agent_is_active, ":agent2"),
				(agent_is_human, ":agent2"),
				(agent_get_team, ":agent2_team", ":agent2"),
				(teams_are_enemies, ":agent2_team", ":agent_team"),
				(agent_get_position, pos2, ":agent2"),
				(get_distance_between_positions, ":enemy_dist", pos2, pos1),
				(lt, ":enemy_dist", ":nearest_dist"),
				(assign, ":nearest_agent", ":agent2"),
				(assign, ":nearest_dist", ":enemy_dist"),
			(try_end),
			(assign, reg1, ":nearest_dist"),
			(assign, reg4, ":nearest_agent")
		]),

	("horse_archer_skirmish",
		[
			(store_script_param, ":agent", 1), #agent
			(store_script_param, ":enemy_agent", 2), #enemy agent
			(store_script_param, ":enemy_dist", 3), #distance from enemy
			(store_script_param, ":min_dist", 4), #min distance (inner radius)
			(store_script_param, ":max_dist", 5), #max distance (outer radius)
			(store_script_param, ":script_param_6", 6), #new position adder
			(try_begin),
				(assign, ":min_dist_from_enemy", ":min_dist"),
				(gt, ":enemy_agent", 0),
				(agent_get_position, pos0, ":agent"),
				(agent_get_position, pos1, ":enemy_agent"),
				# (agent_get_slot, ":skirmish_direction", ":agent", 106), #1/2 agents go clockwise
				(agent_get_slot, ":dist_to_add", ":agent", slot_agent_make_dist_with_enemy),
				# (try_begin),
					# (eq, ":skirmish_direction", 0),
					# (store_random_in_range, ":skirmish_direction", 1, 3),
					# (agent_set_slot, ":agent", 106, ":skirmish_direction"),
				# (try_end),
				(try_begin),
					(le, ":enemy_dist", ":max_dist"),
					(val_add, ":dist_to_add", ":script_param_6"),
					(try_begin),
						(ge, ":dist_to_add", 360),
						(assign, ":dist_to_add", 0),
					(try_end),
					(agent_set_slot, ":agent", slot_agent_make_dist_with_enemy, ":dist_to_add"),
					# (try_begin),
						# (eq, ":skirmish_direction", 1),
						# (val_mul, ":dist_to_add", -1),
						# (val_sub, ":min_dist_from_enemy", 1500), #clockwise agents stay closer to enemy
					# (try_end),
					(position_get_rotation_around_z, reg1, 1),
					(store_sub, reg0, 360, reg1),
					(val_add, ":dist_to_add", reg0),
					(position_rotate_z, pos1, ":dist_to_add"),
					(position_move_x, pos1, ":min_dist_from_enemy", 0),
					(agent_set_scripted_destination, ":agent", pos1, 1), #no rethink?
					(agent_set_slot, ":agent", slot_agent_is_skirmishing, 1),
				(else_try),
					(agent_clear_scripted_mode, ":agent"),
					(agent_set_slot, ":agent", slot_agent_is_skirmishing, 0),
				(try_end),
			(try_end)
		]),


	("assign_seneschals",
		[
          #seneschals - dckplmc
          (try_for_range, ":center_no", walled_centers_begin, walled_centers_end),
            (store_sub, ":offset", ":center_no", walled_centers_begin),
            (store_add, ":cur_object_no", "trp_town_1_seneschal", ":offset"),
            (troop_set_slot, ":cur_object_no", slot_troop_occupation, slto_kingdom_seneschal),
            (party_set_slot,":center_no", slot_town_seneschal, ":cur_object_no"),
          (try_end),
		]),


  # script_get_random_tournament_participant
  # Input: none
  # Output: reg0 = troop_no
  ("get_random_tournament_prize",
    [(store_script_param, ":party_no", 1),
     (party_get_slot, ":cur_faction", ":party_no", slot_center_original_faction),
     (assign, ":cur_merchant", "trp_salt_mine_merchant"),

     (troop_clear_inventory, ":cur_merchant"),
     (store_random_in_range, ":r", 0, 4),

     (try_begin),
         (eq, ":r", 0),
         (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_body_armor, 8),
     (else_try),
         (eq, ":r", 1),
         (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_head_armor, 12),
     (else_try),
         (eq, ":r", 2),
          (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_one_handed_wpn, 5),
          (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_two_handed_wpn, 5),
          (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_polearm, 5),
          (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_shield, 6),
          (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_bow, 4),
          (troop_add_merchandise_with_faction, ":cur_merchant", ":cur_faction", itp_type_crossbow, 3),
     (else_try),
         (eq, ":r", 3),
         (troop_add_merchandise_with_faction,":cur_merchant", ":cur_faction",itp_type_horse,5),
     (try_end),
     (troop_sort_inventory, ":cur_merchant"),
     (troop_get_inventory_capacity, ":inv_cap", ":cur_merchant"),
     (try_for_range, ":i_slot", ek_food + 2, ":inv_cap"),
        (troop_set_inventory_slot,":cur_merchant",":i_slot",-1),
     (try_end),

     ]),
### MMC gambler ###
### Three Cards ### Dice game ###
# "script_mmc_gamblers_header"
# Description: create presentation header for mmc gamblers
# Input1:
# Output: none
 ("mmc_gamblers_header",
   [	(assign,"$g_presentation_obj_1",-1), # mesh king of spades
        (assign,"$g_presentation_obj_2",-1), # mesh queen of heart
        (assign,"$g_presentation_obj_3",-1), # mesh king of clubs
        (assign,"$g_presentation_obj_4",-1), # text "@Bet: {reg51}Denar"
        (assign,"$g_presentation_obj_5",-1), # text "@Money: {reg1}Denar"
        (assign,"$g_presentation_obj_6",-1), # "mesh_text_bar"
        (assign,"$g_presentation_obj_7",-1), # slider
        (assign,"$g_presentation_obj_8",-1), # text "@Bet: {reg51}Denar" above slider
        (assign,"$g_presentation_obj_9",-1), # win or lose window
        (assign,"$g_presentation_obj_10",-1),#done button
        (assign,"$g_presentation_obj_11",-1),#find the lady
        (assign,"$g_presentation_obj_12",-1),#yes
        (assign,"$g_presentation_obj_13",-1),#no
        (assign,"$g_presentation_obj_14",-1),#start game button
        (assign,"$g_presentation_obj_15",-1),
        (assign,"$g_presentation_obj_16",-1),
        (assign,"$g_presentation_obj_17",-1),
		(assign, reg1,0),
		(assign, reg2,0),
		(assign, reg3,0),
		(assign, reg4,0),
		(assign, reg5,0),
        (assign, reg50, 0),
        (assign, reg51, 1),
        (assign, reg52, 0),
        (assign, reg53, 0),#
        (assign, reg55, 1),
        (assign, reg58, 0),
		(str_clear,s1),
        (create_mesh_overlay, reg1, "mesh_3card_table"),#mesh_wood_table
        (position_set_x, pos1, 0),
        (position_set_y, pos1, 0),
        (overlay_set_position, reg1, pos1),

        (str_store_troop_name, s1, "$g_talk_troop"),# NPC
        (create_text_overlay, reg1, "@{s1}", tf_center_justify),
        (position_set_x, pos1, 120),#820
        (position_set_y, pos1, 470),#470
        (overlay_set_position, reg1, pos1),#
        (overlay_set_color, reg1, 0xffffff),
        (str_store_troop_name, s1, "trp_player"),#
        (create_text_overlay, reg1, "@{s1}", tf_center_justify),
        (position_set_x, pos1, 815),#120
        (position_set_y, pos1, 8),#8
        (overlay_set_position, reg1, pos1),#
        (overlay_set_color, reg1, 0xffffff),
#"mesh_jack_black_portrait"
        (create_mesh_overlay_with_tableau_material, reg1, -1, "tableau_troop_note_mesh", "$g_talk_troop"),#-1
        (position_set_x, pos1, 750),
        (position_set_y, pos1, 750),
        (overlay_set_size, reg1, pos1),
        (position_set_x, pos1, 7),#700
        (position_set_y, pos1, 500),#500
        (overlay_set_position, reg1, pos1),
#"mesh_trp_player_portrait"
        (create_mesh_overlay_with_tableau_material, reg1, -1, "tableau_troop_note_mesh", "trp_player"),
        (position_set_x, pos1, 750),
        (position_set_y, pos1, 750),
        (overlay_set_size, reg1, pos1),
        (position_set_x, pos1, 740),#7
        (position_set_y, pos1, 45),#20
        (overlay_set_position, reg1, pos1),
#info window right
        (create_mesh_overlay, reg1, "mesh_3card_window"),#3card_textbar#text_bar
        (position_set_x, pos1, 780),#700
        (position_set_y, pos1, 310),#270
        (overlay_set_position, reg1, pos1),
        (position_set_x, pos1, 250),#
        (position_set_y, pos1, 200),#
        (overlay_set_size, reg1, pos1),

        (str_store_string, s1, "@Bet: {reg51}Denar"),#
        (create_text_overlay, "$g_presentation_obj_4", s1),#
        (position_set_x, pos1, 790),#755
        (position_set_y, pos1, 355),#355
        (overlay_set_position, "$g_presentation_obj_4", pos1),
        (overlay_set_color, "$g_presentation_obj_4",),#0xfffccc
        (store_troop_gold,reg1,"trp_player"),#
        (create_text_overlay, "$g_presentation_obj_5", "@Money: {reg1}Denar"),
        (position_set_x, pos1, 790),#755
        (position_set_y, pos1, 325),#325
        (overlay_set_position, "$g_presentation_obj_5", pos1),
        (overlay_set_color, "$g_presentation_obj_5"),#0xfffccc
    ]
  ),

  # script_d6_roll # "script_d6_roll"
  # Input: arg1 = none
  # Output: reg0 = mesh
  # Output: reg1 = pip
  ("d6_roll",
   [(store_script_param, ":d6", 1),
    (try_begin),
        (try_begin),
		    (eq,":d6", 0),
		    (store_random_in_range,":d6",1,7),
		(try_end),
		(try_begin),
		    (eq,":d6",1),
		    (assign,reg0,"mesh_mmc_dice_1"),
        (else_try),
		    (eq,":d6",2),
		    (assign,reg0,"mesh_mmc_dice_2"),
        (else_try),
		    (eq,":d6",3),
		    (assign,reg0,"mesh_mmc_dice_3"),
		(else_try),
		    (eq,":d6",4),
		    (assign,reg0,"mesh_mmc_dice_4"),
    	(else_try),
		    (eq,":d6",5),
		    (assign,reg0,"mesh_mmc_dice_5"),
    	(else_try),
		    (eq,":d6",6),
		    (assign,reg0,"mesh_mmc_dice_6"),
    	(try_end),
	  (assign,reg1,":d6"),
	(try_end),
   ]),

# "script_draw_d6_side"
# Description: for prsnt_dices_game
# Input:
# Output: none
 ("draw_d6_side",
   [(store_script_param, ":line", 1),
    (store_script_param, ":column", 2),
    (store_script_param, ":side", 3),#1-6
    #(store_script_param, ":present_obj", 4),
    (assign,":dice_x",220),
    (try_begin),
	    (store_mul,":offset_x",":column",55),
	    (val_add,":dice_x",":offset_x"),
        (assign,":dice_y",380),
        (assign,":offset_y",70),
    (try_end),
    (try_begin),
        (gt,":side",6),
        (val_sub,":side",6),
    (try_end),
	(try_begin),
        (eq, ":line", 1),
            (try_begin),
                (gt,"$g_presentation_obj_1", 0),
			    (overlay_set_display, "$g_presentation_obj_1", 0),
			(try_end),
    (else_try),
        (eq, ":line", 2),
            (try_begin),
                (gt,"$g_presentation_obj_2", 0),
			    (overlay_set_display, "$g_presentation_obj_2", 0),
			(try_end),
		(val_add,":dice_x",25),
        (val_sub, ":dice_y", ":offset_y"),
    (else_try),
        (eq, ":line", 3),
            (try_begin),
                (gt,"$g_presentation_obj_3", 0),
			    (overlay_set_display, "$g_presentation_obj_3", 0),
			(try_end),
		(val_sub,":dice_x",25),
		(val_mul,":offset_y",2),
        (val_sub, ":dice_y", ":offset_y"),
 	(try_end),
	(try_begin),
        (call_script, "script_d6_roll",":side"),
			(try_begin),
                (eq, ":line", 1),
                (create_mesh_overlay, "$g_presentation_obj_1", reg0),
				(assign, ":present_obj", "$g_presentation_obj_1"),
			(else_try),
                (eq, ":line", 2),
				(create_mesh_overlay, "$g_presentation_obj_2", reg0),
				(assign, ":present_obj", "$g_presentation_obj_2"),
			(else_try),
                (eq, ":line", 3),
				(create_mesh_overlay, "$g_presentation_obj_3", reg0),
				(assign, ":present_obj", "$g_presentation_obj_3"),
			(try_end),
        (position_set_x, pos1, ":dice_x"),
        (position_set_y, pos1, ":dice_y"),#380
		(overlay_set_position, ":present_obj", pos1),
        (position_set_x, pos1, 500),
        (position_set_y, pos1, 633),
        (overlay_set_size, ":present_obj", pos1),
    (try_end),
 ]),

("simple_remove_disguise",
 [
	(try_begin),
		(gt, "$sneaked_into_town", disguise_none),
		(display_message, "@You retrieve your hidden items.", message_alert),
		(try_begin),
			(eq, "$g_dplmc_player_disguise", 1),
			(set_show_messages, 0),
		(try_for_range, ":i_slot", ek_item_0, ek_food + 1),
			(troop_get_inventory_slot, ":item", "trp_player", ":i_slot"),
			(neq, ":item", -1),
			(troop_get_inventory_slot_modifier, ":imod", "trp_player", ":i_slot"),
			(troop_add_item, "trp_random_town_sequence", ":item", ":imod"),
		(try_end),
			(call_script, "script_move_inventory_and_gold", "trp_player", "trp_random_town_sequence", 0),
			(call_script, "script_dplmc_copy_inventory", "trp_random_town_sequence", "trp_player"),
			(call_script, "script_troop_transfer_gold", "trp_random_town_sequence", "trp_player", 0),
			(set_show_messages, 1),
		(try_end),
		(assign, "$sneaked_into_town", disguise_none),
	(try_end),
]),

### MMC gambler end ###
### Dice game ### Three Cards ### END ###
   #COMBAT OSP BEGIN
#Shield Bash Script
("shield_bash",[
(this_or_next|multiplayer_is_server),
(neg|game_in_multiplayer_mode),
(get_player_agent_no,":player_agent"),
(store_skill_level,":shield_level", "skl_shield", "trp_player"),
(store_sub, ":player_shield_bash_time", 15, ":shield_level"),
(val_div,":player_shield_bash_time",3),
(store_mission_timer_a, ":current_time"),
(agent_get_slot, ":slot_last_shield_bash_time", ":player_agent", 27),
(store_add, ":time_to_shield_bash", ":player_shield_bash_time",":slot_last_shield_bash_time"),

(store_add, ":shieldstat", 1, ":shield_level"),
(store_mul, ":bash_radius", 13, ":shieldstat"),
(try_begin),
(ge, ":current_time", ":time_to_shield_bash"),
(try_begin),
(gt, ":player_agent", 0),
(agent_get_animation, ":anim", ":player_agent",0),
(agent_get_horse, ":my_horse", ":player_agent"),
(agent_get_wielded_item, ":shield_item", ":player_agent", 1),
(try_begin),
	(neq, ":anim", "anim_human_shield_bash"),
	(eq, ":my_horse", -1),
	(item_get_type, ":item_type", ":shield_item"),
	(eq, ":item_type", itp_type_shield),
	(agent_set_animation, ":player_agent","anim_human_shield_bash"),
	(agent_get_position, pos63,":player_agent"),
	(position_move_y,pos63,50),
	(agent_get_troop_id, ":id", ":player_agent"),
	(troop_get_type, ":type", ":id"),
	(try_begin),
		(eq, ":type", tf_male),
		(agent_play_sound, ":player_agent", "snd_man_grunt"), # Keep it down, this is a library.
		(agent_set_slot, ":player_agent", 27, ":current_time"),
	(else_try),
		(agent_play_sound, ":player_agent", "snd_woman_grunt"),	# Shhh...
        (agent_set_slot, ":player_agent", 27, ":current_time"),
	(try_end),
	(try_for_agents,":agent"),
		(gt, ":agent", 0),
		(neg|agent_is_ally,":agent"),#don't bash allies
		(agent_is_human, ":agent"),#stop if not human
		(agent_is_active,":agent"),
		(agent_is_alive,":agent"),
		(try_begin),
			(agent_get_position,pos62,":agent"),
			(get_distance_between_positions,":dist",pos63,pos62),
			(lt,":dist",":bash_radius"),# Now based on shield skill, not doing this for NPCs because that might get expensive.
			(agent_get_horse, ":horse", ":agent"),
			(eq, ":horse", -1),
			(neq,":agent",":player_agent"),
			(agent_play_sound, ":player_agent", "snd_wooden_hit_low_armor_high_damage"),
			(position_move_y,pos62,-25),
			(agent_set_position, ":agent", pos62),
			(try_begin),
				(store_random_in_range, ":rand", 3, 10), # No chance for critical strike unless shield skill +3
				(gt, ":shield_level", ":rand"),
				(agent_set_animation, ":agent","anim_shield_strike"),
			(else_try),
				(agent_set_animation, ":agent", "anim_shield_strike_small"),
			(try_end),
		(try_end),
	(try_end),
	(try_end),
(try_end),
(else_try),
#(display_message, "@You don't have enough shield skill to shield bash again this soon."),
# This message is super spammy and it's absolutely useless after the first time the palyer ever sees it.
(try_end),
]),


#RAMARAUNT SCRIPT - with code from Xenoargh's shield bashing OSP.
#AI shield bashing script
("agent_shield_bash",[
(this_or_next|multiplayer_is_server),
(neg|game_in_multiplayer_mode),
(store_script_param, ":agent", 1),
(agent_get_troop_id, ":troop_id", ":agent"),
(store_skill_level,":shield_level", "skl_shield", ":troop_id"),
(gt, ":shield_level", 5),
(store_sub, ":agent_shield_bash_time", 13, ":shield_level"),
(store_mission_timer_a, ":current_time"),
(try_begin),
(agent_get_wielded_item, ":shield_item", ":agent", 1),
(neq, ":shield_item", -1),
(neq, ":shield_item", 0),
(item_get_type, ":item_type", ":shield_item"),
(eq, ":item_type", itp_type_shield),
(agent_get_slot, ":slot_last_shield_bash_time", ":agent", 27),
(store_add, ":time_to_shield_bash", ":agent_shield_bash_time",":slot_last_shield_bash_time"),
(try_begin),
(ge, ":current_time", ":time_to_shield_bash"),
(try_begin),
(gt, ":agent", 0),
(agent_get_animation, ":anim", ":agent",0),
(agent_get_horse, ":my_horse", ":agent"),
(try_begin),
	(neq, ":anim", "anim_human_shield_bash"),
	(eq, ":my_horse", -1),
	(agent_set_animation, ":agent","anim_human_shield_bash"),
	(agent_get_position, pos63,":agent"),
	(position_move_y,pos63,75),#75 cm directly ahead, so it's not a cuboid space around player center
	(agent_get_troop_id, ":id", ":agent"),
	(troop_get_type, ":type", ":id"),
	(try_begin),
		(eq, ":type", tf_male),
		(agent_play_sound, ":agent", "snd_man_grunt"),
		(agent_set_slot, ":agent", 27, ":current_time"),
	    #(display_message, "@{s2} has shield bashed!"),
	(else_try),
		(agent_play_sound, ":agent", "snd_woman_grunt"),
        (agent_set_slot, ":agent", 27, ":current_time"),
		#(display_message, "@{s2} has shield bashed!"),
	(try_end),
	(try_for_agents,":victims"),
		(gt, ":victims", 0),
		(agent_get_team, ":victim_team", ":victims"),
		(agent_get_team, ":agent_team", ":agent"),
		(teams_are_enemies, ":victim_team", ":agent_team"), #don't bash allies
		(agent_is_human, ":victims"),#stop if not human
		(agent_is_active,":victims"),
		(agent_is_alive,":victims"),
		(try_begin),
			(get_player_agent_no,":player"),
			(eq,":victims",":player"),
			(display_message, "@You have been shield bashed!"),
		(try_end),
		(try_begin),
			(agent_get_position,pos62,":victims"),
			(get_distance_between_positions,":dist",pos63,pos62),
			(lt,":dist",100),#Set this to whatever you like- 1 meter radius clears a big section of crowd
			(agent_get_horse, ":horse", ":victims"),
			(eq, ":horse", -1),
			(neq,":agent",":victims"),
			(agent_play_sound, ":victims", "snd_wooden_hit_low_armor_high_damage"),
			(position_move_y,pos62,-25),
			(agent_set_position, ":victims", pos62),
			(try_begin),
				(store_random_in_range, ":rand", 6, 10), # No chance for critical strike unless shield skill +3
				(gt, ":shield_level", ":rand"),
				(agent_set_animation, ":agent","anim_shield_strike"),
			(else_try),
				(agent_set_animation, ":agent", "anim_shield_strike_small"),
			(try_end),
		(try_end),
	(try_end),
	(try_end),
(try_end),
(try_end),
(try_end),
]),
#End Shield Bash Script

#VIKING CONQUEST DECAP STUFF - NOTE THIS CODE IS SLIGHTLY ALTERED CODE FROM VC, WHICH IS LEGAL AS LONG AS YOU GIVE CREDIT - Ramaraunt
("cf_vc_decap_check_if_possible",
	[(store_script_param_1, ":inflicted_agent_id"),
	(store_script_param_2, ":damage"),
	(store_script_param, ":weapon_id",3),
	(store_script_param, ":attacker_id", 4),

	# Can't be: player, hero or horse nor female
	(agent_is_non_player, ":inflicted_agent_id"),
	(agent_get_troop_id, ":troop_inflicted", ":inflicted_agent_id"),
	(neg | troop_is_hero,":troop_inflicted"),
	(agent_is_human, ":inflicted_agent_id"),
	(troop_get_type, ":is_female", ":troop_inflicted"),
	(val_mod, ":is_female", 2),
	(neq, ":is_female", 1),

	#test if head hit
	(agent_get_position, pos1, ":inflicted_agent_id"),
	(get_distance_between_positions, ":distance", pos1, pos0),
	(is_between, ":distance", 90, 185), # *zing*

	#test if within melee range (this stops most ranged decaps unless they are SUPER close, which doesnt happen often so its ok)
	(agent_get_position, pos2, ":attacker_id"),
	(get_distance_between_positions, ":distance", pos2, pos1),
	(is_between, ":distance", 0, 200),


	# test weapon: cutting damage from a weapon (no missiles)
	(gt, ":weapon_id", 0),
	(item_get_swing_damage_type, ":damage_type", ":weapon_id"),
	(eq, ":damage_type", cut),

	# test to make sure it's a huge hit
	(ge, ":damage", 40),

	# test if agent is dying from the hit
	(store_agent_hit_points, ":inflicted_hp", ":inflicted_agent_id", 1),
	(store_sub, ":inflicted_new_hp", ":inflicted_hp", ":damage"),
	(le, ":inflicted_new_hp", 0),


      ]),

("cf_vc_decap_probability",
    [(store_script_param_1, ":inflicted_agent_id"),
      (store_script_param_2, ":attacker_agent_id"),
      (store_script_param, ":weapon_id",3),

      (agent_is_human, ":inflicted_agent_id"),
      (agent_is_human, ":attacker_agent_id"),
      (gt, ":weapon_id", 0),
	  (get_player_agent_no,":player"),

      ### Probability ###
      #BASE: 5
      #IF PLAYER
      #	BASE: +5
      #	IF MOUNTED +30
      #	IF STR>15 : +10
      #	IF PS>7 : +10
      #IF BOT
      #	IF MOUNTED +10
      #IF AXE +5
      #IF HAS HELMET -5
      #MIN CHANCE: 5
      (assign, ":base_chance", 5),

      (try_begin),

        # Mounted bot
        (agent_get_horse, ":horse_id", ":attacker_agent_id"),
        (try_begin),
          (agent_is_non_player, ":attacker_agent_id"),

          (try_begin),
            (neq, ":horse_id", -1),
            (val_add, ":base_chance", 10),
          (try_end),

          #Player bonus
        (else_try),
		  (eq,":attacker_agent_id",":player"),
		  (store_attribute_level, ":skill", ":player", ca_strength),
          (val_add, ":base_chance", ":skill"),
          (try_begin),
            (neq, ":horse_id", -1),
            (val_add, ":base_chance", 30),
          (try_end),
        (try_end),


        # Helmet
        (try_begin),
          (agent_get_item_slot, ":head_gear", ":inflicted_agent_id", ek_head),
          (ge, ":head_gear", 1),
          (item_get_head_armor, ":armor", ":head_gear"),
          (gt, ":armor", 20),
          (val_sub, ":base_chance", 5),
        (try_end),

        (val_max, ":base_chance", 5),
      (try_end),

      (store_random_in_range, ":rand", 0, 101),

      #(val_div, ":base_chance", 2),#VC-3296
      # Debugging
      (ge, ":base_chance", ":rand"),]),

  # Description: for decapitation -> blood, helmet, spawn head
  # Input: inflicted_agent_id, head_position
  # Output: none
  ("vc_decap_special_effects",
    [(store_script_param_1, ":inflicted_agent_id"),

      # Checks if agent was using a helmet
      (try_begin),
        (agent_get_item_slot, ":head_gear", ":inflicted_agent_id", ek_head),
        (ge, ":head_gear", 1),
        (assign, ":spawn_for_timer", 60),

        # helmet on the ground
        (copy_position, pos2, pos1),
        (position_move_x, pos2, 20, 0),
        (position_move_z, pos2, -30, 0),
        (store_random_in_range, ":rot_x", 10, 40),
        (store_random_in_range, ":rot_z", 15, 75),
        (position_rotate_x, pos2, ":rot_x", 1),
        (position_rotate_z, pos2, ":rot_z", 1),
        (position_set_z_to_ground_level, pos2),
        (position_move_y, pos2, -5, 1),
        (set_spawn_position, pos2),
        (spawn_item, ":head_gear", 0, ":spawn_for_timer"),

        (agent_unequip_item, ":inflicted_agent_id", ":head_gear"),
      (try_end),

      # equip invisible head on agent
      (agent_equip_item, ":inflicted_agent_id", "itm_untitled"),

      # blood
      (copy_position, pos2, pos0),
      (set_spawn_position, pos2),
      (particle_system_burst, "psys_game_blood", pos2, 5),

      # fake head
      (spawn_scene_prop, "spr_physics_head"),
      (assign, ":head_id", reg0),

      (prop_instance_enable_physics, ":head_id", 1),

      # makes sure the agent dies
      (agent_set_hit_points,":inflicted_agent_id", 0, 1),]),


#VIKING CONQUEST END
#COMBAT OSP END

#custom armor
  #script_add_troop_to_custom_armor_tableau
  # INPUT: troop_no, item (g_current_opened_item_details), side (g_custom_armor_angle)
  # OUTPUT: none
  ("add_troop_to_custom_armor_tableau",	# NOT USED YET - Pure Somebody code
    [
       (store_script_param, ":troop_no",1),
       (store_mul, ":side", "$g_custom_armor_angle", 60), #add some more sides

       (set_fixed_point_multiplier, 100),

       (cur_tableau_clear_override_items),

	   (cur_tableau_set_override_flags, af_override_weapons),

       (init_position, pos2),
       (position_rotate_z, pos2, ":side"),
       (cur_tableau_set_camera_parameters, 1, 4, 6, 10, 10000),

       (init_position, pos5),
       (assign, ":cam_height", 105),
#       (val_mod, ":camera_distance", 5),
       (assign, ":camera_distance", 380),
       (assign, ":camera_yaw", -15),
       (assign, ":camera_pitch", -18),
       (val_clamp, "$g_custom_armor_angle", 0, anim_walk_forward_crouch - anim_walk_backward),
       (store_add, ":animation", "$g_custom_armor_angle", "anim_walk_backward"),

       (position_set_z, pos5, ":cam_height"),

       # camera looks towards -z axis
       (position_rotate_x, pos5, -90),
       (position_rotate_z, pos5, 180),

       # now apply yaw and pitch
       (position_rotate_y, pos5, ":camera_yaw"),
       (position_rotate_x, pos5, ":camera_pitch"),
       (position_move_z, pos5, ":camera_distance", 0),
       (position_move_x, pos5, 5, 0),

	   (try_begin), #shouldn't be necessary, it's already on the troop (player character) - good for hand items
         (gt, "$g_current_opened_item_details", -1),
         (cur_tableau_add_override_item, "$g_current_opened_item_details"),
       (try_end),

		(call_script, "script_show_body_on_tableau", ":troop_no"), # force show body item for tattoos, and loins if cenzored
		#custom armor

       (cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
       (cur_tableau_set_camera_position, pos5),

       (copy_position, pos8, pos5),
       (position_rotate_x, pos8, -90), #y axis aligned with camera now. z is up
       (position_rotate_z, pos8, 30),
       (position_rotate_x, pos8, -60),
       (cur_tableau_add_sun_light, pos8, 155,155,155),
     ]),
#DtheHun
  ("init_custom_armor1",
    [
    (store_script_param, ":agent_no", 1),
    #(store_script_param, ":troop_no", 2),
    (store_script_param, ":sub_part", 3),
    (store_script_param, ":sub_comp", 4),
	(str_clear, s1),
  #SAVE AGENT ARMOR SLOT FOR SCENE
	(try_begin),
		(neq, ":agent_no", -1),
		(store_add, ":agent_armor_slot", slot_agent_armor_slots_begin, ":sub_part"),
		(agent_set_slot, ":agent_no", ":agent_armor_slot", ":sub_comp"),
	(try_end),
  #MAKE COMPONENT MESH STRING OUTPUT
    (assign, ":value", -1),
    (assign, "$g_custom_armor_param_count", 8),
	(try_begin), #SKIN none, assassin*, leather
      (eq, ":sub_part", 0),
      (is_between, ":sub_comp", 0, 3), #2 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_skin_0"),
    (else_try), #CHEST none, loin, sonja, risty
      (eq, ":sub_part", 1),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_bra_0"),
	(else_try), #PANTY none, morag*, chain, risty, angela
      (eq, ":sub_part", 2),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_panty_0"),
	(else_try), #BELT none, assassin*, sonja, angela, risty
      (eq, ":sub_part", 3),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_belt_0"),
    (else_try), #BUTT none, assassin*, angela?, sonja, loin
      (eq, ":sub_part", 4),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_ass_0"),
    (else_try), #KNEE none, scale, sonja, assassin
      (eq, ":sub_part", 5),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_knee_0"),
    (else_try), #PAULDRON LEFT none, plate, scale, assa_pauld, sonja, risty
      (eq, ":sub_part", 6),
      (is_between, ":sub_comp", 0, 6), #5 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_pdn_l_0"),
    (else_try), #PAULDRON RIGHT none, plate, scale, assa_pauld, sonja, risty
      (eq, ":sub_part", 7),
      (is_between, ":sub_comp", 0, 6), #5 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_pdn_r_0"),
    (else_try), #ELBOW LEFT none, plate, assassin_sleeves
      (eq, ":sub_part", 8),
      (is_between, ":sub_comp", 0, 3), #2 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_elb_l_0"),
    (else_try), #ELBOW RIGHT none, plate, plate, assassin_sleeves
      (eq, ":sub_part", 9),
      (is_between, ":sub_comp", 0, 3), #2 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_elb_r_0"),
    (else_try), #BRACER LEFT none, plate, sonja, Risty
      (eq, ":sub_part", 10),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_brc_l_0"),
    (else_try), #BRACER RIGHT none, plate, sonja, Risty
      (eq, ":sub_part", 11),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_brc_r_0"),
	(else_try), #NECK none,
      (eq, ":sub_part", 12),
      (is_between, ":sub_comp", 0, 2), #1 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_neck_0"),
    (else_try), #CAPE none,
      (eq, ":sub_part", 13),
      (is_between, ":sub_comp", 0, 2), #1 + none
      (store_add, ":value", ":sub_comp", "itm_ca1_cape_0"),
	(else_try), #END
      (assign, "$g_custom_armor_param_count", 0),
    (try_end),
    (try_begin),
      (neq, ":value", -1),
      (str_store_item_name, s1, ":value"), 	#<- item name (string)
    (try_end),
	(assign, reg0, ":value"), 				#<- item_no
    ]
  ),

  ("init_custom_armor2",
    [
    (store_script_param, ":agent_no", 1),
    #(store_script_param, ":troop_no", 2),
    (store_script_param, ":sub_part", 3),
    (store_script_param, ":sub_comp", 4),
	(str_clear, s1),
  #SAVE AGENT ARMOR SLOT FOR SCENE
	(try_begin),
		(neq, ":agent_no", -1),
		(store_add, ":agent_armor_slot", slot_agent_armor_slots_begin, ":sub_part"),
		(agent_set_slot, ":agent_no", ":agent_armor_slot", ":sub_comp"),
	(try_end),
  #MAKE COMPONENT MESH STRING OUTPUT
    (assign, ":value", -1),
    (assign, "$g_custom_armor_param_count", 10),
	(try_begin), #SKIN none, assassin*, chainmail, leather
      (eq, ":sub_part", 0),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_skin_0"),
    (else_try), #CHEST none, scale, angela, sonja, -loin, -risty
      (eq, ":sub_part", 1),
      (is_between, ":sub_comp", 0, 6), #5 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_bra_0"),
	(else_try), #PANTY none, assassin*, chain, risty, angela
      (eq, ":sub_part", 2),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_panty_0"),
	(else_try), #BELT none, assassin*, sonja, angela, -risty
      (eq, ":sub_part", 3),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_belt_0"),
    (else_try), #BUTT none, assassin*, angela, scale, sonja, loin
      (eq, ":sub_part", 4),
      (is_between, ":sub_comp", 0, 6), #5 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_ass_0"),
    (else_try), #KNEE none, angela, plated_assassin, assassin, sonja, -scale
      (eq, ":sub_part", 5),
      (is_between, ":sub_comp", 0, 6), #5 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_knee_0"),
    (else_try), #PAULDRON LEFT none, plate, scale, assa_pauld, ang_shoul, ang_pauld, assa_shoul, sonja,-risty
      (eq, ":sub_part", 6),
      (is_between, ":sub_comp", 0, 9), #8 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_pdn_l_0"),
    (else_try), #PAULDRON RIGHT none, plate, scale, assa_pauld, ang_shoul, ang_pauld, assa_shoul, sonja, -risty
      (eq, ":sub_part", 7),
      (is_between, ":sub_comp", 0, 9), #8 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_pdn_r_0"),
    (else_try), #ELBOW LEFT none, plate, assassin_sleeves, angela
      (eq, ":sub_part", 8),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_elb_l_0"),
    (else_try), #ELBOW RIGHT none, plate, assassin_sleeves, angela
      (eq, ":sub_part", 9),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_elb_r_0"),
    (else_try), #BRACER LEFT none, plate, sonja, angela,  Risty
      (eq, ":sub_part", 10),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_brc_l_0"),
    (else_try), #BRACER RIGHT none, plate, sonja, angela, Risty
      (eq, ":sub_part", 11),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_brc_r_0"),
    (else_try), #NECK none, -sonja
      (eq, ":sub_part", 12),
      (is_between, ":sub_comp", 0, 2), #1 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_neck_0"),
    (else_try), #CAPE none, -angela
      (eq, ":sub_part", 13),
      (is_between, ":sub_comp", 0, 2), #1 + none
      (store_add, ":value", ":sub_comp", "itm_ca2_cape_0"),
	(else_try), #END
      (assign, "$g_custom_armor_param_count", 0),
    (try_end),
    (try_begin),
      (neq, ":value", -1),
      (str_store_item_name, s1, ":value"), 	#<- item name (string)
    (try_end),
	(assign, reg0, ":value"), 				#<- item_no
    ]
  ),

  ("init_custom_armor3",
    [
    (store_script_param, ":agent_no", 1),
    #(store_script_param, ":troop_no", 2),
    (store_script_param, ":sub_part", 3),
    (store_script_param, ":sub_comp", 4),
	(str_clear, s1),
  #SAVE AGENT ARMOR SLOT FOR SCENE
	(try_begin),
		(neq, ":agent_no", -1),
		(store_add, ":agent_armor_slot", slot_agent_armor_slots_begin, ":sub_part"),
		(agent_set_slot, ":agent_no", ":agent_armor_slot", ":sub_comp"),
	(try_end),
  #MAKE COMPONENT MESH STRING OUTPUT
    (assign, ":value", -1),
    (assign, "$g_custom_armor_param_count", 12),
	(try_begin), #SKIN none, assassin*, chainmail, leather
      (eq, ":sub_part", 0),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_skin_0"),
    (else_try), #CHEST none, plate, scale, angela, -loin, -sonja, -risty
      (eq, ":sub_part", 1),
      (is_between, ":sub_comp", 0, 7), #6 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_bra_0"),
	(else_try), #PANTY none, morag*, chain, risty, angela
      (eq, ":sub_part", 2),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_panty_0"),
	(else_try), #BELT none, assassin*, ?angela, sonja, -risty
      (eq, ":sub_part", 3),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_belt_0"),
    (else_try), #BUTT none, assassin*, ?angela, scale, sonja, -loin
      (eq, ":sub_part", 4),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_ass_0"),
    (else_try), #KNEE none, plate, plated_assassin, angela, -assassin, -sonja, -scale
      (eq, ":sub_part", 5),
      (is_between, ":sub_comp", 0, 7), #6 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_knee_0"),
    (else_try), #PAULDRON LEFT none, plate, scale, assa_shoul, ang_pauld, ang_shold, -assa_pauld, -sonja, -risty,
      (eq, ":sub_part", 6),
      (is_between, ":sub_comp", 0, 9), #8 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_pdn_l_0"),
    (else_try), #PAULDRON RIGHT none, plate, scale, assa_shoul, ang_pauld, ang_shold, -assa_pauld, -sonja, -risty,
      (eq, ":sub_part", 7),
      (is_between, ":sub_comp", 0, 9), #8 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_pdn_r_0"),
    (else_try), #ELBOW LEFT none, plate, angela, -assassin_sleeves
      (eq, ":sub_part", 8),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_elb_l_0"),
    (else_try), #ELBOW RIGHT none, plate, angela, -assassin_sleeves
      (eq, ":sub_part", 9),
      (is_between, ":sub_comp", 0, 4), #3 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_elb_r_0"),
    (else_try), #BRACER LEFT none, plate, sonja, angela, Risty
      (eq, ":sub_part", 10),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_brc_l_0"),
    (else_try), #BRACER RIGHT none, plate, sonja, angela, Risty
      (eq, ":sub_part", 11),
      (is_between, ":sub_comp", 0, 5), #4 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_brc_r_0"),
    (else_try), #NECK none, -sonja
      (eq, ":sub_part", 12),
      (is_between, ":sub_comp", 0, 2), #1 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_neck_0"),
    (else_try), #CAPE none, -angela
      (eq, ":sub_part", 13),
      (is_between, ":sub_comp", 0, 2), #1 + none
      (store_add, ":value", ":sub_comp", "itm_ca3_cape_0"),
	(else_try), #END
      (assign, "$g_custom_armor_param_count", 0),
    (try_end),
    (try_begin),
      (neq, ":value", -1),
      (str_store_item_name, s1, ":value"), 	#<- item name (string)
    (try_end),
	(assign, reg0, ":value"), 				#<- item_no
    ]
  ),

  ("init_plate_helm_dthun",
    [
    (store_script_param, ":agent_no", 1),
    #(store_script_param, ":troop_no", 2),
    (store_script_param, ":sub_part", 3),
    (store_script_param, ":sub_comp", 4),
	(str_clear, s1),
  #SAVE AGENT ARMOR SLOT FOR SCENE
	(try_begin),
		(neq, ":agent_no", -1),
		(store_add, ":agent_armor_slot", slot_agent_helm_slots_begin, ":sub_part"),
		(agent_set_slot, ":agent_no", ":agent_armor_slot", ":sub_comp"),
	(try_end),
  #MAKE COMPONENT MESH STRING OUTPUT
    (assign, ":value", -1),
    (assign, "$g_custom_armor_param_count", 5),
	(try_begin), #DECORATION: none, plate_wings, angela_wings
      (eq, ":sub_part", 0),
      (is_between, ":sub_comp", 0, 3), #2 + none
      (store_add, ":value", ":sub_comp", "itm_cph_dec_0"),
	(else_try), #END
      (assign, "$g_custom_armor_param_count", 0),
    (try_end),
    (try_begin),
      (neq, ":value", -1),
      (str_store_item_name, s1, ":value"), 	#<- item name (string)
    (try_end),
	(assign, reg0, ":value"), 				#<- item_no
    ]
  ),
  ("init_angela_helm",
    [
    (store_script_param, ":agent_no", 1),
    #(store_script_param, ":troop_no", 2),
    (store_script_param, ":sub_part", 3),
    (store_script_param, ":sub_comp", 4),
	(str_clear, s1),
  #SAVE AGENT ARMOR SLOT FOR SCENE
	(try_begin),
		(neq, ":agent_no", -1),
		(store_add, ":agent_armor_slot", slot_agent_helm_slots_begin, ":sub_part"),
		(agent_set_slot, ":agent_no", ":agent_armor_slot", ":sub_comp"),
	(try_end),
  #MAKE COMPONENT MESH STRING OUTPUT
    (assign, ":value", -1),
    (assign, "$g_custom_armor_param_count", 5),
	(try_begin), #FACE: none, angela
      (eq, ":sub_part", 0),
      (is_between, ":sub_comp", 0, 2), #1 + none
      (store_add, ":value", ":sub_comp", "itm_cah_face_0"),
	(else_try), #WING_UP: none, angela
      (eq, ":sub_part", 1),
      (is_between, ":sub_comp", 0, 2), #1 + none
      (store_add, ":value", ":sub_comp", "itm_cah_wings_up_0"),
	(else_try), #WING_DOWN: none, angela
      (eq, ":sub_part", 2),
      (is_between, ":sub_comp", 0, 2), #1 + none
      (store_add, ":value", ":sub_comp", "itm_cah_wings_down_0"),
	(else_try), #END
      (assign, "$g_custom_armor_param_count", 0),
    (try_end),
    (try_begin),
      (neq, ":value", -1),
      (str_store_item_name, s1, ":value"), 	#<- item name (string)
    (try_end),
	(assign, reg0, ":value"), 				#<- item_no
    ]
  ),
#/custom armor
  ("sir_lady", [ #male 1, female 0, (player, talk_troop) -> (reg33, reg6)
		(troop_get_type, ":is_female", "trp_player"),
		(try_begin),
			(ge, ":is_female", 1),
			(assign, reg33, 0),
		(else_try),
			(assign, reg33, 1),
		(try_end),
		#(troop_get_type, ":is_female", "$g_talk_troop"),
		#(try_begin),
		#	(ge, ":is_female", 1),
		#	(assign, reg6, 0),
		#(else_try),
		#	(assign, reg6, 1),
		#(try_end),
	]
  ),

#DtheHun

  #script_add_troop_to_custom_armor_tableau
  # INPUT: troop_no, item (g_current_opened_item_details), side (g_custom_armor_angle)
  # OUTPUT: reg0 (-1):do nothing, (0):equip body, (1):equip loincloth - for additional troop equip if must (character -> face morpf)
  ("show_body_on_tableau",
    [
		(store_script_param, ":troop_no", 1),
		(assign, reg0, -1),
		(try_begin),
			(troop_get_type, ":is_female", ":troop_no"),
			(ge, ":is_female", 1),
			(troop_get_inventory_slot, ":item_no", ":troop_no", ek_body),
			(eq, ":item_no", -1), #-1:none equipped
			(cur_tableau_clear_override_items),
			(cur_tableau_set_override_flags, af_override_everything), # makes it possible to set_override ek_body item without adding it to troop
			(try_begin),
				#(eq, "$g_cenzura", 1),
				(eq, 0, 1),
				(cur_tableau_add_override_item, "itm_loincloth"),
				(assign, reg0, 1),
			(else_try),
				(cur_tableau_add_override_item, "itm_body_fem"),
				(assign, reg0, 0),
			(try_end),
			(try_for_range, ":item_slot", ek_head, ek_horse), # do removed clothes back
				(troop_get_inventory_slot, ":item_no", ":troop_no", ":item_slot"),
				(ge, ":item_no", 0),
				(cur_tableau_add_override_item, ":item_no"),
			(try_end),
		(try_end),
     ]),

  #script_add_troop_to_custom_armor_tableau
  # INPUT: troop_no, item (g_current_opened_item_details), side (g_custom_armor_angle)
  # OUTPUT: none
  ("remove_body_from_inventory",
    [
		(store_script_param, ":troop_no", 1),
		(troop_get_type, ":is_female", ":troop_no"),
		(try_begin),
			(ge, ":is_female", 1),	#check: body/loincloth equipped ->remove it from inventory (equipped in character window for face morph scene)
			(try_begin),	# troop has it from opening character tab till next inventory opening -> can lose it in battle, has unique flag -> won't see back (hopefully noone equips it)
				(troop_has_item_equipped, ":troop_no", "itm_body_fem"),
				(troop_remove_item, ":troop_no", "itm_body_fem"),
			(else_try),
				(troop_has_item_equipped, ":troop_no", "itm_loincloth"),
				(troop_remove_item, ":troop_no", "itm_loincloth"),
			(else_try),
				#(eq, "$g_cenzura", 1),
				(eq, 0, 1),
				(try_begin),
					(troop_has_item_equipped, ":troop_no", "itm_loin_top"),
					(troop_remove_item, ":troop_no", "itm_loin_top"),
				(else_try),
					(troop_has_item_equipped, ":troop_no", "itm_loin_skirt"),
					(troop_remove_item, ":troop_no", "itm_loin_skirt"),
				(try_end),
			(try_end),
		(try_end),
     ]),

  ("done_skin",
	[
		(store_script_param, ":agent_no", 1),
		(try_begin),
			(agent_is_active, ":agent_no"),
			(agent_is_alive, ":agent_no"),
			(agent_is_human, ":agent_no"),
			(agent_get_troop_id, ":troop_no", ":agent_no"),
			(troop_get_type, ":is_female", ":troop_no"),
			(ge, ":is_female", 1),
			(agent_get_item_slot, ":body_armor", ":agent_no", ek_body),
			(try_begin),
				(neq, ":body_armor", -1),
				(agent_unequip_item, ":agent_no", ":body_armor"),	# (may have changed in inventory, and have the same base name -> changes only second time without unequipping)
			(try_end),
			(try_begin),
				(this_or_next|eq, ":body_armor", -1),
				(this_or_next|eq, ":body_armor", "itm_body_fem"), # <- remained back from character window equip
				(this_or_next|eq, ":body_armor", "itm_loin_top"),
				(eq, ":body_armor",  "itm_loin_skirt"),	# <- trp_looter_woman
				(try_begin), #Nincs -> cenzura -> "loincloth" felvesz
					(eq, "$g_cenzura", 1),
					(agent_equip_item, ":agent_no", "itm_loincloth"),
				(else_try), #Volt rajta?
					(this_or_next|eq, ":body_armor", -1),
					(eq, ":body_armor", "itm_body_fem"),
					(troop_get_inventory_slot, ":item_no", ":troop_no", ek_body),
					(try_begin),
					#Had the troop clothes training before mission?
						#mtf_override body -> equip loin parts corresponding to base armor components (bra?, bottom?)
						(gt, ":item_no", -1),
						(neq, ":item_no", "itm_body_fem"), # <- remained back from character window equip
						(try_begin), #save first customizable
						#Custom
							(item_slot_ge, ":item_no", slot_item_num_components, 1),
							(assign, ":cur_mesh_slot", slot_troop_armor_slots_begin), 	#0.: skin slot
							(try_begin),
							#Has Skin -> loincloth
								(troop_get_slot, ":skin", ":troop_no", ":cur_mesh_slot"),
								(neq, ":skin", 0),
								(agent_equip_item, ":agent_no", "itm_loincloth"),
							(else_try),
							#!Skin, Panty, Bra -> loincloth
								(val_add, ":cur_mesh_slot", 1),							#1.: chest slot
								(troop_get_slot, ":bra", ":troop_no", ":cur_mesh_slot"),
								(val_add, ":cur_mesh_slot", 1),							#2.: panty slot
								(troop_get_slot, ":panty", ":troop_no", ":cur_mesh_slot"),
							   #(eq, ":skin", 0),
								(neq, ":bra", 0),
								(neq, ":panty", 0),
								(agent_equip_item, ":agent_no", "itm_loincloth"),
							(else_try),
							#!Skin, Bra, !Panty -> loin_top
							   #(eq, ":skin", 0),
								(neq, ":bra", 0),
								(eq, ":panty", 0),
								(agent_equip_item, ":agent_no", "itm_loin_top"),
							(else_try),
							#!Skin, !Bra, Panty -> loin_skirt
							   #(eq, ":skin", 0),
								(eq, ":bra", 0),
								(neq, ":panty", 0),
								(agent_equip_item, ":agent_no", "itm_loin_skirt"),
							(else_try),
							#!Skin, !Bra, !Panty -> body for TATTOOS
							   #(eq, ":skin", 0),
							   #(eq, ":bra", 0),
							   #(eq, ":panty", 0),
								(agent_equip_item, ":agent_no", "itm_body_fem"),
							(try_end),
						(else_try),
						#Egyeb ruha	-> "loincloth" felvesz
							(agent_equip_item, ":agent_no", "itm_loincloth"),
						(try_end),
					(else_try),
					#Was nude before mission -> body for TATTOOS
						(agent_equip_item, ":agent_no", "itm_body_fem"),
					(try_end),
				(try_end),
			(else_try),	#Equip back original item
				(agent_equip_item, ":agent_no", ":body_armor"),
			(try_end),
		(try_end),
	]
  ),

  ("done_skin_multiplayer",
	[
		(store_script_param, ":agent_no", 1),
		(try_begin),
			(agent_is_active, ":agent_no"),
			(agent_is_alive, ":agent_no"),
			(agent_is_human, ":agent_no"),
			(agent_get_item_slot, ":body_armor", ":agent_no", ek_body),
			(eq, ":body_armor", -1),
			(agent_equip_item, ":agent_no", "itm_loincloth"), # man also equip - troop_type always 0 - "is_female" not working
		(try_end),
	]
  ),

  ("set_custom_armor_slots",
	[
	   #set slots random for everyone
		(try_for_range, ":npc", 0, "trp_coop_companion_equipment_ui_0"),
			(try_for_range, ":slot_no", slot_troop_armor_slots_begin, slot_troop_helm_slots_end),
				(troop_set_slot, ":npc", ":slot_no", -1), # random = -1
			(try_end),
		(try_end),

	    #(display_message, "@Initializing troop slots DONE"),

	   #Light
		(item_set_slot, "itm_custom_armor1", slot_item_num_components, 14), #14 customizable
		(item_set_slot, "itm_custom_armor1", slot_item_init_script, "script_init_custom_armor1"),
	   #Medium
		(item_set_slot, "itm_custom_armor2", slot_item_num_components, 14), #14 customizable
		(item_set_slot, "itm_custom_armor2", slot_item_init_script, "script_init_custom_armor2"),
	   #Heavy
		(item_set_slot, "itm_custom_armor3", slot_item_num_components, 14), #14 customizable
		(item_set_slot, "itm_custom_armor3", slot_item_init_script, "script_init_custom_armor3"),
	   #Plate Helm
		(item_set_slot, "itm_plate_helm_dthun", slot_item_num_components, 1), #1 customizable
		(item_set_slot, "itm_plate_helm_dthun", slot_item_init_script, "script_init_plate_helm_dthun"),
	   #Angela Helm
		(item_set_slot, "itm_angela_helm", slot_item_num_components, 3), #3 customizable
		(item_set_slot, "itm_angela_helm", slot_item_init_script, "script_init_angela_helm"),
		#(try_for_range, ":slot_no", slot_item_player_slots_begin, slot_item_player_slots_end + 1), # troop slots added insted item slots
		#  (item_set_slot, "itm_plate_helm_dthun", ":slot_no", -1), # random = -1
		#(try_end),

		#(display_message, "@Initializing armor slots DONE"),

		#(troop_set_slot, "trp_player", slot_troop_tattoo, 0),
	]
  ),

  #script_find_customizable_item_equipped_on_troop
  # INPUT: 	troop_no
  # OUTPUT: none
  # SETS: 	item (g_current_opened_item_details)
  ("find_customizable_item_equipped_on_troop",
	[

	#Here's my lazy way.
	 (store_script_param, ":troop_no", 1),
	 (assign, "$g_current_opened_item_details", -1),
	 (assign, ":begin", ek_item_0), #should add a global as iterator
     (try_for_range, ":item_slot", ":begin", ek_foot),
		(troop_get_inventory_slot, ":item_no", ":troop_no", ":item_slot"),
		(gt, ":item_no", -1),
		(this_or_next|eq, ":item_no", itm_custom_armor1),
		(this_or_next|eq, ":item_no", itm_custom_armor2),
		(this_or_next|eq, ":item_no", itm_custom_armor3),
		(this_or_next|eq, ":item_no", itm_plate_helm_dthun),
		(eq, ":item_no", itm_angela_helm),
		(assign, "$g_current_opened_item_details", ":item_no"),
	 (else_try),
		(troop_get_type, ":is_female", ":troop_no"),
		(eq, ":is_female", 5),
		(assign, "$g_current_opened_item_details", "itm_body_fem"),
     (try_end),
	 (gt, "$g_current_opened_item_details", -1),
	# (store_script_param, ":troop_no", 1),
	# (assign, "$g_current_opened_item_details", -1),
	# (assign, ":begin", ek_item_0), #should add a global as iterator
    # (try_for_range_backwards, ":item_slot", ":begin", ek_foot),	#backwards: body armor first
	#	(troop_get_inventory_slot, ":item_no", ":troop_no", ":item_slot"),
	#	(gt, ":item_no", -1),
	#	(item_slot_ge, ":item_no", slot_item_num_components, 1),
	#	(assign, "$g_current_opened_item_details", ":item_no"),
	#	(assign, ":begin", ek_foot),
    # (else_try),	#to be able to change tattoo without custom item # Good idea but leads to unexpected results with the other body, best to just disable it.
	#	(troop_get_type, ":is_female", ":troop_no"),
	#	(ge, ":is_female", 1),
	#	(troop_get_inventory_slot, ":item_no", ":troop_no", ek_body),
	#	(try_begin),
	#		(gt, ":item_no", -1),
	#		(assign, "$g_current_opened_item_details", ":item_no"),
	#	(else_try),
	#		(assign, "$g_current_opened_item_details", "itm_body_fem"),
	#	(try_end),
    # (try_end),
	]
  ),
  #script_item_add_component
  # INPUT: 	1:agent_no, 2:troop_no, 3:use_agent_slots, 4:item_script_no, 5:mesh_num, 6:random_begin, 7:random_end, 8:special_part
  # 	$g_presentation_obj_item_select_2, reg1(:troop_item_slots_begin), reg2(:agent_item_slots_begin)
  # OUTPUT: ":special_part" (reg3)
  # SETS: 	item (g_current_opened_item_details)
  ("custom_item_prepare_component",
	[
	  (store_script_param, ":agent_no", 1),
	  (store_script_param, ":troop_no", 2),
      (store_script_param, ":use_agent_slots", 3),
	  (store_script_param, ":item_script_no", 4),
      (store_script_param, ":mesh_num", 5),
	  (store_script_param, ":random_begin", 6),
	  (store_script_param, ":random_end", 7),
	  (store_script_param, ":special_part", 8),	#(has requirements) 0: nothing, 1: assa. cover, 2:symm. with prev, 3: angela cover
	#GET
	  (store_add, ":troop_item_slot_no", reg1 , ":mesh_num"),
	  (store_add, ":agent_item_slot_no", reg2 , ":mesh_num"),	#<- only body

	  (try_begin),
		(try_begin),
			(eq, ":use_agent_slots", 0),
			(troop_get_slot, ":value", ":troop_no", ":troop_item_slot_no"), # slot_troop_armor_slots_begin + :mesh_num (0-13)
		(else_try),
			(agent_get_slot, ":value", ":agent_no", ":agent_item_slot_no"), #
		(try_end),
      #RANDOMIZE
		(eq, ":value", -1),
		(try_begin),
			(eq, "$g_dthehun_sync_random", 1),
			(troop_get_slot, ":value", "trp_temp_array_a", ":troop_item_slot_no"), # get prev random for tableau mask be sync.
		(else_try),
			(store_random_in_range, ":value", ":random_begin", ":random_end"),
			(try_begin), #special_part
			  #ass cover
				(eq, ":special_part", 1),
				(try_begin),
					(this_or_next|eq, ":value", 1),	# assassin
								 (eq, ":value", 2),	# Angela
					(try_begin),
						(this_or_next|troop_slot_eq, "trp_temp_array_a", slot_troop_armor_slots_begin + 0, 1), 	#has assa skin
						(this_or_next|troop_slot_eq, "trp_temp_array_a", slot_troop_armor_slots_begin + 2, 1), 	#has assa panty
						(this_or_next|troop_slot_eq, "trp_temp_array_a", slot_troop_armor_slots_begin + 2, 2), 	#has Angela panty
						(troop_slot_eq, "trp_temp_array_a", slot_troop_armor_slots_begin + 3, 1), 				#has assa belt
					(else_try),	#<- there is nothing to hanging on it
						(store_random_in_range, ":value", 1, ":random_end"), #<- new shuffle
						(eq, ":value", 1),
						(assign, ":value", 0),
					(try_end),
				(try_end),
			(else_try),
			  # symm. with previous component
				(eq, ":special_part", 2),
				(store_random_in_range, ":rand", 0, 6),	#(less than 16.66% could be asymmetric)
				(ge, ":rand", 1),
				(store_sub, ":prev_troop_item_slot_no", ":troop_item_slot_no", 1),
				(troop_get_slot, ":prev_value", "trp_temp_array_a", ":prev_troop_item_slot_no"),
				(assign, ":value", ":prev_value"),
			(try_end),
		(try_end),
	  (try_end),
	  (troop_set_slot, "trp_temp_array_a", ":troop_item_slot_no", ":value"), # remember randomization for tableau alpha
	  (try_begin),
		(neq, ":value", 0),
		(call_script, ":item_script_no", ":agent_no", ":troop_no", ":mesh_num", ":value"),#
		(neg|str_is_empty, s1),
		(cur_item_add_mesh, s1),
	  (try_end),
	]
  ),

  #script_set_calves - This is for SANDALS!!!
  # INPUT: 	1:agent_no, 2:troop_no,2, reg1(:troop_item_slots_begin), reg2(:agent_item_slots_begin)
  # OUTPUT:	NONE
 ("set_calves", [
	(store_trigger_param_1, ":agent_no"), # -1 if not in scene
	(store_trigger_param_2, ":troop_no"),
	(try_begin),
		(eq, ":agent_no", -1),	#not in scene (presentation)
		(is_between, ":troop_no", "trp_town_1_armorer", "trp_merchants_end"),	#trade - item from merchant inventory gives merchant no despite player equips it
		(assign, ":troop_no", "trp_player"),
	(try_end),
	(try_begin),
		(troop_get_type, ":troop_type", ":troop_no"),
		(try_begin),
			(this_or_next|eq, ":troop_type", tf_female), #female || tf_woman_nude || calfwoman (don't change male!)
			(this_or_next|eq, ":troop_type", tf_woman_nude),
			(eq, ":troop_type", tf_calfwoman),
			(try_begin),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_risty_sandals"), #tf_calfwoman and has sandals on -> no change
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_sonja_boots"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_sonja_armor"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_diabassa_armor"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_plate_armor_dthun"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_custom_armor3"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_custom_armor2"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_custom_armor1"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_risty_armor"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_scale_armor_dthun"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_loincloth"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_loin_top"),
				(this_or_next|troop_has_item_equipped , ":troop_no", "itm_loin_skirt"),
				(troop_has_item_equipped , ":troop_no", "itm_body_fem"),
				(try_begin),
					(this_or_next|eq, ":troop_type", tf_female),(eq, ":troop_type", tf_woman_nude),
					(troop_set_type, ":troop_no", tf_calfwoman),
					(assign, ":troop_changed", 1),
				(try_end),
			(else_try),
				(eq, ":troop_type", tf_calfwoman),
				(troop_set_type, ":troop_no", tf_female),
				(assign, ":troop_changed", 1),
			(try_end),
			(ge, ":agent_no", 0), # in scene - warnings from map else
			(eq, ":troop_changed", 1),
			(troop_get_inventory_slot, ":item_no", ":troop_no", ek_body),
			(ge, ":item_no", 0), # has body armor -> must refresh to see the change in scene
			(agent_unequip_item, ":agent_no", ":item_no"),
			(agent_equip_item, ":agent_no", ":item_no"),
		(try_end),
	(try_end),
	]
  ),

 # script_roll_for_charisma
 # ex:
 # (call_script, "script_roll_for_charisma", Difficulty_Modifier, Target_Troop, Propositioning_Troop),
 # Outputs none
 ("roll_for_charisma", [
  (store_trigger_param_1, ":difmod"),
  (store_trigger_param_2, ":target"), # Should default to 0, which is the player troop
  (store_trigger_param_3, ":roller"),

  (assign, ":end", 0),

    (store_attribute_level, ":cha", ":roller", ca_charisma),
    (assign, ":required_cha", 12),
	(val_add, ":required_cha", ":difmod"),
    (troop_get_slot, ":renown", ":roller", slot_troop_renown),
    (val_div, ":renown", 100),

    (store_skill_level, ":persuasion", "skl_persuasion", ":roller"),

    (call_script, "script_dplmc_store_is_female_troop_1_troop_2", ":target", ":roller"),
    (assign, ":target_gender", reg0),
	(assign, ":roller_gender", reg1),

    (try_begin),
		# Same-gender is a lot harder.
		(eq, ":target_gender", ":roller_gender"),
        (val_add, ":required_cha", 8),
    (else_try),
		# Women are harder.
		(eq, ":target_gender", 1),
        (val_add, ":required_cha", 6),
	(else_try),
		# Men are easier.
        (eq, ":target_gender", 0),
        (val_sub, ":required_cha", 6),
    (try_end),

    (try_begin),
        (is_between, ":target", heroes_begin, heroes_end),

        (val_div, ":renown", 2),

        (try_begin), # Noble ladies are even harder.
            (is_between, ":target", kingdom_ladies_begin, kingdom_ladies_end),
            (val_add, ":required_cha", 10),
            (try_begin),
                (this_or_next|troop_slot_eq, ":target", slot_lord_reputation_type, lrep_moralist),
                (troop_slot_eq, ":target", slot_lord_reputation_type, lrep_conventional),
                (val_add, ":required_cha", 10),
            (else_try),
                (troop_slot_eq, ":target", slot_lord_reputation_type, lrep_adventurous),
                (val_sub, ":required_cha", 5),
            (else_try),
                (troop_slot_eq, ":target", slot_lord_reputation_type, lrep_ambitious),
                (val_add, ":required_cha", 5),
                (val_sub, ":required_cha", ":renown"),
            (try_end),
        (try_end),
    (try_end),

	(try_begin), # Pretenders are MUCH harder. O . O . F .
		(eq, ":target", "$supported_pretender"),
		(troop_get_slot, ":troop_renown", ":target", slot_troop_renown),
		(try_begin),
			(gt, ":troop_renown", ":renown"),
			(store_sub, ":renown_diff", ":troop_renown", ":renown"),
			(val_div, ":renown_diff", 50),
			(val_add, ":required_cha", ":renown_diff"),
		(try_end),
		(val_add, ":required_cha", 20),
	(try_end),

    (call_script, "script_troop_get_relation_with_troop", ":roller", ":target"),
    (assign, ":rel", reg0),
    (try_begin), # Negative relation is a no-go
        (lt, ":rel", 0),
        (assign, ":end", 1),
    (try_end),
    (val_div, ":rel", 5), # Every 5 relation is equal to 1 Cha
    (val_sub, ":required_cha", ":rel"),
    (val_sub, ":persuasion"),
    (val_sub, ":required_cha", ":renown"),

    (val_max, ":required_cha", 9),

    (try_begin),
        (ge, "$cheat_mode", 1),
		(eq, ":roller", "trp_player"),
        (assign, reg0, ":required_cha"),
        (display_message, "@Required Charisma: {reg0}"),
    (try_end),

	(eq, ":end", 0),
    (ge, ":cha", ":required_cha"),
  ]),

  # script_change_player_controversy
  # Input: arg1 = controversy difference
  # Output: none
  ("change_player_controversy",
    [
      (store_script_param_1, ":controversy_dif"),
	  (troop_get_slot, ":controversy", "trp_player", slot_troop_controversy),
	  (troop_set_slot, "trp_player", slot_troop_controversy, ":controversy_dif"),
      (try_begin),
        (lt, ":controversy_dif", 0),
        (display_message, "@Things cool down.", message_positive),
      (else_try),
        (gt, ":controversy_dif", 0),
        (display_message, "@Rumors will certianly spread over this.", message_negative),
      (try_end),
  ]),

# script_pos_helper
# Description: Little Pos Helper by Kuba
# Input1: ti_on_presentation_***
# Output: none
("pos_helper",
 [  (store_script_param, ":ti_on", 1),
    (try_begin),
        (eq, ":ti_on", 1),# ti_on_presentation_load
		(create_text_overlay, "$g_little_pos_helper", "@00,00"),
		(overlay_set_color, "$g_little_pos_helper", 0xFFFFFFFF),
		(position_set_x, pos1, 10),
		(position_set_y, pos1, 700),
		(overlay_set_position, "$g_little_pos_helper", pos1),
    (try_end),
    (try_begin),
        (eq, ":ti_on", 2),# ti_on_presentation_run
		(mouse_get_position, pos1),
		(position_get_x, reg1, pos1),
		(position_get_y, reg2, pos1),
		(overlay_set_text, "$g_little_pos_helper", "@{reg1},{reg2}"),
    (try_end),
 ]),
 # script_update_order_panel_map
  # Input: none
  # Output: none
  ("update_order_panel_map",
   [
    (set_fixed_point_multiplier, 1000),

    (get_scene_boundaries, pos2, pos3),
    (try_begin),
      (ge, "$g_minimap_style", 1), # old style
      (try_for_agents,":cur_agent"),
        (agent_is_human, ":cur_agent"),
        (agent_get_slot, ":agent_overlay", ":cur_agent", slot_agent_map_overlay_id),
        (try_begin),
          (agent_is_alive, ":cur_agent"),
          (call_script, "script_update_agent_position_on_map", ":cur_agent"),
        (else_try),
          (overlay_set_alpha, ":agent_overlay", 0),
        (try_end),
      (try_end),
      # player_chest
      (try_begin),
        (scene_prop_get_instance, ":player_chest", "spr_inventory", 0),
        (ge, ":player_chest", 0),
        (prop_instance_get_position, pos1, ":player_chest"),
        (call_script, "script_convert_3d_pos_to_map_pos"),
        (overlay_set_position, "$g_player_chest_overlay", pos0),
        (overlay_set_alpha, "$g_player_chest_overlay", 0xFF),
      (else_try),
        (overlay_set_alpha, "$g_player_chest_overlay", 0),
      (try_end),
    (try_end),

    # Horse Stamina
    #(get_player_agent_no, ":player_agent"),
    #(agent_get_horse, ":horse_agent", ":player_agent"),
    #(try_begin),
    #  (eq, "$g_horse_charging_for_player", 1),
    #  (ge, ":horse_agent", 0),
    #  (agent_get_slot, ":horse_stamina", ":player_agent", slot_agent_horse_stamina),
    #  (store_agent_hit_points, ":horse_hp", ":horse_agent"),
    #  (assign, reg1, ":horse_stamina"),
    #  (assign, reg2, ":horse_hp"),
    #  (overlay_set_text, "$g_horse_stamina_overlay", "@Horse Stamina: {reg1}/{reg2}"),
    #  (overlay_set_alpha, "$g_horse_stamina_overlay", 0xFF),
    #(else_try),
    #  (overlay_set_alpha, "$g_horse_stamina_overlay", 0),
    #(try_end),
  ]),

  # script_update_map_bar
  # Input: none
  # Output: none
  ("update_map_bar",
   [
    (set_fixed_point_multiplier, 1000),

    (get_player_agent_no, ":player_agent"),
    (try_for_agents,":cur_agent"),
      (agent_is_human, ":cur_agent"),
      (agent_get_slot, ":agent_overlay", ":cur_agent", slot_agent_map_overlay_id),
      (try_begin),
        (agent_is_alive, ":cur_agent"),
        (call_script, "script_update_agent_position_on_map_bar", ":cur_agent"),
      (else_try),
        (overlay_set_alpha, ":agent_overlay", 0),
      (try_end),
    (try_end),
    # player_chest
    (try_begin),
      (scene_prop_get_instance, ":player_chest", "spr_inventory", 0),
      (ge, ":player_chest", 0),
      (prop_instance_get_position, pos1, ":player_chest"),
      (call_script, "script_convert_3d_pos_to_map_bar_pos", -5),
      (overlay_set_position, "$g_player_chest_overlay", pos0),
      (overlay_set_alpha, "$g_player_chest_overlay", 0xFF),
    (else_try),
      (overlay_set_alpha, "$g_player_chest_overlay", 0),
    (try_end),
    # Horse Stamina
    #(agent_get_horse, ":horse_agent", ":player_agent"),
    #(try_begin),
    #  (eq, "$g_horse_charging_for_player", 1),
    #  (ge, ":horse_agent", 0),
    #  (agent_get_slot, ":horse_stamina", ":player_agent", slot_agent_horse_stamina),
    #  (store_agent_hit_points, ":horse_hp", ":horse_agent"),
    #  (assign, reg1, ":horse_stamina"),
    #  (assign, reg2, ":horse_hp"),
    #  (overlay_set_text, "$g_horse_stamina_overlay", "@Horse Stamina: {reg1}/{reg2}"),
    #  (overlay_set_alpha, "$g_horse_stamina_overlay", 0xFF),
    #(else_try),
    #  (overlay_set_alpha, "$g_horse_stamina_overlay", 0),
    #(try_end),
    # enemies-allies-us
    (assign, ":num_us_ready_men", 0),
    (assign, ":num_allies_ready_men", 0),
    (assign, ":num_enemies_ready_men", 0),
    (agent_get_team, ":player_team", ":player_agent"),
    (try_for_agents,":agent_no"),
      (agent_is_human, ":agent_no"),
      (agent_is_alive, ":agent_no"),
      (neq, ":agent_no", ":player_agent"),
      (agent_get_team, ":agent_team", ":agent_no"),
      (try_begin),
        (neg|agent_is_ally, ":agent_no"),
        (val_add, ":num_enemies_ready_men", 1),
      (else_try),
        (eq, ":agent_team", ":player_team"),
        (val_add, ":num_us_ready_men", 1),
      (else_try),
        (val_add, ":num_allies_ready_men", 1),
      (try_end),
    (try_end),
    (assign, reg10, ":num_enemies_ready_men"),
    (assign, reg11, ":num_allies_ready_men"),
    (assign, reg12, ":num_us_ready_men"),
    (overlay_set_text, "$g_battle_enemies_ready", "@{!}{reg10}"),
    (overlay_set_text, "$g_battle_allies_ready", "@{!}{reg11}"),
    (overlay_set_text, "$g_battle_us_ready", "@{!}{reg12}"),
  ]),
  #Presentation line
 ("prsnt_line",
    [
      (store_script_param, ":size_x", 1),
      (store_script_param, ":size_y", 2),
      (store_script_param, ":pos_x", 3),
      (store_script_param, ":pos_y", 4),
      (store_script_param, ":color", 5),

      (create_mesh_overlay, reg1, "mesh_white_plane"),
      (val_mul, ":size_x", 50),
      (val_mul, ":size_y", 50),
      (position_set_x, pos0, ":size_x"),
      (position_set_y, pos0, ":size_y"),
      (overlay_set_size, reg1, pos0),
      (position_set_x, pos0, ":pos_x"),
      (position_set_y, pos0, ":pos_y"),
      (overlay_set_position, reg1, pos0),
      (overlay_set_color, reg1, ":color"),
  ]),
  # script_update_agent_position_on_map_bar
  # Input: arg1 = agent_no
  # Output: none
  ("update_agent_position_on_map_bar",
   [(store_script_param_1, ":agent_no"),
    (agent_get_slot, ":agent_overlay", ":agent_no", slot_agent_map_overlay_id),

    (get_player_agent_no, ":player_agent"),
    (try_begin),
      (le, ":agent_overlay", 0),
      (set_fixed_point_multiplier, 1000),
      (try_begin),
        (eq, ":agent_no", ":player_agent"),
        (create_mesh_overlay, reg1, "mesh_player_dot"),
        (position_set_x, pos1, 800),
        (position_set_y, pos1, 800),
        (overlay_set_size, reg1, pos1),
      (else_try),
        (create_mesh_overlay, reg1, "mesh_white_dot"),
        (position_set_x, pos1, 300),
        (position_set_y, pos1, 300),
        (overlay_set_size, reg1, pos1),
      (try_end),
      (agent_set_slot, ":agent_no", slot_agent_map_overlay_id, reg1),
      (assign, ":agent_overlay", reg1),
    (try_end),

    (agent_get_team, ":player_team", ":player_agent"),
    (try_begin),
      (neq, ":agent_no", ":player_agent"),
      (agent_get_team, ":agent_team", ":agent_no"),
      (try_begin),
        (neg|agent_is_ally, ":agent_no"),
        (overlay_set_color, ":agent_overlay", 0xFF4040),
        (assign, ":y_offset", 10),
      (else_try),
        (eq, ":agent_team", ":player_team"),
        (overlay_set_color, ":agent_overlay", 0x80FF80),
        (assign, ":y_offset", -10),
      (else_try),
        (overlay_set_color, ":agent_overlay", 0x8080FF),
        (assign, ":y_offset", 0),
      (try_end),
    (try_end),

    (try_begin),
      (eq, ":agent_no", ":player_agent"),
      (agent_get_look_position, pos1, ":agent_no"),
      (position_get_rotation_around_z, ":rot", pos1),
      (init_position, pos10),
      (position_rotate_z, pos10, ":rot"),
      (overlay_set_mesh_rotation, ":agent_overlay", pos10),
      (position_set_x, pos0, 620),
      (position_set_y, pos0, 721),
    (else_try),
      (agent_get_position, pos1, ":agent_no"),
      (call_script, "script_convert_3d_pos_to_map_bar_pos", ":y_offset"),
    (try_end),
    (overlay_set_position, ":agent_overlay", pos0),
  ]),

  # script_convert_3d_pos_to_map_bar_pos
  ("convert_3d_pos_to_map_bar_pos",
   [
    (store_script_param_1, ":y_offset"),

    (set_fixed_point_multiplier, 1000),
    (position_move_z, pos1, 170),
    (position_get_screen_projection, pos3, pos1),
    (position_get_x, ":pos_x", pos3),
    (try_begin),
      (is_between, ":pos_x", -200, 1201),
      (val_clamp, ":pos_x", 0, 1001),
    (else_try), # hide on the left
      (lt, ":pos_x", -200),
      (assign, ":pos_x", -250),
    (else_try), # hide on the right
      (gt, ":pos_x", 1200),
      (assign, ":pos_x", 1250),
    (try_end),
    (val_sub, ":pos_x", 500),
    (val_mul, ":pos_x", 20),
    (val_div, ":pos_x", 100),
    (val_add, ":pos_x", 500),
    (store_add, ":pos_y", 721, ":y_offset"),
    (position_set_x, pos0, ":pos_x"),
    (position_set_y, pos0, ":pos_y"),
  ]),

  # # script_convert_map_pos_to_3d_pos
  # ("convert_map_pos_to_3d_pos",
   # [
    # (set_fixed_point_multiplier, 1000),
    # (store_sub, ":map_x", 980, "$g_battle_map_width"),
    # (store_sub, ":map_y", 730, "$g_battle_map_height"),
    # (position_get_x, ":point_x_pos", pos1),
    # (position_get_y, ":point_y_pos", pos1),
    # (val_sub, ":point_x_pos", ":map_x"),
    # (val_sub, ":point_y_pos", ":map_y"),
    # (val_mul, ":point_x_pos", "$g_battle_map_scale"),
    # (val_mul, ":point_y_pos", "$g_battle_map_scale"),
    # (position_set_x, pos3, ":point_x_pos"),
    # (position_set_y, pos3, ":point_y_pos"),
    # (set_fixed_point_multiplier, 1000),
    # (position_transform_position_to_parent, pos0, pos2, pos3),
  # ]),

  ("update_agent_hp_bar",
   [
    (set_fixed_point_multiplier, 1000),

    (get_player_agent_no, ":player_agent"),
    (try_for_agents,":agent_no"),
      (agent_is_human, ":agent_no"),
      (neq, ":agent_no", ":player_agent"),
      (agent_get_slot, ":agent_hp_overlay", ":agent_no", slot_agent_hp_bar_overlay_id),
      (agent_get_slot, ":agent_hp_bg_overlay", ":agent_no", slot_agent_hp_bar_bg_overlay_id),
      #(agent_get_slot, ":agent_name_overlay", ":agent_no", slot_agent_name_overlay_id),
      (try_begin),
        (agent_is_alive, ":agent_no"),
        # (agent_get_slot, ":agent_hp_overlay", ":agent_no", slot_agent_hp_bar_overlay_id),
        # (agent_get_slot, ":agent_hp_bg_overlay", ":agent_no", slot_agent_hp_bar_bg_overlay_id),
        # (agent_get_slot, ":agent_name_overlay", ":agent_no", slot_agent_name_overlay_id),

        (assign, ":create_hp_bar", 0),
        #(assign, ":create_name", 0),
        (try_begin), # create or not
          (agent_is_ally, ":agent_no"),
          (assign, ":create_hp_bar", "$g_hp_bar_ally"),
          #(assign, ":create_name", "$g_name_of_ally"),
        (else_try),
          (assign, ":create_hp_bar", "$g_hp_bar_enemy"),
          #(assign, ":create_name", "$g_name_of_enemy"),
        (try_end),

        (try_begin),
          (le, ":agent_hp_overlay", 0),
          (le, ":agent_hp_bg_overlay", 0),
          #(le, ":agent_name_overlay", 0),
          (set_fixed_point_multiplier, 1000),
          (try_begin),
            (eq, ":create_hp_bar", 1),
            # hp bg
            (create_mesh_overlay, reg1, "mesh_white_plane"),
            (overlay_set_alpha, reg1, 0x44),
            (agent_set_slot, ":agent_no", slot_agent_hp_bar_bg_overlay_id, reg1),
            (assign, ":agent_hp_bg_overlay", reg1),
            # hp
            (create_mesh_overlay, reg1, "mesh_white_plane"),
            (overlay_set_alpha, reg1, 0x44),
            (agent_set_slot, ":agent_no", slot_agent_hp_bar_overlay_id, reg1),
            (assign, ":agent_hp_overlay", reg1),
          (try_end),
          # (try_begin),
            # (eq, ":create_name", 1),
            ## name
            # (agent_get_troop_id, ":troop_id", ":agent_no"),
            # (str_store_troop_name, s1, ":troop_id"),
            # (create_text_overlay, reg1, "@{s1}", tf_center_justify),
            # (overlay_set_alpha, reg1, 0xCC),
            # (agent_set_slot, ":agent_no", slot_agent_name_overlay_id, reg1),
            # (assign, ":agent_name_overlay", reg1),
          # (try_end),
        (try_end),

        # color
        (agent_get_team, ":player_team", ":player_agent"),
        (agent_get_team, ":agent_team", ":agent_no"),
        (agent_get_troop_id, ":troop_id", ":agent_no"),
        (try_begin),
          (eq, ":agent_team", ":player_team"),
          (assign, ":dest_color", 0x00FF00),
        (else_try),
          (agent_is_ally, ":agent_no"),
          (assign, ":dest_color", 0x0000FF),
        (else_try),
          (troop_is_hero, ":troop_id"),
          (assign, ":dest_color", 0xFFFF00),
        (else_try),
          (assign, ":dest_color", 0xFF0000),
        (try_end),
        (try_begin),
          (gt, ":agent_hp_overlay", 0),
          (gt, ":agent_hp_bg_overlay", 0),
          (overlay_set_color, ":agent_hp_overlay", ":dest_color"),
          (overlay_set_color, ":agent_hp_bg_overlay", 0x000000),
        (try_end),
        # (try_begin),
          # (gt, ":agent_name_overlay", 0),
          # (overlay_set_color, ":agent_name_overlay", ":dest_color"),
        # (try_end),

        # size & position
        # (this_or_next|gt, ":agent_name_overlay", 0),
        (gt, ":agent_hp_overlay", 0),

        (agent_get_position, pos1, ":agent_no"),
        (agent_get_horse, ":horse_agent", ":agent_no"),
        (try_begin),
          (ge, ":horse_agent", 0),
          (position_move_z, pos1, 280, 1),
        (else_try),
          (position_move_z, pos1, 180, 1),
        (try_end),
        (position_get_screen_projection, pos2, pos1),
        (position_get_x, ":head_x_pos", pos2),
        (position_get_y, ":head_y_pos", pos2),
        # base size
        (copy_position, pos6, pos1),
        (copy_position, pos7, pos1),
        (position_move_z, pos7, 100, 1),
        (position_get_screen_projection, pos6, pos6),
        (position_get_screen_projection, pos7, pos7),
        (position_get_y, ":screen_y_pos_1", pos6),
        (position_get_y, ":screen_y_pos_2", pos7),
        (store_sub, ":base_x", ":screen_y_pos_2", ":screen_y_pos_1"),
        (val_mul, ":base_x", 3),
        (val_div, ":base_x", 4),
        (val_clamp, ":base_x", 20, 161),
        (store_div, ":base_y", ":base_x", 20),
        (try_begin),
          (is_between, ":head_x_pos", -100, 1100),
          (is_between, ":head_y_pos", -100, 850),
          (agent_get_position, pos3, ":agent_no"),
          (agent_get_position, pos4, ":player_agent"),
          (get_distance_between_positions_in_meters, ":distance", pos3, pos4),
          (try_begin),
            (troop_is_hero, ":troop_id"),
            (val_div, ":distance", 2),
          (try_end),
          (le, ":distance", "$g_hp_bar_dis_limit"),
          # agent no
          (agent_get_horse, ":horse_agent", ":agent_no"),
          (try_begin),
            (ge, ":horse_agent", 0),
            (position_move_z, pos3, 280, 1),
          (else_try),
            (position_move_z, pos3, 180, 1),
          (try_end),
          # player agent
          (agent_get_horse, ":player_horse", ":player_agent"),
          (try_begin),
            (ge, ":player_horse", 0),
            (position_move_z, pos4, 280, 1),
          (else_try),
            (position_move_z, pos4, 180, 1),
          (try_end),
          (position_move_z, pos3, 50, 1),
          (position_move_z, pos4, 50, 1),
          (position_has_line_of_sight_to_position, pos3, pos4),

          (try_begin),
            (gt, ":agent_hp_overlay", 0),
            (gt, ":agent_hp_bg_overlay", 0),
            ## hp bg
            (assign, ":x_offset", ":base_x"),
            (val_div, ":x_offset", 2),
            (val_add, ":x_offset", 1),
            (store_sub, ":hp_bg_x", ":head_x_pos", ":x_offset"),
            (store_sub, ":hp_bg_y", ":head_y_pos", 1),
            (position_set_x, pos1, ":hp_bg_x"),
            (position_set_y, pos1, ":hp_bg_y"),
            (overlay_set_position, ":agent_hp_bg_overlay", pos1),
            (store_add, ":bg_width", ":base_x", 2),
            (val_mul, ":bg_width", 50),
            (store_add, ":bg_height", ":base_y", 2),
            (val_mul, ":bg_height", 50),
            (position_set_x, pos1, ":bg_width"),
            (position_set_y, pos1, ":bg_height"),
            (overlay_set_size, ":agent_hp_bg_overlay", pos1),
            (overlay_set_alpha, ":agent_hp_bg_overlay", 0x44),
            ## hp
            (store_add, ":hp_x", ":hp_bg_x", 1),
            (store_add, ":hp_y", ":hp_bg_y", 1),
            (position_set_x, pos1, ":hp_x"),
            (position_set_y, pos1, ":hp_y"),
            (overlay_set_position, ":agent_hp_overlay", pos1),
            (store_agent_hit_points, ":agent_hp",":agent_no"),
            (store_mul, ":hp_width", ":agent_hp", 50),
            (val_mul, ":hp_width", ":base_x"),
            (val_div, ":hp_width", 100),
            (val_min, ":hp_width", ":bg_width"),
            (store_mul, ":hp_height", ":base_y", 50),
            (position_set_x, pos1, ":hp_width"),
            (position_set_y, pos1, ":hp_height"),
            (overlay_set_size, ":agent_hp_overlay", pos1),
            (overlay_set_alpha, ":agent_hp_overlay", 0x44),
          (try_end),

          # name
          # (try_begin),
            # (gt, ":agent_name_overlay", 0),
            # (assign, ":name_x", ":head_x_pos"),
            # (store_add, ":name_y", ":head_y_pos", 5),
            # (position_set_x, pos1, ":name_x"),
            # (position_set_y, pos1, ":name_y"),
            # (overlay_set_position, ":agent_name_overlay", pos1),
            # (store_mul, ":name_size", ":base_x", 9),
            # (position_set_x, pos1, ":name_size"),
            # (position_set_y, pos1, ":name_size"),
            # (overlay_set_size, ":agent_name_overlay", pos1),
            # (overlay_set_alpha, ":agent_name_overlay", 0xCC),
          # (try_end),
        (else_try),
          (overlay_set_alpha, ":agent_hp_overlay", 0),
          (overlay_set_alpha, ":agent_hp_bg_overlay", 0),
          # (overlay_set_alpha, ":agent_name_overlay", 0),
        (try_end),
      (else_try),
        (try_begin),
          (gt, ":agent_hp_overlay", 0),
          (gt, ":agent_hp_bg_overlay", 0),
          (overlay_set_alpha, ":agent_hp_overlay", 0),
          (overlay_set_alpha, ":agent_hp_bg_overlay", 0),
        (try_end),
        # (try_begin),
          # (gt, ":agent_name_overlay", 0),
          # (overlay_set_alpha, ":agent_name_overlay", 0),
        # (try_end),
        (agent_set_slot, ":agent_no", slot_agent_hp_bar_overlay_id, 0),
        (agent_set_slot, ":agent_no", slot_agent_hp_bar_bg_overlay_id, 0),
        #(agent_set_slot, ":agent_no", slot_agent_name_overlay_id, 0),
      (try_end),
    (try_end),
  ]),

  #("get_troop_backup_hp_times_factor",
    #[
      #(store_script_param, ":troop_no", 1),

      #(store_character_level, ":troop_level", ":troop_no"),
      #(store_mul, ":backup_hp_factor", ":troop_level", 4),
      #(assign, reg0, ":backup_hp_factor"),
    #]),

  #("get_agent_backup_hp_times_factor",
    #[
      #(store_script_param, ":agent_no", 1),

      #(agent_get_party_id, ":party_no", ":agent_no"),
      #(try_begin),
        #(le, ":party_no", -1),
        #(assign, ":backup_hp_factor", 0),
      #(else_try),
        #(party_stack_get_troop_id, ":leader", ":party_no", 0),
        #(troop_is_hero, ":leader"),
        #(store_skill_level, ":leadership_level", "skl_leadership", ":leader"),
        #(store_mul, ":backup_hp_factor", ":leadership_level", 6),
        #(try_begin),
          #(eq, ":party_no", "p_main_party"),
          #(agent_get_troop_id, ":troop_no", ":agent_no"),
          #(call_script, "script_game_get_morale_of_troops_from_faction", ":troop_no"),
          #(assign, ":troop_morale", reg0),
          #(val_clamp, ":troop_morale", 0, 100),
          #(val_mul, ":backup_hp_factor", ":troop_morale"),
          #(val_div, ":backup_hp_factor", 99),
        #(try_end),
      #(else_try),
        #(assign, ":backup_hp_factor", 0),
      #(try_end),
      #(assign, reg0, ":backup_hp_factor"),
    #]),
    #CC
 #Universal Sorting scripts
 #script_rearrange_inventory
#input: arg1 - troop_id, arg2 - sorting order; 0 - simple (compact inventory, removing spaces), 1 - by cost, 2 - by type.
#output : none
 ("rearrange_inventory",
  [(store_script_param, ":troop_id", 1),
   (store_script_param, ":type", 2),
   (troop_get_inventory_capacity, ":inv_cap", ":troop_id"),
   (try_begin),
     (eq, ":type", 0),
     (try_for_range, ":slot_no", 11, ":inv_cap"),
        (troop_get_inventory_slot, ":item", ":troop_id", ":slot_no"),
        (gt, ":item", 0),
        (troop_get_inventory_slot_modifier, ":mod", ":troop_id", ":slot_no"),
        (troop_inventory_slot_get_item_amount, ":amount", ":troop_id", ":slot_no"),
        (assign, ":target_slot", -1),
        (try_for_range_backwards, ":to_slot", 10, ":slot_no"),
          (troop_get_inventory_slot, ":is_full", ":troop_id", ":to_slot"),
          (le, ":is_full", 0),
          (assign, ":target_slot", ":to_slot"),
        (try_end),
        (neq, ":target_slot", -1),
        (troop_set_inventory_slot, ":troop_id", ":target_slot", ":item"),
        (troop_set_inventory_slot_modifier, ":troop_id", ":target_slot", ":mod"),
        (try_begin),
         (gt, ":amount", 0),
         (troop_inventory_slot_set_item_amount, ":troop_id", ":target_slot", ":amount"),
        (try_end),
        (troop_set_inventory_slot, ":troop_id", ":slot_no", -1),
        (troop_inventory_slot_set_item_amount, ":troop_id", ":slot_no", 0),
     (try_end),
    (else_try),
       (eq, ":type", 1),
       (troop_sort_inventory, ":troop_id"),
    (else_try),
       (eq, ":type", 2),
       (assign, ":temp_slot", 0),
#define sorting order
       (troop_set_slot, "trp_temp_array_a", 0, itp_type_one_handed_wpn),
       (troop_set_slot, "trp_temp_array_a", 1, itp_type_two_handed_wpn),
       (troop_set_slot, "trp_temp_array_a", 2, itp_type_polearm),
       (troop_set_slot, "trp_temp_array_a", 3, itp_type_bow),
       (troop_set_slot, "trp_temp_array_a", 4, itp_type_crossbow),
       (troop_set_slot, "trp_temp_array_a", 5, itp_type_thrown),
       (troop_set_slot, "trp_temp_array_a", 6, itp_type_arrows),
       (troop_set_slot, "trp_temp_array_a", 7, itp_type_bolts),
       (troop_set_slot, "trp_temp_array_a", 8, itp_type_shield),
       (troop_set_slot, "trp_temp_array_a", 9, itp_type_head_armor),
       (troop_set_slot, "trp_temp_array_a", 10, itp_type_body_armor),
       (troop_set_slot, "trp_temp_array_a", 11, itp_type_foot_armor),
       (troop_set_slot, "trp_temp_array_a", 12, itp_type_hand_armor),
       (troop_set_slot, "trp_temp_array_a", 13, itp_type_horse),
       (troop_set_slot, "trp_temp_array_a", 14, itp_type_goods),
       (troop_set_slot, "trp_temp_array_a", 15, itp_type_book),
       (troop_set_slot, "trp_temp_array_a", 16, itp_type_pistol),
       (troop_set_slot, "trp_temp_array_a", 17, itp_type_musket),
       (troop_set_slot, "trp_temp_array_a", 18, itp_type_bullets),
       (troop_set_slot, "trp_temp_array_a", 19, itp_type_animal),
#define sorting order
       (call_script, "script_clear_inventory", "trp_temp_array_a"),
       (troop_sort_inventory, ":troop_id"),
       (try_for_range, ":array_pos", 0, 20),
         (try_for_range, ":slot_no", 10, ":inv_cap"),
           (troop_get_inventory_slot, ":item", ":troop_id", ":slot_no"),
           (gt, ":item", 0),
           (item_get_type, ":item_type", ":item"),
           (troop_slot_eq, "trp_temp_array_a", ":array_pos", ":item_type"),
           (troop_inventory_slot_get_item_amount, ":amount", ":troop_id", ":slot_no"),
           (troop_get_inventory_slot_modifier, ":mod", ":troop_id", ":slot_no"),
           (troop_set_inventory_slot, "trp_temp_array_a", ":temp_slot", ":item"),
           (troop_set_inventory_slot_modifier, "trp_temp_array_a", ":temp_slot", ":mod"),
           (try_begin),
             (gt, ":amount", 0),
             (troop_inventory_slot_set_item_amount, "trp_temp_array_a", ":temp_slot", ":amount"),
           (try_end),
           (val_add, ":temp_slot", 1),
          (try_end),
       (try_end),
       (troop_clear_inventory, ":troop_id"),
       (try_for_range, ":slot_no", 0, ":inv_cap"),
            (troop_get_inventory_slot, ":item", "trp_temp_array_a", ":slot_no"),
            (troop_get_inventory_slot_modifier, ":mod", "trp_temp_array_a", ":slot_no"),
            (troop_inventory_slot_get_item_amount, ":amount", "trp_temp_array_a", ":slot_no"),
            (val_add, ":slot_no", 10),
            (troop_set_inventory_slot, ":troop_id", ":slot_no", ":item"),
            (troop_set_inventory_slot_modifier, ":troop_id", ":slot_no", ":mod"),
            (try_begin),
              (gt, ":amount", 0),
              (troop_inventory_slot_set_item_amount, ":troop_id", ":slot_no", ":amount"),
            (try_end),
            (try_begin),
              (le, ":item", 0),
              (assign, ":inv_cap", 0),
            (try_end),
         (try_end),
    (try_end),
   ]),
#script_clear_inventory
#INPUT: arg1 = troop_id
  ("clear_inventory",
   [(store_script_param_1, ":troop_id"),
    (troop_clear_inventory,":troop_id"),
    (try_for_range, ":item", 0, 10),
       (troop_set_inventory_slot, ":troop_id", ":item",  -1),
    (try_end),]),
 #End Universal Sorting scripts
]# modmerger_start version=201 type=2
try:
    component_name = "scripts"
    var_set = { "scripts" : scripts }
    from modmerger import modmerge
    modmerge(var_set)
except:
    raise
# modmerger_end
